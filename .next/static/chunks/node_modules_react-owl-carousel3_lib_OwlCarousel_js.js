(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["node_modules_react-owl-carousel3_lib_OwlCarousel_js"],{

/***/ "./node_modules/react-owl-carousel3/lib/OwlCarousel.js":
/*!*************************************************************!*\
  !*** ./node_modules/react-owl-carousel3/lib/OwlCarousel.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
	else {}
})(this, function(__WEBPACK_EXTERNAL_MODULE_12__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __nested_webpack_require_656__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_656__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__nested_webpack_require_656__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__nested_webpack_require_656__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__nested_webpack_require_656__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__nested_webpack_require_656__.d = function(exports, name, getter) {
/******/ 		if(!__nested_webpack_require_656__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__nested_webpack_require_656__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__nested_webpack_require_656__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__nested_webpack_require_656__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__nested_webpack_require_656__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __nested_webpack_require_656__(__nested_webpack_require_656__.s = 13);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/node-libs-browser/~/process/browser.js\n// module id = 0\n// module chunks = 0\n\n//# sourceURL=webpack:///./~/node-libs-browser/~/process/browser.js?");

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * jQuery JavaScript Library v3.3.1\n * https://jquery.com/\n *\n * Includes Sizzle.js\n * https://sizzlejs.com/\n *\n * Copyright JS Foundation and other contributors\n * Released under the MIT license\n * https://jquery.org/license\n *\n * Date: 2018-01-20T17:24Z\n */\n( function( global, factory ) {\n\n\t\"use strict\";\n\n\tif ( typeof module === \"object\" && typeof module.exports === \"object\" ) {\n\n\t\t// For CommonJS and CommonJS-like environments where a proper `window`\n\t\t// is present, execute the factory and get jQuery.\n\t\t// For environments that do not have a `window` with a `document`\n\t\t// (such as Node.js), expose a factory as module.exports.\n\t\t// This accentuates the need for the creation of a real `window`.\n\t\t// e.g. var jQuery = require(\"jquery\")(window);\n\t\t// See ticket #14549 for more info.\n\t\tmodule.exports = global.document ?\n\t\t\tfactory( global, true ) :\n\t\t\tfunction( w ) {\n\t\t\t\tif ( !w.document ) {\n\t\t\t\t\tthrow new Error( \"jQuery requires a window with a document\" );\n\t\t\t\t}\n\t\t\t\treturn factory( w );\n\t\t\t};\n\t} else {\n\t\tfactory( global );\n\t}\n\n// Pass this if window is not defined yet\n} )( typeof window !== \"undefined\" ? window : this, function( window, noGlobal ) {\n\n// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1\n// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode\n// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common\n// enough that all such attempts are guarded in a try block.\n\"use strict\";\n\nvar arr = [];\n\nvar document = window.document;\n\nvar getProto = Object.getPrototypeOf;\n\nvar slice = arr.slice;\n\nvar concat = arr.concat;\n\nvar push = arr.push;\n\nvar indexOf = arr.indexOf;\n\nvar class2type = {};\n\nvar toString = class2type.toString;\n\nvar hasOwn = class2type.hasOwnProperty;\n\nvar fnToString = hasOwn.toString;\n\nvar ObjectFunctionString = fnToString.call( Object );\n\nvar support = {};\n\nvar isFunction = function isFunction( obj ) {\n\n      // Support: Chrome <=57, Firefox <=52\n      // In some browsers, typeof returns \"function\" for HTML <object> elements\n      // (i.e., `typeof document.createElement( \"object\" ) === \"function\"`).\n      // We don't want to classify *any* DOM node as a function.\n      return typeof obj === \"function\" && typeof obj.nodeType !== \"number\";\n  };\n\n\nvar isWindow = function isWindow( obj ) {\n\t\treturn obj != null && obj === obj.window;\n\t};\n\n\n\n\n\tvar preservedScriptAttributes = {\n\t\ttype: true,\n\t\tsrc: true,\n\t\tnoModule: true\n\t};\n\n\tfunction DOMEval( code, doc, node ) {\n\t\tdoc = doc || document;\n\n\t\tvar i,\n\t\t\tscript = doc.createElement( \"script\" );\n\n\t\tscript.text = code;\n\t\tif ( node ) {\n\t\t\tfor ( i in preservedScriptAttributes ) {\n\t\t\t\tif ( node[ i ] ) {\n\t\t\t\t\tscript[ i ] = node[ i ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdoc.head.appendChild( script ).parentNode.removeChild( script );\n\t}\n\n\nfunction toType( obj ) {\n\tif ( obj == null ) {\n\t\treturn obj + \"\";\n\t}\n\n\t// Support: Android <=2.3 only (functionish RegExp)\n\treturn typeof obj === \"object\" || typeof obj === \"function\" ?\n\t\tclass2type[ toString.call( obj ) ] || \"object\" :\n\t\ttypeof obj;\n}\n/* global Symbol */\n// Defining this global in .eslintrc.json would create a danger of using the global\n// unguarded in another place, it seems safer to define global only for this module\n\n\n\nvar\n\tversion = \"3.3.1\",\n\n\t// Define a local copy of jQuery\n\tjQuery = function( selector, context ) {\n\n\t\t// The jQuery object is actually just the init constructor 'enhanced'\n\t\t// Need init if jQuery is called (just allow error to be thrown if not included)\n\t\treturn new jQuery.fn.init( selector, context );\n\t},\n\n\t// Support: Android <=4.0 only\n\t// Make sure we trim BOM and NBSP\n\trtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g;\n\njQuery.fn = jQuery.prototype = {\n\n\t// The current version of jQuery being used\n\tjquery: version,\n\n\tconstructor: jQuery,\n\n\t// The default length of a jQuery object is 0\n\tlength: 0,\n\n\ttoArray: function() {\n\t\treturn slice.call( this );\n\t},\n\n\t// Get the Nth element in the matched element set OR\n\t// Get the whole matched element set as a clean array\n\tget: function( num ) {\n\n\t\t// Return all the elements in a clean array\n\t\tif ( num == null ) {\n\t\t\treturn slice.call( this );\n\t\t}\n\n\t\t// Return just the one element from the set\n\t\treturn num < 0 ? this[ num + this.length ] : this[ num ];\n\t},\n\n\t// Take an array of elements and push it onto the stack\n\t// (returning the new matched element set)\n\tpushStack: function( elems ) {\n\n\t\t// Build a new jQuery matched element set\n\t\tvar ret = jQuery.merge( this.constructor(), elems );\n\n\t\t// Add the old object onto the stack (as a reference)\n\t\tret.prevObject = this;\n\n\t\t// Return the newly-formed element set\n\t\treturn ret;\n\t},\n\n\t// Execute a callback for every element in the matched set.\n\teach: function( callback ) {\n\t\treturn jQuery.each( this, callback );\n\t},\n\n\tmap: function( callback ) {\n\t\treturn this.pushStack( jQuery.map( this, function( elem, i ) {\n\t\t\treturn callback.call( elem, i, elem );\n\t\t} ) );\n\t},\n\n\tslice: function() {\n\t\treturn this.pushStack( slice.apply( this, arguments ) );\n\t},\n\n\tfirst: function() {\n\t\treturn this.eq( 0 );\n\t},\n\n\tlast: function() {\n\t\treturn this.eq( -1 );\n\t},\n\n\teq: function( i ) {\n\t\tvar len = this.length,\n\t\t\tj = +i + ( i < 0 ? len : 0 );\n\t\treturn this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );\n\t},\n\n\tend: function() {\n\t\treturn this.prevObject || this.constructor();\n\t},\n\n\t// For internal use only.\n\t// Behaves like an Array's method, not like a jQuery method.\n\tpush: push,\n\tsort: arr.sort,\n\tsplice: arr.splice\n};\n\njQuery.extend = jQuery.fn.extend = function() {\n\tvar options, name, src, copy, copyIsArray, clone,\n\t\ttarget = arguments[ 0 ] || {},\n\t\ti = 1,\n\t\tlength = arguments.length,\n\t\tdeep = false;\n\n\t// Handle a deep copy situation\n\tif ( typeof target === \"boolean\" ) {\n\t\tdeep = target;\n\n\t\t// Skip the boolean and the target\n\t\ttarget = arguments[ i ] || {};\n\t\ti++;\n\t}\n\n\t// Handle case when target is a string or something (possible in deep copy)\n\tif ( typeof target !== \"object\" && !isFunction( target ) ) {\n\t\ttarget = {};\n\t}\n\n\t// Extend jQuery itself if only one argument is passed\n\tif ( i === length ) {\n\t\ttarget = this;\n\t\ti--;\n\t}\n\n\tfor ( ; i < length; i++ ) {\n\n\t\t// Only deal with non-null/undefined values\n\t\tif ( ( options = arguments[ i ] ) != null ) {\n\n\t\t\t// Extend the base object\n\t\t\tfor ( name in options ) {\n\t\t\t\tsrc = target[ name ];\n\t\t\t\tcopy = options[ name ];\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif ( target === copy ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\tif ( deep && copy && ( jQuery.isPlainObject( copy ) ||\n\t\t\t\t\t( copyIsArray = Array.isArray( copy ) ) ) ) {\n\n\t\t\t\t\tif ( copyIsArray ) {\n\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\tclone = src && Array.isArray( src ) ? src : [];\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclone = src && jQuery.isPlainObject( src ) ? src : {};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\ttarget[ name ] = jQuery.extend( deep, clone, copy );\n\n\t\t\t\t// Don't bring in undefined values\n\t\t\t\t} else if ( copy !== undefined ) {\n\t\t\t\t\ttarget[ name ] = copy;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n\njQuery.extend( {\n\n\t// Unique for each copy of jQuery on the page\n\texpando: \"jQuery\" + ( version + Math.random() ).replace( /\\D/g, \"\" ),\n\n\t// Assume jQuery is ready without the ready module\n\tisReady: true,\n\n\terror: function( msg ) {\n\t\tthrow new Error( msg );\n\t},\n\n\tnoop: function() {},\n\n\tisPlainObject: function( obj ) {\n\t\tvar proto, Ctor;\n\n\t\t// Detect obvious negatives\n\t\t// Use toString instead of jQuery.type to catch host objects\n\t\tif ( !obj || toString.call( obj ) !== \"[object Object]\" ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tproto = getProto( obj );\n\n\t\t// Objects with no prototype (e.g., `Object.create( null )`) are plain\n\t\tif ( !proto ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Objects with prototype are plain iff they were constructed by a global Object function\n\t\tCtor = hasOwn.call( proto, \"constructor\" ) && proto.constructor;\n\t\treturn typeof Ctor === \"function\" && fnToString.call( Ctor ) === ObjectFunctionString;\n\t},\n\n\tisEmptyObject: function( obj ) {\n\n\t\t/* eslint-disable no-unused-vars */\n\t\t// See https://github.com/eslint/eslint/issues/6125\n\t\tvar name;\n\n\t\tfor ( name in obj ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t},\n\n\t// Evaluates a script in a global context\n\tglobalEval: function( code ) {\n\t\tDOMEval( code );\n\t},\n\n\teach: function( obj, callback ) {\n\t\tvar length, i = 0;\n\n\t\tif ( isArrayLike( obj ) ) {\n\t\t\tlength = obj.length;\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor ( i in obj ) {\n\t\t\t\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn obj;\n\t},\n\n\t// Support: Android <=4.0 only\n\ttrim: function( text ) {\n\t\treturn text == null ?\n\t\t\t\"\" :\n\t\t\t( text + \"\" ).replace( rtrim, \"\" );\n\t},\n\n\t// results is for internal usage only\n\tmakeArray: function( arr, results ) {\n\t\tvar ret = results || [];\n\n\t\tif ( arr != null ) {\n\t\t\tif ( isArrayLike( Object( arr ) ) ) {\n\t\t\t\tjQuery.merge( ret,\n\t\t\t\t\ttypeof arr === \"string\" ?\n\t\t\t\t\t[ arr ] : arr\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tpush.call( ret, arr );\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tinArray: function( elem, arr, i ) {\n\t\treturn arr == null ? -1 : indexOf.call( arr, elem, i );\n\t},\n\n\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t// push.apply(_, arraylike) throws on ancient WebKit\n\tmerge: function( first, second ) {\n\t\tvar len = +second.length,\n\t\t\tj = 0,\n\t\t\ti = first.length;\n\n\t\tfor ( ; j < len; j++ ) {\n\t\t\tfirst[ i++ ] = second[ j ];\n\t\t}\n\n\t\tfirst.length = i;\n\n\t\treturn first;\n\t},\n\n\tgrep: function( elems, callback, invert ) {\n\t\tvar callbackInverse,\n\t\t\tmatches = [],\n\t\t\ti = 0,\n\t\t\tlength = elems.length,\n\t\t\tcallbackExpect = !invert;\n\n\t\t// Go through the array, only saving the items\n\t\t// that pass the validator function\n\t\tfor ( ; i < length; i++ ) {\n\t\t\tcallbackInverse = !callback( elems[ i ], i );\n\t\t\tif ( callbackInverse !== callbackExpect ) {\n\t\t\t\tmatches.push( elems[ i ] );\n\t\t\t}\n\t\t}\n\n\t\treturn matches;\n\t},\n\n\t// arg is for internal usage only\n\tmap: function( elems, callback, arg ) {\n\t\tvar length, value,\n\t\t\ti = 0,\n\t\t\tret = [];\n\n\t\t// Go through the array, translating each of the items to their new values\n\t\tif ( isArrayLike( elems ) ) {\n\t\t\tlength = elems.length;\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret.push( value );\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Go through every key on the object,\n\t\t} else {\n\t\t\tfor ( i in elems ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret.push( value );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Flatten any nested arrays\n\t\treturn concat.apply( [], ret );\n\t},\n\n\t// A global GUID counter for objects\n\tguid: 1,\n\n\t// jQuery.support is not used in Core but other projects attach their\n\t// properties to it so it needs to exist.\n\tsupport: support\n} );\n\nif ( typeof Symbol === \"function\" ) {\n\tjQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];\n}\n\n// Populate the class2type map\njQuery.each( \"Boolean Number String Function Array Date RegExp Object Error Symbol\".split( \" \" ),\nfunction( i, name ) {\n\tclass2type[ \"[object \" + name + \"]\" ] = name.toLowerCase();\n} );\n\nfunction isArrayLike( obj ) {\n\n\t// Support: real iOS 8.2 only (not reproducible in simulator)\n\t// `in` check used to prevent JIT error (gh-2145)\n\t// hasOwn isn't used here due to false negatives\n\t// regarding Nodelist length in IE\n\tvar length = !!obj && \"length\" in obj && obj.length,\n\t\ttype = toType( obj );\n\n\tif ( isFunction( obj ) || isWindow( obj ) ) {\n\t\treturn false;\n\t}\n\n\treturn type === \"array\" || length === 0 ||\n\t\ttypeof length === \"number\" && length > 0 && ( length - 1 ) in obj;\n}\nvar Sizzle =\n/*!\n * Sizzle CSS Selector Engine v2.3.3\n * https://sizzlejs.com/\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2016-08-08\n */\n(function( window ) {\n\nvar i,\n\tsupport,\n\tExpr,\n\tgetText,\n\tisXML,\n\ttokenize,\n\tcompile,\n\tselect,\n\toutermostContext,\n\tsortInput,\n\thasDuplicate,\n\n\t// Local document vars\n\tsetDocument,\n\tdocument,\n\tdocElem,\n\tdocumentIsHTML,\n\trbuggyQSA,\n\trbuggyMatches,\n\tmatches,\n\tcontains,\n\n\t// Instance-specific data\n\texpando = \"sizzle\" + 1 * new Date(),\n\tpreferredDoc = window.document,\n\tdirruns = 0,\n\tdone = 0,\n\tclassCache = createCache(),\n\ttokenCache = createCache(),\n\tcompilerCache = createCache(),\n\tsortOrder = function( a, b ) {\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t}\n\t\treturn 0;\n\t},\n\n\t// Instance methods\n\thasOwn = ({}).hasOwnProperty,\n\tarr = [],\n\tpop = arr.pop,\n\tpush_native = arr.push,\n\tpush = arr.push,\n\tslice = arr.slice,\n\t// Use a stripped-down indexOf as it's faster than native\n\t// https://jsperf.com/thor-indexof-vs-for/5\n\tindexOf = function( list, elem ) {\n\t\tvar i = 0,\n\t\t\tlen = list.length;\n\t\tfor ( ; i < len; i++ ) {\n\t\t\tif ( list[i] === elem ) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t},\n\n\tbooleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",\n\n\t// Regular expressions\n\n\t// http://www.w3.org/TR/css3-selectors/#whitespace\n\twhitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n\n\t// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\n\tidentifier = \"(?:\\\\\\\\.|[\\\\w-]|[^\\0-\\\\xa0])+\",\n\n\t// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\n\tattributes = \"\\\\[\" + whitespace + \"*(\" + identifier + \")(?:\" + whitespace +\n\t\t// Operator (capture 2)\n\t\t\"*([*^$|!~]?=)\" + whitespace +\n\t\t// \"Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]\"\n\t\t\"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\" + identifier + \"))|)\" + whitespace +\n\t\t\"*\\\\]\",\n\n\tpseudos = \":(\" + identifier + \")(?:\\\\((\" +\n\t\t// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n\t\t// 1. quoted (capture 3; capture 4 or capture 5)\n\t\t\"('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|\" +\n\t\t// 2. simple (capture 6)\n\t\t\"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes + \")*)|\" +\n\t\t// 3. anything else (capture 2)\n\t\t\".*\" +\n\t\t\")\\\\)|)\",\n\n\t// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n\trwhitespace = new RegExp( whitespace + \"+\", \"g\" ),\n\trtrim = new RegExp( \"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\", \"g\" ),\n\n\trcomma = new RegExp( \"^\" + whitespace + \"*,\" + whitespace + \"*\" ),\n\trcombinators = new RegExp( \"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace + \"*\" ),\n\n\trattributeQuotes = new RegExp( \"=\" + whitespace + \"*([^\\\\]'\\\"]*?)\" + whitespace + \"*\\\\]\", \"g\" ),\n\n\trpseudo = new RegExp( pseudos ),\n\tridentifier = new RegExp( \"^\" + identifier + \"$\" ),\n\n\tmatchExpr = {\n\t\t\"ID\": new RegExp( \"^#(\" + identifier + \")\" ),\n\t\t\"CLASS\": new RegExp( \"^\\\\.(\" + identifier + \")\" ),\n\t\t\"TAG\": new RegExp( \"^(\" + identifier + \"|[*])\" ),\n\t\t\"ATTR\": new RegExp( \"^\" + attributes ),\n\t\t\"PSEUDO\": new RegExp( \"^\" + pseudos ),\n\t\t\"CHILD\": new RegExp( \"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + whitespace +\n\t\t\t\"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" + whitespace +\n\t\t\t\"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\" ),\n\t\t\"bool\": new RegExp( \"^(?:\" + booleans + \")$\", \"i\" ),\n\t\t// For use in libraries implementing .is()\n\t\t// We use this for POS matching in `select`\n\t\t\"needsContext\": new RegExp( \"^\" + whitespace + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" +\n\t\t\twhitespace + \"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\" )\n\t},\n\n\trinputs = /^(?:input|select|textarea|button)$/i,\n\trheader = /^h\\d$/i,\n\n\trnative = /^[^{]+\\{\\s*\\[native \\w/,\n\n\t// Easily-parseable/retrievable ID or TAG or CLASS selectors\n\trquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n\n\trsibling = /[+~]/,\n\n\t// CSS escapes\n\t// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n\trunescape = new RegExp( \"\\\\\\\\([\\\\da-f]{1,6}\" + whitespace + \"?|(\" + whitespace + \")|.)\", \"ig\" ),\n\tfunescape = function( _, escaped, escapedWhitespace ) {\n\t\tvar high = \"0x\" + escaped - 0x10000;\n\t\t// NaN means non-codepoint\n\t\t// Support: Firefox<24\n\t\t// Workaround erroneous numeric interpretation of +\"0x\"\n\t\treturn high !== high || escapedWhitespace ?\n\t\t\tescaped :\n\t\t\thigh < 0 ?\n\t\t\t\t// BMP codepoint\n\t\t\t\tString.fromCharCode( high + 0x10000 ) :\n\t\t\t\t// Supplemental Plane codepoint (surrogate pair)\n\t\t\t\tString.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );\n\t},\n\n\t// CSS string/identifier serialization\n\t// https://drafts.csswg.org/cssom/#common-serializing-idioms\n\trcssescape = /([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\0-\\x1f\\x7f-\\uFFFF\\w-]/g,\n\tfcssescape = function( ch, asCodePoint ) {\n\t\tif ( asCodePoint ) {\n\n\t\t\t// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER\n\t\t\tif ( ch === \"\\0\" ) {\n\t\t\t\treturn \"\\uFFFD\";\n\t\t\t}\n\n\t\t\t// Control characters and (dependent upon position) numbers get escaped as code points\n\t\t\treturn ch.slice( 0, -1 ) + \"\\\\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + \" \";\n\t\t}\n\n\t\t// Other potentially-special ASCII characters get backslash-escaped\n\t\treturn \"\\\\\" + ch;\n\t},\n\n\t// Used for iframes\n\t// See setDocument()\n\t// Removing the function wrapper causes a \"Permission Denied\"\n\t// error in IE\n\tunloadHandler = function() {\n\t\tsetDocument();\n\t},\n\n\tdisabledAncestor = addCombinator(\n\t\tfunction( elem ) {\n\t\t\treturn elem.disabled === true && (\"form\" in elem || \"label\" in elem);\n\t\t},\n\t\t{ dir: \"parentNode\", next: \"legend\" }\n\t);\n\n// Optimize for push.apply( _, NodeList )\ntry {\n\tpush.apply(\n\t\t(arr = slice.call( preferredDoc.childNodes )),\n\t\tpreferredDoc.childNodes\n\t);\n\t// Support: Android<4.0\n\t// Detect silently failing push.apply\n\tarr[ preferredDoc.childNodes.length ].nodeType;\n} catch ( e ) {\n\tpush = { apply: arr.length ?\n\n\t\t// Leverage slice if possible\n\t\tfunction( target, els ) {\n\t\t\tpush_native.apply( target, slice.call(els) );\n\t\t} :\n\n\t\t// Support: IE<9\n\t\t// Otherwise append directly\n\t\tfunction( target, els ) {\n\t\t\tvar j = target.length,\n\t\t\t\ti = 0;\n\t\t\t// Can't trust NodeList.length\n\t\t\twhile ( (target[j++] = els[i++]) ) {}\n\t\t\ttarget.length = j - 1;\n\t\t}\n\t};\n}\n\nfunction Sizzle( selector, context, results, seed ) {\n\tvar m, i, elem, nid, match, groups, newSelector,\n\t\tnewContext = context && context.ownerDocument,\n\n\t\t// nodeType defaults to 9, since context defaults to document\n\t\tnodeType = context ? context.nodeType : 9;\n\n\tresults = results || [];\n\n\t// Return early from calls with invalid selector or context\n\tif ( typeof selector !== \"string\" || !selector ||\n\t\tnodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {\n\n\t\treturn results;\n\t}\n\n\t// Try to shortcut find operations (as opposed to filters) in HTML documents\n\tif ( !seed ) {\n\n\t\tif ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {\n\t\t\tsetDocument( context );\n\t\t}\n\t\tcontext = context || document;\n\n\t\tif ( documentIsHTML ) {\n\n\t\t\t// If the selector is sufficiently simple, try using a \"get*By*\" DOM method\n\t\t\t// (excepting DocumentFragment context, where the methods don't exist)\n\t\t\tif ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {\n\n\t\t\t\t// ID selector\n\t\t\t\tif ( (m = match[1]) ) {\n\n\t\t\t\t\t// Document context\n\t\t\t\t\tif ( nodeType === 9 ) {\n\t\t\t\t\t\tif ( (elem = context.getElementById( m )) ) {\n\n\t\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\t\tif ( elem.id === m ) {\n\t\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t// Element context\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\tif ( newContext && (elem = newContext.getElementById( m )) &&\n\t\t\t\t\t\t\tcontains( context, elem ) &&\n\t\t\t\t\t\t\telem.id === m ) {\n\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t// Type selector\n\t\t\t\t} else if ( match[2] ) {\n\t\t\t\t\tpush.apply( results, context.getElementsByTagName( selector ) );\n\t\t\t\t\treturn results;\n\n\t\t\t\t// Class selector\n\t\t\t\t} else if ( (m = match[3]) && support.getElementsByClassName &&\n\t\t\t\t\tcontext.getElementsByClassName ) {\n\n\t\t\t\t\tpush.apply( results, context.getElementsByClassName( m ) );\n\t\t\t\t\treturn results;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Take advantage of querySelectorAll\n\t\t\tif ( support.qsa &&\n\t\t\t\t!compilerCache[ selector + \" \" ] &&\n\t\t\t\t(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {\n\n\t\t\t\tif ( nodeType !== 1 ) {\n\t\t\t\t\tnewContext = context;\n\t\t\t\t\tnewSelector = selector;\n\n\t\t\t\t// qSA looks outside Element context, which is not what we want\n\t\t\t\t// Thanks to Andrew Dupont for this workaround technique\n\t\t\t\t// Support: IE <=8\n\t\t\t\t// Exclude object elements\n\t\t\t\t} else if ( context.nodeName.toLowerCase() !== \"object\" ) {\n\n\t\t\t\t\t// Capture the context ID, setting it first if necessary\n\t\t\t\t\tif ( (nid = context.getAttribute( \"id\" )) ) {\n\t\t\t\t\t\tnid = nid.replace( rcssescape, fcssescape );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontext.setAttribute( \"id\", (nid = expando) );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Prefix every selector in the list\n\t\t\t\t\tgroups = tokenize( selector );\n\t\t\t\t\ti = groups.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tgroups[i] = \"#\" + nid + \" \" + toSelector( groups[i] );\n\t\t\t\t\t}\n\t\t\t\t\tnewSelector = groups.join( \",\" );\n\n\t\t\t\t\t// Expand context for sibling selectors\n\t\t\t\t\tnewContext = rsibling.test( selector ) && testContext( context.parentNode ) ||\n\t\t\t\t\t\tcontext;\n\t\t\t\t}\n\n\t\t\t\tif ( newSelector ) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tpush.apply( results,\n\t\t\t\t\t\t\tnewContext.querySelectorAll( newSelector )\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t} catch ( qsaError ) {\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tif ( nid === expando ) {\n\t\t\t\t\t\t\tcontext.removeAttribute( \"id\" );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// All others\n\treturn select( selector.replace( rtrim, \"$1\" ), context, results, seed );\n}\n\n/**\n * Create key-value caches of limited size\n * @returns {function(string, object)} Returns the Object data after storing it on itself with\n *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n *\tdeleting the oldest entry\n */\nfunction createCache() {\n\tvar keys = [];\n\n\tfunction cache( key, value ) {\n\t\t// Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\n\t\tif ( keys.push( key + \" \" ) > Expr.cacheLength ) {\n\t\t\t// Only keep the most recent entries\n\t\t\tdelete cache[ keys.shift() ];\n\t\t}\n\t\treturn (cache[ key + \" \" ] = value);\n\t}\n\treturn cache;\n}\n\n/**\n * Mark a function for special use by Sizzle\n * @param {Function} fn The function to mark\n */\nfunction markFunction( fn ) {\n\tfn[ expando ] = true;\n\treturn fn;\n}\n\n/**\n * Support testing using an element\n * @param {Function} fn Passed the created element and returns a boolean result\n */\nfunction assert( fn ) {\n\tvar el = document.createElement(\"fieldset\");\n\n\ttry {\n\t\treturn !!fn( el );\n\t} catch (e) {\n\t\treturn false;\n\t} finally {\n\t\t// Remove from its parent by default\n\t\tif ( el.parentNode ) {\n\t\t\tel.parentNode.removeChild( el );\n\t\t}\n\t\t// release memory in IE\n\t\tel = null;\n\t}\n}\n\n/**\n * Adds the same handler for all of the specified attrs\n * @param {String} attrs Pipe-separated list of attributes\n * @param {Function} handler The method that will be applied\n */\nfunction addHandle( attrs, handler ) {\n\tvar arr = attrs.split(\"|\"),\n\t\ti = arr.length;\n\n\twhile ( i-- ) {\n\t\tExpr.attrHandle[ arr[i] ] = handler;\n\t}\n}\n\n/**\n * Checks document order of two siblings\n * @param {Element} a\n * @param {Element} b\n * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n */\nfunction siblingCheck( a, b ) {\n\tvar cur = b && a,\n\t\tdiff = cur && a.nodeType === 1 && b.nodeType === 1 &&\n\t\t\ta.sourceIndex - b.sourceIndex;\n\n\t// Use IE sourceIndex if available on both nodes\n\tif ( diff ) {\n\t\treturn diff;\n\t}\n\n\t// Check if b follows a\n\tif ( cur ) {\n\t\twhile ( (cur = cur.nextSibling) ) {\n\t\t\tif ( cur === b ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn a ? 1 : -1;\n}\n\n/**\n * Returns a function to use in pseudos for input types\n * @param {String} type\n */\nfunction createInputPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn name === \"input\" && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for buttons\n * @param {String} type\n */\nfunction createButtonPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn (name === \"input\" || name === \"button\") && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for :enabled/:disabled\n * @param {Boolean} disabled true for :disabled; false for :enabled\n */\nfunction createDisabledPseudo( disabled ) {\n\n\t// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable\n\treturn function( elem ) {\n\n\t\t// Only certain elements can match :enabled or :disabled\n\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled\n\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled\n\t\tif ( \"form\" in elem ) {\n\n\t\t\t// Check for inherited disabledness on relevant non-disabled elements:\n\t\t\t// * listed form-associated elements in a disabled fieldset\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#category-listed\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled\n\t\t\t// * option elements in a disabled optgroup\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled\n\t\t\t// All such elements have a \"form\" property.\n\t\t\tif ( elem.parentNode && elem.disabled === false ) {\n\n\t\t\t\t// Option elements defer to a parent optgroup if present\n\t\t\t\tif ( \"label\" in elem ) {\n\t\t\t\t\tif ( \"label\" in elem.parentNode ) {\n\t\t\t\t\t\treturn elem.parentNode.disabled === disabled;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn elem.disabled === disabled;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Support: IE 6 - 11\n\t\t\t\t// Use the isDisabled shortcut property to check for disabled fieldset ancestors\n\t\t\t\treturn elem.isDisabled === disabled ||\n\n\t\t\t\t\t// Where there is no isDisabled, check manually\n\t\t\t\t\t/* jshint -W018 */\n\t\t\t\t\telem.isDisabled !== !disabled &&\n\t\t\t\t\t\tdisabledAncestor( elem ) === disabled;\n\t\t\t}\n\n\t\t\treturn elem.disabled === disabled;\n\n\t\t// Try to winnow out elements that can't be disabled before trusting the disabled property.\n\t\t// Some victims get caught in our net (label, legend, menu, track), but it shouldn't\n\t\t// even exist on them, let alone have a boolean value.\n\t\t} else if ( \"label\" in elem ) {\n\t\t\treturn elem.disabled === disabled;\n\t\t}\n\n\t\t// Remaining elements are neither :enabled nor :disabled\n\t\treturn false;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for positionals\n * @param {Function} fn\n */\nfunction createPositionalPseudo( fn ) {\n\treturn markFunction(function( argument ) {\n\t\targument = +argument;\n\t\treturn markFunction(function( seed, matches ) {\n\t\t\tvar j,\n\t\t\t\tmatchIndexes = fn( [], seed.length, argument ),\n\t\t\t\ti = matchIndexes.length;\n\n\t\t\t// Match elements found at the specified indexes\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( seed[ (j = matchIndexes[i]) ] ) {\n\t\t\t\t\tseed[j] = !(matches[j] = seed[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n}\n\n/**\n * Checks a node for validity as a Sizzle context\n * @param {Element|Object=} context\n * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n */\nfunction testContext( context ) {\n\treturn context && typeof context.getElementsByTagName !== \"undefined\" && context;\n}\n\n// Expose support vars for convenience\nsupport = Sizzle.support = {};\n\n/**\n * Detects XML nodes\n * @param {Element|Object} elem An element or a document\n * @returns {Boolean} True iff elem is a non-HTML XML node\n */\nisXML = Sizzle.isXML = function( elem ) {\n\t// documentElement is verified for cases where it doesn't yet exist\n\t// (such as loading iframes in IE - #4833)\n\tvar documentElement = elem && (elem.ownerDocument || elem).documentElement;\n\treturn documentElement ? documentElement.nodeName !== \"HTML\" : false;\n};\n\n/**\n * Sets document-related variables once based on the current document\n * @param {Element|Object} [doc] An element or document object to use to set the document\n * @returns {Object} Returns the current document\n */\nsetDocument = Sizzle.setDocument = function( node ) {\n\tvar hasCompare, subWindow,\n\t\tdoc = node ? node.ownerDocument || node : preferredDoc;\n\n\t// Return early if doc is invalid or already selected\n\tif ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {\n\t\treturn document;\n\t}\n\n\t// Update global variables\n\tdocument = doc;\n\tdocElem = document.documentElement;\n\tdocumentIsHTML = !isXML( document );\n\n\t// Support: IE 9-11, Edge\n\t// Accessing iframe documents after unload throws \"permission denied\" errors (jQuery #13936)\n\tif ( preferredDoc !== document &&\n\t\t(subWindow = document.defaultView) && subWindow.top !== subWindow ) {\n\n\t\t// Support: IE 11, Edge\n\t\tif ( subWindow.addEventListener ) {\n\t\t\tsubWindow.addEventListener( \"unload\", unloadHandler, false );\n\n\t\t// Support: IE 9 - 10 only\n\t\t} else if ( subWindow.attachEvent ) {\n\t\t\tsubWindow.attachEvent( \"onunload\", unloadHandler );\n\t\t}\n\t}\n\n\t/* Attributes\n\t---------------------------------------------------------------------- */\n\n\t// Support: IE<8\n\t// Verify that getAttribute really returns attributes and not properties\n\t// (excepting IE8 booleans)\n\tsupport.attributes = assert(function( el ) {\n\t\tel.className = \"i\";\n\t\treturn !el.getAttribute(\"className\");\n\t});\n\n\t/* getElement(s)By*\n\t---------------------------------------------------------------------- */\n\n\t// Check if getElementsByTagName(\"*\") returns only elements\n\tsupport.getElementsByTagName = assert(function( el ) {\n\t\tel.appendChild( document.createComment(\"\") );\n\t\treturn !el.getElementsByTagName(\"*\").length;\n\t});\n\n\t// Support: IE<9\n\tsupport.getElementsByClassName = rnative.test( document.getElementsByClassName );\n\n\t// Support: IE<10\n\t// Check if getElementById returns elements by name\n\t// The broken getElementById methods don't pick up programmatically-set names,\n\t// so use a roundabout getElementsByName test\n\tsupport.getById = assert(function( el ) {\n\t\tdocElem.appendChild( el ).id = expando;\n\t\treturn !document.getElementsByName || !document.getElementsByName( expando ).length;\n\t});\n\n\t// ID filter and find\n\tif ( support.getById ) {\n\t\tExpr.filter[\"ID\"] = function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn elem.getAttribute(\"id\") === attrId;\n\t\t\t};\n\t\t};\n\t\tExpr.find[\"ID\"] = function( id, context ) {\n\t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\n\t\t\t\tvar elem = context.getElementById( id );\n\t\t\t\treturn elem ? [ elem ] : [];\n\t\t\t}\n\t\t};\n\t} else {\n\t\tExpr.filter[\"ID\"] =  function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\tvar node = typeof elem.getAttributeNode !== \"undefined\" &&\n\t\t\t\t\telem.getAttributeNode(\"id\");\n\t\t\t\treturn node && node.value === attrId;\n\t\t\t};\n\t\t};\n\n\t\t// Support: IE 6 - 7 only\n\t\t// getElementById is not reliable as a find shortcut\n\t\tExpr.find[\"ID\"] = function( id, context ) {\n\t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\n\t\t\t\tvar node, i, elems,\n\t\t\t\t\telem = context.getElementById( id );\n\n\t\t\t\tif ( elem ) {\n\n\t\t\t\t\t// Verify the id attribute\n\t\t\t\t\tnode = elem.getAttributeNode(\"id\");\n\t\t\t\t\tif ( node && node.value === id ) {\n\t\t\t\t\t\treturn [ elem ];\n\t\t\t\t\t}\n\n\t\t\t\t\t// Fall back on getElementsByName\n\t\t\t\t\telems = context.getElementsByName( id );\n\t\t\t\t\ti = 0;\n\t\t\t\t\twhile ( (elem = elems[i++]) ) {\n\t\t\t\t\t\tnode = elem.getAttributeNode(\"id\");\n\t\t\t\t\t\tif ( node && node.value === id ) {\n\t\t\t\t\t\t\treturn [ elem ];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn [];\n\t\t\t}\n\t\t};\n\t}\n\n\t// Tag\n\tExpr.find[\"TAG\"] = support.getElementsByTagName ?\n\t\tfunction( tag, context ) {\n\t\t\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\n\t\t\t\treturn context.getElementsByTagName( tag );\n\n\t\t\t// DocumentFragment nodes don't have gEBTN\n\t\t\t} else if ( support.qsa ) {\n\t\t\t\treturn context.querySelectorAll( tag );\n\t\t\t}\n\t\t} :\n\n\t\tfunction( tag, context ) {\n\t\t\tvar elem,\n\t\t\t\ttmp = [],\n\t\t\t\ti = 0,\n\t\t\t\t// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\n\t\t\t\tresults = context.getElementsByTagName( tag );\n\n\t\t\t// Filter out possible comments\n\t\t\tif ( tag === \"*\" ) {\n\t\t\t\twhile ( (elem = results[i++]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\ttmp.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn tmp;\n\t\t\t}\n\t\t\treturn results;\n\t\t};\n\n\t// Class\n\tExpr.find[\"CLASS\"] = support.getElementsByClassName && function( className, context ) {\n\t\tif ( typeof context.getElementsByClassName !== \"undefined\" && documentIsHTML ) {\n\t\t\treturn context.getElementsByClassName( className );\n\t\t}\n\t};\n\n\t/* QSA/matchesSelector\n\t---------------------------------------------------------------------- */\n\n\t// QSA and matchesSelector support\n\n\t// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n\trbuggyMatches = [];\n\n\t// qSa(:focus) reports false when true (Chrome 21)\n\t// We allow this because of a bug in IE8/9 that throws an error\n\t// whenever `document.activeElement` is accessed on an iframe\n\t// So, we allow :focus to pass through QSA all the time to avoid the IE error\n\t// See https://bugs.jquery.com/ticket/13378\n\trbuggyQSA = [];\n\n\tif ( (support.qsa = rnative.test( document.querySelectorAll )) ) {\n\t\t// Build QSA regex\n\t\t// Regex strategy adopted from Diego Perini\n\t\tassert(function( el ) {\n\t\t\t// Select is set to empty string on purpose\n\t\t\t// This is to test IE's treatment of not explicitly\n\t\t\t// setting a boolean content attribute,\n\t\t\t// since its presence should be enough\n\t\t\t// https://bugs.jquery.com/ticket/12359\n\t\t\tdocElem.appendChild( el ).innerHTML = \"<a id='\" + expando + \"'></a>\" +\n\t\t\t\t\"<select id='\" + expando + \"-\\r\\\\' msallowcapture=''>\" +\n\t\t\t\t\"<option selected=''></option></select>\";\n\n\t\t\t// Support: IE8, Opera 11-12.16\n\t\t\t// Nothing should be selected when empty strings follow ^= or $= or *=\n\t\t\t// The test attribute must be unknown in Opera but \"safe\" for WinRT\n\t\t\t// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\n\t\t\tif ( el.querySelectorAll(\"[msallowcapture^='']\").length ) {\n\t\t\t\trbuggyQSA.push( \"[*^$]=\" + whitespace + \"*(?:''|\\\"\\\")\" );\n\t\t\t}\n\n\t\t\t// Support: IE8\n\t\t\t// Boolean attributes and \"value\" are not treated correctly\n\t\t\tif ( !el.querySelectorAll(\"[selected]\").length ) {\n\t\t\t\trbuggyQSA.push( \"\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\" );\n\t\t\t}\n\n\t\t\t// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+\n\t\t\tif ( !el.querySelectorAll( \"[id~=\" + expando + \"-]\" ).length ) {\n\t\t\t\trbuggyQSA.push(\"~=\");\n\t\t\t}\n\n\t\t\t// Webkit/Opera - :checked should return selected option elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( !el.querySelectorAll(\":checked\").length ) {\n\t\t\t\trbuggyQSA.push(\":checked\");\n\t\t\t}\n\n\t\t\t// Support: Safari 8+, iOS 8+\n\t\t\t// https://bugs.webkit.org/show_bug.cgi?id=136851\n\t\t\t// In-page `selector#id sibling-combinator selector` fails\n\t\t\tif ( !el.querySelectorAll( \"a#\" + expando + \"+*\" ).length ) {\n\t\t\t\trbuggyQSA.push(\".#.+[+~]\");\n\t\t\t}\n\t\t});\n\n\t\tassert(function( el ) {\n\t\t\tel.innerHTML = \"<a href='' disabled='disabled'></a>\" +\n\t\t\t\t\"<select disabled='disabled'><option/></select>\";\n\n\t\t\t// Support: Windows 8 Native Apps\n\t\t\t// The type and name attributes are restricted during .innerHTML assignment\n\t\t\tvar input = document.createElement(\"input\");\n\t\t\tinput.setAttribute( \"type\", \"hidden\" );\n\t\t\tel.appendChild( input ).setAttribute( \"name\", \"D\" );\n\n\t\t\t// Support: IE8\n\t\t\t// Enforce case-sensitivity of name attribute\n\t\t\tif ( el.querySelectorAll(\"[name=d]\").length ) {\n\t\t\t\trbuggyQSA.push( \"name\" + whitespace + \"*[*^$|!~]?=\" );\n\t\t\t}\n\n\t\t\t// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( el.querySelectorAll(\":enabled\").length !== 2 ) {\n\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n\t\t\t}\n\n\t\t\t// Support: IE9-11+\n\t\t\t// IE's :disabled selector does not pick up the children of disabled fieldsets\n\t\t\tdocElem.appendChild( el ).disabled = true;\n\t\t\tif ( el.querySelectorAll(\":disabled\").length !== 2 ) {\n\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n\t\t\t}\n\n\t\t\t// Opera 10-11 does not throw on post-comma invalid pseudos\n\t\t\tel.querySelectorAll(\"*,:x\");\n\t\t\trbuggyQSA.push(\",.*:\");\n\t\t});\n\t}\n\n\tif ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||\n\t\tdocElem.webkitMatchesSelector ||\n\t\tdocElem.mozMatchesSelector ||\n\t\tdocElem.oMatchesSelector ||\n\t\tdocElem.msMatchesSelector) )) ) {\n\n\t\tassert(function( el ) {\n\t\t\t// Check to see if it's possible to do matchesSelector\n\t\t\t// on a disconnected node (IE 9)\n\t\t\tsupport.disconnectedMatch = matches.call( el, \"*\" );\n\n\t\t\t// This should fail with an exception\n\t\t\t// Gecko does not error, returns false instead\n\t\t\tmatches.call( el, \"[s!='']:x\" );\n\t\t\trbuggyMatches.push( \"!=\", pseudos );\n\t\t});\n\t}\n\n\trbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join(\"|\") );\n\trbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join(\"|\") );\n\n\t/* Contains\n\t---------------------------------------------------------------------- */\n\thasCompare = rnative.test( docElem.compareDocumentPosition );\n\n\t// Element contains another\n\t// Purposefully self-exclusive\n\t// As in, an element does not contain itself\n\tcontains = hasCompare || rnative.test( docElem.contains ) ?\n\t\tfunction( a, b ) {\n\t\t\tvar adown = a.nodeType === 9 ? a.documentElement : a,\n\t\t\t\tbup = b && b.parentNode;\n\t\t\treturn a === bup || !!( bup && bup.nodeType === 1 && (\n\t\t\t\tadown.contains ?\n\t\t\t\t\tadown.contains( bup ) :\n\t\t\t\t\ta.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\n\t\t\t));\n\t\t} :\n\t\tfunction( a, b ) {\n\t\t\tif ( b ) {\n\t\t\t\twhile ( (b = b.parentNode) ) {\n\t\t\t\t\tif ( b === a ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\t/* Sorting\n\t---------------------------------------------------------------------- */\n\n\t// Document order sorting\n\tsortOrder = hasCompare ?\n\tfunction( a, b ) {\n\n\t\t// Flag for duplicate removal\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Sort on method existence if only one input has compareDocumentPosition\n\t\tvar compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n\t\tif ( compare ) {\n\t\t\treturn compare;\n\t\t}\n\n\t\t// Calculate position if both inputs belong to the same document\n\t\tcompare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?\n\t\t\ta.compareDocumentPosition( b ) :\n\n\t\t\t// Otherwise we know they are disconnected\n\t\t\t1;\n\n\t\t// Disconnected nodes\n\t\tif ( compare & 1 ||\n\t\t\t(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {\n\n\t\t\t// Choose the first element that is related to our preferred document\n\t\t\tif ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\t// Maintain original order\n\t\t\treturn sortInput ?\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t0;\n\t\t}\n\n\t\treturn compare & 4 ? -1 : 1;\n\t} :\n\tfunction( a, b ) {\n\t\t// Exit early if the nodes are identical\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\taup = a.parentNode,\n\t\t\tbup = b.parentNode,\n\t\t\tap = [ a ],\n\t\t\tbp = [ b ];\n\n\t\t// Parentless nodes are either documents or disconnected\n\t\tif ( !aup || !bup ) {\n\t\t\treturn a === document ? -1 :\n\t\t\t\tb === document ? 1 :\n\t\t\t\taup ? -1 :\n\t\t\t\tbup ? 1 :\n\t\t\t\tsortInput ?\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t0;\n\n\t\t// If the nodes are siblings, we can do a quick check\n\t\t} else if ( aup === bup ) {\n\t\t\treturn siblingCheck( a, b );\n\t\t}\n\n\t\t// Otherwise we need full lists of their ancestors for comparison\n\t\tcur = a;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tap.unshift( cur );\n\t\t}\n\t\tcur = b;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tbp.unshift( cur );\n\t\t}\n\n\t\t// Walk down the tree looking for a discrepancy\n\t\twhile ( ap[i] === bp[i] ) {\n\t\t\ti++;\n\t\t}\n\n\t\treturn i ?\n\t\t\t// Do a sibling check if the nodes have a common ancestor\n\t\t\tsiblingCheck( ap[i], bp[i] ) :\n\n\t\t\t// Otherwise nodes in our document sort first\n\t\t\tap[i] === preferredDoc ? -1 :\n\t\t\tbp[i] === preferredDoc ? 1 :\n\t\t\t0;\n\t};\n\n\treturn document;\n};\n\nSizzle.matches = function( expr, elements ) {\n\treturn Sizzle( expr, null, null, elements );\n};\n\nSizzle.matchesSelector = function( elem, expr ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\t// Make sure that attribute selectors are quoted\n\texpr = expr.replace( rattributeQuotes, \"='$1']\" );\n\n\tif ( support.matchesSelector && documentIsHTML &&\n\t\t!compilerCache[ expr + \" \" ] &&\n\t\t( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&\n\t\t( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {\n\n\t\ttry {\n\t\t\tvar ret = matches.call( elem, expr );\n\n\t\t\t// IE 9's matchesSelector returns false on disconnected nodes\n\t\t\tif ( ret || support.disconnectedMatch ||\n\t\t\t\t\t// As well, disconnected nodes are said to be in a document\n\t\t\t\t\t// fragment in IE 9\n\t\t\t\t\telem.document && elem.document.nodeType !== 11 ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} catch (e) {}\n\t}\n\n\treturn Sizzle( expr, document, null, [ elem ] ).length > 0;\n};\n\nSizzle.contains = function( context, elem ) {\n\t// Set document vars if needed\n\tif ( ( context.ownerDocument || context ) !== document ) {\n\t\tsetDocument( context );\n\t}\n\treturn contains( context, elem );\n};\n\nSizzle.attr = function( elem, name ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\tvar fn = Expr.attrHandle[ name.toLowerCase() ],\n\t\t// Don't get fooled by Object.prototype properties (jQuery #13807)\n\t\tval = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?\n\t\t\tfn( elem, name, !documentIsHTML ) :\n\t\t\tundefined;\n\n\treturn val !== undefined ?\n\t\tval :\n\t\tsupport.attributes || !documentIsHTML ?\n\t\t\telem.getAttribute( name ) :\n\t\t\t(val = elem.getAttributeNode(name)) && val.specified ?\n\t\t\t\tval.value :\n\t\t\t\tnull;\n};\n\nSizzle.escape = function( sel ) {\n\treturn (sel + \"\").replace( rcssescape, fcssescape );\n};\n\nSizzle.error = function( msg ) {\n\tthrow new Error( \"Syntax error, unrecognized expression: \" + msg );\n};\n\n/**\n * Document sorting and removing duplicates\n * @param {ArrayLike} results\n */\nSizzle.uniqueSort = function( results ) {\n\tvar elem,\n\t\tduplicates = [],\n\t\tj = 0,\n\t\ti = 0;\n\n\t// Unless we *know* we can detect duplicates, assume their presence\n\thasDuplicate = !support.detectDuplicates;\n\tsortInput = !support.sortStable && results.slice( 0 );\n\tresults.sort( sortOrder );\n\n\tif ( hasDuplicate ) {\n\t\twhile ( (elem = results[i++]) ) {\n\t\t\tif ( elem === results[ i ] ) {\n\t\t\t\tj = duplicates.push( i );\n\t\t\t}\n\t\t}\n\t\twhile ( j-- ) {\n\t\t\tresults.splice( duplicates[ j ], 1 );\n\t\t}\n\t}\n\n\t// Clear input after sorting to release objects\n\t// See https://github.com/jquery/sizzle/pull/225\n\tsortInput = null;\n\n\treturn results;\n};\n\n/**\n * Utility function for retrieving the text value of an array of DOM nodes\n * @param {Array|Element} elem\n */\ngetText = Sizzle.getText = function( elem ) {\n\tvar node,\n\t\tret = \"\",\n\t\ti = 0,\n\t\tnodeType = elem.nodeType;\n\n\tif ( !nodeType ) {\n\t\t// If no nodeType, this is expected to be an array\n\t\twhile ( (node = elem[i++]) ) {\n\t\t\t// Do not traverse comment nodes\n\t\t\tret += getText( node );\n\t\t}\n\t} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {\n\t\t// Use textContent for elements\n\t\t// innerText usage removed for consistency of new lines (jQuery #11153)\n\t\tif ( typeof elem.textContent === \"string\" ) {\n\t\t\treturn elem.textContent;\n\t\t} else {\n\t\t\t// Traverse its children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tret += getText( elem );\n\t\t\t}\n\t\t}\n\t} else if ( nodeType === 3 || nodeType === 4 ) {\n\t\treturn elem.nodeValue;\n\t}\n\t// Do not include comment or processing instruction nodes\n\n\treturn ret;\n};\n\nExpr = Sizzle.selectors = {\n\n\t// Can be adjusted by the user\n\tcacheLength: 50,\n\n\tcreatePseudo: markFunction,\n\n\tmatch: matchExpr,\n\n\tattrHandle: {},\n\n\tfind: {},\n\n\trelative: {\n\t\t\">\": { dir: \"parentNode\", first: true },\n\t\t\" \": { dir: \"parentNode\" },\n\t\t\"+\": { dir: \"previousSibling\", first: true },\n\t\t\"~\": { dir: \"previousSibling\" }\n\t},\n\n\tpreFilter: {\n\t\t\"ATTR\": function( match ) {\n\t\t\tmatch[1] = match[1].replace( runescape, funescape );\n\n\t\t\t// Move the given value to match[3] whether quoted or unquoted\n\t\t\tmatch[3] = ( match[3] || match[4] || match[5] || \"\" ).replace( runescape, funescape );\n\n\t\t\tif ( match[2] === \"~=\" ) {\n\t\t\t\tmatch[3] = \" \" + match[3] + \" \";\n\t\t\t}\n\n\t\t\treturn match.slice( 0, 4 );\n\t\t},\n\n\t\t\"CHILD\": function( match ) {\n\t\t\t/* matches from matchExpr[\"CHILD\"]\n\t\t\t\t1 type (only|nth|...)\n\t\t\t\t2 what (child|of-type)\n\t\t\t\t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n\t\t\t\t4 xn-component of xn+y argument ([+-]?\\d*n|)\n\t\t\t\t5 sign of xn-component\n\t\t\t\t6 x of xn-component\n\t\t\t\t7 sign of y-component\n\t\t\t\t8 y of y-component\n\t\t\t*/\n\t\t\tmatch[1] = match[1].toLowerCase();\n\n\t\t\tif ( match[1].slice( 0, 3 ) === \"nth\" ) {\n\t\t\t\t// nth-* requires argument\n\t\t\t\tif ( !match[3] ) {\n\t\t\t\t\tSizzle.error( match[0] );\n\t\t\t\t}\n\n\t\t\t\t// numeric x and y parameters for Expr.filter.CHILD\n\t\t\t\t// remember that false/true cast respectively to 0/1\n\t\t\t\tmatch[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === \"even\" || match[3] === \"odd\" ) );\n\t\t\t\tmatch[5] = +( ( match[7] + match[8] ) || match[3] === \"odd\" );\n\n\t\t\t// other types prohibit arguments\n\t\t\t} else if ( match[3] ) {\n\t\t\t\tSizzle.error( match[0] );\n\t\t\t}\n\n\t\t\treturn match;\n\t\t},\n\n\t\t\"PSEUDO\": function( match ) {\n\t\t\tvar excess,\n\t\t\t\tunquoted = !match[6] && match[2];\n\n\t\t\tif ( matchExpr[\"CHILD\"].test( match[0] ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// Accept quoted arguments as-is\n\t\t\tif ( match[3] ) {\n\t\t\t\tmatch[2] = match[4] || match[5] || \"\";\n\n\t\t\t// Strip excess characters from unquoted arguments\n\t\t\t} else if ( unquoted && rpseudo.test( unquoted ) &&\n\t\t\t\t// Get excess from tokenize (recursively)\n\t\t\t\t(excess = tokenize( unquoted, true )) &&\n\t\t\t\t// advance to the next closing parenthesis\n\t\t\t\t(excess = unquoted.indexOf( \")\", unquoted.length - excess ) - unquoted.length) ) {\n\n\t\t\t\t// excess is a negative index\n\t\t\t\tmatch[0] = match[0].slice( 0, excess );\n\t\t\t\tmatch[2] = unquoted.slice( 0, excess );\n\t\t\t}\n\n\t\t\t// Return only captures needed by the pseudo filter method (type and argument)\n\t\t\treturn match.slice( 0, 3 );\n\t\t}\n\t},\n\n\tfilter: {\n\n\t\t\"TAG\": function( nodeNameSelector ) {\n\t\t\tvar nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn nodeNameSelector === \"*\" ?\n\t\t\t\tfunction() { return true; } :\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n\t\t\t\t};\n\t\t},\n\n\t\t\"CLASS\": function( className ) {\n\t\t\tvar pattern = classCache[ className + \" \" ];\n\n\t\t\treturn pattern ||\n\t\t\t\t(pattern = new RegExp( \"(^|\" + whitespace + \")\" + className + \"(\" + whitespace + \"|$)\" )) &&\n\t\t\t\tclassCache( className, function( elem ) {\n\t\t\t\t\treturn pattern.test( typeof elem.className === \"string\" && elem.className || typeof elem.getAttribute !== \"undefined\" && elem.getAttribute(\"class\") || \"\" );\n\t\t\t\t});\n\t\t},\n\n\t\t\"ATTR\": function( name, operator, check ) {\n\t\t\treturn function( elem ) {\n\t\t\t\tvar result = Sizzle.attr( elem, name );\n\n\t\t\t\tif ( result == null ) {\n\t\t\t\t\treturn operator === \"!=\";\n\t\t\t\t}\n\t\t\t\tif ( !operator ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tresult += \"\";\n\n\t\t\t\treturn operator === \"=\" ? result === check :\n\t\t\t\t\toperator === \"!=\" ? result !== check :\n\t\t\t\t\toperator === \"^=\" ? check && result.indexOf( check ) === 0 :\n\t\t\t\t\toperator === \"*=\" ? check && result.indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"$=\" ? check && result.slice( -check.length ) === check :\n\t\t\t\t\toperator === \"~=\" ? ( \" \" + result.replace( rwhitespace, \" \" ) + \" \" ).indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"|=\" ? result === check || result.slice( 0, check.length + 1 ) === check + \"-\" :\n\t\t\t\t\tfalse;\n\t\t\t};\n\t\t},\n\n\t\t\"CHILD\": function( type, what, argument, first, last ) {\n\t\t\tvar simple = type.slice( 0, 3 ) !== \"nth\",\n\t\t\t\tforward = type.slice( -4 ) !== \"last\",\n\t\t\t\tofType = what === \"of-type\";\n\n\t\t\treturn first === 1 && last === 0 ?\n\n\t\t\t\t// Shortcut for :nth-*(n)\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn !!elem.parentNode;\n\t\t\t\t} :\n\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tvar cache, uniqueCache, outerCache, node, nodeIndex, start,\n\t\t\t\t\t\tdir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\n\t\t\t\t\t\tparent = elem.parentNode,\n\t\t\t\t\t\tname = ofType && elem.nodeName.toLowerCase(),\n\t\t\t\t\t\tuseCache = !xml && !ofType,\n\t\t\t\t\t\tdiff = false;\n\n\t\t\t\t\tif ( parent ) {\n\n\t\t\t\t\t\t// :(first|last|only)-(child|of-type)\n\t\t\t\t\t\tif ( simple ) {\n\t\t\t\t\t\t\twhile ( dir ) {\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\twhile ( (node = node[ dir ]) ) {\n\t\t\t\t\t\t\t\t\tif ( ofType ?\n\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) {\n\n\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Reverse direction for :only-* (if we haven't yet done so)\n\t\t\t\t\t\t\t\tstart = dir = type === \"only\" && !start && \"nextSibling\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstart = [ forward ? parent.firstChild : parent.lastChild ];\n\n\t\t\t\t\t\t// non-xml :nth-child(...) stores cache data on `parent`\n\t\t\t\t\t\tif ( forward && useCache ) {\n\n\t\t\t\t\t\t\t// Seek `elem` from a previously-cached index\n\n\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\tnode = parent;\n\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n\t\t\t\t\t\t\tdiff = nodeIndex && cache[ 2 ];\n\t\t\t\t\t\t\tnode = nodeIndex && parent.childNodes[ nodeIndex ];\n\n\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\n\t\t\t\t\t\t\t\t// Fallback to seeking `elem` from the start\n\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\t// When found, cache indexes on `parent` and break\n\t\t\t\t\t\t\t\tif ( node.nodeType === 1 && ++diff && node === elem ) {\n\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, nodeIndex, diff ];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Use previously-cached element index if available\n\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n\t\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n\t\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n\t\t\t\t\t\t\t\tdiff = nodeIndex;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// xml :nth-child(...)\n\t\t\t\t\t\t\t// or :nth-last-child(...) or :nth(-last)?-of-type(...)\n\t\t\t\t\t\t\tif ( diff === false ) {\n\t\t\t\t\t\t\t\t// Use the same loop as above to seek `elem` from the start\n\t\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\t\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\t\tif ( ( ofType ?\n\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) &&\n\t\t\t\t\t\t\t\t\t\t++diff ) {\n\n\t\t\t\t\t\t\t\t\t\t// Cache the index of each encountered element\n\t\t\t\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n\t\t\t\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n\t\t\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, diff ];\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tif ( node === elem ) {\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Incorporate the offset, then check against cycle size\n\t\t\t\t\t\tdiff -= last;\n\t\t\t\t\t\treturn diff === first || ( diff % first === 0 && diff / first >= 0 );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t},\n\n\t\t\"PSEUDO\": function( pseudo, argument ) {\n\t\t\t// pseudo-class names are case-insensitive\n\t\t\t// http://www.w3.org/TR/selectors/#pseudo-classes\n\t\t\t// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n\t\t\t// Remember that setFilters inherits from pseudos\n\t\t\tvar args,\n\t\t\t\tfn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||\n\t\t\t\t\tSizzle.error( \"unsupported pseudo: \" + pseudo );\n\n\t\t\t// The user may use createPseudo to indicate that\n\t\t\t// arguments are needed to create the filter function\n\t\t\t// just as Sizzle does\n\t\t\tif ( fn[ expando ] ) {\n\t\t\t\treturn fn( argument );\n\t\t\t}\n\n\t\t\t// But maintain support for old signatures\n\t\t\tif ( fn.length > 1 ) {\n\t\t\t\targs = [ pseudo, pseudo, \"\", argument ];\n\t\t\t\treturn Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?\n\t\t\t\t\tmarkFunction(function( seed, matches ) {\n\t\t\t\t\t\tvar idx,\n\t\t\t\t\t\t\tmatched = fn( seed, argument ),\n\t\t\t\t\t\t\ti = matched.length;\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tidx = indexOf( seed, matched[i] );\n\t\t\t\t\t\t\tseed[ idx ] = !( matches[ idx ] = matched[i] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}) :\n\t\t\t\t\tfunction( elem ) {\n\t\t\t\t\t\treturn fn( elem, 0, args );\n\t\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn fn;\n\t\t}\n\t},\n\n\tpseudos: {\n\t\t// Potentially complex pseudos\n\t\t\"not\": markFunction(function( selector ) {\n\t\t\t// Trim the selector passed to compile\n\t\t\t// to avoid treating leading and trailing\n\t\t\t// spaces as combinators\n\t\t\tvar input = [],\n\t\t\t\tresults = [],\n\t\t\t\tmatcher = compile( selector.replace( rtrim, \"$1\" ) );\n\n\t\t\treturn matcher[ expando ] ?\n\t\t\t\tmarkFunction(function( seed, matches, context, xml ) {\n\t\t\t\t\tvar elem,\n\t\t\t\t\t\tunmatched = matcher( seed, null, xml, [] ),\n\t\t\t\t\t\ti = seed.length;\n\n\t\t\t\t\t// Match elements unmatched by `matcher`\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = unmatched[i]) ) {\n\t\t\t\t\t\t\tseed[i] = !(matches[i] = elem);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}) :\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tinput[0] = elem;\n\t\t\t\t\tmatcher( input, null, xml, results );\n\t\t\t\t\t// Don't keep the element (issue #299)\n\t\t\t\t\tinput[0] = null;\n\t\t\t\t\treturn !results.pop();\n\t\t\t\t};\n\t\t}),\n\n\t\t\"has\": markFunction(function( selector ) {\n\t\t\treturn function( elem ) {\n\t\t\t\treturn Sizzle( selector, elem ).length > 0;\n\t\t\t};\n\t\t}),\n\n\t\t\"contains\": markFunction(function( text ) {\n\t\t\ttext = text.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;\n\t\t\t};\n\t\t}),\n\n\t\t// \"Whether an element is represented by a :lang() selector\n\t\t// is based solely on the element's language value\n\t\t// being equal to the identifier C,\n\t\t// or beginning with the identifier C immediately followed by \"-\".\n\t\t// The matching of C against the element's language value is performed case-insensitively.\n\t\t// The identifier C does not have to be a valid language name.\"\n\t\t// http://www.w3.org/TR/selectors/#lang-pseudo\n\t\t\"lang\": markFunction( function( lang ) {\n\t\t\t// lang value must be a valid identifier\n\t\t\tif ( !ridentifier.test(lang || \"\") ) {\n\t\t\t\tSizzle.error( \"unsupported lang: \" + lang );\n\t\t\t}\n\t\t\tlang = lang.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn function( elem ) {\n\t\t\t\tvar elemLang;\n\t\t\t\tdo {\n\t\t\t\t\tif ( (elemLang = documentIsHTML ?\n\t\t\t\t\t\telem.lang :\n\t\t\t\t\t\telem.getAttribute(\"xml:lang\") || elem.getAttribute(\"lang\")) ) {\n\n\t\t\t\t\t\telemLang = elemLang.toLowerCase();\n\t\t\t\t\t\treturn elemLang === lang || elemLang.indexOf( lang + \"-\" ) === 0;\n\t\t\t\t\t}\n\t\t\t\t} while ( (elem = elem.parentNode) && elem.nodeType === 1 );\n\t\t\t\treturn false;\n\t\t\t};\n\t\t}),\n\n\t\t// Miscellaneous\n\t\t\"target\": function( elem ) {\n\t\t\tvar hash = window.location && window.location.hash;\n\t\t\treturn hash && hash.slice( 1 ) === elem.id;\n\t\t},\n\n\t\t\"root\": function( elem ) {\n\t\t\treturn elem === docElem;\n\t\t},\n\n\t\t\"focus\": function( elem ) {\n\t\t\treturn elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\n\t\t},\n\n\t\t// Boolean properties\n\t\t\"enabled\": createDisabledPseudo( false ),\n\t\t\"disabled\": createDisabledPseudo( true ),\n\n\t\t\"checked\": function( elem ) {\n\t\t\t// In CSS3, :checked should return both checked and selected elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\tvar nodeName = elem.nodeName.toLowerCase();\n\t\t\treturn (nodeName === \"input\" && !!elem.checked) || (nodeName === \"option\" && !!elem.selected);\n\t\t},\n\n\t\t\"selected\": function( elem ) {\n\t\t\t// Accessing this property makes selected-by-default\n\t\t\t// options in Safari work properly\n\t\t\tif ( elem.parentNode ) {\n\t\t\t\telem.parentNode.selectedIndex;\n\t\t\t}\n\n\t\t\treturn elem.selected === true;\n\t\t},\n\n\t\t// Contents\n\t\t\"empty\": function( elem ) {\n\t\t\t// http://www.w3.org/TR/selectors/#empty-pseudo\n\t\t\t// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n\t\t\t//   but not by others (comment: 8; processing instruction: 7; etc.)\n\t\t\t// nodeType < 6 works because attributes (2) do not appear as children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tif ( elem.nodeType < 6 ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\n\t\t\"parent\": function( elem ) {\n\t\t\treturn !Expr.pseudos[\"empty\"]( elem );\n\t\t},\n\n\t\t// Element/input types\n\t\t\"header\": function( elem ) {\n\t\t\treturn rheader.test( elem.nodeName );\n\t\t},\n\n\t\t\"input\": function( elem ) {\n\t\t\treturn rinputs.test( elem.nodeName );\n\t\t},\n\n\t\t\"button\": function( elem ) {\n\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\treturn name === \"input\" && elem.type === \"button\" || name === \"button\";\n\t\t},\n\n\t\t\"text\": function( elem ) {\n\t\t\tvar attr;\n\t\t\treturn elem.nodeName.toLowerCase() === \"input\" &&\n\t\t\t\telem.type === \"text\" &&\n\n\t\t\t\t// Support: IE<8\n\t\t\t\t// New HTML5 attribute values (e.g., \"search\") appear with elem.type === \"text\"\n\t\t\t\t( (attr = elem.getAttribute(\"type\")) == null || attr.toLowerCase() === \"text\" );\n\t\t},\n\n\t\t// Position-in-collection\n\t\t\"first\": createPositionalPseudo(function() {\n\t\t\treturn [ 0 ];\n\t\t}),\n\n\t\t\"last\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\treturn [ length - 1 ];\n\t\t}),\n\n\t\t\"eq\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\treturn [ argument < 0 ? argument + length : argument ];\n\t\t}),\n\n\t\t\"even\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"odd\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 1;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"lt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; --i >= 0; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"gt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; ++i < length; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t})\n\t}\n};\n\nExpr.pseudos[\"nth\"] = Expr.pseudos[\"eq\"];\n\n// Add button/input type pseudos\nfor ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\n\tExpr.pseudos[ i ] = createInputPseudo( i );\n}\nfor ( i in { submit: true, reset: true } ) {\n\tExpr.pseudos[ i ] = createButtonPseudo( i );\n}\n\n// Easy API for creating new setFilters\nfunction setFilters() {}\nsetFilters.prototype = Expr.filters = Expr.pseudos;\nExpr.setFilters = new setFilters();\n\ntokenize = Sizzle.tokenize = function( selector, parseOnly ) {\n\tvar matched, match, tokens, type,\n\t\tsoFar, groups, preFilters,\n\t\tcached = tokenCache[ selector + \" \" ];\n\n\tif ( cached ) {\n\t\treturn parseOnly ? 0 : cached.slice( 0 );\n\t}\n\n\tsoFar = selector;\n\tgroups = [];\n\tpreFilters = Expr.preFilter;\n\n\twhile ( soFar ) {\n\n\t\t// Comma and first run\n\t\tif ( !matched || (match = rcomma.exec( soFar )) ) {\n\t\t\tif ( match ) {\n\t\t\t\t// Don't consume trailing commas as valid\n\t\t\t\tsoFar = soFar.slice( match[0].length ) || soFar;\n\t\t\t}\n\t\t\tgroups.push( (tokens = []) );\n\t\t}\n\n\t\tmatched = false;\n\n\t\t// Combinators\n\t\tif ( (match = rcombinators.exec( soFar )) ) {\n\t\t\tmatched = match.shift();\n\t\t\ttokens.push({\n\t\t\t\tvalue: matched,\n\t\t\t\t// Cast descendant combinators to space\n\t\t\t\ttype: match[0].replace( rtrim, \" \" )\n\t\t\t});\n\t\t\tsoFar = soFar.slice( matched.length );\n\t\t}\n\n\t\t// Filters\n\t\tfor ( type in Expr.filter ) {\n\t\t\tif ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||\n\t\t\t\t(match = preFilters[ type ]( match ))) ) {\n\t\t\t\tmatched = match.shift();\n\t\t\t\ttokens.push({\n\t\t\t\t\tvalue: matched,\n\t\t\t\t\ttype: type,\n\t\t\t\t\tmatches: match\n\t\t\t\t});\n\t\t\t\tsoFar = soFar.slice( matched.length );\n\t\t\t}\n\t\t}\n\n\t\tif ( !matched ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Return the length of the invalid excess\n\t// if we're just parsing\n\t// Otherwise, throw an error or return tokens\n\treturn parseOnly ?\n\t\tsoFar.length :\n\t\tsoFar ?\n\t\t\tSizzle.error( selector ) :\n\t\t\t// Cache the tokens\n\t\t\ttokenCache( selector, groups ).slice( 0 );\n};\n\nfunction toSelector( tokens ) {\n\tvar i = 0,\n\t\tlen = tokens.length,\n\t\tselector = \"\";\n\tfor ( ; i < len; i++ ) {\n\t\tselector += tokens[i].value;\n\t}\n\treturn selector;\n}\n\nfunction addCombinator( matcher, combinator, base ) {\n\tvar dir = combinator.dir,\n\t\tskip = combinator.next,\n\t\tkey = skip || dir,\n\t\tcheckNonElements = base && key === \"parentNode\",\n\t\tdoneName = done++;\n\n\treturn combinator.first ?\n\t\t// Check against closest ancestor/preceding element\n\t\tfunction( elem, context, xml ) {\n\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\treturn matcher( elem, context, xml );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t} :\n\n\t\t// Check against all ancestor/preceding elements\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar oldCache, uniqueCache, outerCache,\n\t\t\t\tnewCache = [ dirruns, doneName ];\n\n\t\t\t// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching\n\t\t\tif ( xml ) {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\touterCache = elem[ expando ] || (elem[ expando ] = {});\n\n\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\tuniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});\n\n\t\t\t\t\t\tif ( skip && skip === elem.nodeName.toLowerCase() ) {\n\t\t\t\t\t\t\telem = elem[ dir ] || elem;\n\t\t\t\t\t\t} else if ( (oldCache = uniqueCache[ key ]) &&\n\t\t\t\t\t\t\toldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {\n\n\t\t\t\t\t\t\t// Assign to newCache so results back-propagate to previous elements\n\t\t\t\t\t\t\treturn (newCache[ 2 ] = oldCache[ 2 ]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Reuse newcache so results back-propagate to previous elements\n\t\t\t\t\t\t\tuniqueCache[ key ] = newCache;\n\n\t\t\t\t\t\t\t// A match means we're done; a fail means we have to keep checking\n\t\t\t\t\t\t\tif ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n}\n\nfunction elementMatcher( matchers ) {\n\treturn matchers.length > 1 ?\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar i = matchers.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( !matchers[i]( elem, context, xml ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} :\n\t\tmatchers[0];\n}\n\nfunction multipleContexts( selector, contexts, results ) {\n\tvar i = 0,\n\t\tlen = contexts.length;\n\tfor ( ; i < len; i++ ) {\n\t\tSizzle( selector, contexts[i], results );\n\t}\n\treturn results;\n}\n\nfunction condense( unmatched, map, filter, context, xml ) {\n\tvar elem,\n\t\tnewUnmatched = [],\n\t\ti = 0,\n\t\tlen = unmatched.length,\n\t\tmapped = map != null;\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (elem = unmatched[i]) ) {\n\t\t\tif ( !filter || filter( elem, context, xml ) ) {\n\t\t\t\tnewUnmatched.push( elem );\n\t\t\t\tif ( mapped ) {\n\t\t\t\t\tmap.push( i );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn newUnmatched;\n}\n\nfunction setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {\n\tif ( postFilter && !postFilter[ expando ] ) {\n\t\tpostFilter = setMatcher( postFilter );\n\t}\n\tif ( postFinder && !postFinder[ expando ] ) {\n\t\tpostFinder = setMatcher( postFinder, postSelector );\n\t}\n\treturn markFunction(function( seed, results, context, xml ) {\n\t\tvar temp, i, elem,\n\t\t\tpreMap = [],\n\t\t\tpostMap = [],\n\t\t\tpreexisting = results.length,\n\n\t\t\t// Get initial elements from seed or context\n\t\t\telems = seed || multipleContexts( selector || \"*\", context.nodeType ? [ context ] : context, [] ),\n\n\t\t\t// Prefilter to get matcher input, preserving a map for seed-results synchronization\n\t\t\tmatcherIn = preFilter && ( seed || !selector ) ?\n\t\t\t\tcondense( elems, preMap, preFilter, context, xml ) :\n\t\t\t\telems,\n\n\t\t\tmatcherOut = matcher ?\n\t\t\t\t// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n\t\t\t\tpostFinder || ( seed ? preFilter : preexisting || postFilter ) ?\n\n\t\t\t\t\t// ...intermediate processing is necessary\n\t\t\t\t\t[] :\n\n\t\t\t\t\t// ...otherwise use results directly\n\t\t\t\t\tresults :\n\t\t\t\tmatcherIn;\n\n\t\t// Find primary matches\n\t\tif ( matcher ) {\n\t\t\tmatcher( matcherIn, matcherOut, context, xml );\n\t\t}\n\n\t\t// Apply postFilter\n\t\tif ( postFilter ) {\n\t\t\ttemp = condense( matcherOut, postMap );\n\t\t\tpostFilter( temp, [], context, xml );\n\n\t\t\t// Un-match failing elements by moving them back to matcherIn\n\t\t\ti = temp.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( (elem = temp[i]) ) {\n\t\t\t\t\tmatcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( seed ) {\n\t\t\tif ( postFinder || preFilter ) {\n\t\t\t\tif ( postFinder ) {\n\t\t\t\t\t// Get the final matcherOut by condensing this intermediate into postFinder contexts\n\t\t\t\t\ttemp = [];\n\t\t\t\t\ti = matcherOut.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = matcherOut[i]) ) {\n\t\t\t\t\t\t\t// Restore matcherIn since elem is not yet a final match\n\t\t\t\t\t\t\ttemp.push( (matcherIn[i] = elem) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpostFinder( null, (matcherOut = []), temp, xml );\n\t\t\t\t}\n\n\t\t\t\t// Move matched elements from seed to results to keep them synchronized\n\t\t\t\ti = matcherOut.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( (elem = matcherOut[i]) &&\n\t\t\t\t\t\t(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {\n\n\t\t\t\t\t\tseed[temp] = !(results[temp] = elem);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Add elements to results, through postFinder if defined\n\t\t} else {\n\t\t\tmatcherOut = condense(\n\t\t\t\tmatcherOut === results ?\n\t\t\t\t\tmatcherOut.splice( preexisting, matcherOut.length ) :\n\t\t\t\t\tmatcherOut\n\t\t\t);\n\t\t\tif ( postFinder ) {\n\t\t\t\tpostFinder( null, results, matcherOut, xml );\n\t\t\t} else {\n\t\t\t\tpush.apply( results, matcherOut );\n\t\t\t}\n\t\t}\n\t});\n}\n\nfunction matcherFromTokens( tokens ) {\n\tvar checkContext, matcher, j,\n\t\tlen = tokens.length,\n\t\tleadingRelative = Expr.relative[ tokens[0].type ],\n\t\timplicitRelative = leadingRelative || Expr.relative[\" \"],\n\t\ti = leadingRelative ? 1 : 0,\n\n\t\t// The foundational matcher ensures that elements are reachable from top-level context(s)\n\t\tmatchContext = addCombinator( function( elem ) {\n\t\t\treturn elem === checkContext;\n\t\t}, implicitRelative, true ),\n\t\tmatchAnyContext = addCombinator( function( elem ) {\n\t\t\treturn indexOf( checkContext, elem ) > -1;\n\t\t}, implicitRelative, true ),\n\t\tmatchers = [ function( elem, context, xml ) {\n\t\t\tvar ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (\n\t\t\t\t(checkContext = context).nodeType ?\n\t\t\t\t\tmatchContext( elem, context, xml ) :\n\t\t\t\t\tmatchAnyContext( elem, context, xml ) );\n\t\t\t// Avoid hanging onto element (issue #299)\n\t\t\tcheckContext = null;\n\t\t\treturn ret;\n\t\t} ];\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (matcher = Expr.relative[ tokens[i].type ]) ) {\n\t\t\tmatchers = [ addCombinator(elementMatcher( matchers ), matcher) ];\n\t\t} else {\n\t\t\tmatcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );\n\n\t\t\t// Return special upon seeing a positional matcher\n\t\t\tif ( matcher[ expando ] ) {\n\t\t\t\t// Find the next relative operator (if any) for proper handling\n\t\t\t\tj = ++i;\n\t\t\t\tfor ( ; j < len; j++ ) {\n\t\t\t\t\tif ( Expr.relative[ tokens[j].type ] ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn setMatcher(\n\t\t\t\t\ti > 1 && elementMatcher( matchers ),\n\t\t\t\t\ti > 1 && toSelector(\n\t\t\t\t\t\t// If the preceding token was a descendant combinator, insert an implicit any-element `*`\n\t\t\t\t\t\ttokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === \" \" ? \"*\" : \"\" })\n\t\t\t\t\t).replace( rtrim, \"$1\" ),\n\t\t\t\t\tmatcher,\n\t\t\t\t\ti < j && matcherFromTokens( tokens.slice( i, j ) ),\n\t\t\t\t\tj < len && matcherFromTokens( (tokens = tokens.slice( j )) ),\n\t\t\t\t\tj < len && toSelector( tokens )\n\t\t\t\t);\n\t\t\t}\n\t\t\tmatchers.push( matcher );\n\t\t}\n\t}\n\n\treturn elementMatcher( matchers );\n}\n\nfunction matcherFromGroupMatchers( elementMatchers, setMatchers ) {\n\tvar bySet = setMatchers.length > 0,\n\t\tbyElement = elementMatchers.length > 0,\n\t\tsuperMatcher = function( seed, context, xml, results, outermost ) {\n\t\t\tvar elem, j, matcher,\n\t\t\t\tmatchedCount = 0,\n\t\t\t\ti = \"0\",\n\t\t\t\tunmatched = seed && [],\n\t\t\t\tsetMatched = [],\n\t\t\t\tcontextBackup = outermostContext,\n\t\t\t\t// We must always have either seed elements or outermost context\n\t\t\t\telems = seed || byElement && Expr.find[\"TAG\"]( \"*\", outermost ),\n\t\t\t\t// Use integer dirruns iff this is the outermost matcher\n\t\t\t\tdirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),\n\t\t\t\tlen = elems.length;\n\n\t\t\tif ( outermost ) {\n\t\t\t\toutermostContext = context === document || context || outermost;\n\t\t\t}\n\n\t\t\t// Add elements passing elementMatchers directly to results\n\t\t\t// Support: IE<9, Safari\n\t\t\t// Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching elements by id\n\t\t\tfor ( ; i !== len && (elem = elems[i]) != null; i++ ) {\n\t\t\t\tif ( byElement && elem ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\tif ( !context && elem.ownerDocument !== document ) {\n\t\t\t\t\t\tsetDocument( elem );\n\t\t\t\t\t\txml = !documentIsHTML;\n\t\t\t\t\t}\n\t\t\t\t\twhile ( (matcher = elementMatchers[j++]) ) {\n\t\t\t\t\t\tif ( matcher( elem, context || document, xml) ) {\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( outermost ) {\n\t\t\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Track unmatched elements for set filters\n\t\t\t\tif ( bySet ) {\n\t\t\t\t\t// They will have gone through all possible matchers\n\t\t\t\t\tif ( (elem = !matcher && elem) ) {\n\t\t\t\t\t\tmatchedCount--;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Lengthen the array for every element, matched or not\n\t\t\t\t\tif ( seed ) {\n\t\t\t\t\t\tunmatched.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// `i` is now the count of elements visited above, and adding it to `matchedCount`\n\t\t\t// makes the latter nonnegative.\n\t\t\tmatchedCount += i;\n\n\t\t\t// Apply set filters to unmatched elements\n\t\t\t// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`\n\t\t\t// equals `i`), unless we didn't visit _any_ elements in the above loop because we have\n\t\t\t// no element matchers and no seed.\n\t\t\t// Incrementing an initially-string \"0\" `i` allows `i` to remain a string only in that\n\t\t\t// case, which will result in a \"00\" `matchedCount` that differs from `i` but is also\n\t\t\t// numerically zero.\n\t\t\tif ( bySet && i !== matchedCount ) {\n\t\t\t\tj = 0;\n\t\t\t\twhile ( (matcher = setMatchers[j++]) ) {\n\t\t\t\t\tmatcher( unmatched, setMatched, context, xml );\n\t\t\t\t}\n\n\t\t\t\tif ( seed ) {\n\t\t\t\t\t// Reintegrate element matches to eliminate the need for sorting\n\t\t\t\t\tif ( matchedCount > 0 ) {\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tif ( !(unmatched[i] || setMatched[i]) ) {\n\t\t\t\t\t\t\t\tsetMatched[i] = pop.call( results );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Discard index placeholder values to get only actual matches\n\t\t\t\t\tsetMatched = condense( setMatched );\n\t\t\t\t}\n\n\t\t\t\t// Add matches to results\n\t\t\t\tpush.apply( results, setMatched );\n\n\t\t\t\t// Seedless set matches succeeding multiple successful matchers stipulate sorting\n\t\t\t\tif ( outermost && !seed && setMatched.length > 0 &&\n\t\t\t\t\t( matchedCount + setMatchers.length ) > 1 ) {\n\n\t\t\t\t\tSizzle.uniqueSort( results );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Override manipulation of globals by nested matchers\n\t\t\tif ( outermost ) {\n\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\toutermostContext = contextBackup;\n\t\t\t}\n\n\t\t\treturn unmatched;\n\t\t};\n\n\treturn bySet ?\n\t\tmarkFunction( superMatcher ) :\n\t\tsuperMatcher;\n}\n\ncompile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {\n\tvar i,\n\t\tsetMatchers = [],\n\t\telementMatchers = [],\n\t\tcached = compilerCache[ selector + \" \" ];\n\n\tif ( !cached ) {\n\t\t// Generate a function of recursive functions that can be used to check each element\n\t\tif ( !match ) {\n\t\t\tmatch = tokenize( selector );\n\t\t}\n\t\ti = match.length;\n\t\twhile ( i-- ) {\n\t\t\tcached = matcherFromTokens( match[i] );\n\t\t\tif ( cached[ expando ] ) {\n\t\t\t\tsetMatchers.push( cached );\n\t\t\t} else {\n\t\t\t\telementMatchers.push( cached );\n\t\t\t}\n\t\t}\n\n\t\t// Cache the compiled function\n\t\tcached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );\n\n\t\t// Save selector and tokenization\n\t\tcached.selector = selector;\n\t}\n\treturn cached;\n};\n\n/**\n * A low-level selection function that works with Sizzle's compiled\n *  selector functions\n * @param {String|Function} selector A selector or a pre-compiled\n *  selector function built with Sizzle.compile\n * @param {Element} context\n * @param {Array} [results]\n * @param {Array} [seed] A set of elements to match against\n */\nselect = Sizzle.select = function( selector, context, results, seed ) {\n\tvar i, tokens, token, type, find,\n\t\tcompiled = typeof selector === \"function\" && selector,\n\t\tmatch = !seed && tokenize( (selector = compiled.selector || selector) );\n\n\tresults = results || [];\n\n\t// Try to minimize operations if there is only one selector in the list and no seed\n\t// (the latter of which guarantees us context)\n\tif ( match.length === 1 ) {\n\n\t\t// Reduce context if the leading compound selector is an ID\n\t\ttokens = match[0] = match[0].slice( 0 );\n\t\tif ( tokens.length > 2 && (token = tokens[0]).type === \"ID\" &&\n\t\t\t\tcontext.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {\n\n\t\t\tcontext = ( Expr.find[\"ID\"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];\n\t\t\tif ( !context ) {\n\t\t\t\treturn results;\n\n\t\t\t// Precompiled matchers will still verify ancestry, so step up a level\n\t\t\t} else if ( compiled ) {\n\t\t\t\tcontext = context.parentNode;\n\t\t\t}\n\n\t\t\tselector = selector.slice( tokens.shift().value.length );\n\t\t}\n\n\t\t// Fetch a seed set for right-to-left matching\n\t\ti = matchExpr[\"needsContext\"].test( selector ) ? 0 : tokens.length;\n\t\twhile ( i-- ) {\n\t\t\ttoken = tokens[i];\n\n\t\t\t// Abort if we hit a combinator\n\t\t\tif ( Expr.relative[ (type = token.type) ] ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( (find = Expr.find[ type ]) ) {\n\t\t\t\t// Search, expanding context for leading sibling combinators\n\t\t\t\tif ( (seed = find(\n\t\t\t\t\ttoken.matches[0].replace( runescape, funescape ),\n\t\t\t\t\trsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context\n\t\t\t\t)) ) {\n\n\t\t\t\t\t// If seed is empty or no tokens remain, we can return early\n\t\t\t\t\ttokens.splice( i, 1 );\n\t\t\t\t\tselector = seed.length && toSelector( tokens );\n\t\t\t\t\tif ( !selector ) {\n\t\t\t\t\t\tpush.apply( results, seed );\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Compile and execute a filtering function if one is not provided\n\t// Provide `match` to avoid retokenization if we modified the selector above\n\t( compiled || compile( selector, match ) )(\n\t\tseed,\n\t\tcontext,\n\t\t!documentIsHTML,\n\t\tresults,\n\t\t!context || rsibling.test( selector ) && testContext( context.parentNode ) || context\n\t);\n\treturn results;\n};\n\n// One-time assignments\n\n// Sort stability\nsupport.sortStable = expando.split(\"\").sort( sortOrder ).join(\"\") === expando;\n\n// Support: Chrome 14-35+\n// Always assume duplicates if they aren't passed to the comparison function\nsupport.detectDuplicates = !!hasDuplicate;\n\n// Initialize against the default document\nsetDocument();\n\n// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n// Detached nodes confoundingly follow *each other*\nsupport.sortDetached = assert(function( el ) {\n\t// Should return 1, but returns 4 (following)\n\treturn el.compareDocumentPosition( document.createElement(\"fieldset\") ) & 1;\n});\n\n// Support: IE<8\n// Prevent attribute/property \"interpolation\"\n// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\nif ( !assert(function( el ) {\n\tel.innerHTML = \"<a href='#'></a>\";\n\treturn el.firstChild.getAttribute(\"href\") === \"#\" ;\n}) ) {\n\taddHandle( \"type|href|height|width\", function( elem, name, isXML ) {\n\t\tif ( !isXML ) {\n\t\t\treturn elem.getAttribute( name, name.toLowerCase() === \"type\" ? 1 : 2 );\n\t\t}\n\t});\n}\n\n// Support: IE<9\n// Use defaultValue in place of getAttribute(\"value\")\nif ( !support.attributes || !assert(function( el ) {\n\tel.innerHTML = \"<input/>\";\n\tel.firstChild.setAttribute( \"value\", \"\" );\n\treturn el.firstChild.getAttribute( \"value\" ) === \"\";\n}) ) {\n\taddHandle( \"value\", function( elem, name, isXML ) {\n\t\tif ( !isXML && elem.nodeName.toLowerCase() === \"input\" ) {\n\t\t\treturn elem.defaultValue;\n\t\t}\n\t});\n}\n\n// Support: IE<9\n// Use getAttributeNode to fetch booleans when getAttribute lies\nif ( !assert(function( el ) {\n\treturn el.getAttribute(\"disabled\") == null;\n}) ) {\n\taddHandle( booleans, function( elem, name, isXML ) {\n\t\tvar val;\n\t\tif ( !isXML ) {\n\t\t\treturn elem[ name ] === true ? name.toLowerCase() :\n\t\t\t\t\t(val = elem.getAttributeNode( name )) && val.specified ?\n\t\t\t\t\tval.value :\n\t\t\t\tnull;\n\t\t}\n\t});\n}\n\nreturn Sizzle;\n\n})( window );\n\n\n\njQuery.find = Sizzle;\njQuery.expr = Sizzle.selectors;\n\n// Deprecated\njQuery.expr[ \":\" ] = jQuery.expr.pseudos;\njQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;\njQuery.text = Sizzle.getText;\njQuery.isXMLDoc = Sizzle.isXML;\njQuery.contains = Sizzle.contains;\njQuery.escapeSelector = Sizzle.escape;\n\n\n\n\nvar dir = function( elem, dir, until ) {\n\tvar matched = [],\n\t\ttruncate = until !== undefined;\n\n\twhile ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {\n\t\tif ( elem.nodeType === 1 ) {\n\t\t\tif ( truncate && jQuery( elem ).is( until ) ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmatched.push( elem );\n\t\t}\n\t}\n\treturn matched;\n};\n\n\nvar siblings = function( n, elem ) {\n\tvar matched = [];\n\n\tfor ( ; n; n = n.nextSibling ) {\n\t\tif ( n.nodeType === 1 && n !== elem ) {\n\t\t\tmatched.push( n );\n\t\t}\n\t}\n\n\treturn matched;\n};\n\n\nvar rneedsContext = jQuery.expr.match.needsContext;\n\n\n\nfunction nodeName( elem, name ) {\n\n  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\n\n};\nvar rsingleTag = ( /^<([a-z][^\\/\\0>:\\x20\\t\\r\\n\\f]*)[\\x20\\t\\r\\n\\f]*\\/?>(?:<\\/\\1>|)$/i );\n\n\n\n// Implement the identical functionality for filter and not\nfunction winnow( elements, qualifier, not ) {\n\tif ( isFunction( qualifier ) ) {\n\t\treturn jQuery.grep( elements, function( elem, i ) {\n\t\t\treturn !!qualifier.call( elem, i, elem ) !== not;\n\t\t} );\n\t}\n\n\t// Single element\n\tif ( qualifier.nodeType ) {\n\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\treturn ( elem === qualifier ) !== not;\n\t\t} );\n\t}\n\n\t// Arraylike of elements (jQuery, arguments, Array)\n\tif ( typeof qualifier !== \"string\" ) {\n\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\treturn ( indexOf.call( qualifier, elem ) > -1 ) !== not;\n\t\t} );\n\t}\n\n\t// Filtered directly for both simple and complex selectors\n\treturn jQuery.filter( qualifier, elements, not );\n}\n\njQuery.filter = function( expr, elems, not ) {\n\tvar elem = elems[ 0 ];\n\n\tif ( not ) {\n\t\texpr = \":not(\" + expr + \")\";\n\t}\n\n\tif ( elems.length === 1 && elem.nodeType === 1 ) {\n\t\treturn jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];\n\t}\n\n\treturn jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {\n\t\treturn elem.nodeType === 1;\n\t} ) );\n};\n\njQuery.fn.extend( {\n\tfind: function( selector ) {\n\t\tvar i, ret,\n\t\t\tlen = this.length,\n\t\t\tself = this;\n\n\t\tif ( typeof selector !== \"string\" ) {\n\t\t\treturn this.pushStack( jQuery( selector ).filter( function() {\n\t\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\t\tif ( jQuery.contains( self[ i ], this ) ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} ) );\n\t\t}\n\n\t\tret = this.pushStack( [] );\n\n\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\tjQuery.find( selector, self[ i ], ret );\n\t\t}\n\n\t\treturn len > 1 ? jQuery.uniqueSort( ret ) : ret;\n\t},\n\tfilter: function( selector ) {\n\t\treturn this.pushStack( winnow( this, selector || [], false ) );\n\t},\n\tnot: function( selector ) {\n\t\treturn this.pushStack( winnow( this, selector || [], true ) );\n\t},\n\tis: function( selector ) {\n\t\treturn !!winnow(\n\t\t\tthis,\n\n\t\t\t// If this is a positional/relative selector, check membership in the returned set\n\t\t\t// so $(\"p:first\").is(\"p:last\") won't return true for a doc with two \"p\".\n\t\t\ttypeof selector === \"string\" && rneedsContext.test( selector ) ?\n\t\t\t\tjQuery( selector ) :\n\t\t\t\tselector || [],\n\t\t\tfalse\n\t\t).length;\n\t}\n} );\n\n\n// Initialize a jQuery object\n\n\n// A central reference to the root jQuery(document)\nvar rootjQuery,\n\n\t// A simple way to check for HTML strings\n\t// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n\t// Strict HTML recognition (#11290: must start with <)\n\t// Shortcut simple #id case for speed\n\trquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]+))$/,\n\n\tinit = jQuery.fn.init = function( selector, context, root ) {\n\t\tvar match, elem;\n\n\t\t// HANDLE: $(\"\"), $(null), $(undefined), $(false)\n\t\tif ( !selector ) {\n\t\t\treturn this;\n\t\t}\n\n\t\t// Method init() accepts an alternate rootjQuery\n\t\t// so migrate can support jQuery.sub (gh-2101)\n\t\troot = root || rootjQuery;\n\n\t\t// Handle HTML strings\n\t\tif ( typeof selector === \"string\" ) {\n\t\t\tif ( selector[ 0 ] === \"<\" &&\n\t\t\t\tselector[ selector.length - 1 ] === \">\" &&\n\t\t\t\tselector.length >= 3 ) {\n\n\t\t\t\t// Assume that strings that start and end with <> are HTML and skip the regex check\n\t\t\t\tmatch = [ null, selector, null ];\n\n\t\t\t} else {\n\t\t\t\tmatch = rquickExpr.exec( selector );\n\t\t\t}\n\n\t\t\t// Match html or make sure no context is specified for #id\n\t\t\tif ( match && ( match[ 1 ] || !context ) ) {\n\n\t\t\t\t// HANDLE: $(html) -> $(array)\n\t\t\t\tif ( match[ 1 ] ) {\n\t\t\t\t\tcontext = context instanceof jQuery ? context[ 0 ] : context;\n\n\t\t\t\t\t// Option to run scripts is true for back-compat\n\t\t\t\t\t// Intentionally let the error be thrown if parseHTML is not present\n\t\t\t\t\tjQuery.merge( this, jQuery.parseHTML(\n\t\t\t\t\t\tmatch[ 1 ],\n\t\t\t\t\t\tcontext && context.nodeType ? context.ownerDocument || context : document,\n\t\t\t\t\t\ttrue\n\t\t\t\t\t) );\n\n\t\t\t\t\t// HANDLE: $(html, props)\n\t\t\t\t\tif ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {\n\t\t\t\t\t\tfor ( match in context ) {\n\n\t\t\t\t\t\t\t// Properties of context are called as methods if possible\n\t\t\t\t\t\t\tif ( isFunction( this[ match ] ) ) {\n\t\t\t\t\t\t\t\tthis[ match ]( context[ match ] );\n\n\t\t\t\t\t\t\t// ...and otherwise set as attributes\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.attr( match, context[ match ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this;\n\n\t\t\t\t// HANDLE: $(#id)\n\t\t\t\t} else {\n\t\t\t\t\telem = document.getElementById( match[ 2 ] );\n\n\t\t\t\t\tif ( elem ) {\n\n\t\t\t\t\t\t// Inject the element directly into the jQuery object\n\t\t\t\t\t\tthis[ 0 ] = elem;\n\t\t\t\t\t\tthis.length = 1;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\n\t\t\t// HANDLE: $(expr, $(...))\n\t\t\t} else if ( !context || context.jquery ) {\n\t\t\t\treturn ( context || root ).find( selector );\n\n\t\t\t// HANDLE: $(expr, context)\n\t\t\t// (which is just equivalent to: $(context).find(expr)\n\t\t\t} else {\n\t\t\t\treturn this.constructor( context ).find( selector );\n\t\t\t}\n\n\t\t// HANDLE: $(DOMElement)\n\t\t} else if ( selector.nodeType ) {\n\t\t\tthis[ 0 ] = selector;\n\t\t\tthis.length = 1;\n\t\t\treturn this;\n\n\t\t// HANDLE: $(function)\n\t\t// Shortcut for document ready\n\t\t} else if ( isFunction( selector ) ) {\n\t\t\treturn root.ready !== undefined ?\n\t\t\t\troot.ready( selector ) :\n\n\t\t\t\t// Execute immediately if ready is not present\n\t\t\t\tselector( jQuery );\n\t\t}\n\n\t\treturn jQuery.makeArray( selector, this );\n\t};\n\n// Give the init function the jQuery prototype for later instantiation\ninit.prototype = jQuery.fn;\n\n// Initialize central reference\nrootjQuery = jQuery( document );\n\n\nvar rparentsprev = /^(?:parents|prev(?:Until|All))/,\n\n\t// Methods guaranteed to produce a unique set when starting from a unique set\n\tguaranteedUnique = {\n\t\tchildren: true,\n\t\tcontents: true,\n\t\tnext: true,\n\t\tprev: true\n\t};\n\njQuery.fn.extend( {\n\thas: function( target ) {\n\t\tvar targets = jQuery( target, this ),\n\t\t\tl = targets.length;\n\n\t\treturn this.filter( function() {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tif ( jQuery.contains( this, targets[ i ] ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t},\n\n\tclosest: function( selectors, context ) {\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\tl = this.length,\n\t\t\tmatched = [],\n\t\t\ttargets = typeof selectors !== \"string\" && jQuery( selectors );\n\n\t\t// Positional selectors never match, since there's no _selection_ context\n\t\tif ( !rneedsContext.test( selectors ) ) {\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tfor ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {\n\n\t\t\t\t\t// Always skip document fragments\n\t\t\t\t\tif ( cur.nodeType < 11 && ( targets ?\n\t\t\t\t\t\ttargets.index( cur ) > -1 :\n\n\t\t\t\t\t\t// Don't pass non-elements to Sizzle\n\t\t\t\t\t\tcur.nodeType === 1 &&\n\t\t\t\t\t\t\tjQuery.find.matchesSelector( cur, selectors ) ) ) {\n\n\t\t\t\t\t\tmatched.push( cur );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );\n\t},\n\n\t// Determine the position of an element within the set\n\tindex: function( elem ) {\n\n\t\t// No argument, return index in parent\n\t\tif ( !elem ) {\n\t\t\treturn ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;\n\t\t}\n\n\t\t// Index in selector\n\t\tif ( typeof elem === \"string\" ) {\n\t\t\treturn indexOf.call( jQuery( elem ), this[ 0 ] );\n\t\t}\n\n\t\t// Locate the position of the desired element\n\t\treturn indexOf.call( this,\n\n\t\t\t// If it receives a jQuery object, the first element is used\n\t\t\telem.jquery ? elem[ 0 ] : elem\n\t\t);\n\t},\n\n\tadd: function( selector, context ) {\n\t\treturn this.pushStack(\n\t\t\tjQuery.uniqueSort(\n\t\t\t\tjQuery.merge( this.get(), jQuery( selector, context ) )\n\t\t\t)\n\t\t);\n\t},\n\n\taddBack: function( selector ) {\n\t\treturn this.add( selector == null ?\n\t\t\tthis.prevObject : this.prevObject.filter( selector )\n\t\t);\n\t}\n} );\n\nfunction sibling( cur, dir ) {\n\twhile ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}\n\treturn cur;\n}\n\njQuery.each( {\n\tparent: function( elem ) {\n\t\tvar parent = elem.parentNode;\n\t\treturn parent && parent.nodeType !== 11 ? parent : null;\n\t},\n\tparents: function( elem ) {\n\t\treturn dir( elem, \"parentNode\" );\n\t},\n\tparentsUntil: function( elem, i, until ) {\n\t\treturn dir( elem, \"parentNode\", until );\n\t},\n\tnext: function( elem ) {\n\t\treturn sibling( elem, \"nextSibling\" );\n\t},\n\tprev: function( elem ) {\n\t\treturn sibling( elem, \"previousSibling\" );\n\t},\n\tnextAll: function( elem ) {\n\t\treturn dir( elem, \"nextSibling\" );\n\t},\n\tprevAll: function( elem ) {\n\t\treturn dir( elem, \"previousSibling\" );\n\t},\n\tnextUntil: function( elem, i, until ) {\n\t\treturn dir( elem, \"nextSibling\", until );\n\t},\n\tprevUntil: function( elem, i, until ) {\n\t\treturn dir( elem, \"previousSibling\", until );\n\t},\n\tsiblings: function( elem ) {\n\t\treturn siblings( ( elem.parentNode || {} ).firstChild, elem );\n\t},\n\tchildren: function( elem ) {\n\t\treturn siblings( elem.firstChild );\n\t},\n\tcontents: function( elem ) {\n        if ( nodeName( elem, \"iframe\" ) ) {\n            return elem.contentDocument;\n        }\n\n        // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only\n        // Treat the template element as a regular one in browsers that\n        // don't support it.\n        if ( nodeName( elem, \"template\" ) ) {\n            elem = elem.content || elem;\n        }\n\n        return jQuery.merge( [], elem.childNodes );\n\t}\n}, function( name, fn ) {\n\tjQuery.fn[ name ] = function( until, selector ) {\n\t\tvar matched = jQuery.map( this, fn, until );\n\n\t\tif ( name.slice( -5 ) !== \"Until\" ) {\n\t\t\tselector = until;\n\t\t}\n\n\t\tif ( selector && typeof selector === \"string\" ) {\n\t\t\tmatched = jQuery.filter( selector, matched );\n\t\t}\n\n\t\tif ( this.length > 1 ) {\n\n\t\t\t// Remove duplicates\n\t\t\tif ( !guaranteedUnique[ name ] ) {\n\t\t\t\tjQuery.uniqueSort( matched );\n\t\t\t}\n\n\t\t\t// Reverse order for parents* and prev-derivatives\n\t\t\tif ( rparentsprev.test( name ) ) {\n\t\t\t\tmatched.reverse();\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( matched );\n\t};\n} );\nvar rnothtmlwhite = ( /[^\\x20\\t\\r\\n\\f]+/g );\n\n\n\n// Convert String-formatted options into Object-formatted ones\nfunction createOptions( options ) {\n\tvar object = {};\n\tjQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {\n\t\tobject[ flag ] = true;\n\t} );\n\treturn object;\n}\n\n/*\n * Create a callback list using the following parameters:\n *\n *\toptions: an optional list of space-separated options that will change how\n *\t\t\tthe callback list behaves or a more traditional option object\n *\n * By default a callback list will act like an event callback list and can be\n * \"fired\" multiple times.\n *\n * Possible options:\n *\n *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n *\n *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n *\t\t\t\t\tvalues (like a Deferred)\n *\n *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n *\n *\tstopOnFalse:\tinterrupt callings when a callback returns false\n *\n */\njQuery.Callbacks = function( options ) {\n\n\t// Convert options from String-formatted to Object-formatted if needed\n\t// (we check in cache first)\n\toptions = typeof options === \"string\" ?\n\t\tcreateOptions( options ) :\n\t\tjQuery.extend( {}, options );\n\n\tvar // Flag to know if list is currently firing\n\t\tfiring,\n\n\t\t// Last fire value for non-forgettable lists\n\t\tmemory,\n\n\t\t// Flag to know if list was already fired\n\t\tfired,\n\n\t\t// Flag to prevent firing\n\t\tlocked,\n\n\t\t// Actual callback list\n\t\tlist = [],\n\n\t\t// Queue of execution data for repeatable lists\n\t\tqueue = [],\n\n\t\t// Index of currently firing callback (modified by add/remove as needed)\n\t\tfiringIndex = -1,\n\n\t\t// Fire callbacks\n\t\tfire = function() {\n\n\t\t\t// Enforce single-firing\n\t\t\tlocked = locked || options.once;\n\n\t\t\t// Execute callbacks for all pending executions,\n\t\t\t// respecting firingIndex overrides and runtime changes\n\t\t\tfired = firing = true;\n\t\t\tfor ( ; queue.length; firingIndex = -1 ) {\n\t\t\t\tmemory = queue.shift();\n\t\t\t\twhile ( ++firingIndex < list.length ) {\n\n\t\t\t\t\t// Run callback and check for early termination\n\t\t\t\t\tif ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&\n\t\t\t\t\t\toptions.stopOnFalse ) {\n\n\t\t\t\t\t\t// Jump to end and forget the data so .add doesn't re-fire\n\t\t\t\t\t\tfiringIndex = list.length;\n\t\t\t\t\t\tmemory = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Forget the data if we're done with it\n\t\t\tif ( !options.memory ) {\n\t\t\t\tmemory = false;\n\t\t\t}\n\n\t\t\tfiring = false;\n\n\t\t\t// Clean up if we're done firing for good\n\t\t\tif ( locked ) {\n\n\t\t\t\t// Keep an empty list if we have data for future add calls\n\t\t\t\tif ( memory ) {\n\t\t\t\t\tlist = [];\n\n\t\t\t\t// Otherwise, this object is spent\n\t\t\t\t} else {\n\t\t\t\t\tlist = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t// Actual Callbacks object\n\t\tself = {\n\n\t\t\t// Add a callback or a collection of callbacks to the list\n\t\t\tadd: function() {\n\t\t\t\tif ( list ) {\n\n\t\t\t\t\t// If we have memory from a past run, we should fire after adding\n\t\t\t\t\tif ( memory && !firing ) {\n\t\t\t\t\t\tfiringIndex = list.length - 1;\n\t\t\t\t\t\tqueue.push( memory );\n\t\t\t\t\t}\n\n\t\t\t\t\t( function add( args ) {\n\t\t\t\t\t\tjQuery.each( args, function( _, arg ) {\n\t\t\t\t\t\t\tif ( isFunction( arg ) ) {\n\t\t\t\t\t\t\t\tif ( !options.unique || !self.has( arg ) ) {\n\t\t\t\t\t\t\t\t\tlist.push( arg );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if ( arg && arg.length && toType( arg ) !== \"string\" ) {\n\n\t\t\t\t\t\t\t\t// Inspect recursively\n\t\t\t\t\t\t\t\tadd( arg );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} );\n\t\t\t\t\t} )( arguments );\n\n\t\t\t\t\tif ( memory && !firing ) {\n\t\t\t\t\t\tfire();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Remove a callback from the list\n\t\t\tremove: function() {\n\t\t\t\tjQuery.each( arguments, function( _, arg ) {\n\t\t\t\t\tvar index;\n\t\t\t\t\twhile ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\n\t\t\t\t\t\tlist.splice( index, 1 );\n\n\t\t\t\t\t\t// Handle firing indexes\n\t\t\t\t\t\tif ( index <= firingIndex ) {\n\t\t\t\t\t\t\tfiringIndex--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Check if a given callback is in the list.\n\t\t\t// If no argument is given, return whether or not list has callbacks attached.\n\t\t\thas: function( fn ) {\n\t\t\t\treturn fn ?\n\t\t\t\t\tjQuery.inArray( fn, list ) > -1 :\n\t\t\t\t\tlist.length > 0;\n\t\t\t},\n\n\t\t\t// Remove all callbacks from the list\n\t\t\tempty: function() {\n\t\t\t\tif ( list ) {\n\t\t\t\t\tlist = [];\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Disable .fire and .add\n\t\t\t// Abort any current/pending executions\n\t\t\t// Clear all callbacks and values\n\t\t\tdisable: function() {\n\t\t\t\tlocked = queue = [];\n\t\t\t\tlist = memory = \"\";\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tdisabled: function() {\n\t\t\t\treturn !list;\n\t\t\t},\n\n\t\t\t// Disable .fire\n\t\t\t// Also disable .add unless we have memory (since it would have no effect)\n\t\t\t// Abort any pending executions\n\t\t\tlock: function() {\n\t\t\t\tlocked = queue = [];\n\t\t\t\tif ( !memory && !firing ) {\n\t\t\t\t\tlist = memory = \"\";\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tlocked: function() {\n\t\t\t\treturn !!locked;\n\t\t\t},\n\n\t\t\t// Call all callbacks with the given context and arguments\n\t\t\tfireWith: function( context, args ) {\n\t\t\t\tif ( !locked ) {\n\t\t\t\t\targs = args || [];\n\t\t\t\t\targs = [ context, args.slice ? args.slice() : args ];\n\t\t\t\t\tqueue.push( args );\n\t\t\t\t\tif ( !firing ) {\n\t\t\t\t\t\tfire();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Call all the callbacks with the given arguments\n\t\t\tfire: function() {\n\t\t\t\tself.fireWith( this, arguments );\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// To know if the callbacks have already been called at least once\n\t\t\tfired: function() {\n\t\t\t\treturn !!fired;\n\t\t\t}\n\t\t};\n\n\treturn self;\n};\n\n\nfunction Identity( v ) {\n\treturn v;\n}\nfunction Thrower( ex ) {\n\tthrow ex;\n}\n\nfunction adoptValue( value, resolve, reject, noValue ) {\n\tvar method;\n\n\ttry {\n\n\t\t// Check for promise aspect first to privilege synchronous behavior\n\t\tif ( value && isFunction( ( method = value.promise ) ) ) {\n\t\t\tmethod.call( value ).done( resolve ).fail( reject );\n\n\t\t// Other thenables\n\t\t} else if ( value && isFunction( ( method = value.then ) ) ) {\n\t\t\tmethod.call( value, resolve, reject );\n\n\t\t// Other non-thenables\n\t\t} else {\n\n\t\t\t// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:\n\t\t\t// * false: [ value ].slice( 0 ) => resolve( value )\n\t\t\t// * true: [ value ].slice( 1 ) => resolve()\n\t\t\tresolve.apply( undefined, [ value ].slice( noValue ) );\n\t\t}\n\n\t// For Promises/A+, convert exceptions into rejections\n\t// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in\n\t// Deferred#then to conditionally suppress rejection.\n\t} catch ( value ) {\n\n\t\t// Support: Android 4.0 only\n\t\t// Strict mode functions invoked without .call/.apply get global-object context\n\t\treject.apply( undefined, [ value ] );\n\t}\n}\n\njQuery.extend( {\n\n\tDeferred: function( func ) {\n\t\tvar tuples = [\n\n\t\t\t\t// action, add listener, callbacks,\n\t\t\t\t// ... .then handlers, argument index, [final state]\n\t\t\t\t[ \"notify\", \"progress\", jQuery.Callbacks( \"memory\" ),\n\t\t\t\t\tjQuery.Callbacks( \"memory\" ), 2 ],\n\t\t\t\t[ \"resolve\", \"done\", jQuery.Callbacks( \"once memory\" ),\n\t\t\t\t\tjQuery.Callbacks( \"once memory\" ), 0, \"resolved\" ],\n\t\t\t\t[ \"reject\", \"fail\", jQuery.Callbacks( \"once memory\" ),\n\t\t\t\t\tjQuery.Callbacks( \"once memory\" ), 1, \"rejected\" ]\n\t\t\t],\n\t\t\tstate = \"pending\",\n\t\t\tpromise = {\n\t\t\t\tstate: function() {\n\t\t\t\t\treturn state;\n\t\t\t\t},\n\t\t\t\talways: function() {\n\t\t\t\t\tdeferred.done( arguments ).fail( arguments );\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\t\"catch\": function( fn ) {\n\t\t\t\t\treturn promise.then( null, fn );\n\t\t\t\t},\n\n\t\t\t\t// Keep pipe for back-compat\n\t\t\t\tpipe: function( /* fnDone, fnFail, fnProgress */ ) {\n\t\t\t\t\tvar fns = arguments;\n\n\t\t\t\t\treturn jQuery.Deferred( function( newDefer ) {\n\t\t\t\t\t\tjQuery.each( tuples, function( i, tuple ) {\n\n\t\t\t\t\t\t\t// Map tuples (progress, done, fail) to arguments (done, fail, progress)\n\t\t\t\t\t\t\tvar fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];\n\n\t\t\t\t\t\t\t// deferred.progress(function() { bind to newDefer or newDefer.notify })\n\t\t\t\t\t\t\t// deferred.done(function() { bind to newDefer or newDefer.resolve })\n\t\t\t\t\t\t\t// deferred.fail(function() { bind to newDefer or newDefer.reject })\n\t\t\t\t\t\t\tdeferred[ tuple[ 1 ] ]( function() {\n\t\t\t\t\t\t\t\tvar returned = fn && fn.apply( this, arguments );\n\t\t\t\t\t\t\t\tif ( returned && isFunction( returned.promise ) ) {\n\t\t\t\t\t\t\t\t\treturned.promise()\n\t\t\t\t\t\t\t\t\t\t.progress( newDefer.notify )\n\t\t\t\t\t\t\t\t\t\t.done( newDefer.resolve )\n\t\t\t\t\t\t\t\t\t\t.fail( newDefer.reject );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tnewDefer[ tuple[ 0 ] + \"With\" ](\n\t\t\t\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\t\t\t\tfn ? [ returned ] : arguments\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tfns = null;\n\t\t\t\t\t} ).promise();\n\t\t\t\t},\n\t\t\t\tthen: function( onFulfilled, onRejected, onProgress ) {\n\t\t\t\t\tvar maxDepth = 0;\n\t\t\t\t\tfunction resolve( depth, deferred, handler, special ) {\n\t\t\t\t\t\treturn function() {\n\t\t\t\t\t\t\tvar that = this,\n\t\t\t\t\t\t\t\targs = arguments,\n\t\t\t\t\t\t\t\tmightThrow = function() {\n\t\t\t\t\t\t\t\t\tvar returned, then;\n\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.3\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-59\n\t\t\t\t\t\t\t\t\t// Ignore double-resolution attempts\n\t\t\t\t\t\t\t\t\tif ( depth < maxDepth ) {\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturned = handler.apply( that, args );\n\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.1\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-48\n\t\t\t\t\t\t\t\t\tif ( returned === deferred.promise() ) {\n\t\t\t\t\t\t\t\t\t\tthrow new TypeError( \"Thenable self-resolution\" );\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ sections 2.3.3.1, 3.5\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-54\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-75\n\t\t\t\t\t\t\t\t\t// Retrieve `then` only once\n\t\t\t\t\t\t\t\t\tthen = returned &&\n\n\t\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.4\n\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-64\n\t\t\t\t\t\t\t\t\t\t// Only check objects and functions for thenability\n\t\t\t\t\t\t\t\t\t\t( typeof returned === \"object\" ||\n\t\t\t\t\t\t\t\t\t\t\ttypeof returned === \"function\" ) &&\n\t\t\t\t\t\t\t\t\t\treturned.then;\n\n\t\t\t\t\t\t\t\t\t// Handle a returned thenable\n\t\t\t\t\t\t\t\t\tif ( isFunction( then ) ) {\n\n\t\t\t\t\t\t\t\t\t\t// Special processors (notify) just wait for resolution\n\t\t\t\t\t\t\t\t\t\tif ( special ) {\n\t\t\t\t\t\t\t\t\t\t\tthen.call(\n\t\t\t\t\t\t\t\t\t\t\t\treturned,\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity, special ),\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Thrower, special )\n\t\t\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t\t\t// Normal processors (resolve) also hook into progress\n\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t// ...and disregard older resolution values\n\t\t\t\t\t\t\t\t\t\t\tmaxDepth++;\n\n\t\t\t\t\t\t\t\t\t\t\tthen.call(\n\t\t\t\t\t\t\t\t\t\t\t\treturned,\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity, special ),\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Thrower, special ),\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity,\n\t\t\t\t\t\t\t\t\t\t\t\t\tdeferred.notifyWith )\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Handle all other returned values\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t// Only substitute handlers pass on context\n\t\t\t\t\t\t\t\t\t\t// and multiple values (non-spec behavior)\n\t\t\t\t\t\t\t\t\t\tif ( handler !== Identity ) {\n\t\t\t\t\t\t\t\t\t\t\tthat = undefined;\n\t\t\t\t\t\t\t\t\t\t\targs = [ returned ];\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t// Process the value(s)\n\t\t\t\t\t\t\t\t\t\t// Default process is resolve\n\t\t\t\t\t\t\t\t\t\t( special || deferred.resolveWith )( that, args );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\t\t// Only normal processors (resolve) catch and reject exceptions\n\t\t\t\t\t\t\t\tprocess = special ?\n\t\t\t\t\t\t\t\t\tmightThrow :\n\t\t\t\t\t\t\t\t\tfunction() {\n\t\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\t\tmightThrow();\n\t\t\t\t\t\t\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\t\t\t\t\t\t\tif ( jQuery.Deferred.exceptionHook ) {\n\t\t\t\t\t\t\t\t\t\t\t\tjQuery.Deferred.exceptionHook( e,\n\t\t\t\t\t\t\t\t\t\t\t\t\tprocess.stackTrace );\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.4.1\n\t\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-61\n\t\t\t\t\t\t\t\t\t\t\t// Ignore post-resolution exceptions\n\t\t\t\t\t\t\t\t\t\t\tif ( depth + 1 >= maxDepth ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t// Only substitute handlers pass on context\n\t\t\t\t\t\t\t\t\t\t\t\t// and multiple values (non-spec behavior)\n\t\t\t\t\t\t\t\t\t\t\t\tif ( handler !== Thrower ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tthat = undefined;\n\t\t\t\t\t\t\t\t\t\t\t\t\targs = [ e ];\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tdeferred.rejectWith( that, args );\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.1\n\t\t\t\t\t\t\t// https://promisesaplus.com/#point-57\n\t\t\t\t\t\t\t// Re-resolve promises immediately to dodge false rejection from\n\t\t\t\t\t\t\t// subsequent errors\n\t\t\t\t\t\t\tif ( depth ) {\n\t\t\t\t\t\t\t\tprocess();\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// Call an optional hook to record the stack, in case of exception\n\t\t\t\t\t\t\t\t// since it's otherwise lost when execution goes async\n\t\t\t\t\t\t\t\tif ( jQuery.Deferred.getStackHook ) {\n\t\t\t\t\t\t\t\t\tprocess.stackTrace = jQuery.Deferred.getStackHook();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\twindow.setTimeout( process );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\treturn jQuery.Deferred( function( newDefer ) {\n\n\t\t\t\t\t\t// progress_handlers.add( ... )\n\t\t\t\t\t\ttuples[ 0 ][ 3 ].add(\n\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\tisFunction( onProgress ) ?\n\t\t\t\t\t\t\t\t\tonProgress :\n\t\t\t\t\t\t\t\t\tIdentity,\n\t\t\t\t\t\t\t\tnewDefer.notifyWith\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// fulfilled_handlers.add( ... )\n\t\t\t\t\t\ttuples[ 1 ][ 3 ].add(\n\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\tisFunction( onFulfilled ) ?\n\t\t\t\t\t\t\t\t\tonFulfilled :\n\t\t\t\t\t\t\t\t\tIdentity\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// rejected_handlers.add( ... )\n\t\t\t\t\t\ttuples[ 2 ][ 3 ].add(\n\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\tisFunction( onRejected ) ?\n\t\t\t\t\t\t\t\t\tonRejected :\n\t\t\t\t\t\t\t\t\tThrower\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t} ).promise();\n\t\t\t\t},\n\n\t\t\t\t// Get a promise for this deferred\n\t\t\t\t// If obj is provided, the promise aspect is added to the object\n\t\t\t\tpromise: function( obj ) {\n\t\t\t\t\treturn obj != null ? jQuery.extend( obj, promise ) : promise;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdeferred = {};\n\n\t\t// Add list-specific methods\n\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\tvar list = tuple[ 2 ],\n\t\t\t\tstateString = tuple[ 5 ];\n\n\t\t\t// promise.progress = list.add\n\t\t\t// promise.done = list.add\n\t\t\t// promise.fail = list.add\n\t\t\tpromise[ tuple[ 1 ] ] = list.add;\n\n\t\t\t// Handle state\n\t\t\tif ( stateString ) {\n\t\t\t\tlist.add(\n\t\t\t\t\tfunction() {\n\n\t\t\t\t\t\t// state = \"resolved\" (i.e., fulfilled)\n\t\t\t\t\t\t// state = \"rejected\"\n\t\t\t\t\t\tstate = stateString;\n\t\t\t\t\t},\n\n\t\t\t\t\t// rejected_callbacks.disable\n\t\t\t\t\t// fulfilled_callbacks.disable\n\t\t\t\t\ttuples[ 3 - i ][ 2 ].disable,\n\n\t\t\t\t\t// rejected_handlers.disable\n\t\t\t\t\t// fulfilled_handlers.disable\n\t\t\t\t\ttuples[ 3 - i ][ 3 ].disable,\n\n\t\t\t\t\t// progress_callbacks.lock\n\t\t\t\t\ttuples[ 0 ][ 2 ].lock,\n\n\t\t\t\t\t// progress_handlers.lock\n\t\t\t\t\ttuples[ 0 ][ 3 ].lock\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// progress_handlers.fire\n\t\t\t// fulfilled_handlers.fire\n\t\t\t// rejected_handlers.fire\n\t\t\tlist.add( tuple[ 3 ].fire );\n\n\t\t\t// deferred.notify = function() { deferred.notifyWith(...) }\n\t\t\t// deferred.resolve = function() { deferred.resolveWith(...) }\n\t\t\t// deferred.reject = function() { deferred.rejectWith(...) }\n\t\t\tdeferred[ tuple[ 0 ] ] = function() {\n\t\t\t\tdeferred[ tuple[ 0 ] + \"With\" ]( this === deferred ? undefined : this, arguments );\n\t\t\t\treturn this;\n\t\t\t};\n\n\t\t\t// deferred.notifyWith = list.fireWith\n\t\t\t// deferred.resolveWith = list.fireWith\n\t\t\t// deferred.rejectWith = list.fireWith\n\t\t\tdeferred[ tuple[ 0 ] + \"With\" ] = list.fireWith;\n\t\t} );\n\n\t\t// Make the deferred a promise\n\t\tpromise.promise( deferred );\n\n\t\t// Call given func if any\n\t\tif ( func ) {\n\t\t\tfunc.call( deferred, deferred );\n\t\t}\n\n\t\t// All done!\n\t\treturn deferred;\n\t},\n\n\t// Deferred helper\n\twhen: function( singleValue ) {\n\t\tvar\n\n\t\t\t// count of uncompleted subordinates\n\t\t\tremaining = arguments.length,\n\n\t\t\t// count of unprocessed arguments\n\t\t\ti = remaining,\n\n\t\t\t// subordinate fulfillment data\n\t\t\tresolveContexts = Array( i ),\n\t\t\tresolveValues = slice.call( arguments ),\n\n\t\t\t// the master Deferred\n\t\t\tmaster = jQuery.Deferred(),\n\n\t\t\t// subordinate callback factory\n\t\t\tupdateFunc = function( i ) {\n\t\t\t\treturn function( value ) {\n\t\t\t\t\tresolveContexts[ i ] = this;\n\t\t\t\t\tresolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;\n\t\t\t\t\tif ( !( --remaining ) ) {\n\t\t\t\t\t\tmaster.resolveWith( resolveContexts, resolveValues );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t};\n\n\t\t// Single- and empty arguments are adopted like Promise.resolve\n\t\tif ( remaining <= 1 ) {\n\t\t\tadoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,\n\t\t\t\t!remaining );\n\n\t\t\t// Use .then() to unwrap secondary thenables (cf. gh-3000)\n\t\t\tif ( master.state() === \"pending\" ||\n\t\t\t\tisFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {\n\n\t\t\t\treturn master.then();\n\t\t\t}\n\t\t}\n\n\t\t// Multiple arguments are aggregated like Promise.all array elements\n\t\twhile ( i-- ) {\n\t\t\tadoptValue( resolveValues[ i ], updateFunc( i ), master.reject );\n\t\t}\n\n\t\treturn master.promise();\n\t}\n} );\n\n\n// These usually indicate a programmer mistake during development,\n// warn about them ASAP rather than swallowing them by default.\nvar rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;\n\njQuery.Deferred.exceptionHook = function( error, stack ) {\n\n\t// Support: IE 8 - 9 only\n\t// Console exists when dev tools are open, which can happen at any time\n\tif ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {\n\t\twindow.console.warn( \"jQuery.Deferred exception: \" + error.message, error.stack, stack );\n\t}\n};\n\n\n\n\njQuery.readyException = function( error ) {\n\twindow.setTimeout( function() {\n\t\tthrow error;\n\t} );\n};\n\n\n\n\n// The deferred used on DOM ready\nvar readyList = jQuery.Deferred();\n\njQuery.fn.ready = function( fn ) {\n\n\treadyList\n\t\t.then( fn )\n\n\t\t// Wrap jQuery.readyException in a function so that the lookup\n\t\t// happens at the time of error handling instead of callback\n\t\t// registration.\n\t\t.catch( function( error ) {\n\t\t\tjQuery.readyException( error );\n\t\t} );\n\n\treturn this;\n};\n\njQuery.extend( {\n\n\t// Is the DOM ready to be used? Set to true once it occurs.\n\tisReady: false,\n\n\t// A counter to track how many items to wait for before\n\t// the ready event fires. See #6781\n\treadyWait: 1,\n\n\t// Handle when the DOM is ready\n\tready: function( wait ) {\n\n\t\t// Abort if there are pending holds or we're already ready\n\t\tif ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Remember that the DOM is ready\n\t\tjQuery.isReady = true;\n\n\t\t// If a normal DOM Ready event fired, decrement, and wait if need be\n\t\tif ( wait !== true && --jQuery.readyWait > 0 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If there are functions bound, to execute\n\t\treadyList.resolveWith( document, [ jQuery ] );\n\t}\n} );\n\njQuery.ready.then = readyList.then;\n\n// The ready event handler and self cleanup method\nfunction completed() {\n\tdocument.removeEventListener( \"DOMContentLoaded\", completed );\n\twindow.removeEventListener( \"load\", completed );\n\tjQuery.ready();\n}\n\n// Catch cases where $(document).ready() is called\n// after the browser event has already occurred.\n// Support: IE <=9 - 10 only\n// Older IE sometimes signals \"interactive\" too soon\nif ( document.readyState === \"complete\" ||\n\t( document.readyState !== \"loading\" && !document.documentElement.doScroll ) ) {\n\n\t// Handle it asynchronously to allow scripts the opportunity to delay ready\n\twindow.setTimeout( jQuery.ready );\n\n} else {\n\n\t// Use the handy event callback\n\tdocument.addEventListener( \"DOMContentLoaded\", completed );\n\n\t// A fallback to window.onload, that will always work\n\twindow.addEventListener( \"load\", completed );\n}\n\n\n\n\n// Multifunctional method to get and set values of a collection\n// The value/s can optionally be executed if it's a function\nvar access = function( elems, fn, key, value, chainable, emptyGet, raw ) {\n\tvar i = 0,\n\t\tlen = elems.length,\n\t\tbulk = key == null;\n\n\t// Sets many values\n\tif ( toType( key ) === \"object\" ) {\n\t\tchainable = true;\n\t\tfor ( i in key ) {\n\t\t\taccess( elems, fn, i, key[ i ], true, emptyGet, raw );\n\t\t}\n\n\t// Sets one value\n\t} else if ( value !== undefined ) {\n\t\tchainable = true;\n\n\t\tif ( !isFunction( value ) ) {\n\t\t\traw = true;\n\t\t}\n\n\t\tif ( bulk ) {\n\n\t\t\t// Bulk operations run against the entire set\n\t\t\tif ( raw ) {\n\t\t\t\tfn.call( elems, value );\n\t\t\t\tfn = null;\n\n\t\t\t// ...except when executing function values\n\t\t\t} else {\n\t\t\t\tbulk = fn;\n\t\t\t\tfn = function( elem, key, value ) {\n\t\t\t\t\treturn bulk.call( jQuery( elem ), value );\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tif ( fn ) {\n\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\tfn(\n\t\t\t\t\telems[ i ], key, raw ?\n\t\t\t\t\tvalue :\n\t\t\t\t\tvalue.call( elems[ i ], i, fn( elems[ i ], key ) )\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( chainable ) {\n\t\treturn elems;\n\t}\n\n\t// Gets\n\tif ( bulk ) {\n\t\treturn fn.call( elems );\n\t}\n\n\treturn len ? fn( elems[ 0 ], key ) : emptyGet;\n};\n\n\n// Matches dashed string for camelizing\nvar rmsPrefix = /^-ms-/,\n\trdashAlpha = /-([a-z])/g;\n\n// Used by camelCase as callback to replace()\nfunction fcamelCase( all, letter ) {\n\treturn letter.toUpperCase();\n}\n\n// Convert dashed to camelCase; used by the css and data modules\n// Support: IE <=9 - 11, Edge 12 - 15\n// Microsoft forgot to hump their vendor prefix (#9572)\nfunction camelCase( string ) {\n\treturn string.replace( rmsPrefix, \"ms-\" ).replace( rdashAlpha, fcamelCase );\n}\nvar acceptData = function( owner ) {\n\n\t// Accepts only:\n\t//  - Node\n\t//    - Node.ELEMENT_NODE\n\t//    - Node.DOCUMENT_NODE\n\t//  - Object\n\t//    - Any\n\treturn owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );\n};\n\n\n\n\nfunction Data() {\n\tthis.expando = jQuery.expando + Data.uid++;\n}\n\nData.uid = 1;\n\nData.prototype = {\n\n\tcache: function( owner ) {\n\n\t\t// Check if the owner object already has a cache\n\t\tvar value = owner[ this.expando ];\n\n\t\t// If not, create one\n\t\tif ( !value ) {\n\t\t\tvalue = {};\n\n\t\t\t// We can accept data for non-element nodes in modern browsers,\n\t\t\t// but we should not, see #8335.\n\t\t\t// Always return an empty object.\n\t\t\tif ( acceptData( owner ) ) {\n\n\t\t\t\t// If it is a node unlikely to be stringify-ed or looped over\n\t\t\t\t// use plain assignment\n\t\t\t\tif ( owner.nodeType ) {\n\t\t\t\t\towner[ this.expando ] = value;\n\n\t\t\t\t// Otherwise secure it in a non-enumerable property\n\t\t\t\t// configurable must be true to allow the property to be\n\t\t\t\t// deleted when data is removed\n\t\t\t\t} else {\n\t\t\t\t\tObject.defineProperty( owner, this.expando, {\n\t\t\t\t\t\tvalue: value,\n\t\t\t\t\t\tconfigurable: true\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn value;\n\t},\n\tset: function( owner, data, value ) {\n\t\tvar prop,\n\t\t\tcache = this.cache( owner );\n\n\t\t// Handle: [ owner, key, value ] args\n\t\t// Always use camelCase key (gh-2257)\n\t\tif ( typeof data === \"string\" ) {\n\t\t\tcache[ camelCase( data ) ] = value;\n\n\t\t// Handle: [ owner, { properties } ] args\n\t\t} else {\n\n\t\t\t// Copy the properties one-by-one to the cache object\n\t\t\tfor ( prop in data ) {\n\t\t\t\tcache[ camelCase( prop ) ] = data[ prop ];\n\t\t\t}\n\t\t}\n\t\treturn cache;\n\t},\n\tget: function( owner, key ) {\n\t\treturn key === undefined ?\n\t\t\tthis.cache( owner ) :\n\n\t\t\t// Always use camelCase key (gh-2257)\n\t\t\towner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];\n\t},\n\taccess: function( owner, key, value ) {\n\n\t\t// In cases where either:\n\t\t//\n\t\t//   1. No key was specified\n\t\t//   2. A string key was specified, but no value provided\n\t\t//\n\t\t// Take the \"read\" path and allow the get method to determine\n\t\t// which value to return, respectively either:\n\t\t//\n\t\t//   1. The entire cache object\n\t\t//   2. The data stored at the key\n\t\t//\n\t\tif ( key === undefined ||\n\t\t\t\t( ( key && typeof key === \"string\" ) && value === undefined ) ) {\n\n\t\t\treturn this.get( owner, key );\n\t\t}\n\n\t\t// When the key is not a string, or both a key and value\n\t\t// are specified, set or extend (existing objects) with either:\n\t\t//\n\t\t//   1. An object of properties\n\t\t//   2. A key and value\n\t\t//\n\t\tthis.set( owner, key, value );\n\n\t\t// Since the \"set\" path can have two possible entry points\n\t\t// return the expected data based on which path was taken[*]\n\t\treturn value !== undefined ? value : key;\n\t},\n\tremove: function( owner, key ) {\n\t\tvar i,\n\t\t\tcache = owner[ this.expando ];\n\n\t\tif ( cache === undefined ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( key !== undefined ) {\n\n\t\t\t// Support array or space separated string of keys\n\t\t\tif ( Array.isArray( key ) ) {\n\n\t\t\t\t// If key is an array of keys...\n\t\t\t\t// We always set camelCase keys, so remove that.\n\t\t\t\tkey = key.map( camelCase );\n\t\t\t} else {\n\t\t\t\tkey = camelCase( key );\n\n\t\t\t\t// If a key with the spaces exists, use it.\n\t\t\t\t// Otherwise, create an array by matching non-whitespace\n\t\t\t\tkey = key in cache ?\n\t\t\t\t\t[ key ] :\n\t\t\t\t\t( key.match( rnothtmlwhite ) || [] );\n\t\t\t}\n\n\t\t\ti = key.length;\n\n\t\t\twhile ( i-- ) {\n\t\t\t\tdelete cache[ key[ i ] ];\n\t\t\t}\n\t\t}\n\n\t\t// Remove the expando if there's no more data\n\t\tif ( key === undefined || jQuery.isEmptyObject( cache ) ) {\n\n\t\t\t// Support: Chrome <=35 - 45\n\t\t\t// Webkit & Blink performance suffers when deleting properties\n\t\t\t// from DOM nodes, so set to undefined instead\n\t\t\t// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)\n\t\t\tif ( owner.nodeType ) {\n\t\t\t\towner[ this.expando ] = undefined;\n\t\t\t} else {\n\t\t\t\tdelete owner[ this.expando ];\n\t\t\t}\n\t\t}\n\t},\n\thasData: function( owner ) {\n\t\tvar cache = owner[ this.expando ];\n\t\treturn cache !== undefined && !jQuery.isEmptyObject( cache );\n\t}\n};\nvar dataPriv = new Data();\n\nvar dataUser = new Data();\n\n\n\n//\tImplementation Summary\n//\n//\t1. Enforce API surface and semantic compatibility with 1.9.x branch\n//\t2. Improve the module's maintainability by reducing the storage\n//\t\tpaths to a single mechanism.\n//\t3. Use the same single mechanism to support \"private\" and \"user\" data.\n//\t4. _Never_ expose \"private\" data to user code (TODO: Drop _data, _removeData)\n//\t5. Avoid exposing implementation details on user objects (eg. expando properties)\n//\t6. Provide a clear path for implementation upgrade to WeakMap in 2014\n\nvar rbrace = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,\n\trmultiDash = /[A-Z]/g;\n\nfunction getData( data ) {\n\tif ( data === \"true\" ) {\n\t\treturn true;\n\t}\n\n\tif ( data === \"false\" ) {\n\t\treturn false;\n\t}\n\n\tif ( data === \"null\" ) {\n\t\treturn null;\n\t}\n\n\t// Only convert to a number if it doesn't change the string\n\tif ( data === +data + \"\" ) {\n\t\treturn +data;\n\t}\n\n\tif ( rbrace.test( data ) ) {\n\t\treturn JSON.parse( data );\n\t}\n\n\treturn data;\n}\n\nfunction dataAttr( elem, key, data ) {\n\tvar name;\n\n\t// If nothing was found internally, try to fetch any\n\t// data from the HTML5 data-* attribute\n\tif ( data === undefined && elem.nodeType === 1 ) {\n\t\tname = \"data-\" + key.replace( rmultiDash, \"-$&\" ).toLowerCase();\n\t\tdata = elem.getAttribute( name );\n\n\t\tif ( typeof data === \"string\" ) {\n\t\t\ttry {\n\t\t\t\tdata = getData( data );\n\t\t\t} catch ( e ) {}\n\n\t\t\t// Make sure we set the data so it isn't changed later\n\t\t\tdataUser.set( elem, key, data );\n\t\t} else {\n\t\t\tdata = undefined;\n\t\t}\n\t}\n\treturn data;\n}\n\njQuery.extend( {\n\thasData: function( elem ) {\n\t\treturn dataUser.hasData( elem ) || dataPriv.hasData( elem );\n\t},\n\n\tdata: function( elem, name, data ) {\n\t\treturn dataUser.access( elem, name, data );\n\t},\n\n\tremoveData: function( elem, name ) {\n\t\tdataUser.remove( elem, name );\n\t},\n\n\t// TODO: Now that all calls to _data and _removeData have been replaced\n\t// with direct calls to dataPriv methods, these can be deprecated.\n\t_data: function( elem, name, data ) {\n\t\treturn dataPriv.access( elem, name, data );\n\t},\n\n\t_removeData: function( elem, name ) {\n\t\tdataPriv.remove( elem, name );\n\t}\n} );\n\njQuery.fn.extend( {\n\tdata: function( key, value ) {\n\t\tvar i, name, data,\n\t\t\telem = this[ 0 ],\n\t\t\tattrs = elem && elem.attributes;\n\n\t\t// Gets all values\n\t\tif ( key === undefined ) {\n\t\t\tif ( this.length ) {\n\t\t\t\tdata = dataUser.get( elem );\n\n\t\t\t\tif ( elem.nodeType === 1 && !dataPriv.get( elem, \"hasDataAttrs\" ) ) {\n\t\t\t\t\ti = attrs.length;\n\t\t\t\t\twhile ( i-- ) {\n\n\t\t\t\t\t\t// Support: IE 11 only\n\t\t\t\t\t\t// The attrs elements can be null (#14894)\n\t\t\t\t\t\tif ( attrs[ i ] ) {\n\t\t\t\t\t\t\tname = attrs[ i ].name;\n\t\t\t\t\t\t\tif ( name.indexOf( \"data-\" ) === 0 ) {\n\t\t\t\t\t\t\t\tname = camelCase( name.slice( 5 ) );\n\t\t\t\t\t\t\t\tdataAttr( elem, name, data[ name ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdataPriv.set( elem, \"hasDataAttrs\", true );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\t// Sets multiple values\n\t\tif ( typeof key === \"object\" ) {\n\t\t\treturn this.each( function() {\n\t\t\t\tdataUser.set( this, key );\n\t\t\t} );\n\t\t}\n\n\t\treturn access( this, function( value ) {\n\t\t\tvar data;\n\n\t\t\t// The calling jQuery object (element matches) is not empty\n\t\t\t// (and therefore has an element appears at this[ 0 ]) and the\n\t\t\t// `value` parameter was not undefined. An empty jQuery object\n\t\t\t// will result in `undefined` for elem = this[ 0 ] which will\n\t\t\t// throw an exception if an attempt to read a data cache is made.\n\t\t\tif ( elem && value === undefined ) {\n\n\t\t\t\t// Attempt to get data from the cache\n\t\t\t\t// The key will always be camelCased in Data\n\t\t\t\tdata = dataUser.get( elem, key );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// Attempt to \"discover\" the data in\n\t\t\t\t// HTML5 custom data-* attrs\n\t\t\t\tdata = dataAttr( elem, key );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// We tried really hard, but the data doesn't exist.\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Set the data...\n\t\t\tthis.each( function() {\n\n\t\t\t\t// We always store the camelCased key\n\t\t\t\tdataUser.set( this, key, value );\n\t\t\t} );\n\t\t}, null, value, arguments.length > 1, null, true );\n\t},\n\n\tremoveData: function( key ) {\n\t\treturn this.each( function() {\n\t\t\tdataUser.remove( this, key );\n\t\t} );\n\t}\n} );\n\n\njQuery.extend( {\n\tqueue: function( elem, type, data ) {\n\t\tvar queue;\n\n\t\tif ( elem ) {\n\t\t\ttype = ( type || \"fx\" ) + \"queue\";\n\t\t\tqueue = dataPriv.get( elem, type );\n\n\t\t\t// Speed up dequeue by getting out quickly if this is just a lookup\n\t\t\tif ( data ) {\n\t\t\t\tif ( !queue || Array.isArray( data ) ) {\n\t\t\t\t\tqueue = dataPriv.access( elem, type, jQuery.makeArray( data ) );\n\t\t\t\t} else {\n\t\t\t\t\tqueue.push( data );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn queue || [];\n\t\t}\n\t},\n\n\tdequeue: function( elem, type ) {\n\t\ttype = type || \"fx\";\n\n\t\tvar queue = jQuery.queue( elem, type ),\n\t\t\tstartLength = queue.length,\n\t\t\tfn = queue.shift(),\n\t\t\thooks = jQuery._queueHooks( elem, type ),\n\t\t\tnext = function() {\n\t\t\t\tjQuery.dequeue( elem, type );\n\t\t\t};\n\n\t\t// If the fx queue is dequeued, always remove the progress sentinel\n\t\tif ( fn === \"inprogress\" ) {\n\t\t\tfn = queue.shift();\n\t\t\tstartLength--;\n\t\t}\n\n\t\tif ( fn ) {\n\n\t\t\t// Add a progress sentinel to prevent the fx queue from being\n\t\t\t// automatically dequeued\n\t\t\tif ( type === \"fx\" ) {\n\t\t\t\tqueue.unshift( \"inprogress\" );\n\t\t\t}\n\n\t\t\t// Clear up the last queue stop function\n\t\t\tdelete hooks.stop;\n\t\t\tfn.call( elem, next, hooks );\n\t\t}\n\n\t\tif ( !startLength && hooks ) {\n\t\t\thooks.empty.fire();\n\t\t}\n\t},\n\n\t// Not public - generate a queueHooks object, or return the current one\n\t_queueHooks: function( elem, type ) {\n\t\tvar key = type + \"queueHooks\";\n\t\treturn dataPriv.get( elem, key ) || dataPriv.access( elem, key, {\n\t\t\tempty: jQuery.Callbacks( \"once memory\" ).add( function() {\n\t\t\t\tdataPriv.remove( elem, [ type + \"queue\", key ] );\n\t\t\t} )\n\t\t} );\n\t}\n} );\n\njQuery.fn.extend( {\n\tqueue: function( type, data ) {\n\t\tvar setter = 2;\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tdata = type;\n\t\t\ttype = \"fx\";\n\t\t\tsetter--;\n\t\t}\n\n\t\tif ( arguments.length < setter ) {\n\t\t\treturn jQuery.queue( this[ 0 ], type );\n\t\t}\n\n\t\treturn data === undefined ?\n\t\t\tthis :\n\t\t\tthis.each( function() {\n\t\t\t\tvar queue = jQuery.queue( this, type, data );\n\n\t\t\t\t// Ensure a hooks for this queue\n\t\t\t\tjQuery._queueHooks( this, type );\n\n\t\t\t\tif ( type === \"fx\" && queue[ 0 ] !== \"inprogress\" ) {\n\t\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t\t}\n\t\t\t} );\n\t},\n\tdequeue: function( type ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.dequeue( this, type );\n\t\t} );\n\t},\n\tclearQueue: function( type ) {\n\t\treturn this.queue( type || \"fx\", [] );\n\t},\n\n\t// Get a promise resolved when queues of a certain type\n\t// are emptied (fx is the type by default)\n\tpromise: function( type, obj ) {\n\t\tvar tmp,\n\t\t\tcount = 1,\n\t\t\tdefer = jQuery.Deferred(),\n\t\t\telements = this,\n\t\t\ti = this.length,\n\t\t\tresolve = function() {\n\t\t\t\tif ( !( --count ) ) {\n\t\t\t\t\tdefer.resolveWith( elements, [ elements ] );\n\t\t\t\t}\n\t\t\t};\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tobj = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\ttype = type || \"fx\";\n\n\t\twhile ( i-- ) {\n\t\t\ttmp = dataPriv.get( elements[ i ], type + \"queueHooks\" );\n\t\t\tif ( tmp && tmp.empty ) {\n\t\t\t\tcount++;\n\t\t\t\ttmp.empty.add( resolve );\n\t\t\t}\n\t\t}\n\t\tresolve();\n\t\treturn defer.promise( obj );\n\t}\n} );\nvar pnum = ( /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/ ).source;\n\nvar rcssNum = new RegExp( \"^(?:([+-])=|)(\" + pnum + \")([a-z%]*)$\", \"i\" );\n\n\nvar cssExpand = [ \"Top\", \"Right\", \"Bottom\", \"Left\" ];\n\nvar isHiddenWithinTree = function( elem, el ) {\n\n\t\t// isHiddenWithinTree might be called from jQuery#filter function;\n\t\t// in that case, element will be second argument\n\t\telem = el || elem;\n\n\t\t// Inline style trumps all\n\t\treturn elem.style.display === \"none\" ||\n\t\t\telem.style.display === \"\" &&\n\n\t\t\t// Otherwise, check computed style\n\t\t\t// Support: Firefox <=43 - 45\n\t\t\t// Disconnected elements can have computed display: none, so first confirm that elem is\n\t\t\t// in the document.\n\t\t\tjQuery.contains( elem.ownerDocument, elem ) &&\n\n\t\t\tjQuery.css( elem, \"display\" ) === \"none\";\n\t};\n\nvar swap = function( elem, options, callback, args ) {\n\tvar ret, name,\n\t\told = {};\n\n\t// Remember the old values, and insert the new ones\n\tfor ( name in options ) {\n\t\told[ name ] = elem.style[ name ];\n\t\telem.style[ name ] = options[ name ];\n\t}\n\n\tret = callback.apply( elem, args || [] );\n\n\t// Revert the old values\n\tfor ( name in options ) {\n\t\telem.style[ name ] = old[ name ];\n\t}\n\n\treturn ret;\n};\n\n\n\n\nfunction adjustCSS( elem, prop, valueParts, tween ) {\n\tvar adjusted, scale,\n\t\tmaxIterations = 20,\n\t\tcurrentValue = tween ?\n\t\t\tfunction() {\n\t\t\t\treturn tween.cur();\n\t\t\t} :\n\t\t\tfunction() {\n\t\t\t\treturn jQuery.css( elem, prop, \"\" );\n\t\t\t},\n\t\tinitial = currentValue(),\n\t\tunit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" ),\n\n\t\t// Starting value computation is required for potential unit mismatches\n\t\tinitialInUnit = ( jQuery.cssNumber[ prop ] || unit !== \"px\" && +initial ) &&\n\t\t\trcssNum.exec( jQuery.css( elem, prop ) );\n\n\tif ( initialInUnit && initialInUnit[ 3 ] !== unit ) {\n\n\t\t// Support: Firefox <=54\n\t\t// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)\n\t\tinitial = initial / 2;\n\n\t\t// Trust units reported by jQuery.css\n\t\tunit = unit || initialInUnit[ 3 ];\n\n\t\t// Iteratively approximate from a nonzero starting point\n\t\tinitialInUnit = +initial || 1;\n\n\t\twhile ( maxIterations-- ) {\n\n\t\t\t// Evaluate and update our best guess (doubling guesses that zero out).\n\t\t\t// Finish if the scale equals or crosses 1 (making the old*new product non-positive).\n\t\t\tjQuery.style( elem, prop, initialInUnit + unit );\n\t\t\tif ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {\n\t\t\t\tmaxIterations = 0;\n\t\t\t}\n\t\t\tinitialInUnit = initialInUnit / scale;\n\n\t\t}\n\n\t\tinitialInUnit = initialInUnit * 2;\n\t\tjQuery.style( elem, prop, initialInUnit + unit );\n\n\t\t// Make sure we update the tween properties later on\n\t\tvalueParts = valueParts || [];\n\t}\n\n\tif ( valueParts ) {\n\t\tinitialInUnit = +initialInUnit || +initial || 0;\n\n\t\t// Apply relative offset (+=/-=) if specified\n\t\tadjusted = valueParts[ 1 ] ?\n\t\t\tinitialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :\n\t\t\t+valueParts[ 2 ];\n\t\tif ( tween ) {\n\t\t\ttween.unit = unit;\n\t\t\ttween.start = initialInUnit;\n\t\t\ttween.end = adjusted;\n\t\t}\n\t}\n\treturn adjusted;\n}\n\n\nvar defaultDisplayMap = {};\n\nfunction getDefaultDisplay( elem ) {\n\tvar temp,\n\t\tdoc = elem.ownerDocument,\n\t\tnodeName = elem.nodeName,\n\t\tdisplay = defaultDisplayMap[ nodeName ];\n\n\tif ( display ) {\n\t\treturn display;\n\t}\n\n\ttemp = doc.body.appendChild( doc.createElement( nodeName ) );\n\tdisplay = jQuery.css( temp, \"display\" );\n\n\ttemp.parentNode.removeChild( temp );\n\n\tif ( display === \"none\" ) {\n\t\tdisplay = \"block\";\n\t}\n\tdefaultDisplayMap[ nodeName ] = display;\n\n\treturn display;\n}\n\nfunction showHide( elements, show ) {\n\tvar display, elem,\n\t\tvalues = [],\n\t\tindex = 0,\n\t\tlength = elements.length;\n\n\t// Determine new display value for elements that need to change\n\tfor ( ; index < length; index++ ) {\n\t\telem = elements[ index ];\n\t\tif ( !elem.style ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tdisplay = elem.style.display;\n\t\tif ( show ) {\n\n\t\t\t// Since we force visibility upon cascade-hidden elements, an immediate (and slow)\n\t\t\t// check is required in this first loop unless we have a nonempty display value (either\n\t\t\t// inline or about-to-be-restored)\n\t\t\tif ( display === \"none\" ) {\n\t\t\t\tvalues[ index ] = dataPriv.get( elem, \"display\" ) || null;\n\t\t\t\tif ( !values[ index ] ) {\n\t\t\t\t\telem.style.display = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( elem.style.display === \"\" && isHiddenWithinTree( elem ) ) {\n\t\t\t\tvalues[ index ] = getDefaultDisplay( elem );\n\t\t\t}\n\t\t} else {\n\t\t\tif ( display !== \"none\" ) {\n\t\t\t\tvalues[ index ] = \"none\";\n\n\t\t\t\t// Remember what we're overwriting\n\t\t\t\tdataPriv.set( elem, \"display\", display );\n\t\t\t}\n\t\t}\n\t}\n\n\t// Set the display of the elements in a second loop to avoid constant reflow\n\tfor ( index = 0; index < length; index++ ) {\n\t\tif ( values[ index ] != null ) {\n\t\t\telements[ index ].style.display = values[ index ];\n\t\t}\n\t}\n\n\treturn elements;\n}\n\njQuery.fn.extend( {\n\tshow: function() {\n\t\treturn showHide( this, true );\n\t},\n\thide: function() {\n\t\treturn showHide( this );\n\t},\n\ttoggle: function( state ) {\n\t\tif ( typeof state === \"boolean\" ) {\n\t\t\treturn state ? this.show() : this.hide();\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tif ( isHiddenWithinTree( this ) ) {\n\t\t\t\tjQuery( this ).show();\n\t\t\t} else {\n\t\t\t\tjQuery( this ).hide();\n\t\t\t}\n\t\t} );\n\t}\n} );\nvar rcheckableType = ( /^(?:checkbox|radio)$/i );\n\nvar rtagName = ( /<([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]+)/i );\n\nvar rscriptType = ( /^$|^module$|\\/(?:java|ecma)script/i );\n\n\n\n// We have to close these tags to support XHTML (#13200)\nvar wrapMap = {\n\n\t// Support: IE <=9 only\n\toption: [ 1, \"<select multiple='multiple'>\", \"</select>\" ],\n\n\t// XHTML parsers do not magically insert elements in the\n\t// same way that tag soup parsers do. So we cannot shorten\n\t// this by omitting <tbody> or other required elements.\n\tthead: [ 1, \"<table>\", \"</table>\" ],\n\tcol: [ 2, \"<table><colgroup>\", \"</colgroup></table>\" ],\n\ttr: [ 2, \"<table><tbody>\", \"</tbody></table>\" ],\n\ttd: [ 3, \"<table><tbody><tr>\", \"</tr></tbody></table>\" ],\n\n\t_default: [ 0, \"\", \"\" ]\n};\n\n// Support: IE <=9 only\nwrapMap.optgroup = wrapMap.option;\n\nwrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\nwrapMap.th = wrapMap.td;\n\n\nfunction getAll( context, tag ) {\n\n\t// Support: IE <=9 - 11 only\n\t// Use typeof to avoid zero-argument method invocation on host objects (#15151)\n\tvar ret;\n\n\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\n\t\tret = context.getElementsByTagName( tag || \"*\" );\n\n\t} else if ( typeof context.querySelectorAll !== \"undefined\" ) {\n\t\tret = context.querySelectorAll( tag || \"*\" );\n\n\t} else {\n\t\tret = [];\n\t}\n\n\tif ( tag === undefined || tag && nodeName( context, tag ) ) {\n\t\treturn jQuery.merge( [ context ], ret );\n\t}\n\n\treturn ret;\n}\n\n\n// Mark scripts as having already been evaluated\nfunction setGlobalEval( elems, refElements ) {\n\tvar i = 0,\n\t\tl = elems.length;\n\n\tfor ( ; i < l; i++ ) {\n\t\tdataPriv.set(\n\t\t\telems[ i ],\n\t\t\t\"globalEval\",\n\t\t\t!refElements || dataPriv.get( refElements[ i ], \"globalEval\" )\n\t\t);\n\t}\n}\n\n\nvar rhtml = /<|&#?\\w+;/;\n\nfunction buildFragment( elems, context, scripts, selection, ignored ) {\n\tvar elem, tmp, tag, wrap, contains, j,\n\t\tfragment = context.createDocumentFragment(),\n\t\tnodes = [],\n\t\ti = 0,\n\t\tl = elems.length;\n\n\tfor ( ; i < l; i++ ) {\n\t\telem = elems[ i ];\n\n\t\tif ( elem || elem === 0 ) {\n\n\t\t\t// Add nodes directly\n\t\t\tif ( toType( elem ) === \"object\" ) {\n\n\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\tjQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );\n\n\t\t\t// Convert non-html into a text node\n\t\t\t} else if ( !rhtml.test( elem ) ) {\n\t\t\t\tnodes.push( context.createTextNode( elem ) );\n\n\t\t\t// Convert html into DOM nodes\n\t\t\t} else {\n\t\t\t\ttmp = tmp || fragment.appendChild( context.createElement( \"div\" ) );\n\n\t\t\t\t// Deserialize a standard representation\n\t\t\t\ttag = ( rtagName.exec( elem ) || [ \"\", \"\" ] )[ 1 ].toLowerCase();\n\t\t\t\twrap = wrapMap[ tag ] || wrapMap._default;\n\t\t\t\ttmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];\n\n\t\t\t\t// Descend through wrappers to the right content\n\t\t\t\tj = wrap[ 0 ];\n\t\t\t\twhile ( j-- ) {\n\t\t\t\t\ttmp = tmp.lastChild;\n\t\t\t\t}\n\n\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\tjQuery.merge( nodes, tmp.childNodes );\n\n\t\t\t\t// Remember the top-level container\n\t\t\t\ttmp = fragment.firstChild;\n\n\t\t\t\t// Ensure the created nodes are orphaned (#12392)\n\t\t\t\ttmp.textContent = \"\";\n\t\t\t}\n\t\t}\n\t}\n\n\t// Remove wrapper from fragment\n\tfragment.textContent = \"\";\n\n\ti = 0;\n\twhile ( ( elem = nodes[ i++ ] ) ) {\n\n\t\t// Skip elements already in the context collection (trac-4087)\n\t\tif ( selection && jQuery.inArray( elem, selection ) > -1 ) {\n\t\t\tif ( ignored ) {\n\t\t\t\tignored.push( elem );\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tcontains = jQuery.contains( elem.ownerDocument, elem );\n\n\t\t// Append to fragment\n\t\ttmp = getAll( fragment.appendChild( elem ), \"script\" );\n\n\t\t// Preserve script evaluation history\n\t\tif ( contains ) {\n\t\t\tsetGlobalEval( tmp );\n\t\t}\n\n\t\t// Capture executables\n\t\tif ( scripts ) {\n\t\t\tj = 0;\n\t\t\twhile ( ( elem = tmp[ j++ ] ) ) {\n\t\t\t\tif ( rscriptType.test( elem.type || \"\" ) ) {\n\t\t\t\t\tscripts.push( elem );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn fragment;\n}\n\n\n( function() {\n\tvar fragment = document.createDocumentFragment(),\n\t\tdiv = fragment.appendChild( document.createElement( \"div\" ) ),\n\t\tinput = document.createElement( \"input\" );\n\n\t// Support: Android 4.0 - 4.3 only\n\t// Check state lost if the name is set (#11217)\n\t// Support: Windows Web Apps (WWA)\n\t// `name` and `type` must use .setAttribute for WWA (#14901)\n\tinput.setAttribute( \"type\", \"radio\" );\n\tinput.setAttribute( \"checked\", \"checked\" );\n\tinput.setAttribute( \"name\", \"t\" );\n\n\tdiv.appendChild( input );\n\n\t// Support: Android <=4.1 only\n\t// Older WebKit doesn't clone checked state correctly in fragments\n\tsupport.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;\n\n\t// Support: IE <=11 only\n\t// Make sure textarea (and checkbox) defaultValue is properly cloned\n\tdiv.innerHTML = \"<textarea>x</textarea>\";\n\tsupport.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;\n} )();\nvar documentElement = document.documentElement;\n\n\n\nvar\n\trkeyEvent = /^key/,\n\trmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,\n\trtypenamespace = /^([^.]*)(?:\\.(.+)|)/;\n\nfunction returnTrue() {\n\treturn true;\n}\n\nfunction returnFalse() {\n\treturn false;\n}\n\n// Support: IE <=9 only\n// See #13393 for more info\nfunction safeActiveElement() {\n\ttry {\n\t\treturn document.activeElement;\n\t} catch ( err ) { }\n}\n\nfunction on( elem, types, selector, data, fn, one ) {\n\tvar origFn, type;\n\n\t// Types can be a map of types/handlers\n\tif ( typeof types === \"object\" ) {\n\n\t\t// ( types-Object, selector, data )\n\t\tif ( typeof selector !== \"string\" ) {\n\n\t\t\t// ( types-Object, data )\n\t\t\tdata = data || selector;\n\t\t\tselector = undefined;\n\t\t}\n\t\tfor ( type in types ) {\n\t\t\ton( elem, type, selector, data, types[ type ], one );\n\t\t}\n\t\treturn elem;\n\t}\n\n\tif ( data == null && fn == null ) {\n\n\t\t// ( types, fn )\n\t\tfn = selector;\n\t\tdata = selector = undefined;\n\t} else if ( fn == null ) {\n\t\tif ( typeof selector === \"string\" ) {\n\n\t\t\t// ( types, selector, fn )\n\t\t\tfn = data;\n\t\t\tdata = undefined;\n\t\t} else {\n\n\t\t\t// ( types, data, fn )\n\t\t\tfn = data;\n\t\t\tdata = selector;\n\t\t\tselector = undefined;\n\t\t}\n\t}\n\tif ( fn === false ) {\n\t\tfn = returnFalse;\n\t} else if ( !fn ) {\n\t\treturn elem;\n\t}\n\n\tif ( one === 1 ) {\n\t\torigFn = fn;\n\t\tfn = function( event ) {\n\n\t\t\t// Can use an empty set, since event contains the info\n\t\t\tjQuery().off( event );\n\t\t\treturn origFn.apply( this, arguments );\n\t\t};\n\n\t\t// Use same guid so caller can remove using origFn\n\t\tfn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );\n\t}\n\treturn elem.each( function() {\n\t\tjQuery.event.add( this, types, fn, data, selector );\n\t} );\n}\n\n/*\n * Helper functions for managing events -- not part of the public interface.\n * Props to Dean Edwards' addEvent library for many of the ideas.\n */\njQuery.event = {\n\n\tglobal: {},\n\n\tadd: function( elem, types, handler, data, selector ) {\n\n\t\tvar handleObjIn, eventHandle, tmp,\n\t\t\tevents, t, handleObj,\n\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\telemData = dataPriv.get( elem );\n\n\t\t// Don't attach events to noData or text/comment nodes (but allow plain objects)\n\t\tif ( !elemData ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Caller can pass in an object of custom data in lieu of the handler\n\t\tif ( handler.handler ) {\n\t\t\thandleObjIn = handler;\n\t\t\thandler = handleObjIn.handler;\n\t\t\tselector = handleObjIn.selector;\n\t\t}\n\n\t\t// Ensure that invalid selectors throw exceptions at attach time\n\t\t// Evaluate against documentElement in case elem is a non-element node (e.g., document)\n\t\tif ( selector ) {\n\t\t\tjQuery.find.matchesSelector( documentElement, selector );\n\t\t}\n\n\t\t// Make sure that the handler has a unique ID, used to find/remove it later\n\t\tif ( !handler.guid ) {\n\t\t\thandler.guid = jQuery.guid++;\n\t\t}\n\n\t\t// Init the element's event structure and main handler, if this is the first\n\t\tif ( !( events = elemData.events ) ) {\n\t\t\tevents = elemData.events = {};\n\t\t}\n\t\tif ( !( eventHandle = elemData.handle ) ) {\n\t\t\teventHandle = elemData.handle = function( e ) {\n\n\t\t\t\t// Discard the second event of a jQuery.event.trigger() and\n\t\t\t\t// when an event is called after a page has unloaded\n\t\t\t\treturn typeof jQuery !== \"undefined\" && jQuery.event.triggered !== e.type ?\n\t\t\t\t\tjQuery.event.dispatch.apply( elem, arguments ) : undefined;\n\t\t\t};\n\t\t}\n\n\t\t// Handle multiple events separated by a space\n\t\ttypes = ( types || \"\" ).match( rnothtmlwhite ) || [ \"\" ];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[ t ] ) || [];\n\t\t\ttype = origType = tmp[ 1 ];\n\t\t\tnamespaces = ( tmp[ 2 ] || \"\" ).split( \".\" ).sort();\n\n\t\t\t// There *must* be a type, no attaching namespace-only handlers\n\t\t\tif ( !type ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// If event changes its type, use the special event handlers for the changed type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// If selector defined, determine special event api type, otherwise given type\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\n\t\t\t// Update special based on newly reset type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// handleObj is passed to all event handlers\n\t\t\thandleObj = jQuery.extend( {\n\t\t\t\ttype: type,\n\t\t\t\torigType: origType,\n\t\t\t\tdata: data,\n\t\t\t\thandler: handler,\n\t\t\t\tguid: handler.guid,\n\t\t\t\tselector: selector,\n\t\t\t\tneedsContext: selector && jQuery.expr.match.needsContext.test( selector ),\n\t\t\t\tnamespace: namespaces.join( \".\" )\n\t\t\t}, handleObjIn );\n\n\t\t\t// Init the event handler queue if we're the first\n\t\t\tif ( !( handlers = events[ type ] ) ) {\n\t\t\t\thandlers = events[ type ] = [];\n\t\t\t\thandlers.delegateCount = 0;\n\n\t\t\t\t// Only use addEventListener if the special events handler returns false\n\t\t\t\tif ( !special.setup ||\n\t\t\t\t\tspecial.setup.call( elem, data, namespaces, eventHandle ) === false ) {\n\n\t\t\t\t\tif ( elem.addEventListener ) {\n\t\t\t\t\t\telem.addEventListener( type, eventHandle );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( special.add ) {\n\t\t\t\tspecial.add.call( elem, handleObj );\n\n\t\t\t\tif ( !handleObj.handler.guid ) {\n\t\t\t\t\thandleObj.handler.guid = handler.guid;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add to the element's handler list, delegates in front\n\t\t\tif ( selector ) {\n\t\t\t\thandlers.splice( handlers.delegateCount++, 0, handleObj );\n\t\t\t} else {\n\t\t\t\thandlers.push( handleObj );\n\t\t\t}\n\n\t\t\t// Keep track of which events have ever been used, for event optimization\n\t\t\tjQuery.event.global[ type ] = true;\n\t\t}\n\n\t},\n\n\t// Detach an event or set of events from an element\n\tremove: function( elem, types, handler, selector, mappedTypes ) {\n\n\t\tvar j, origCount, tmp,\n\t\t\tevents, t, handleObj,\n\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\telemData = dataPriv.hasData( elem ) && dataPriv.get( elem );\n\n\t\tif ( !elemData || !( events = elemData.events ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Once for each type.namespace in types; type may be omitted\n\t\ttypes = ( types || \"\" ).match( rnothtmlwhite ) || [ \"\" ];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[ t ] ) || [];\n\t\t\ttype = origType = tmp[ 1 ];\n\t\t\tnamespaces = ( tmp[ 2 ] || \"\" ).split( \".\" ).sort();\n\n\t\t\t// Unbind all events (on this namespace, if provided) for the element\n\t\t\tif ( !type ) {\n\t\t\t\tfor ( type in events ) {\n\t\t\t\t\tjQuery.event.remove( elem, type + types[ t ], handler, selector, true );\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\t\t\thandlers = events[ type ] || [];\n\t\t\ttmp = tmp[ 2 ] &&\n\t\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join( \"\\\\.(?:.*\\\\.|)\" ) + \"(\\\\.|$)\" );\n\n\t\t\t// Remove matching events\n\t\t\torigCount = j = handlers.length;\n\t\t\twhile ( j-- ) {\n\t\t\t\thandleObj = handlers[ j ];\n\n\t\t\t\tif ( ( mappedTypes || origType === handleObj.origType ) &&\n\t\t\t\t\t( !handler || handler.guid === handleObj.guid ) &&\n\t\t\t\t\t( !tmp || tmp.test( handleObj.namespace ) ) &&\n\t\t\t\t\t( !selector || selector === handleObj.selector ||\n\t\t\t\t\t\tselector === \"**\" && handleObj.selector ) ) {\n\t\t\t\t\thandlers.splice( j, 1 );\n\n\t\t\t\t\tif ( handleObj.selector ) {\n\t\t\t\t\t\thandlers.delegateCount--;\n\t\t\t\t\t}\n\t\t\t\t\tif ( special.remove ) {\n\t\t\t\t\t\tspecial.remove.call( elem, handleObj );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove generic event handler if we removed something and no more handlers exist\n\t\t\t// (avoids potential for endless recursion during removal of special event handlers)\n\t\t\tif ( origCount && !handlers.length ) {\n\t\t\t\tif ( !special.teardown ||\n\t\t\t\t\tspecial.teardown.call( elem, namespaces, elemData.handle ) === false ) {\n\n\t\t\t\t\tjQuery.removeEvent( elem, type, elemData.handle );\n\t\t\t\t}\n\n\t\t\t\tdelete events[ type ];\n\t\t\t}\n\t\t}\n\n\t\t// Remove data and the expando if it's no longer used\n\t\tif ( jQuery.isEmptyObject( events ) ) {\n\t\t\tdataPriv.remove( elem, \"handle events\" );\n\t\t}\n\t},\n\n\tdispatch: function( nativeEvent ) {\n\n\t\t// Make a writable jQuery.Event from the native event object\n\t\tvar event = jQuery.event.fix( nativeEvent );\n\n\t\tvar i, j, ret, matched, handleObj, handlerQueue,\n\t\t\targs = new Array( arguments.length ),\n\t\t\thandlers = ( dataPriv.get( this, \"events\" ) || {} )[ event.type ] || [],\n\t\t\tspecial = jQuery.event.special[ event.type ] || {};\n\n\t\t// Use the fix-ed jQuery.Event rather than the (read-only) native event\n\t\targs[ 0 ] = event;\n\n\t\tfor ( i = 1; i < arguments.length; i++ ) {\n\t\t\targs[ i ] = arguments[ i ];\n\t\t}\n\n\t\tevent.delegateTarget = this;\n\n\t\t// Call the preDispatch hook for the mapped type, and let it bail if desired\n\t\tif ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine handlers\n\t\thandlerQueue = jQuery.event.handlers.call( this, event, handlers );\n\n\t\t// Run delegates first; they may want to stop propagation beneath us\n\t\ti = 0;\n\t\twhile ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {\n\t\t\tevent.currentTarget = matched.elem;\n\n\t\t\tj = 0;\n\t\t\twhile ( ( handleObj = matched.handlers[ j++ ] ) &&\n\t\t\t\t!event.isImmediatePropagationStopped() ) {\n\n\t\t\t\t// Triggered event must either 1) have no namespace, or 2) have namespace(s)\n\t\t\t\t// a subset or equal to those in the bound event (both can have no namespace).\n\t\t\t\tif ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {\n\n\t\t\t\t\tevent.handleObj = handleObj;\n\t\t\t\t\tevent.data = handleObj.data;\n\n\t\t\t\t\tret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||\n\t\t\t\t\t\thandleObj.handler ).apply( matched.elem, args );\n\n\t\t\t\t\tif ( ret !== undefined ) {\n\t\t\t\t\t\tif ( ( event.result = ret ) === false ) {\n\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Call the postDispatch hook for the mapped type\n\t\tif ( special.postDispatch ) {\n\t\t\tspecial.postDispatch.call( this, event );\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\thandlers: function( event, handlers ) {\n\t\tvar i, handleObj, sel, matchedHandlers, matchedSelectors,\n\t\t\thandlerQueue = [],\n\t\t\tdelegateCount = handlers.delegateCount,\n\t\t\tcur = event.target;\n\n\t\t// Find delegate handlers\n\t\tif ( delegateCount &&\n\n\t\t\t// Support: IE <=9\n\t\t\t// Black-hole SVG <use> instance trees (trac-13180)\n\t\t\tcur.nodeType &&\n\n\t\t\t// Support: Firefox <=42\n\t\t\t// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)\n\t\t\t// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click\n\t\t\t// Support: IE 11 only\n\t\t\t// ...but not arrow key \"clicks\" of radio inputs, which can have `button` -1 (gh-2343)\n\t\t\t!( event.type === \"click\" && event.button >= 1 ) ) {\n\n\t\t\tfor ( ; cur !== this; cur = cur.parentNode || this ) {\n\n\t\t\t\t// Don't check non-elements (#13208)\n\t\t\t\t// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)\n\t\t\t\tif ( cur.nodeType === 1 && !( event.type === \"click\" && cur.disabled === true ) ) {\n\t\t\t\t\tmatchedHandlers = [];\n\t\t\t\t\tmatchedSelectors = {};\n\t\t\t\t\tfor ( i = 0; i < delegateCount; i++ ) {\n\t\t\t\t\t\thandleObj = handlers[ i ];\n\n\t\t\t\t\t\t// Don't conflict with Object.prototype properties (#13203)\n\t\t\t\t\t\tsel = handleObj.selector + \" \";\n\n\t\t\t\t\t\tif ( matchedSelectors[ sel ] === undefined ) {\n\t\t\t\t\t\t\tmatchedSelectors[ sel ] = handleObj.needsContext ?\n\t\t\t\t\t\t\t\tjQuery( sel, this ).index( cur ) > -1 :\n\t\t\t\t\t\t\t\tjQuery.find( sel, this, null, [ cur ] ).length;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( matchedSelectors[ sel ] ) {\n\t\t\t\t\t\t\tmatchedHandlers.push( handleObj );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( matchedHandlers.length ) {\n\t\t\t\t\t\thandlerQueue.push( { elem: cur, handlers: matchedHandlers } );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Add the remaining (directly-bound) handlers\n\t\tcur = this;\n\t\tif ( delegateCount < handlers.length ) {\n\t\t\thandlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );\n\t\t}\n\n\t\treturn handlerQueue;\n\t},\n\n\taddProp: function( name, hook ) {\n\t\tObject.defineProperty( jQuery.Event.prototype, name, {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\n\t\t\tget: isFunction( hook ) ?\n\t\t\t\tfunction() {\n\t\t\t\t\tif ( this.originalEvent ) {\n\t\t\t\t\t\t\treturn hook( this.originalEvent );\n\t\t\t\t\t}\n\t\t\t\t} :\n\t\t\t\tfunction() {\n\t\t\t\t\tif ( this.originalEvent ) {\n\t\t\t\t\t\t\treturn this.originalEvent[ name ];\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\tset: function( value ) {\n\t\t\t\tObject.defineProperty( this, name, {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\twritable: true,\n\t\t\t\t\tvalue: value\n\t\t\t\t} );\n\t\t\t}\n\t\t} );\n\t},\n\n\tfix: function( originalEvent ) {\n\t\treturn originalEvent[ jQuery.expando ] ?\n\t\t\toriginalEvent :\n\t\t\tnew jQuery.Event( originalEvent );\n\t},\n\n\tspecial: {\n\t\tload: {\n\n\t\t\t// Prevent triggered image.load events from bubbling to window.load\n\t\t\tnoBubble: true\n\t\t},\n\t\tfocus: {\n\n\t\t\t// Fire native event if possible so blur/focus sequence is correct\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this !== safeActiveElement() && this.focus ) {\n\t\t\t\t\tthis.focus();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdelegateType: \"focusin\"\n\t\t},\n\t\tblur: {\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this === safeActiveElement() && this.blur ) {\n\t\t\t\t\tthis.blur();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdelegateType: \"focusout\"\n\t\t},\n\t\tclick: {\n\n\t\t\t// For checkbox, fire native event so checked state will be right\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this.type === \"checkbox\" && this.click && nodeName( this, \"input\" ) ) {\n\t\t\t\t\tthis.click();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// For cross-browser consistency, don't fire native .click() on links\n\t\t\t_default: function( event ) {\n\t\t\t\treturn nodeName( event.target, \"a\" );\n\t\t\t}\n\t\t},\n\n\t\tbeforeunload: {\n\t\t\tpostDispatch: function( event ) {\n\n\t\t\t\t// Support: Firefox 20+\n\t\t\t\t// Firefox doesn't alert if the returnValue field is not set.\n\t\t\t\tif ( event.result !== undefined && event.originalEvent ) {\n\t\t\t\t\tevent.originalEvent.returnValue = event.result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\njQuery.removeEvent = function( elem, type, handle ) {\n\n\t// This \"if\" is needed for plain objects\n\tif ( elem.removeEventListener ) {\n\t\telem.removeEventListener( type, handle );\n\t}\n};\n\njQuery.Event = function( src, props ) {\n\n\t// Allow instantiation without the 'new' keyword\n\tif ( !( this instanceof jQuery.Event ) ) {\n\t\treturn new jQuery.Event( src, props );\n\t}\n\n\t// Event object\n\tif ( src && src.type ) {\n\t\tthis.originalEvent = src;\n\t\tthis.type = src.type;\n\n\t\t// Events bubbling up the document may have been marked as prevented\n\t\t// by a handler lower down the tree; reflect the correct value.\n\t\tthis.isDefaultPrevented = src.defaultPrevented ||\n\t\t\t\tsrc.defaultPrevented === undefined &&\n\n\t\t\t\t// Support: Android <=2.3 only\n\t\t\t\tsrc.returnValue === false ?\n\t\t\treturnTrue :\n\t\t\treturnFalse;\n\n\t\t// Create target properties\n\t\t// Support: Safari <=6 - 7 only\n\t\t// Target should not be a text node (#504, #13143)\n\t\tthis.target = ( src.target && src.target.nodeType === 3 ) ?\n\t\t\tsrc.target.parentNode :\n\t\t\tsrc.target;\n\n\t\tthis.currentTarget = src.currentTarget;\n\t\tthis.relatedTarget = src.relatedTarget;\n\n\t// Event type\n\t} else {\n\t\tthis.type = src;\n\t}\n\n\t// Put explicitly provided properties onto the event object\n\tif ( props ) {\n\t\tjQuery.extend( this, props );\n\t}\n\n\t// Create a timestamp if incoming event doesn't have one\n\tthis.timeStamp = src && src.timeStamp || Date.now();\n\n\t// Mark it as fixed\n\tthis[ jQuery.expando ] = true;\n};\n\n// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\njQuery.Event.prototype = {\n\tconstructor: jQuery.Event,\n\tisDefaultPrevented: returnFalse,\n\tisPropagationStopped: returnFalse,\n\tisImmediatePropagationStopped: returnFalse,\n\tisSimulated: false,\n\n\tpreventDefault: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isDefaultPrevented = returnTrue;\n\n\t\tif ( e && !this.isSimulated ) {\n\t\t\te.preventDefault();\n\t\t}\n\t},\n\tstopPropagation: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isPropagationStopped = returnTrue;\n\n\t\tif ( e && !this.isSimulated ) {\n\t\t\te.stopPropagation();\n\t\t}\n\t},\n\tstopImmediatePropagation: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isImmediatePropagationStopped = returnTrue;\n\n\t\tif ( e && !this.isSimulated ) {\n\t\t\te.stopImmediatePropagation();\n\t\t}\n\n\t\tthis.stopPropagation();\n\t}\n};\n\n// Includes all common event props including KeyEvent and MouseEvent specific props\njQuery.each( {\n\taltKey: true,\n\tbubbles: true,\n\tcancelable: true,\n\tchangedTouches: true,\n\tctrlKey: true,\n\tdetail: true,\n\teventPhase: true,\n\tmetaKey: true,\n\tpageX: true,\n\tpageY: true,\n\tshiftKey: true,\n\tview: true,\n\t\"char\": true,\n\tcharCode: true,\n\tkey: true,\n\tkeyCode: true,\n\tbutton: true,\n\tbuttons: true,\n\tclientX: true,\n\tclientY: true,\n\toffsetX: true,\n\toffsetY: true,\n\tpointerId: true,\n\tpointerType: true,\n\tscreenX: true,\n\tscreenY: true,\n\ttargetTouches: true,\n\ttoElement: true,\n\ttouches: true,\n\n\twhich: function( event ) {\n\t\tvar button = event.button;\n\n\t\t// Add which for key events\n\t\tif ( event.which == null && rkeyEvent.test( event.type ) ) {\n\t\t\treturn event.charCode != null ? event.charCode : event.keyCode;\n\t\t}\n\n\t\t// Add which for click: 1 === left; 2 === middle; 3 === right\n\t\tif ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {\n\t\t\tif ( button & 1 ) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tif ( button & 2 ) {\n\t\t\t\treturn 3;\n\t\t\t}\n\n\t\t\tif ( button & 4 ) {\n\t\t\t\treturn 2;\n\t\t\t}\n\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn event.which;\n\t}\n}, jQuery.event.addProp );\n\n// Create mouseenter/leave events using mouseover/out and event-time checks\n// so that event delegation works in jQuery.\n// Do the same for pointerenter/pointerleave and pointerover/pointerout\n//\n// Support: Safari 7 only\n// Safari sends mouseenter too often; see:\n// https://bugs.chromium.org/p/chromium/issues/detail?id=470258\n// for the description of the bug (it existed in older Chrome versions as well).\njQuery.each( {\n\tmouseenter: \"mouseover\",\n\tmouseleave: \"mouseout\",\n\tpointerenter: \"pointerover\",\n\tpointerleave: \"pointerout\"\n}, function( orig, fix ) {\n\tjQuery.event.special[ orig ] = {\n\t\tdelegateType: fix,\n\t\tbindType: fix,\n\n\t\thandle: function( event ) {\n\t\t\tvar ret,\n\t\t\t\ttarget = this,\n\t\t\t\trelated = event.relatedTarget,\n\t\t\t\thandleObj = event.handleObj;\n\n\t\t\t// For mouseenter/leave call the handler if related is outside the target.\n\t\t\t// NB: No relatedTarget if the mouse left/entered the browser window\n\t\t\tif ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {\n\t\t\t\tevent.type = handleObj.origType;\n\t\t\t\tret = handleObj.handler.apply( this, arguments );\n\t\t\t\tevent.type = fix;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t};\n} );\n\njQuery.fn.extend( {\n\n\ton: function( types, selector, data, fn ) {\n\t\treturn on( this, types, selector, data, fn );\n\t},\n\tone: function( types, selector, data, fn ) {\n\t\treturn on( this, types, selector, data, fn, 1 );\n\t},\n\toff: function( types, selector, fn ) {\n\t\tvar handleObj, type;\n\t\tif ( types && types.preventDefault && types.handleObj ) {\n\n\t\t\t// ( event )  dispatched jQuery.Event\n\t\t\thandleObj = types.handleObj;\n\t\t\tjQuery( types.delegateTarget ).off(\n\t\t\t\thandleObj.namespace ?\n\t\t\t\t\thandleObj.origType + \".\" + handleObj.namespace :\n\t\t\t\t\thandleObj.origType,\n\t\t\t\thandleObj.selector,\n\t\t\t\thandleObj.handler\n\t\t\t);\n\t\t\treturn this;\n\t\t}\n\t\tif ( typeof types === \"object\" ) {\n\n\t\t\t// ( types-object [, selector] )\n\t\t\tfor ( type in types ) {\n\t\t\t\tthis.off( type, selector, types[ type ] );\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\tif ( selector === false || typeof selector === \"function\" ) {\n\n\t\t\t// ( types [, fn] )\n\t\t\tfn = selector;\n\t\t\tselector = undefined;\n\t\t}\n\t\tif ( fn === false ) {\n\t\t\tfn = returnFalse;\n\t\t}\n\t\treturn this.each( function() {\n\t\t\tjQuery.event.remove( this, types, fn, selector );\n\t\t} );\n\t}\n} );\n\n\nvar\n\n\t/* eslint-disable max-len */\n\n\t// See https://github.com/eslint/eslint/issues/3229\n\trxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]*)[^>]*)\\/>/gi,\n\n\t/* eslint-enable */\n\n\t// Support: IE <=10 - 11, Edge 12 - 13 only\n\t// In IE/Edge using regex groups here causes severe slowdowns.\n\t// See https://connect.microsoft.com/IE/feedback/details/1736512/\n\trnoInnerhtml = /<script|<style|<link/i,\n\n\t// checked=\"checked\" or checked\n\trchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n\trcleanScript = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g;\n\n// Prefer a tbody over its parent table for containing new rows\nfunction manipulationTarget( elem, content ) {\n\tif ( nodeName( elem, \"table\" ) &&\n\t\tnodeName( content.nodeType !== 11 ? content : content.firstChild, \"tr\" ) ) {\n\n\t\treturn jQuery( elem ).children( \"tbody\" )[ 0 ] || elem;\n\t}\n\n\treturn elem;\n}\n\n// Replace/restore the type attribute of script elements for safe DOM manipulation\nfunction disableScript( elem ) {\n\telem.type = ( elem.getAttribute( \"type\" ) !== null ) + \"/\" + elem.type;\n\treturn elem;\n}\nfunction restoreScript( elem ) {\n\tif ( ( elem.type || \"\" ).slice( 0, 5 ) === \"true/\" ) {\n\t\telem.type = elem.type.slice( 5 );\n\t} else {\n\t\telem.removeAttribute( \"type\" );\n\t}\n\n\treturn elem;\n}\n\nfunction cloneCopyEvent( src, dest ) {\n\tvar i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;\n\n\tif ( dest.nodeType !== 1 ) {\n\t\treturn;\n\t}\n\n\t// 1. Copy private data: events, handlers, etc.\n\tif ( dataPriv.hasData( src ) ) {\n\t\tpdataOld = dataPriv.access( src );\n\t\tpdataCur = dataPriv.set( dest, pdataOld );\n\t\tevents = pdataOld.events;\n\n\t\tif ( events ) {\n\t\t\tdelete pdataCur.handle;\n\t\t\tpdataCur.events = {};\n\n\t\t\tfor ( type in events ) {\n\t\t\t\tfor ( i = 0, l = events[ type ].length; i < l; i++ ) {\n\t\t\t\t\tjQuery.event.add( dest, type, events[ type ][ i ] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// 2. Copy user data\n\tif ( dataUser.hasData( src ) ) {\n\t\tudataOld = dataUser.access( src );\n\t\tudataCur = jQuery.extend( {}, udataOld );\n\n\t\tdataUser.set( dest, udataCur );\n\t}\n}\n\n// Fix IE bugs, see support tests\nfunction fixInput( src, dest ) {\n\tvar nodeName = dest.nodeName.toLowerCase();\n\n\t// Fails to persist the checked state of a cloned checkbox or radio button.\n\tif ( nodeName === \"input\" && rcheckableType.test( src.type ) ) {\n\t\tdest.checked = src.checked;\n\n\t// Fails to return the selected option to the default selected state when cloning options\n\t} else if ( nodeName === \"input\" || nodeName === \"textarea\" ) {\n\t\tdest.defaultValue = src.defaultValue;\n\t}\n}\n\nfunction domManip( collection, args, callback, ignored ) {\n\n\t// Flatten any nested arrays\n\targs = concat.apply( [], args );\n\n\tvar fragment, first, scripts, hasScripts, node, doc,\n\t\ti = 0,\n\t\tl = collection.length,\n\t\tiNoClone = l - 1,\n\t\tvalue = args[ 0 ],\n\t\tvalueIsFunction = isFunction( value );\n\n\t// We can't cloneNode fragments that contain checked, in WebKit\n\tif ( valueIsFunction ||\n\t\t\t( l > 1 && typeof value === \"string\" &&\n\t\t\t\t!support.checkClone && rchecked.test( value ) ) ) {\n\t\treturn collection.each( function( index ) {\n\t\t\tvar self = collection.eq( index );\n\t\t\tif ( valueIsFunction ) {\n\t\t\t\targs[ 0 ] = value.call( this, index, self.html() );\n\t\t\t}\n\t\t\tdomManip( self, args, callback, ignored );\n\t\t} );\n\t}\n\n\tif ( l ) {\n\t\tfragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );\n\t\tfirst = fragment.firstChild;\n\n\t\tif ( fragment.childNodes.length === 1 ) {\n\t\t\tfragment = first;\n\t\t}\n\n\t\t// Require either new content or an interest in ignored elements to invoke the callback\n\t\tif ( first || ignored ) {\n\t\t\tscripts = jQuery.map( getAll( fragment, \"script\" ), disableScript );\n\t\t\thasScripts = scripts.length;\n\n\t\t\t// Use the original fragment for the last item\n\t\t\t// instead of the first because it can end up\n\t\t\t// being emptied incorrectly in certain situations (#8070).\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tnode = fragment;\n\n\t\t\t\tif ( i !== iNoClone ) {\n\t\t\t\t\tnode = jQuery.clone( node, true, true );\n\n\t\t\t\t\t// Keep references to cloned scripts for later restoration\n\t\t\t\t\tif ( hasScripts ) {\n\n\t\t\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\t\t\tjQuery.merge( scripts, getAll( node, \"script\" ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcallback.call( collection[ i ], node, i );\n\t\t\t}\n\n\t\t\tif ( hasScripts ) {\n\t\t\t\tdoc = scripts[ scripts.length - 1 ].ownerDocument;\n\n\t\t\t\t// Reenable scripts\n\t\t\t\tjQuery.map( scripts, restoreScript );\n\n\t\t\t\t// Evaluate executable scripts on first document insertion\n\t\t\t\tfor ( i = 0; i < hasScripts; i++ ) {\n\t\t\t\t\tnode = scripts[ i ];\n\t\t\t\t\tif ( rscriptType.test( node.type || \"\" ) &&\n\t\t\t\t\t\t!dataPriv.access( node, \"globalEval\" ) &&\n\t\t\t\t\t\tjQuery.contains( doc, node ) ) {\n\n\t\t\t\t\t\tif ( node.src && ( node.type || \"\" ).toLowerCase()  !== \"module\" ) {\n\n\t\t\t\t\t\t\t// Optional AJAX dependency, but won't run scripts if not present\n\t\t\t\t\t\t\tif ( jQuery._evalUrl ) {\n\t\t\t\t\t\t\t\tjQuery._evalUrl( node.src );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tDOMEval( node.textContent.replace( rcleanScript, \"\" ), doc, node );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn collection;\n}\n\nfunction remove( elem, selector, keepData ) {\n\tvar node,\n\t\tnodes = selector ? jQuery.filter( selector, elem ) : elem,\n\t\ti = 0;\n\n\tfor ( ; ( node = nodes[ i ] ) != null; i++ ) {\n\t\tif ( !keepData && node.nodeType === 1 ) {\n\t\t\tjQuery.cleanData( getAll( node ) );\n\t\t}\n\n\t\tif ( node.parentNode ) {\n\t\t\tif ( keepData && jQuery.contains( node.ownerDocument, node ) ) {\n\t\t\t\tsetGlobalEval( getAll( node, \"script\" ) );\n\t\t\t}\n\t\t\tnode.parentNode.removeChild( node );\n\t\t}\n\t}\n\n\treturn elem;\n}\n\njQuery.extend( {\n\thtmlPrefilter: function( html ) {\n\t\treturn html.replace( rxhtmlTag, \"<$1></$2>\" );\n\t},\n\n\tclone: function( elem, dataAndEvents, deepDataAndEvents ) {\n\t\tvar i, l, srcElements, destElements,\n\t\t\tclone = elem.cloneNode( true ),\n\t\t\tinPage = jQuery.contains( elem.ownerDocument, elem );\n\n\t\t// Fix IE cloning issues\n\t\tif ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&\n\t\t\t\t!jQuery.isXMLDoc( elem ) ) {\n\n\t\t\t// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2\n\t\t\tdestElements = getAll( clone );\n\t\t\tsrcElements = getAll( elem );\n\n\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\tfixInput( srcElements[ i ], destElements[ i ] );\n\t\t\t}\n\t\t}\n\n\t\t// Copy the events from the original to the clone\n\t\tif ( dataAndEvents ) {\n\t\t\tif ( deepDataAndEvents ) {\n\t\t\t\tsrcElements = srcElements || getAll( elem );\n\t\t\t\tdestElements = destElements || getAll( clone );\n\n\t\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\t\tcloneCopyEvent( srcElements[ i ], destElements[ i ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcloneCopyEvent( elem, clone );\n\t\t\t}\n\t\t}\n\n\t\t// Preserve script evaluation history\n\t\tdestElements = getAll( clone, \"script\" );\n\t\tif ( destElements.length > 0 ) {\n\t\t\tsetGlobalEval( destElements, !inPage && getAll( elem, \"script\" ) );\n\t\t}\n\n\t\t// Return the cloned set\n\t\treturn clone;\n\t},\n\n\tcleanData: function( elems ) {\n\t\tvar data, elem, type,\n\t\t\tspecial = jQuery.event.special,\n\t\t\ti = 0;\n\n\t\tfor ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {\n\t\t\tif ( acceptData( elem ) ) {\n\t\t\t\tif ( ( data = elem[ dataPriv.expando ] ) ) {\n\t\t\t\t\tif ( data.events ) {\n\t\t\t\t\t\tfor ( type in data.events ) {\n\t\t\t\t\t\t\tif ( special[ type ] ) {\n\t\t\t\t\t\t\t\tjQuery.event.remove( elem, type );\n\n\t\t\t\t\t\t\t// This is a shortcut to avoid jQuery.event.remove's overhead\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tjQuery.removeEvent( elem, type, data.handle );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Support: Chrome <=35 - 45+\n\t\t\t\t\t// Assign undefined instead of using delete, see Data#remove\n\t\t\t\t\telem[ dataPriv.expando ] = undefined;\n\t\t\t\t}\n\t\t\t\tif ( elem[ dataUser.expando ] ) {\n\n\t\t\t\t\t// Support: Chrome <=35 - 45+\n\t\t\t\t\t// Assign undefined instead of using delete, see Data#remove\n\t\t\t\t\telem[ dataUser.expando ] = undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n} );\n\njQuery.fn.extend( {\n\tdetach: function( selector ) {\n\t\treturn remove( this, selector, true );\n\t},\n\n\tremove: function( selector ) {\n\t\treturn remove( this, selector );\n\t},\n\n\ttext: function( value ) {\n\t\treturn access( this, function( value ) {\n\t\t\treturn value === undefined ?\n\t\t\t\tjQuery.text( this ) :\n\t\t\t\tthis.empty().each( function() {\n\t\t\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\t\t\tthis.textContent = value;\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t}, null, value, arguments.length );\n\t},\n\n\tappend: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.appendChild( elem );\n\t\t\t}\n\t\t} );\n\t},\n\n\tprepend: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.insertBefore( elem, target.firstChild );\n\t\t\t}\n\t\t} );\n\t},\n\n\tbefore: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this );\n\t\t\t}\n\t\t} );\n\t},\n\n\tafter: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this.nextSibling );\n\t\t\t}\n\t\t} );\n\t},\n\n\tempty: function() {\n\t\tvar elem,\n\t\t\ti = 0;\n\n\t\tfor ( ; ( elem = this[ i ] ) != null; i++ ) {\n\t\t\tif ( elem.nodeType === 1 ) {\n\n\t\t\t\t// Prevent memory leaks\n\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\n\t\t\t\t// Remove any remaining nodes\n\t\t\t\telem.textContent = \"\";\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tclone: function( dataAndEvents, deepDataAndEvents ) {\n\t\tdataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n\t\tdeepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n\n\t\treturn this.map( function() {\n\t\t\treturn jQuery.clone( this, dataAndEvents, deepDataAndEvents );\n\t\t} );\n\t},\n\n\thtml: function( value ) {\n\t\treturn access( this, function( value ) {\n\t\t\tvar elem = this[ 0 ] || {},\n\t\t\t\ti = 0,\n\t\t\t\tl = this.length;\n\n\t\t\tif ( value === undefined && elem.nodeType === 1 ) {\n\t\t\t\treturn elem.innerHTML;\n\t\t\t}\n\n\t\t\t// See if we can take a shortcut and just use innerHTML\n\t\t\tif ( typeof value === \"string\" && !rnoInnerhtml.test( value ) &&\n\t\t\t\t!wrapMap[ ( rtagName.exec( value ) || [ \"\", \"\" ] )[ 1 ].toLowerCase() ] ) {\n\n\t\t\t\tvalue = jQuery.htmlPrefilter( value );\n\n\t\t\t\ttry {\n\t\t\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\t\t\telem = this[ i ] || {};\n\n\t\t\t\t\t\t// Remove element nodes and prevent memory leaks\n\t\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\t\t\t\t\t\t\telem.innerHTML = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telem = 0;\n\n\t\t\t\t// If using innerHTML throws an exception, use the fallback method\n\t\t\t\t} catch ( e ) {}\n\t\t\t}\n\n\t\t\tif ( elem ) {\n\t\t\t\tthis.empty().append( value );\n\t\t\t}\n\t\t}, null, value, arguments.length );\n\t},\n\n\treplaceWith: function() {\n\t\tvar ignored = [];\n\n\t\t// Make the changes, replacing each non-ignored context element with the new content\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tvar parent = this.parentNode;\n\n\t\t\tif ( jQuery.inArray( this, ignored ) < 0 ) {\n\t\t\t\tjQuery.cleanData( getAll( this ) );\n\t\t\t\tif ( parent ) {\n\t\t\t\t\tparent.replaceChild( elem, this );\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Force callback invocation\n\t\t}, ignored );\n\t}\n} );\n\njQuery.each( {\n\tappendTo: \"append\",\n\tprependTo: \"prepend\",\n\tinsertBefore: \"before\",\n\tinsertAfter: \"after\",\n\treplaceAll: \"replaceWith\"\n}, function( name, original ) {\n\tjQuery.fn[ name ] = function( selector ) {\n\t\tvar elems,\n\t\t\tret = [],\n\t\t\tinsert = jQuery( selector ),\n\t\t\tlast = insert.length - 1,\n\t\t\ti = 0;\n\n\t\tfor ( ; i <= last; i++ ) {\n\t\t\telems = i === last ? this : this.clone( true );\n\t\t\tjQuery( insert[ i ] )[ original ]( elems );\n\n\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t// .get() because push.apply(_, arraylike) throws on ancient WebKit\n\t\t\tpush.apply( ret, elems.get() );\n\t\t}\n\n\t\treturn this.pushStack( ret );\n\t};\n} );\nvar rnumnonpx = new RegExp( \"^(\" + pnum + \")(?!px)[a-z%]+$\", \"i\" );\n\nvar getStyles = function( elem ) {\n\n\t\t// Support: IE <=11 only, Firefox <=30 (#15098, #14150)\n\t\t// IE throws on elements created in popups\n\t\t// FF meanwhile throws on frame elements through \"defaultView.getComputedStyle\"\n\t\tvar view = elem.ownerDocument.defaultView;\n\n\t\tif ( !view || !view.opener ) {\n\t\t\tview = window;\n\t\t}\n\n\t\treturn view.getComputedStyle( elem );\n\t};\n\nvar rboxStyle = new RegExp( cssExpand.join( \"|\" ), \"i\" );\n\n\n\n( function() {\n\n\t// Executing both pixelPosition & boxSizingReliable tests require only one layout\n\t// so they're executed at the same time to save the second computation.\n\tfunction computeStyleTests() {\n\n\t\t// This is a singleton, we need to execute it only once\n\t\tif ( !div ) {\n\t\t\treturn;\n\t\t}\n\n\t\tcontainer.style.cssText = \"position:absolute;left:-11111px;width:60px;\" +\n\t\t\t\"margin-top:1px;padding:0;border:0\";\n\t\tdiv.style.cssText =\n\t\t\t\"position:relative;display:block;box-sizing:border-box;overflow:scroll;\" +\n\t\t\t\"margin:auto;border:1px;padding:1px;\" +\n\t\t\t\"width:60%;top:1%\";\n\t\tdocumentElement.appendChild( container ).appendChild( div );\n\n\t\tvar divStyle = window.getComputedStyle( div );\n\t\tpixelPositionVal = divStyle.top !== \"1%\";\n\n\t\t// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44\n\t\treliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;\n\n\t\t// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3\n\t\t// Some styles come back with percentage values, even though they shouldn't\n\t\tdiv.style.right = \"60%\";\n\t\tpixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;\n\n\t\t// Support: IE 9 - 11 only\n\t\t// Detect misreporting of content dimensions for box-sizing:border-box elements\n\t\tboxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;\n\n\t\t// Support: IE 9 only\n\t\t// Detect overflow:scroll screwiness (gh-3699)\n\t\tdiv.style.position = \"absolute\";\n\t\tscrollboxSizeVal = div.offsetWidth === 36 || \"absolute\";\n\n\t\tdocumentElement.removeChild( container );\n\n\t\t// Nullify the div so it wouldn't be stored in the memory and\n\t\t// it will also be a sign that checks already performed\n\t\tdiv = null;\n\t}\n\n\tfunction roundPixelMeasures( measure ) {\n\t\treturn Math.round( parseFloat( measure ) );\n\t}\n\n\tvar pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,\n\t\treliableMarginLeftVal,\n\t\tcontainer = document.createElement( \"div\" ),\n\t\tdiv = document.createElement( \"div\" );\n\n\t// Finish early in limited (non-browser) environments\n\tif ( !div.style ) {\n\t\treturn;\n\t}\n\n\t// Support: IE <=9 - 11 only\n\t// Style of cloned element affects source element cloned (#8908)\n\tdiv.style.backgroundClip = \"content-box\";\n\tdiv.cloneNode( true ).style.backgroundClip = \"\";\n\tsupport.clearCloneStyle = div.style.backgroundClip === \"content-box\";\n\n\tjQuery.extend( support, {\n\t\tboxSizingReliable: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn boxSizingReliableVal;\n\t\t},\n\t\tpixelBoxStyles: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn pixelBoxStylesVal;\n\t\t},\n\t\tpixelPosition: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn pixelPositionVal;\n\t\t},\n\t\treliableMarginLeft: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn reliableMarginLeftVal;\n\t\t},\n\t\tscrollboxSize: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn scrollboxSizeVal;\n\t\t}\n\t} );\n} )();\n\n\nfunction curCSS( elem, name, computed ) {\n\tvar width, minWidth, maxWidth, ret,\n\n\t\t// Support: Firefox 51+\n\t\t// Retrieving style before computed somehow\n\t\t// fixes an issue with getting wrong values\n\t\t// on detached elements\n\t\tstyle = elem.style;\n\n\tcomputed = computed || getStyles( elem );\n\n\t// getPropertyValue is needed for:\n\t//   .css('filter') (IE 9 only, #12537)\n\t//   .css('--customProperty) (#3144)\n\tif ( computed ) {\n\t\tret = computed.getPropertyValue( name ) || computed[ name ];\n\n\t\tif ( ret === \"\" && !jQuery.contains( elem.ownerDocument, elem ) ) {\n\t\t\tret = jQuery.style( elem, name );\n\t\t}\n\n\t\t// A tribute to the \"awesome hack by Dean Edwards\"\n\t\t// Android Browser returns percentage for some values,\n\t\t// but width seems to be reliably pixels.\n\t\t// This is against the CSSOM draft spec:\n\t\t// https://drafts.csswg.org/cssom/#resolved-values\n\t\tif ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {\n\n\t\t\t// Remember the original values\n\t\t\twidth = style.width;\n\t\t\tminWidth = style.minWidth;\n\t\t\tmaxWidth = style.maxWidth;\n\n\t\t\t// Put in the new values to get a computed value out\n\t\t\tstyle.minWidth = style.maxWidth = style.width = ret;\n\t\t\tret = computed.width;\n\n\t\t\t// Revert the changed values\n\t\t\tstyle.width = width;\n\t\t\tstyle.minWidth = minWidth;\n\t\t\tstyle.maxWidth = maxWidth;\n\t\t}\n\t}\n\n\treturn ret !== undefined ?\n\n\t\t// Support: IE <=9 - 11 only\n\t\t// IE returns zIndex value as an integer.\n\t\tret + \"\" :\n\t\tret;\n}\n\n\nfunction addGetHookIf( conditionFn, hookFn ) {\n\n\t// Define the hook, we'll check on the first run if it's really needed.\n\treturn {\n\t\tget: function() {\n\t\t\tif ( conditionFn() ) {\n\n\t\t\t\t// Hook not needed (or it's not possible to use it due\n\t\t\t\t// to missing dependency), remove it.\n\t\t\t\tdelete this.get;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Hook needed; redefine it so that the support test is not executed again.\n\t\t\treturn ( this.get = hookFn ).apply( this, arguments );\n\t\t}\n\t};\n}\n\n\nvar\n\n\t// Swappable if display is none or starts with table\n\t// except \"table\", \"table-cell\", or \"table-caption\"\n\t// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\n\trdisplayswap = /^(none|table(?!-c[ea]).+)/,\n\trcustomProp = /^--/,\n\tcssShow = { position: \"absolute\", visibility: \"hidden\", display: \"block\" },\n\tcssNormalTransform = {\n\t\tletterSpacing: \"0\",\n\t\tfontWeight: \"400\"\n\t},\n\n\tcssPrefixes = [ \"Webkit\", \"Moz\", \"ms\" ],\n\temptyStyle = document.createElement( \"div\" ).style;\n\n// Return a css property mapped to a potentially vendor prefixed property\nfunction vendorPropName( name ) {\n\n\t// Shortcut for names that are not vendor prefixed\n\tif ( name in emptyStyle ) {\n\t\treturn name;\n\t}\n\n\t// Check for vendor prefixed names\n\tvar capName = name[ 0 ].toUpperCase() + name.slice( 1 ),\n\t\ti = cssPrefixes.length;\n\n\twhile ( i-- ) {\n\t\tname = cssPrefixes[ i ] + capName;\n\t\tif ( name in emptyStyle ) {\n\t\t\treturn name;\n\t\t}\n\t}\n}\n\n// Return a property mapped along what jQuery.cssProps suggests or to\n// a vendor prefixed property.\nfunction finalPropName( name ) {\n\tvar ret = jQuery.cssProps[ name ];\n\tif ( !ret ) {\n\t\tret = jQuery.cssProps[ name ] = vendorPropName( name ) || name;\n\t}\n\treturn ret;\n}\n\nfunction setPositiveNumber( elem, value, subtract ) {\n\n\t// Any relative (+/-) values have already been\n\t// normalized at this point\n\tvar matches = rcssNum.exec( value );\n\treturn matches ?\n\n\t\t// Guard against undefined \"subtract\", e.g., when used as in cssHooks\n\t\tMath.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || \"px\" ) :\n\t\tvalue;\n}\n\nfunction boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {\n\tvar i = dimension === \"width\" ? 1 : 0,\n\t\textra = 0,\n\t\tdelta = 0;\n\n\t// Adjustment may not be necessary\n\tif ( box === ( isBorderBox ? \"border\" : \"content\" ) ) {\n\t\treturn 0;\n\t}\n\n\tfor ( ; i < 4; i += 2 ) {\n\n\t\t// Both box models exclude margin\n\t\tif ( box === \"margin\" ) {\n\t\t\tdelta += jQuery.css( elem, box + cssExpand[ i ], true, styles );\n\t\t}\n\n\t\t// If we get here with a content-box, we're seeking \"padding\" or \"border\" or \"margin\"\n\t\tif ( !isBorderBox ) {\n\n\t\t\t// Add padding\n\t\t\tdelta += jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\n\t\t\t// For \"border\" or \"margin\", add border\n\t\t\tif ( box !== \"padding\" ) {\n\t\t\t\tdelta += jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\n\t\t\t// But still keep track of it otherwise\n\t\t\t} else {\n\t\t\t\textra += jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t}\n\n\t\t// If we get here with a border-box (content + padding + border), we're seeking \"content\" or\n\t\t// \"padding\" or \"margin\"\n\t\t} else {\n\n\t\t\t// For \"content\", subtract padding\n\t\t\tif ( box === \"content\" ) {\n\t\t\t\tdelta -= jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\t\t\t}\n\n\t\t\t// For \"content\" or \"padding\", subtract border\n\t\t\tif ( box !== \"margin\" ) {\n\t\t\t\tdelta -= jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t}\n\t\t}\n\t}\n\n\t// Account for positive content-box scroll gutter when requested by providing computedVal\n\tif ( !isBorderBox && computedVal >= 0 ) {\n\n\t\t// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border\n\t\t// Assuming integer scroll gutter, subtract the rest and round down\n\t\tdelta += Math.max( 0, Math.ceil(\n\t\t\telem[ \"offset\" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -\n\t\t\tcomputedVal -\n\t\t\tdelta -\n\t\t\textra -\n\t\t\t0.5\n\t\t) );\n\t}\n\n\treturn delta;\n}\n\nfunction getWidthOrHeight( elem, dimension, extra ) {\n\n\t// Start with computed style\n\tvar styles = getStyles( elem ),\n\t\tval = curCSS( elem, dimension, styles ),\n\t\tisBorderBox = jQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\",\n\t\tvalueIsBorderBox = isBorderBox;\n\n\t// Support: Firefox <=54\n\t// Return a confounding non-pixel value or feign ignorance, as appropriate.\n\tif ( rnumnonpx.test( val ) ) {\n\t\tif ( !extra ) {\n\t\t\treturn val;\n\t\t}\n\t\tval = \"auto\";\n\t}\n\n\t// Check for style in case a browser which returns unreliable values\n\t// for getComputedStyle silently falls back to the reliable elem.style\n\tvalueIsBorderBox = valueIsBorderBox &&\n\t\t( support.boxSizingReliable() || val === elem.style[ dimension ] );\n\n\t// Fall back to offsetWidth/offsetHeight when value is \"auto\"\n\t// This happens for inline elements with no explicit setting (gh-3571)\n\t// Support: Android <=4.1 - 4.3 only\n\t// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)\n\tif ( val === \"auto\" ||\n\t\t!parseFloat( val ) && jQuery.css( elem, \"display\", false, styles ) === \"inline\" ) {\n\n\t\tval = elem[ \"offset\" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ];\n\n\t\t// offsetWidth/offsetHeight provide border-box values\n\t\tvalueIsBorderBox = true;\n\t}\n\n\t// Normalize \"\" and auto\n\tval = parseFloat( val ) || 0;\n\n\t// Adjust for the element's box model\n\treturn ( val +\n\t\tboxModelAdjustment(\n\t\t\telem,\n\t\t\tdimension,\n\t\t\textra || ( isBorderBox ? \"border\" : \"content\" ),\n\t\t\tvalueIsBorderBox,\n\t\t\tstyles,\n\n\t\t\t// Provide the current computed size to request scroll gutter calculation (gh-3589)\n\t\t\tval\n\t\t)\n\t) + \"px\";\n}\n\njQuery.extend( {\n\n\t// Add in style property hooks for overriding the default\n\t// behavior of getting and setting a style property\n\tcssHooks: {\n\t\topacity: {\n\t\t\tget: function( elem, computed ) {\n\t\t\t\tif ( computed ) {\n\n\t\t\t\t\t// We should always get a number back from opacity\n\t\t\t\t\tvar ret = curCSS( elem, \"opacity\" );\n\t\t\t\t\treturn ret === \"\" ? \"1\" : ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t// Don't automatically add \"px\" to these possibly-unitless properties\n\tcssNumber: {\n\t\t\"animationIterationCount\": true,\n\t\t\"columnCount\": true,\n\t\t\"fillOpacity\": true,\n\t\t\"flexGrow\": true,\n\t\t\"flexShrink\": true,\n\t\t\"fontWeight\": true,\n\t\t\"lineHeight\": true,\n\t\t\"opacity\": true,\n\t\t\"order\": true,\n\t\t\"orphans\": true,\n\t\t\"widows\": true,\n\t\t\"zIndex\": true,\n\t\t\"zoom\": true\n\t},\n\n\t// Add in properties whose names you wish to fix before\n\t// setting or getting the value\n\tcssProps: {},\n\n\t// Get and set the style property on a DOM Node\n\tstyle: function( elem, name, value, extra ) {\n\n\t\t// Don't set styles on text and comment nodes\n\t\tif ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Make sure that we're working with the right name\n\t\tvar ret, type, hooks,\n\t\t\torigName = camelCase( name ),\n\t\t\tisCustomProp = rcustomProp.test( name ),\n\t\t\tstyle = elem.style;\n\n\t\t// Make sure that we're working with the right name. We don't\n\t\t// want to query the value if it is a CSS custom property\n\t\t// since they are user-defined.\n\t\tif ( !isCustomProp ) {\n\t\t\tname = finalPropName( origName );\n\t\t}\n\n\t\t// Gets hook for the prefixed version, then unprefixed version\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// Check if we're setting a value\n\t\tif ( value !== undefined ) {\n\t\t\ttype = typeof value;\n\n\t\t\t// Convert \"+=\" or \"-=\" to relative numbers (#7345)\n\t\t\tif ( type === \"string\" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {\n\t\t\t\tvalue = adjustCSS( elem, name, ret );\n\n\t\t\t\t// Fixes bug #9237\n\t\t\t\ttype = \"number\";\n\t\t\t}\n\n\t\t\t// Make sure that null and NaN values aren't set (#7116)\n\t\t\tif ( value == null || value !== value ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If a number was passed in, add the unit (except for certain CSS properties)\n\t\t\tif ( type === \"number\" ) {\n\t\t\t\tvalue += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? \"\" : \"px\" );\n\t\t\t}\n\n\t\t\t// background-* props affect original clone's values\n\t\t\tif ( !support.clearCloneStyle && value === \"\" && name.indexOf( \"background\" ) === 0 ) {\n\t\t\t\tstyle[ name ] = \"inherit\";\n\t\t\t}\n\n\t\t\t// If a hook was provided, use that value, otherwise just set the specified value\n\t\t\tif ( !hooks || !( \"set\" in hooks ) ||\n\t\t\t\t( value = hooks.set( elem, value, extra ) ) !== undefined ) {\n\n\t\t\t\tif ( isCustomProp ) {\n\t\t\t\t\tstyle.setProperty( name, value );\n\t\t\t\t} else {\n\t\t\t\t\tstyle[ name ] = value;\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// If a hook was provided get the non-computed value from there\n\t\t\tif ( hooks && \"get\" in hooks &&\n\t\t\t\t( ret = hooks.get( elem, false, extra ) ) !== undefined ) {\n\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t// Otherwise just get the value from the style object\n\t\t\treturn style[ name ];\n\t\t}\n\t},\n\n\tcss: function( elem, name, extra, styles ) {\n\t\tvar val, num, hooks,\n\t\t\torigName = camelCase( name ),\n\t\t\tisCustomProp = rcustomProp.test( name );\n\n\t\t// Make sure that we're working with the right name. We don't\n\t\t// want to modify the value if it is a CSS custom property\n\t\t// since they are user-defined.\n\t\tif ( !isCustomProp ) {\n\t\t\tname = finalPropName( origName );\n\t\t}\n\n\t\t// Try prefixed name followed by the unprefixed name\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// If a hook was provided get the computed value from there\n\t\tif ( hooks && \"get\" in hooks ) {\n\t\t\tval = hooks.get( elem, true, extra );\n\t\t}\n\n\t\t// Otherwise, if a way to get the computed value exists, use that\n\t\tif ( val === undefined ) {\n\t\t\tval = curCSS( elem, name, styles );\n\t\t}\n\n\t\t// Convert \"normal\" to computed value\n\t\tif ( val === \"normal\" && name in cssNormalTransform ) {\n\t\t\tval = cssNormalTransform[ name ];\n\t\t}\n\n\t\t// Make numeric if forced or a qualifier was provided and val looks numeric\n\t\tif ( extra === \"\" || extra ) {\n\t\t\tnum = parseFloat( val );\n\t\t\treturn extra === true || isFinite( num ) ? num || 0 : val;\n\t\t}\n\n\t\treturn val;\n\t}\n} );\n\njQuery.each( [ \"height\", \"width\" ], function( i, dimension ) {\n\tjQuery.cssHooks[ dimension ] = {\n\t\tget: function( elem, computed, extra ) {\n\t\t\tif ( computed ) {\n\n\t\t\t\t// Certain elements can have dimension info if we invisibly show them\n\t\t\t\t// but it must have a current display style that would benefit\n\t\t\t\treturn rdisplayswap.test( jQuery.css( elem, \"display\" ) ) &&\n\n\t\t\t\t\t// Support: Safari 8+\n\t\t\t\t\t// Table columns in Safari have non-zero offsetWidth & zero\n\t\t\t\t\t// getBoundingClientRect().width unless display is changed.\n\t\t\t\t\t// Support: IE <=11 only\n\t\t\t\t\t// Running getBoundingClientRect on a disconnected node\n\t\t\t\t\t// in IE throws an error.\n\t\t\t\t\t( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?\n\t\t\t\t\t\tswap( elem, cssShow, function() {\n\t\t\t\t\t\t\treturn getWidthOrHeight( elem, dimension, extra );\n\t\t\t\t\t\t} ) :\n\t\t\t\t\t\tgetWidthOrHeight( elem, dimension, extra );\n\t\t\t}\n\t\t},\n\n\t\tset: function( elem, value, extra ) {\n\t\t\tvar matches,\n\t\t\t\tstyles = getStyles( elem ),\n\t\t\t\tisBorderBox = jQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\",\n\t\t\t\tsubtract = extra && boxModelAdjustment(\n\t\t\t\t\telem,\n\t\t\t\t\tdimension,\n\t\t\t\t\textra,\n\t\t\t\t\tisBorderBox,\n\t\t\t\t\tstyles\n\t\t\t\t);\n\n\t\t\t// Account for unreliable border-box dimensions by comparing offset* to computed and\n\t\t\t// faking a content-box to get border and padding (gh-3699)\n\t\t\tif ( isBorderBox && support.scrollboxSize() === styles.position ) {\n\t\t\t\tsubtract -= Math.ceil(\n\t\t\t\t\telem[ \"offset\" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -\n\t\t\t\t\tparseFloat( styles[ dimension ] ) -\n\t\t\t\t\tboxModelAdjustment( elem, dimension, \"border\", false, styles ) -\n\t\t\t\t\t0.5\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Convert to pixels if value adjustment is needed\n\t\t\tif ( subtract && ( matches = rcssNum.exec( value ) ) &&\n\t\t\t\t( matches[ 3 ] || \"px\" ) !== \"px\" ) {\n\n\t\t\t\telem.style[ dimension ] = value;\n\t\t\t\tvalue = jQuery.css( elem, dimension );\n\t\t\t}\n\n\t\t\treturn setPositiveNumber( elem, value, subtract );\n\t\t}\n\t};\n} );\n\njQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,\n\tfunction( elem, computed ) {\n\t\tif ( computed ) {\n\t\t\treturn ( parseFloat( curCSS( elem, \"marginLeft\" ) ) ||\n\t\t\t\telem.getBoundingClientRect().left -\n\t\t\t\t\tswap( elem, { marginLeft: 0 }, function() {\n\t\t\t\t\t\treturn elem.getBoundingClientRect().left;\n\t\t\t\t\t} )\n\t\t\t\t) + \"px\";\n\t\t}\n\t}\n);\n\n// These hooks are used by animate to expand properties\njQuery.each( {\n\tmargin: \"\",\n\tpadding: \"\",\n\tborder: \"Width\"\n}, function( prefix, suffix ) {\n\tjQuery.cssHooks[ prefix + suffix ] = {\n\t\texpand: function( value ) {\n\t\t\tvar i = 0,\n\t\t\t\texpanded = {},\n\n\t\t\t\t// Assumes a single number if not a string\n\t\t\t\tparts = typeof value === \"string\" ? value.split( \" \" ) : [ value ];\n\n\t\t\tfor ( ; i < 4; i++ ) {\n\t\t\t\texpanded[ prefix + cssExpand[ i ] + suffix ] =\n\t\t\t\t\tparts[ i ] || parts[ i - 2 ] || parts[ 0 ];\n\t\t\t}\n\n\t\t\treturn expanded;\n\t\t}\n\t};\n\n\tif ( prefix !== \"margin\" ) {\n\t\tjQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;\n\t}\n} );\n\njQuery.fn.extend( {\n\tcss: function( name, value ) {\n\t\treturn access( this, function( elem, name, value ) {\n\t\t\tvar styles, len,\n\t\t\t\tmap = {},\n\t\t\t\ti = 0;\n\n\t\t\tif ( Array.isArray( name ) ) {\n\t\t\t\tstyles = getStyles( elem );\n\t\t\t\tlen = name.length;\n\n\t\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\t\tmap[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );\n\t\t\t\t}\n\n\t\t\t\treturn map;\n\t\t\t}\n\n\t\t\treturn value !== undefined ?\n\t\t\t\tjQuery.style( elem, name, value ) :\n\t\t\t\tjQuery.css( elem, name );\n\t\t}, name, value, arguments.length > 1 );\n\t}\n} );\n\n\nfunction Tween( elem, options, prop, end, easing ) {\n\treturn new Tween.prototype.init( elem, options, prop, end, easing );\n}\njQuery.Tween = Tween;\n\nTween.prototype = {\n\tconstructor: Tween,\n\tinit: function( elem, options, prop, end, easing, unit ) {\n\t\tthis.elem = elem;\n\t\tthis.prop = prop;\n\t\tthis.easing = easing || jQuery.easing._default;\n\t\tthis.options = options;\n\t\tthis.start = this.now = this.cur();\n\t\tthis.end = end;\n\t\tthis.unit = unit || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" );\n\t},\n\tcur: function() {\n\t\tvar hooks = Tween.propHooks[ this.prop ];\n\n\t\treturn hooks && hooks.get ?\n\t\t\thooks.get( this ) :\n\t\t\tTween.propHooks._default.get( this );\n\t},\n\trun: function( percent ) {\n\t\tvar eased,\n\t\t\thooks = Tween.propHooks[ this.prop ];\n\n\t\tif ( this.options.duration ) {\n\t\t\tthis.pos = eased = jQuery.easing[ this.easing ](\n\t\t\t\tpercent, this.options.duration * percent, 0, 1, this.options.duration\n\t\t\t);\n\t\t} else {\n\t\t\tthis.pos = eased = percent;\n\t\t}\n\t\tthis.now = ( this.end - this.start ) * eased + this.start;\n\n\t\tif ( this.options.step ) {\n\t\t\tthis.options.step.call( this.elem, this.now, this );\n\t\t}\n\n\t\tif ( hooks && hooks.set ) {\n\t\t\thooks.set( this );\n\t\t} else {\n\t\t\tTween.propHooks._default.set( this );\n\t\t}\n\t\treturn this;\n\t}\n};\n\nTween.prototype.init.prototype = Tween.prototype;\n\nTween.propHooks = {\n\t_default: {\n\t\tget: function( tween ) {\n\t\t\tvar result;\n\n\t\t\t// Use a property on the element directly when it is not a DOM element,\n\t\t\t// or when there is no matching style property that exists.\n\t\t\tif ( tween.elem.nodeType !== 1 ||\n\t\t\t\ttween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {\n\t\t\t\treturn tween.elem[ tween.prop ];\n\t\t\t}\n\n\t\t\t// Passing an empty string as a 3rd parameter to .css will automatically\n\t\t\t// attempt a parseFloat and fallback to a string if the parse fails.\n\t\t\t// Simple values such as \"10px\" are parsed to Float;\n\t\t\t// complex values such as \"rotate(1rad)\" are returned as-is.\n\t\t\tresult = jQuery.css( tween.elem, tween.prop, \"\" );\n\n\t\t\t// Empty strings, null, undefined and \"auto\" are converted to 0.\n\t\t\treturn !result || result === \"auto\" ? 0 : result;\n\t\t},\n\t\tset: function( tween ) {\n\n\t\t\t// Use step hook for back compat.\n\t\t\t// Use cssHook if its there.\n\t\t\t// Use .style if available and use plain properties where available.\n\t\t\tif ( jQuery.fx.step[ tween.prop ] ) {\n\t\t\t\tjQuery.fx.step[ tween.prop ]( tween );\n\t\t\t} else if ( tween.elem.nodeType === 1 &&\n\t\t\t\t( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||\n\t\t\t\t\tjQuery.cssHooks[ tween.prop ] ) ) {\n\t\t\t\tjQuery.style( tween.elem, tween.prop, tween.now + tween.unit );\n\t\t\t} else {\n\t\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t\t}\n\t\t}\n\t}\n};\n\n// Support: IE <=9 only\n// Panic based approach to setting things on disconnected nodes\nTween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n\tset: function( tween ) {\n\t\tif ( tween.elem.nodeType && tween.elem.parentNode ) {\n\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t}\n\t}\n};\n\njQuery.easing = {\n\tlinear: function( p ) {\n\t\treturn p;\n\t},\n\tswing: function( p ) {\n\t\treturn 0.5 - Math.cos( p * Math.PI ) / 2;\n\t},\n\t_default: \"swing\"\n};\n\njQuery.fx = Tween.prototype.init;\n\n// Back compat <1.8 extension point\njQuery.fx.step = {};\n\n\n\n\nvar\n\tfxNow, inProgress,\n\trfxtypes = /^(?:toggle|show|hide)$/,\n\trrun = /queueHooks$/;\n\nfunction schedule() {\n\tif ( inProgress ) {\n\t\tif ( document.hidden === false && window.requestAnimationFrame ) {\n\t\t\twindow.requestAnimationFrame( schedule );\n\t\t} else {\n\t\t\twindow.setTimeout( schedule, jQuery.fx.interval );\n\t\t}\n\n\t\tjQuery.fx.tick();\n\t}\n}\n\n// Animations created synchronously will run synchronously\nfunction createFxNow() {\n\twindow.setTimeout( function() {\n\t\tfxNow = undefined;\n\t} );\n\treturn ( fxNow = Date.now() );\n}\n\n// Generate parameters to create a standard animation\nfunction genFx( type, includeWidth ) {\n\tvar which,\n\t\ti = 0,\n\t\tattrs = { height: type };\n\n\t// If we include width, step value is 1 to do all cssExpand values,\n\t// otherwise step value is 2 to skip over Left and Right\n\tincludeWidth = includeWidth ? 1 : 0;\n\tfor ( ; i < 4; i += 2 - includeWidth ) {\n\t\twhich = cssExpand[ i ];\n\t\tattrs[ \"margin\" + which ] = attrs[ \"padding\" + which ] = type;\n\t}\n\n\tif ( includeWidth ) {\n\t\tattrs.opacity = attrs.width = type;\n\t}\n\n\treturn attrs;\n}\n\nfunction createTween( value, prop, animation ) {\n\tvar tween,\n\t\tcollection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ \"*\" ] ),\n\t\tindex = 0,\n\t\tlength = collection.length;\n\tfor ( ; index < length; index++ ) {\n\t\tif ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {\n\n\t\t\t// We're done with this property\n\t\t\treturn tween;\n\t\t}\n\t}\n}\n\nfunction defaultPrefilter( elem, props, opts ) {\n\tvar prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,\n\t\tisBox = \"width\" in props || \"height\" in props,\n\t\tanim = this,\n\t\torig = {},\n\t\tstyle = elem.style,\n\t\thidden = elem.nodeType && isHiddenWithinTree( elem ),\n\t\tdataShow = dataPriv.get( elem, \"fxshow\" );\n\n\t// Queue-skipping animations hijack the fx hooks\n\tif ( !opts.queue ) {\n\t\thooks = jQuery._queueHooks( elem, \"fx\" );\n\t\tif ( hooks.unqueued == null ) {\n\t\t\thooks.unqueued = 0;\n\t\t\toldfire = hooks.empty.fire;\n\t\t\thooks.empty.fire = function() {\n\t\t\t\tif ( !hooks.unqueued ) {\n\t\t\t\t\toldfire();\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\thooks.unqueued++;\n\n\t\tanim.always( function() {\n\n\t\t\t// Ensure the complete handler is called before this completes\n\t\t\tanim.always( function() {\n\t\t\t\thooks.unqueued--;\n\t\t\t\tif ( !jQuery.queue( elem, \"fx\" ).length ) {\n\t\t\t\t\thooks.empty.fire();\n\t\t\t\t}\n\t\t\t} );\n\t\t} );\n\t}\n\n\t// Detect show/hide animations\n\tfor ( prop in props ) {\n\t\tvalue = props[ prop ];\n\t\tif ( rfxtypes.test( value ) ) {\n\t\t\tdelete props[ prop ];\n\t\t\ttoggle = toggle || value === \"toggle\";\n\t\t\tif ( value === ( hidden ? \"hide\" : \"show\" ) ) {\n\n\t\t\t\t// Pretend to be hidden if this is a \"show\" and\n\t\t\t\t// there is still data from a stopped show/hide\n\t\t\t\tif ( value === \"show\" && dataShow && dataShow[ prop ] !== undefined ) {\n\t\t\t\t\thidden = true;\n\n\t\t\t\t// Ignore all other no-op show/hide data\n\t\t\t\t} else {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\torig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );\n\t\t}\n\t}\n\n\t// Bail out if this is a no-op like .hide().hide()\n\tpropTween = !jQuery.isEmptyObject( props );\n\tif ( !propTween && jQuery.isEmptyObject( orig ) ) {\n\t\treturn;\n\t}\n\n\t// Restrict \"overflow\" and \"display\" styles during box animations\n\tif ( isBox && elem.nodeType === 1 ) {\n\n\t\t// Support: IE <=9 - 11, Edge 12 - 15\n\t\t// Record all 3 overflow attributes because IE does not infer the shorthand\n\t\t// from identically-valued overflowX and overflowY and Edge just mirrors\n\t\t// the overflowX value there.\n\t\topts.overflow = [ style.overflow, style.overflowX, style.overflowY ];\n\n\t\t// Identify a display type, preferring old show/hide data over the CSS cascade\n\t\trestoreDisplay = dataShow && dataShow.display;\n\t\tif ( restoreDisplay == null ) {\n\t\t\trestoreDisplay = dataPriv.get( elem, \"display\" );\n\t\t}\n\t\tdisplay = jQuery.css( elem, \"display\" );\n\t\tif ( display === \"none\" ) {\n\t\t\tif ( restoreDisplay ) {\n\t\t\t\tdisplay = restoreDisplay;\n\t\t\t} else {\n\n\t\t\t\t// Get nonempty value(s) by temporarily forcing visibility\n\t\t\t\tshowHide( [ elem ], true );\n\t\t\t\trestoreDisplay = elem.style.display || restoreDisplay;\n\t\t\t\tdisplay = jQuery.css( elem, \"display\" );\n\t\t\t\tshowHide( [ elem ] );\n\t\t\t}\n\t\t}\n\n\t\t// Animate inline elements as inline-block\n\t\tif ( display === \"inline\" || display === \"inline-block\" && restoreDisplay != null ) {\n\t\t\tif ( jQuery.css( elem, \"float\" ) === \"none\" ) {\n\n\t\t\t\t// Restore the original display value at the end of pure show/hide animations\n\t\t\t\tif ( !propTween ) {\n\t\t\t\t\tanim.done( function() {\n\t\t\t\t\t\tstyle.display = restoreDisplay;\n\t\t\t\t\t} );\n\t\t\t\t\tif ( restoreDisplay == null ) {\n\t\t\t\t\t\tdisplay = style.display;\n\t\t\t\t\t\trestoreDisplay = display === \"none\" ? \"\" : display;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstyle.display = \"inline-block\";\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( opts.overflow ) {\n\t\tstyle.overflow = \"hidden\";\n\t\tanim.always( function() {\n\t\t\tstyle.overflow = opts.overflow[ 0 ];\n\t\t\tstyle.overflowX = opts.overflow[ 1 ];\n\t\t\tstyle.overflowY = opts.overflow[ 2 ];\n\t\t} );\n\t}\n\n\t// Implement show/hide animations\n\tpropTween = false;\n\tfor ( prop in orig ) {\n\n\t\t// General show/hide setup for this element animation\n\t\tif ( !propTween ) {\n\t\t\tif ( dataShow ) {\n\t\t\t\tif ( \"hidden\" in dataShow ) {\n\t\t\t\t\thidden = dataShow.hidden;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdataShow = dataPriv.access( elem, \"fxshow\", { display: restoreDisplay } );\n\t\t\t}\n\n\t\t\t// Store hidden/visible for toggle so `.stop().toggle()` \"reverses\"\n\t\t\tif ( toggle ) {\n\t\t\t\tdataShow.hidden = !hidden;\n\t\t\t}\n\n\t\t\t// Show elements before animating them\n\t\t\tif ( hidden ) {\n\t\t\t\tshowHide( [ elem ], true );\n\t\t\t}\n\n\t\t\t/* eslint-disable no-loop-func */\n\n\t\t\tanim.done( function() {\n\n\t\t\t/* eslint-enable no-loop-func */\n\n\t\t\t\t// The final step of a \"hide\" animation is actually hiding the element\n\t\t\t\tif ( !hidden ) {\n\t\t\t\t\tshowHide( [ elem ] );\n\t\t\t\t}\n\t\t\t\tdataPriv.remove( elem, \"fxshow\" );\n\t\t\t\tfor ( prop in orig ) {\n\t\t\t\t\tjQuery.style( elem, prop, orig[ prop ] );\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\n\t\t// Per-property setup\n\t\tpropTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );\n\t\tif ( !( prop in dataShow ) ) {\n\t\t\tdataShow[ prop ] = propTween.start;\n\t\t\tif ( hidden ) {\n\t\t\t\tpropTween.end = propTween.start;\n\t\t\t\tpropTween.start = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction propFilter( props, specialEasing ) {\n\tvar index, name, easing, value, hooks;\n\n\t// camelCase, specialEasing and expand cssHook pass\n\tfor ( index in props ) {\n\t\tname = camelCase( index );\n\t\teasing = specialEasing[ name ];\n\t\tvalue = props[ index ];\n\t\tif ( Array.isArray( value ) ) {\n\t\t\teasing = value[ 1 ];\n\t\t\tvalue = props[ index ] = value[ 0 ];\n\t\t}\n\n\t\tif ( index !== name ) {\n\t\t\tprops[ name ] = value;\n\t\t\tdelete props[ index ];\n\t\t}\n\n\t\thooks = jQuery.cssHooks[ name ];\n\t\tif ( hooks && \"expand\" in hooks ) {\n\t\t\tvalue = hooks.expand( value );\n\t\t\tdelete props[ name ];\n\n\t\t\t// Not quite $.extend, this won't overwrite existing keys.\n\t\t\t// Reusing 'index' because we have the correct \"name\"\n\t\t\tfor ( index in value ) {\n\t\t\t\tif ( !( index in props ) ) {\n\t\t\t\t\tprops[ index ] = value[ index ];\n\t\t\t\t\tspecialEasing[ index ] = easing;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tspecialEasing[ name ] = easing;\n\t\t}\n\t}\n}\n\nfunction Animation( elem, properties, options ) {\n\tvar result,\n\t\tstopped,\n\t\tindex = 0,\n\t\tlength = Animation.prefilters.length,\n\t\tdeferred = jQuery.Deferred().always( function() {\n\n\t\t\t// Don't match elem in the :animated selector\n\t\t\tdelete tick.elem;\n\t\t} ),\n\t\ttick = function() {\n\t\t\tif ( stopped ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar currentTime = fxNow || createFxNow(),\n\t\t\t\tremaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),\n\n\t\t\t\t// Support: Android 2.3 only\n\t\t\t\t// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)\n\t\t\t\ttemp = remaining / animation.duration || 0,\n\t\t\t\tpercent = 1 - temp,\n\t\t\t\tindex = 0,\n\t\t\t\tlength = animation.tweens.length;\n\n\t\t\tfor ( ; index < length; index++ ) {\n\t\t\t\tanimation.tweens[ index ].run( percent );\n\t\t\t}\n\n\t\t\tdeferred.notifyWith( elem, [ animation, percent, remaining ] );\n\n\t\t\t// If there's more to do, yield\n\t\t\tif ( percent < 1 && length ) {\n\t\t\t\treturn remaining;\n\t\t\t}\n\n\t\t\t// If this was an empty animation, synthesize a final progress notification\n\t\t\tif ( !length ) {\n\t\t\t\tdeferred.notifyWith( elem, [ animation, 1, 0 ] );\n\t\t\t}\n\n\t\t\t// Resolve the animation and report its conclusion\n\t\t\tdeferred.resolveWith( elem, [ animation ] );\n\t\t\treturn false;\n\t\t},\n\t\tanimation = deferred.promise( {\n\t\t\telem: elem,\n\t\t\tprops: jQuery.extend( {}, properties ),\n\t\t\topts: jQuery.extend( true, {\n\t\t\t\tspecialEasing: {},\n\t\t\t\teasing: jQuery.easing._default\n\t\t\t}, options ),\n\t\t\toriginalProperties: properties,\n\t\t\toriginalOptions: options,\n\t\t\tstartTime: fxNow || createFxNow(),\n\t\t\tduration: options.duration,\n\t\t\ttweens: [],\n\t\t\tcreateTween: function( prop, end ) {\n\t\t\t\tvar tween = jQuery.Tween( elem, animation.opts, prop, end,\n\t\t\t\t\t\tanimation.opts.specialEasing[ prop ] || animation.opts.easing );\n\t\t\t\tanimation.tweens.push( tween );\n\t\t\t\treturn tween;\n\t\t\t},\n\t\t\tstop: function( gotoEnd ) {\n\t\t\t\tvar index = 0,\n\n\t\t\t\t\t// If we are going to the end, we want to run all the tweens\n\t\t\t\t\t// otherwise we skip this part\n\t\t\t\t\tlength = gotoEnd ? animation.tweens.length : 0;\n\t\t\t\tif ( stopped ) {\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t\tstopped = true;\n\t\t\t\tfor ( ; index < length; index++ ) {\n\t\t\t\t\tanimation.tweens[ index ].run( 1 );\n\t\t\t\t}\n\n\t\t\t\t// Resolve when we played the last frame; otherwise, reject\n\t\t\t\tif ( gotoEnd ) {\n\t\t\t\t\tdeferred.notifyWith( elem, [ animation, 1, 0 ] );\n\t\t\t\t\tdeferred.resolveWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t} else {\n\t\t\t\t\tdeferred.rejectWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\t\t} ),\n\t\tprops = animation.props;\n\n\tpropFilter( props, animation.opts.specialEasing );\n\n\tfor ( ; index < length; index++ ) {\n\t\tresult = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );\n\t\tif ( result ) {\n\t\t\tif ( isFunction( result.stop ) ) {\n\t\t\t\tjQuery._queueHooks( animation.elem, animation.opts.queue ).stop =\n\t\t\t\t\tresult.stop.bind( result );\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tjQuery.map( props, createTween, animation );\n\n\tif ( isFunction( animation.opts.start ) ) {\n\t\tanimation.opts.start.call( elem, animation );\n\t}\n\n\t// Attach callbacks from options\n\tanimation\n\t\t.progress( animation.opts.progress )\n\t\t.done( animation.opts.done, animation.opts.complete )\n\t\t.fail( animation.opts.fail )\n\t\t.always( animation.opts.always );\n\n\tjQuery.fx.timer(\n\t\tjQuery.extend( tick, {\n\t\t\telem: elem,\n\t\t\tanim: animation,\n\t\t\tqueue: animation.opts.queue\n\t\t} )\n\t);\n\n\treturn animation;\n}\n\njQuery.Animation = jQuery.extend( Animation, {\n\n\ttweeners: {\n\t\t\"*\": [ function( prop, value ) {\n\t\t\tvar tween = this.createTween( prop, value );\n\t\t\tadjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );\n\t\t\treturn tween;\n\t\t} ]\n\t},\n\n\ttweener: function( props, callback ) {\n\t\tif ( isFunction( props ) ) {\n\t\t\tcallback = props;\n\t\t\tprops = [ \"*\" ];\n\t\t} else {\n\t\t\tprops = props.match( rnothtmlwhite );\n\t\t}\n\n\t\tvar prop,\n\t\t\tindex = 0,\n\t\t\tlength = props.length;\n\n\t\tfor ( ; index < length; index++ ) {\n\t\t\tprop = props[ index ];\n\t\t\tAnimation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];\n\t\t\tAnimation.tweeners[ prop ].unshift( callback );\n\t\t}\n\t},\n\n\tprefilters: [ defaultPrefilter ],\n\n\tprefilter: function( callback, prepend ) {\n\t\tif ( prepend ) {\n\t\t\tAnimation.prefilters.unshift( callback );\n\t\t} else {\n\t\t\tAnimation.prefilters.push( callback );\n\t\t}\n\t}\n} );\n\njQuery.speed = function( speed, easing, fn ) {\n\tvar opt = speed && typeof speed === \"object\" ? jQuery.extend( {}, speed ) : {\n\t\tcomplete: fn || !fn && easing ||\n\t\t\tisFunction( speed ) && speed,\n\t\tduration: speed,\n\t\teasing: fn && easing || easing && !isFunction( easing ) && easing\n\t};\n\n\t// Go to the end state if fx are off\n\tif ( jQuery.fx.off ) {\n\t\topt.duration = 0;\n\n\t} else {\n\t\tif ( typeof opt.duration !== \"number\" ) {\n\t\t\tif ( opt.duration in jQuery.fx.speeds ) {\n\t\t\t\topt.duration = jQuery.fx.speeds[ opt.duration ];\n\n\t\t\t} else {\n\t\t\t\topt.duration = jQuery.fx.speeds._default;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Normalize opt.queue - true/undefined/null -> \"fx\"\n\tif ( opt.queue == null || opt.queue === true ) {\n\t\topt.queue = \"fx\";\n\t}\n\n\t// Queueing\n\topt.old = opt.complete;\n\n\topt.complete = function() {\n\t\tif ( isFunction( opt.old ) ) {\n\t\t\topt.old.call( this );\n\t\t}\n\n\t\tif ( opt.queue ) {\n\t\t\tjQuery.dequeue( this, opt.queue );\n\t\t}\n\t};\n\n\treturn opt;\n};\n\njQuery.fn.extend( {\n\tfadeTo: function( speed, to, easing, callback ) {\n\n\t\t// Show any hidden elements after setting opacity to 0\n\t\treturn this.filter( isHiddenWithinTree ).css( \"opacity\", 0 ).show()\n\n\t\t\t// Animate to the value specified\n\t\t\t.end().animate( { opacity: to }, speed, easing, callback );\n\t},\n\tanimate: function( prop, speed, easing, callback ) {\n\t\tvar empty = jQuery.isEmptyObject( prop ),\n\t\t\toptall = jQuery.speed( speed, easing, callback ),\n\t\t\tdoAnimation = function() {\n\n\t\t\t\t// Operate on a copy of prop so per-property easing won't be lost\n\t\t\t\tvar anim = Animation( this, jQuery.extend( {}, prop ), optall );\n\n\t\t\t\t// Empty animations, or finishing resolves immediately\n\t\t\t\tif ( empty || dataPriv.get( this, \"finish\" ) ) {\n\t\t\t\t\tanim.stop( true );\n\t\t\t\t}\n\t\t\t};\n\t\t\tdoAnimation.finish = doAnimation;\n\n\t\treturn empty || optall.queue === false ?\n\t\t\tthis.each( doAnimation ) :\n\t\t\tthis.queue( optall.queue, doAnimation );\n\t},\n\tstop: function( type, clearQueue, gotoEnd ) {\n\t\tvar stopQueue = function( hooks ) {\n\t\t\tvar stop = hooks.stop;\n\t\t\tdelete hooks.stop;\n\t\t\tstop( gotoEnd );\n\t\t};\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tgotoEnd = clearQueue;\n\t\t\tclearQueue = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\tif ( clearQueue && type !== false ) {\n\t\t\tthis.queue( type || \"fx\", [] );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar dequeue = true,\n\t\t\t\tindex = type != null && type + \"queueHooks\",\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tdata = dataPriv.get( this );\n\n\t\t\tif ( index ) {\n\t\t\t\tif ( data[ index ] && data[ index ].stop ) {\n\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( index in data ) {\n\t\t\t\t\tif ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {\n\t\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this &&\n\t\t\t\t\t( type == null || timers[ index ].queue === type ) ) {\n\n\t\t\t\t\ttimers[ index ].anim.stop( gotoEnd );\n\t\t\t\t\tdequeue = false;\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Start the next in the queue if the last step wasn't forced.\n\t\t\t// Timers currently will call their complete callbacks, which\n\t\t\t// will dequeue but only if they were gotoEnd.\n\t\t\tif ( dequeue || !gotoEnd ) {\n\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t}\n\t\t} );\n\t},\n\tfinish: function( type ) {\n\t\tif ( type !== false ) {\n\t\t\ttype = type || \"fx\";\n\t\t}\n\t\treturn this.each( function() {\n\t\t\tvar index,\n\t\t\t\tdata = dataPriv.get( this ),\n\t\t\t\tqueue = data[ type + \"queue\" ],\n\t\t\t\thooks = data[ type + \"queueHooks\" ],\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tlength = queue ? queue.length : 0;\n\n\t\t\t// Enable finishing flag on private data\n\t\t\tdata.finish = true;\n\n\t\t\t// Empty the queue first\n\t\t\tjQuery.queue( this, type, [] );\n\n\t\t\tif ( hooks && hooks.stop ) {\n\t\t\t\thooks.stop.call( this, true );\n\t\t\t}\n\n\t\t\t// Look for any active animations, and finish them\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this && timers[ index ].queue === type ) {\n\t\t\t\t\ttimers[ index ].anim.stop( true );\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Look for any animations in the old queue and finish them\n\t\t\tfor ( index = 0; index < length; index++ ) {\n\t\t\t\tif ( queue[ index ] && queue[ index ].finish ) {\n\t\t\t\t\tqueue[ index ].finish.call( this );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Turn off finishing flag\n\t\t\tdelete data.finish;\n\t\t} );\n\t}\n} );\n\njQuery.each( [ \"toggle\", \"show\", \"hide\" ], function( i, name ) {\n\tvar cssFn = jQuery.fn[ name ];\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn speed == null || typeof speed === \"boolean\" ?\n\t\t\tcssFn.apply( this, arguments ) :\n\t\t\tthis.animate( genFx( name, true ), speed, easing, callback );\n\t};\n} );\n\n// Generate shortcuts for custom animations\njQuery.each( {\n\tslideDown: genFx( \"show\" ),\n\tslideUp: genFx( \"hide\" ),\n\tslideToggle: genFx( \"toggle\" ),\n\tfadeIn: { opacity: \"show\" },\n\tfadeOut: { opacity: \"hide\" },\n\tfadeToggle: { opacity: \"toggle\" }\n}, function( name, props ) {\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn this.animate( props, speed, easing, callback );\n\t};\n} );\n\njQuery.timers = [];\njQuery.fx.tick = function() {\n\tvar timer,\n\t\ti = 0,\n\t\ttimers = jQuery.timers;\n\n\tfxNow = Date.now();\n\n\tfor ( ; i < timers.length; i++ ) {\n\t\ttimer = timers[ i ];\n\n\t\t// Run the timer and safely remove it when done (allowing for external removal)\n\t\tif ( !timer() && timers[ i ] === timer ) {\n\t\t\ttimers.splice( i--, 1 );\n\t\t}\n\t}\n\n\tif ( !timers.length ) {\n\t\tjQuery.fx.stop();\n\t}\n\tfxNow = undefined;\n};\n\njQuery.fx.timer = function( timer ) {\n\tjQuery.timers.push( timer );\n\tjQuery.fx.start();\n};\n\njQuery.fx.interval = 13;\njQuery.fx.start = function() {\n\tif ( inProgress ) {\n\t\treturn;\n\t}\n\n\tinProgress = true;\n\tschedule();\n};\n\njQuery.fx.stop = function() {\n\tinProgress = null;\n};\n\njQuery.fx.speeds = {\n\tslow: 600,\n\tfast: 200,\n\n\t// Default speed\n\t_default: 400\n};\n\n\n// Based off of the plugin by Clint Helfers, with permission.\n// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/\njQuery.fn.delay = function( time, type ) {\n\ttime = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;\n\ttype = type || \"fx\";\n\n\treturn this.queue( type, function( next, hooks ) {\n\t\tvar timeout = window.setTimeout( next, time );\n\t\thooks.stop = function() {\n\t\t\twindow.clearTimeout( timeout );\n\t\t};\n\t} );\n};\n\n\n( function() {\n\tvar input = document.createElement( \"input\" ),\n\t\tselect = document.createElement( \"select\" ),\n\t\topt = select.appendChild( document.createElement( \"option\" ) );\n\n\tinput.type = \"checkbox\";\n\n\t// Support: Android <=4.3 only\n\t// Default value for a checkbox should be \"on\"\n\tsupport.checkOn = input.value !== \"\";\n\n\t// Support: IE <=11 only\n\t// Must access selectedIndex to make default options select\n\tsupport.optSelected = opt.selected;\n\n\t// Support: IE <=11 only\n\t// An input loses its value after becoming a radio\n\tinput = document.createElement( \"input\" );\n\tinput.value = \"t\";\n\tinput.type = \"radio\";\n\tsupport.radioValue = input.value === \"t\";\n} )();\n\n\nvar boolHook,\n\tattrHandle = jQuery.expr.attrHandle;\n\njQuery.fn.extend( {\n\tattr: function( name, value ) {\n\t\treturn access( this, jQuery.attr, name, value, arguments.length > 1 );\n\t},\n\n\tremoveAttr: function( name ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.removeAttr( this, name );\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tattr: function( elem, name, value ) {\n\t\tvar ret, hooks,\n\t\t\tnType = elem.nodeType;\n\n\t\t// Don't get/set attributes on text, comment and attribute nodes\n\t\tif ( nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Fallback to prop when attributes are not supported\n\t\tif ( typeof elem.getAttribute === \"undefined\" ) {\n\t\t\treturn jQuery.prop( elem, name, value );\n\t\t}\n\n\t\t// Attribute hooks are determined by the lowercase version\n\t\t// Grab necessary hook if one is defined\n\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n\t\t\thooks = jQuery.attrHooks[ name.toLowerCase() ] ||\n\t\t\t\t( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\t\t\tif ( value === null ) {\n\t\t\t\tjQuery.removeAttr( elem, name );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( hooks && \"set\" in hooks &&\n\t\t\t\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\telem.setAttribute( name, value + \"\" );\n\t\t\treturn value;\n\t\t}\n\n\t\tif ( hooks && \"get\" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = jQuery.find.attr( elem, name );\n\n\t\t// Non-existent attributes return null, we normalize to undefined\n\t\treturn ret == null ? undefined : ret;\n\t},\n\n\tattrHooks: {\n\t\ttype: {\n\t\t\tset: function( elem, value ) {\n\t\t\t\tif ( !support.radioValue && value === \"radio\" &&\n\t\t\t\t\tnodeName( elem, \"input\" ) ) {\n\t\t\t\t\tvar val = elem.value;\n\t\t\t\t\telem.setAttribute( \"type\", value );\n\t\t\t\t\tif ( val ) {\n\t\t\t\t\t\telem.value = val;\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tremoveAttr: function( elem, value ) {\n\t\tvar name,\n\t\t\ti = 0,\n\n\t\t\t// Attribute names can contain non-HTML whitespace characters\n\t\t\t// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n\t\t\tattrNames = value && value.match( rnothtmlwhite );\n\n\t\tif ( attrNames && elem.nodeType === 1 ) {\n\t\t\twhile ( ( name = attrNames[ i++ ] ) ) {\n\t\t\t\telem.removeAttribute( name );\n\t\t\t}\n\t\t}\n\t}\n} );\n\n// Hooks for boolean attributes\nboolHook = {\n\tset: function( elem, value, name ) {\n\t\tif ( value === false ) {\n\n\t\t\t// Remove boolean attributes when set to false\n\t\t\tjQuery.removeAttr( elem, name );\n\t\t} else {\n\t\t\telem.setAttribute( name, name );\n\t\t}\n\t\treturn name;\n\t}\n};\n\njQuery.each( jQuery.expr.match.bool.source.match( /\\w+/g ), function( i, name ) {\n\tvar getter = attrHandle[ name ] || jQuery.find.attr;\n\n\tattrHandle[ name ] = function( elem, name, isXML ) {\n\t\tvar ret, handle,\n\t\t\tlowercaseName = name.toLowerCase();\n\n\t\tif ( !isXML ) {\n\n\t\t\t// Avoid an infinite loop by temporarily removing this function from the getter\n\t\t\thandle = attrHandle[ lowercaseName ];\n\t\t\tattrHandle[ lowercaseName ] = ret;\n\t\t\tret = getter( elem, name, isXML ) != null ?\n\t\t\t\tlowercaseName :\n\t\t\t\tnull;\n\t\t\tattrHandle[ lowercaseName ] = handle;\n\t\t}\n\t\treturn ret;\n\t};\n} );\n\n\n\n\nvar rfocusable = /^(?:input|select|textarea|button)$/i,\n\trclickable = /^(?:a|area)$/i;\n\njQuery.fn.extend( {\n\tprop: function( name, value ) {\n\t\treturn access( this, jQuery.prop, name, value, arguments.length > 1 );\n\t},\n\n\tremoveProp: function( name ) {\n\t\treturn this.each( function() {\n\t\t\tdelete this[ jQuery.propFix[ name ] || name ];\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tprop: function( elem, name, value ) {\n\t\tvar ret, hooks,\n\t\t\tnType = elem.nodeType;\n\n\t\t// Don't get/set properties on text, comment and attribute nodes\n\t\tif ( nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n\n\t\t\t// Fix name and attach hooks\n\t\t\tname = jQuery.propFix[ name ] || name;\n\t\t\thooks = jQuery.propHooks[ name ];\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\t\t\tif ( hooks && \"set\" in hooks &&\n\t\t\t\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\treturn ( elem[ name ] = value );\n\t\t}\n\n\t\tif ( hooks && \"get\" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\n\t\t\treturn ret;\n\t\t}\n\n\t\treturn elem[ name ];\n\t},\n\n\tpropHooks: {\n\t\ttabIndex: {\n\t\t\tget: function( elem ) {\n\n\t\t\t\t// Support: IE <=9 - 11 only\n\t\t\t\t// elem.tabIndex doesn't always return the\n\t\t\t\t// correct value when it hasn't been explicitly set\n\t\t\t\t// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/\n\t\t\t\t// Use proper attribute retrieval(#12072)\n\t\t\t\tvar tabindex = jQuery.find.attr( elem, \"tabindex\" );\n\n\t\t\t\tif ( tabindex ) {\n\t\t\t\t\treturn parseInt( tabindex, 10 );\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\trfocusable.test( elem.nodeName ) ||\n\t\t\t\t\trclickable.test( elem.nodeName ) &&\n\t\t\t\t\telem.href\n\t\t\t\t) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t},\n\n\tpropFix: {\n\t\t\"for\": \"htmlFor\",\n\t\t\"class\": \"className\"\n\t}\n} );\n\n// Support: IE <=11 only\n// Accessing the selectedIndex property\n// forces the browser to respect setting selected\n// on the option\n// The getter ensures a default option is selected\n// when in an optgroup\n// eslint rule \"no-unused-expressions\" is disabled for this code\n// since it considers such accessions noop\nif ( !support.optSelected ) {\n\tjQuery.propHooks.selected = {\n\t\tget: function( elem ) {\n\n\t\t\t/* eslint no-unused-expressions: \"off\" */\n\n\t\t\tvar parent = elem.parentNode;\n\t\t\tif ( parent && parent.parentNode ) {\n\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\t\tset: function( elem ) {\n\n\t\t\t/* eslint no-unused-expressions: \"off\" */\n\n\t\t\tvar parent = elem.parentNode;\n\t\t\tif ( parent ) {\n\t\t\t\tparent.selectedIndex;\n\n\t\t\t\tif ( parent.parentNode ) {\n\t\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\njQuery.each( [\n\t\"tabIndex\",\n\t\"readOnly\",\n\t\"maxLength\",\n\t\"cellSpacing\",\n\t\"cellPadding\",\n\t\"rowSpan\",\n\t\"colSpan\",\n\t\"useMap\",\n\t\"frameBorder\",\n\t\"contentEditable\"\n], function() {\n\tjQuery.propFix[ this.toLowerCase() ] = this;\n} );\n\n\n\n\n\t// Strip and collapse whitespace according to HTML spec\n\t// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace\n\tfunction stripAndCollapse( value ) {\n\t\tvar tokens = value.match( rnothtmlwhite ) || [];\n\t\treturn tokens.join( \" \" );\n\t}\n\n\nfunction getClass( elem ) {\n\treturn elem.getAttribute && elem.getAttribute( \"class\" ) || \"\";\n}\n\nfunction classesToArray( value ) {\n\tif ( Array.isArray( value ) ) {\n\t\treturn value;\n\t}\n\tif ( typeof value === \"string\" ) {\n\t\treturn value.match( rnothtmlwhite ) || [];\n\t}\n\treturn [];\n}\n\njQuery.fn.extend( {\n\taddClass: function( value ) {\n\t\tvar classes, elem, cur, curValue, clazz, j, finalValue,\n\t\t\ti = 0;\n\n\t\tif ( isFunction( value ) ) {\n\t\t\treturn this.each( function( j ) {\n\t\t\t\tjQuery( this ).addClass( value.call( this, j, getClass( this ) ) );\n\t\t\t} );\n\t\t}\n\n\t\tclasses = classesToArray( value );\n\n\t\tif ( classes.length ) {\n\t\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\t\tcurValue = getClass( elem );\n\t\t\t\tcur = elem.nodeType === 1 && ( \" \" + stripAndCollapse( curValue ) + \" \" );\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( ( clazz = classes[ j++ ] ) ) {\n\t\t\t\t\t\tif ( cur.indexOf( \" \" + clazz + \" \" ) < 0 ) {\n\t\t\t\t\t\t\tcur += clazz + \" \";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Only assign if different to avoid unneeded rendering.\n\t\t\t\t\tfinalValue = stripAndCollapse( cur );\n\t\t\t\t\tif ( curValue !== finalValue ) {\n\t\t\t\t\t\telem.setAttribute( \"class\", finalValue );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tremoveClass: function( value ) {\n\t\tvar classes, elem, cur, curValue, clazz, j, finalValue,\n\t\t\ti = 0;\n\n\t\tif ( isFunction( value ) ) {\n\t\t\treturn this.each( function( j ) {\n\t\t\t\tjQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );\n\t\t\t} );\n\t\t}\n\n\t\tif ( !arguments.length ) {\n\t\t\treturn this.attr( \"class\", \"\" );\n\t\t}\n\n\t\tclasses = classesToArray( value );\n\n\t\tif ( classes.length ) {\n\t\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\t\tcurValue = getClass( elem );\n\n\t\t\t\t// This expression is here for better compressibility (see addClass)\n\t\t\t\tcur = elem.nodeType === 1 && ( \" \" + stripAndCollapse( curValue ) + \" \" );\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( ( clazz = classes[ j++ ] ) ) {\n\n\t\t\t\t\t\t// Remove *all* instances\n\t\t\t\t\t\twhile ( cur.indexOf( \" \" + clazz + \" \" ) > -1 ) {\n\t\t\t\t\t\t\tcur = cur.replace( \" \" + clazz + \" \", \" \" );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Only assign if different to avoid unneeded rendering.\n\t\t\t\t\tfinalValue = stripAndCollapse( cur );\n\t\t\t\t\tif ( curValue !== finalValue ) {\n\t\t\t\t\t\telem.setAttribute( \"class\", finalValue );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\ttoggleClass: function( value, stateVal ) {\n\t\tvar type = typeof value,\n\t\t\tisValidValue = type === \"string\" || Array.isArray( value );\n\n\t\tif ( typeof stateVal === \"boolean\" && isValidValue ) {\n\t\t\treturn stateVal ? this.addClass( value ) : this.removeClass( value );\n\t\t}\n\n\t\tif ( isFunction( value ) ) {\n\t\t\treturn this.each( function( i ) {\n\t\t\t\tjQuery( this ).toggleClass(\n\t\t\t\t\tvalue.call( this, i, getClass( this ), stateVal ),\n\t\t\t\t\tstateVal\n\t\t\t\t);\n\t\t\t} );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar className, i, self, classNames;\n\n\t\t\tif ( isValidValue ) {\n\n\t\t\t\t// Toggle individual class names\n\t\t\t\ti = 0;\n\t\t\t\tself = jQuery( this );\n\t\t\t\tclassNames = classesToArray( value );\n\n\t\t\t\twhile ( ( className = classNames[ i++ ] ) ) {\n\n\t\t\t\t\t// Check each className given, space separated list\n\t\t\t\t\tif ( self.hasClass( className ) ) {\n\t\t\t\t\t\tself.removeClass( className );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.addClass( className );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// Toggle whole class name\n\t\t\t} else if ( value === undefined || type === \"boolean\" ) {\n\t\t\t\tclassName = getClass( this );\n\t\t\t\tif ( className ) {\n\n\t\t\t\t\t// Store className if set\n\t\t\t\t\tdataPriv.set( this, \"__className__\", className );\n\t\t\t\t}\n\n\t\t\t\t// If the element has a class name or if we're passed `false`,\n\t\t\t\t// then remove the whole classname (if there was one, the above saved it).\n\t\t\t\t// Otherwise bring back whatever was previously saved (if anything),\n\t\t\t\t// falling back to the empty string if nothing was stored.\n\t\t\t\tif ( this.setAttribute ) {\n\t\t\t\t\tthis.setAttribute( \"class\",\n\t\t\t\t\t\tclassName || value === false ?\n\t\t\t\t\t\t\"\" :\n\t\t\t\t\t\tdataPriv.get( this, \"__className__\" ) || \"\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t},\n\n\thasClass: function( selector ) {\n\t\tvar className, elem,\n\t\t\ti = 0;\n\n\t\tclassName = \" \" + selector + \" \";\n\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\tif ( elem.nodeType === 1 &&\n\t\t\t\t( \" \" + stripAndCollapse( getClass( elem ) ) + \" \" ).indexOf( className ) > -1 ) {\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n} );\n\n\n\n\nvar rreturn = /\\r/g;\n\njQuery.fn.extend( {\n\tval: function( value ) {\n\t\tvar hooks, ret, valueIsFunction,\n\t\t\telem = this[ 0 ];\n\n\t\tif ( !arguments.length ) {\n\t\t\tif ( elem ) {\n\t\t\t\thooks = jQuery.valHooks[ elem.type ] ||\n\t\t\t\t\tjQuery.valHooks[ elem.nodeName.toLowerCase() ];\n\n\t\t\t\tif ( hooks &&\n\t\t\t\t\t\"get\" in hooks &&\n\t\t\t\t\t( ret = hooks.get( elem, \"value\" ) ) !== undefined\n\t\t\t\t) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tret = elem.value;\n\n\t\t\t\t// Handle most common string cases\n\t\t\t\tif ( typeof ret === \"string\" ) {\n\t\t\t\t\treturn ret.replace( rreturn, \"\" );\n\t\t\t\t}\n\n\t\t\t\t// Handle cases where value is null/undef or number\n\t\t\t\treturn ret == null ? \"\" : ret;\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tvalueIsFunction = isFunction( value );\n\n\t\treturn this.each( function( i ) {\n\t\t\tvar val;\n\n\t\t\tif ( this.nodeType !== 1 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( valueIsFunction ) {\n\t\t\t\tval = value.call( this, i, jQuery( this ).val() );\n\t\t\t} else {\n\t\t\t\tval = value;\n\t\t\t}\n\n\t\t\t// Treat null/undefined as \"\"; convert numbers to string\n\t\t\tif ( val == null ) {\n\t\t\t\tval = \"\";\n\n\t\t\t} else if ( typeof val === \"number\" ) {\n\t\t\t\tval += \"\";\n\n\t\t\t} else if ( Array.isArray( val ) ) {\n\t\t\t\tval = jQuery.map( val, function( value ) {\n\t\t\t\t\treturn value == null ? \"\" : value + \"\";\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\thooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];\n\n\t\t\t// If set returns undefined, fall back to normal setting\n\t\t\tif ( !hooks || !( \"set\" in hooks ) || hooks.set( this, val, \"value\" ) === undefined ) {\n\t\t\t\tthis.value = val;\n\t\t\t}\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tvalHooks: {\n\t\toption: {\n\t\t\tget: function( elem ) {\n\n\t\t\t\tvar val = jQuery.find.attr( elem, \"value\" );\n\t\t\t\treturn val != null ?\n\t\t\t\t\tval :\n\n\t\t\t\t\t// Support: IE <=10 - 11 only\n\t\t\t\t\t// option.text throws exceptions (#14686, #14858)\n\t\t\t\t\t// Strip and collapse whitespace\n\t\t\t\t\t// https://html.spec.whatwg.org/#strip-and-collapse-whitespace\n\t\t\t\t\tstripAndCollapse( jQuery.text( elem ) );\n\t\t\t}\n\t\t},\n\t\tselect: {\n\t\t\tget: function( elem ) {\n\t\t\t\tvar value, option, i,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tindex = elem.selectedIndex,\n\t\t\t\t\tone = elem.type === \"select-one\",\n\t\t\t\t\tvalues = one ? null : [],\n\t\t\t\t\tmax = one ? index + 1 : options.length;\n\n\t\t\t\tif ( index < 0 ) {\n\t\t\t\t\ti = max;\n\n\t\t\t\t} else {\n\t\t\t\t\ti = one ? index : 0;\n\t\t\t\t}\n\n\t\t\t\t// Loop through all the selected options\n\t\t\t\tfor ( ; i < max; i++ ) {\n\t\t\t\t\toption = options[ i ];\n\n\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t// IE8-9 doesn't update selected after form reset (#2551)\n\t\t\t\t\tif ( ( option.selected || i === index ) &&\n\n\t\t\t\t\t\t\t// Don't return options that are disabled or in a disabled optgroup\n\t\t\t\t\t\t\t!option.disabled &&\n\t\t\t\t\t\t\t( !option.parentNode.disabled ||\n\t\t\t\t\t\t\t\t!nodeName( option.parentNode, \"optgroup\" ) ) ) {\n\n\t\t\t\t\t\t// Get the specific value for the option\n\t\t\t\t\t\tvalue = jQuery( option ).val();\n\n\t\t\t\t\t\t// We don't need an array for one selects\n\t\t\t\t\t\tif ( one ) {\n\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Multi-Selects return an array\n\t\t\t\t\t\tvalues.push( value );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn values;\n\t\t\t},\n\n\t\t\tset: function( elem, value ) {\n\t\t\t\tvar optionSet, option,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tvalues = jQuery.makeArray( value ),\n\t\t\t\t\ti = options.length;\n\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\toption = options[ i ];\n\n\t\t\t\t\t/* eslint-disable no-cond-assign */\n\n\t\t\t\t\tif ( option.selected =\n\t\t\t\t\t\tjQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1\n\t\t\t\t\t) {\n\t\t\t\t\t\toptionSet = true;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* eslint-enable no-cond-assign */\n\t\t\t\t}\n\n\t\t\t\t// Force browsers to behave consistently when non-matching value is set\n\t\t\t\tif ( !optionSet ) {\n\t\t\t\t\telem.selectedIndex = -1;\n\t\t\t\t}\n\t\t\t\treturn values;\n\t\t\t}\n\t\t}\n\t}\n} );\n\n// Radios and checkboxes getter/setter\njQuery.each( [ \"radio\", \"checkbox\" ], function() {\n\tjQuery.valHooks[ this ] = {\n\t\tset: function( elem, value ) {\n\t\t\tif ( Array.isArray( value ) ) {\n\t\t\t\treturn ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );\n\t\t\t}\n\t\t}\n\t};\n\tif ( !support.checkOn ) {\n\t\tjQuery.valHooks[ this ].get = function( elem ) {\n\t\t\treturn elem.getAttribute( \"value\" ) === null ? \"on\" : elem.value;\n\t\t};\n\t}\n} );\n\n\n\n\n// Return jQuery for attributes-only inclusion\n\n\nsupport.focusin = \"onfocusin\" in window;\n\n\nvar rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,\n\tstopPropagationCallback = function( e ) {\n\t\te.stopPropagation();\n\t};\n\njQuery.extend( jQuery.event, {\n\n\ttrigger: function( event, data, elem, onlyHandlers ) {\n\n\t\tvar i, cur, tmp, bubbleType, ontype, handle, special, lastElement,\n\t\t\teventPath = [ elem || document ],\n\t\t\ttype = hasOwn.call( event, \"type\" ) ? event.type : event,\n\t\t\tnamespaces = hasOwn.call( event, \"namespace\" ) ? event.namespace.split( \".\" ) : [];\n\n\t\tcur = lastElement = tmp = elem = elem || document;\n\n\t\t// Don't do events on text and comment nodes\n\t\tif ( elem.nodeType === 3 || elem.nodeType === 8 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// focus/blur morphs to focusin/out; ensure we're not firing them right now\n\t\tif ( rfocusMorph.test( type + jQuery.event.triggered ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( type.indexOf( \".\" ) > -1 ) {\n\n\t\t\t// Namespaced trigger; create a regexp to match event type in handle()\n\t\t\tnamespaces = type.split( \".\" );\n\t\t\ttype = namespaces.shift();\n\t\t\tnamespaces.sort();\n\t\t}\n\t\tontype = type.indexOf( \":\" ) < 0 && \"on\" + type;\n\n\t\t// Caller can pass in a jQuery.Event object, Object, or just an event type string\n\t\tevent = event[ jQuery.expando ] ?\n\t\t\tevent :\n\t\t\tnew jQuery.Event( type, typeof event === \"object\" && event );\n\n\t\t// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\n\t\tevent.isTrigger = onlyHandlers ? 2 : 3;\n\t\tevent.namespace = namespaces.join( \".\" );\n\t\tevent.rnamespace = event.namespace ?\n\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join( \"\\\\.(?:.*\\\\.|)\" ) + \"(\\\\.|$)\" ) :\n\t\t\tnull;\n\n\t\t// Clean up the event in case it is being reused\n\t\tevent.result = undefined;\n\t\tif ( !event.target ) {\n\t\t\tevent.target = elem;\n\t\t}\n\n\t\t// Clone any incoming data and prepend the event, creating the handler arg list\n\t\tdata = data == null ?\n\t\t\t[ event ] :\n\t\t\tjQuery.makeArray( data, [ event ] );\n\n\t\t// Allow special events to draw outside the lines\n\t\tspecial = jQuery.event.special[ type ] || {};\n\t\tif ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine event propagation path in advance, per W3C events spec (#9951)\n\t\t// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\n\t\tif ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {\n\n\t\t\tbubbleType = special.delegateType || type;\n\t\t\tif ( !rfocusMorph.test( bubbleType + type ) ) {\n\t\t\t\tcur = cur.parentNode;\n\t\t\t}\n\t\t\tfor ( ; cur; cur = cur.parentNode ) {\n\t\t\t\teventPath.push( cur );\n\t\t\t\ttmp = cur;\n\t\t\t}\n\n\t\t\t// Only add window if we got to document (e.g., not plain obj or detached DOM)\n\t\t\tif ( tmp === ( elem.ownerDocument || document ) ) {\n\t\t\t\teventPath.push( tmp.defaultView || tmp.parentWindow || window );\n\t\t\t}\n\t\t}\n\n\t\t// Fire handlers on the event path\n\t\ti = 0;\n\t\twhile ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {\n\t\t\tlastElement = cur;\n\t\t\tevent.type = i > 1 ?\n\t\t\t\tbubbleType :\n\t\t\t\tspecial.bindType || type;\n\n\t\t\t// jQuery handler\n\t\t\thandle = ( dataPriv.get( cur, \"events\" ) || {} )[ event.type ] &&\n\t\t\t\tdataPriv.get( cur, \"handle\" );\n\t\t\tif ( handle ) {\n\t\t\t\thandle.apply( cur, data );\n\t\t\t}\n\n\t\t\t// Native handler\n\t\t\thandle = ontype && cur[ ontype ];\n\t\t\tif ( handle && handle.apply && acceptData( cur ) ) {\n\t\t\t\tevent.result = handle.apply( cur, data );\n\t\t\t\tif ( event.result === false ) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tevent.type = type;\n\n\t\t// If nobody prevented the default action, do it now\n\t\tif ( !onlyHandlers && !event.isDefaultPrevented() ) {\n\n\t\t\tif ( ( !special._default ||\n\t\t\t\tspecial._default.apply( eventPath.pop(), data ) === false ) &&\n\t\t\t\tacceptData( elem ) ) {\n\n\t\t\t\t// Call a native DOM method on the target with the same name as the event.\n\t\t\t\t// Don't do default actions on window, that's where global variables be (#6170)\n\t\t\t\tif ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {\n\n\t\t\t\t\t// Don't re-trigger an onFOO event when we call its FOO() method\n\t\t\t\t\ttmp = elem[ ontype ];\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = null;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Prevent re-triggering of the same event, since we already bubbled it above\n\t\t\t\t\tjQuery.event.triggered = type;\n\n\t\t\t\t\tif ( event.isPropagationStopped() ) {\n\t\t\t\t\t\tlastElement.addEventListener( type, stopPropagationCallback );\n\t\t\t\t\t}\n\n\t\t\t\t\telem[ type ]();\n\n\t\t\t\t\tif ( event.isPropagationStopped() ) {\n\t\t\t\t\t\tlastElement.removeEventListener( type, stopPropagationCallback );\n\t\t\t\t\t}\n\n\t\t\t\t\tjQuery.event.triggered = undefined;\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\t// Piggyback on a donor event to simulate a different one\n\t// Used only for `focus(in | out)` events\n\tsimulate: function( type, elem, event ) {\n\t\tvar e = jQuery.extend(\n\t\t\tnew jQuery.Event(),\n\t\t\tevent,\n\t\t\t{\n\t\t\t\ttype: type,\n\t\t\t\tisSimulated: true\n\t\t\t}\n\t\t);\n\n\t\tjQuery.event.trigger( e, null, elem );\n\t}\n\n} );\n\njQuery.fn.extend( {\n\n\ttrigger: function( type, data ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.event.trigger( type, data, this );\n\t\t} );\n\t},\n\ttriggerHandler: function( type, data ) {\n\t\tvar elem = this[ 0 ];\n\t\tif ( elem ) {\n\t\t\treturn jQuery.event.trigger( type, data, elem, true );\n\t\t}\n\t}\n} );\n\n\n// Support: Firefox <=44\n// Firefox doesn't have focus(in | out) events\n// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787\n//\n// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1\n// focus(in | out) events fire after focus & blur events,\n// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order\n// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857\nif ( !support.focusin ) {\n\tjQuery.each( { focus: \"focusin\", blur: \"focusout\" }, function( orig, fix ) {\n\n\t\t// Attach a single capturing handler on the document while someone wants focusin/focusout\n\t\tvar handler = function( event ) {\n\t\t\tjQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );\n\t\t};\n\n\t\tjQuery.event.special[ fix ] = {\n\t\t\tsetup: function() {\n\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\tattaches = dataPriv.access( doc, fix );\n\n\t\t\t\tif ( !attaches ) {\n\t\t\t\t\tdoc.addEventListener( orig, handler, true );\n\t\t\t\t}\n\t\t\t\tdataPriv.access( doc, fix, ( attaches || 0 ) + 1 );\n\t\t\t},\n\t\t\tteardown: function() {\n\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\tattaches = dataPriv.access( doc, fix ) - 1;\n\n\t\t\t\tif ( !attaches ) {\n\t\t\t\t\tdoc.removeEventListener( orig, handler, true );\n\t\t\t\t\tdataPriv.remove( doc, fix );\n\n\t\t\t\t} else {\n\t\t\t\t\tdataPriv.access( doc, fix, attaches );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t} );\n}\nvar location = window.location;\n\nvar nonce = Date.now();\n\nvar rquery = ( /\\?/ );\n\n\n\n// Cross-browser xml parsing\njQuery.parseXML = function( data ) {\n\tvar xml;\n\tif ( !data || typeof data !== \"string\" ) {\n\t\treturn null;\n\t}\n\n\t// Support: IE 9 - 11 only\n\t// IE throws on parseFromString with invalid input.\n\ttry {\n\t\txml = ( new window.DOMParser() ).parseFromString( data, \"text/xml\" );\n\t} catch ( e ) {\n\t\txml = undefined;\n\t}\n\n\tif ( !xml || xml.getElementsByTagName( \"parsererror\" ).length ) {\n\t\tjQuery.error( \"Invalid XML: \" + data );\n\t}\n\treturn xml;\n};\n\n\nvar\n\trbracket = /\\[\\]$/,\n\trCRLF = /\\r?\\n/g,\n\trsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\n\trsubmittable = /^(?:input|select|textarea|keygen)/i;\n\nfunction buildParams( prefix, obj, traditional, add ) {\n\tvar name;\n\n\tif ( Array.isArray( obj ) ) {\n\n\t\t// Serialize array item.\n\t\tjQuery.each( obj, function( i, v ) {\n\t\t\tif ( traditional || rbracket.test( prefix ) ) {\n\n\t\t\t\t// Treat each array item as a scalar.\n\t\t\t\tadd( prefix, v );\n\n\t\t\t} else {\n\n\t\t\t\t// Item is non-scalar (array or object), encode its numeric index.\n\t\t\t\tbuildParams(\n\t\t\t\t\tprefix + \"[\" + ( typeof v === \"object\" && v != null ? i : \"\" ) + \"]\",\n\t\t\t\t\tv,\n\t\t\t\t\ttraditional,\n\t\t\t\t\tadd\n\t\t\t\t);\n\t\t\t}\n\t\t} );\n\n\t} else if ( !traditional && toType( obj ) === \"object\" ) {\n\n\t\t// Serialize object item.\n\t\tfor ( name in obj ) {\n\t\t\tbuildParams( prefix + \"[\" + name + \"]\", obj[ name ], traditional, add );\n\t\t}\n\n\t} else {\n\n\t\t// Serialize scalar item.\n\t\tadd( prefix, obj );\n\t}\n}\n\n// Serialize an array of form elements or a set of\n// key/values into a query string\njQuery.param = function( a, traditional ) {\n\tvar prefix,\n\t\ts = [],\n\t\tadd = function( key, valueOrFunction ) {\n\n\t\t\t// If value is a function, invoke it and use its return value\n\t\t\tvar value = isFunction( valueOrFunction ) ?\n\t\t\t\tvalueOrFunction() :\n\t\t\t\tvalueOrFunction;\n\n\t\t\ts[ s.length ] = encodeURIComponent( key ) + \"=\" +\n\t\t\t\tencodeURIComponent( value == null ? \"\" : value );\n\t\t};\n\n\t// If an array was passed in, assume that it is an array of form elements.\n\tif ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {\n\n\t\t// Serialize the form elements\n\t\tjQuery.each( a, function() {\n\t\t\tadd( this.name, this.value );\n\t\t} );\n\n\t} else {\n\n\t\t// If traditional, encode the \"old\" way (the way 1.3.2 or older\n\t\t// did it), otherwise encode params recursively.\n\t\tfor ( prefix in a ) {\n\t\t\tbuildParams( prefix, a[ prefix ], traditional, add );\n\t\t}\n\t}\n\n\t// Return the resulting serialization\n\treturn s.join( \"&\" );\n};\n\njQuery.fn.extend( {\n\tserialize: function() {\n\t\treturn jQuery.param( this.serializeArray() );\n\t},\n\tserializeArray: function() {\n\t\treturn this.map( function() {\n\n\t\t\t// Can add propHook for \"elements\" to filter or add form elements\n\t\t\tvar elements = jQuery.prop( this, \"elements\" );\n\t\t\treturn elements ? jQuery.makeArray( elements ) : this;\n\t\t} )\n\t\t.filter( function() {\n\t\t\tvar type = this.type;\n\n\t\t\t// Use .is( \":disabled\" ) so that fieldset[disabled] works\n\t\t\treturn this.name && !jQuery( this ).is( \":disabled\" ) &&\n\t\t\t\trsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&\n\t\t\t\t( this.checked || !rcheckableType.test( type ) );\n\t\t} )\n\t\t.map( function( i, elem ) {\n\t\t\tvar val = jQuery( this ).val();\n\n\t\t\tif ( val == null ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif ( Array.isArray( val ) ) {\n\t\t\t\treturn jQuery.map( val, function( val ) {\n\t\t\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t} ).get();\n\t}\n} );\n\n\nvar\n\tr20 = /%20/g,\n\trhash = /#.*$/,\n\trantiCache = /([?&])_=[^&]*/,\n\trheaders = /^(.*?):[ \\t]*([^\\r\\n]*)$/mg,\n\n\t// #7653, #8125, #8152: local protocol detection\n\trlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n\trnoContent = /^(?:GET|HEAD)$/,\n\trprotocol = /^\\/\\//,\n\n\t/* Prefilters\n\t * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n\t * 2) These are called:\n\t *    - BEFORE asking for a transport\n\t *    - AFTER param serialization (s.data is a string if s.processData is true)\n\t * 3) key is the dataType\n\t * 4) the catchall symbol \"*\" can be used\n\t * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\n\t */\n\tprefilters = {},\n\n\t/* Transports bindings\n\t * 1) key is the dataType\n\t * 2) the catchall symbol \"*\" can be used\n\t * 3) selection will start with transport dataType and THEN go to \"*\" if needed\n\t */\n\ttransports = {},\n\n\t// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n\tallTypes = \"*/\".concat( \"*\" ),\n\n\t// Anchor tag for parsing the document origin\n\toriginAnchor = document.createElement( \"a\" );\n\toriginAnchor.href = location.href;\n\n// Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\nfunction addToPrefiltersOrTransports( structure ) {\n\n\t// dataTypeExpression is optional and defaults to \"*\"\n\treturn function( dataTypeExpression, func ) {\n\n\t\tif ( typeof dataTypeExpression !== \"string\" ) {\n\t\t\tfunc = dataTypeExpression;\n\t\t\tdataTypeExpression = \"*\";\n\t\t}\n\n\t\tvar dataType,\n\t\t\ti = 0,\n\t\t\tdataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];\n\n\t\tif ( isFunction( func ) ) {\n\n\t\t\t// For each dataType in the dataTypeExpression\n\t\t\twhile ( ( dataType = dataTypes[ i++ ] ) ) {\n\n\t\t\t\t// Prepend if requested\n\t\t\t\tif ( dataType[ 0 ] === \"+\" ) {\n\t\t\t\t\tdataType = dataType.slice( 1 ) || \"*\";\n\t\t\t\t\t( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );\n\n\t\t\t\t// Otherwise append\n\t\t\t\t} else {\n\t\t\t\t\t( structure[ dataType ] = structure[ dataType ] || [] ).push( func );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\n// Base inspection function for prefilters and transports\nfunction inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {\n\n\tvar inspected = {},\n\t\tseekingTransport = ( structure === transports );\n\n\tfunction inspect( dataType ) {\n\t\tvar selected;\n\t\tinspected[ dataType ] = true;\n\t\tjQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {\n\t\t\tvar dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );\n\t\t\tif ( typeof dataTypeOrTransport === \"string\" &&\n\t\t\t\t!seekingTransport && !inspected[ dataTypeOrTransport ] ) {\n\n\t\t\t\toptions.dataTypes.unshift( dataTypeOrTransport );\n\t\t\t\tinspect( dataTypeOrTransport );\n\t\t\t\treturn false;\n\t\t\t} else if ( seekingTransport ) {\n\t\t\t\treturn !( selected = dataTypeOrTransport );\n\t\t\t}\n\t\t} );\n\t\treturn selected;\n\t}\n\n\treturn inspect( options.dataTypes[ 0 ] ) || !inspected[ \"*\" ] && inspect( \"*\" );\n}\n\n// A special extend for ajax options\n// that takes \"flat\" options (not to be deep extended)\n// Fixes #9887\nfunction ajaxExtend( target, src ) {\n\tvar key, deep,\n\t\tflatOptions = jQuery.ajaxSettings.flatOptions || {};\n\n\tfor ( key in src ) {\n\t\tif ( src[ key ] !== undefined ) {\n\t\t\t( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];\n\t\t}\n\t}\n\tif ( deep ) {\n\t\tjQuery.extend( true, target, deep );\n\t}\n\n\treturn target;\n}\n\n/* Handles responses to an ajax request:\n * - finds the right dataType (mediates between content-type and expected dataType)\n * - returns the corresponding response\n */\nfunction ajaxHandleResponses( s, jqXHR, responses ) {\n\n\tvar ct, type, finalDataType, firstDataType,\n\t\tcontents = s.contents,\n\t\tdataTypes = s.dataTypes;\n\n\t// Remove auto dataType and get content-type in the process\n\twhile ( dataTypes[ 0 ] === \"*\" ) {\n\t\tdataTypes.shift();\n\t\tif ( ct === undefined ) {\n\t\t\tct = s.mimeType || jqXHR.getResponseHeader( \"Content-Type\" );\n\t\t}\n\t}\n\n\t// Check if we're dealing with a known content-type\n\tif ( ct ) {\n\t\tfor ( type in contents ) {\n\t\t\tif ( contents[ type ] && contents[ type ].test( ct ) ) {\n\t\t\t\tdataTypes.unshift( type );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Check to see if we have a response for the expected dataType\n\tif ( dataTypes[ 0 ] in responses ) {\n\t\tfinalDataType = dataTypes[ 0 ];\n\t} else {\n\n\t\t// Try convertible dataTypes\n\t\tfor ( type in responses ) {\n\t\t\tif ( !dataTypes[ 0 ] || s.converters[ type + \" \" + dataTypes[ 0 ] ] ) {\n\t\t\t\tfinalDataType = type;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( !firstDataType ) {\n\t\t\t\tfirstDataType = type;\n\t\t\t}\n\t\t}\n\n\t\t// Or just use first one\n\t\tfinalDataType = finalDataType || firstDataType;\n\t}\n\n\t// If we found a dataType\n\t// We add the dataType to the list if needed\n\t// and return the corresponding response\n\tif ( finalDataType ) {\n\t\tif ( finalDataType !== dataTypes[ 0 ] ) {\n\t\t\tdataTypes.unshift( finalDataType );\n\t\t}\n\t\treturn responses[ finalDataType ];\n\t}\n}\n\n/* Chain conversions given the request and the original response\n * Also sets the responseXXX fields on the jqXHR instance\n */\nfunction ajaxConvert( s, response, jqXHR, isSuccess ) {\n\tvar conv2, current, conv, tmp, prev,\n\t\tconverters = {},\n\n\t\t// Work with a copy of dataTypes in case we need to modify it for conversion\n\t\tdataTypes = s.dataTypes.slice();\n\n\t// Create converters map with lowercased keys\n\tif ( dataTypes[ 1 ] ) {\n\t\tfor ( conv in s.converters ) {\n\t\t\tconverters[ conv.toLowerCase() ] = s.converters[ conv ];\n\t\t}\n\t}\n\n\tcurrent = dataTypes.shift();\n\n\t// Convert to each sequential dataType\n\twhile ( current ) {\n\n\t\tif ( s.responseFields[ current ] ) {\n\t\t\tjqXHR[ s.responseFields[ current ] ] = response;\n\t\t}\n\n\t\t// Apply the dataFilter if provided\n\t\tif ( !prev && isSuccess && s.dataFilter ) {\n\t\t\tresponse = s.dataFilter( response, s.dataType );\n\t\t}\n\n\t\tprev = current;\n\t\tcurrent = dataTypes.shift();\n\n\t\tif ( current ) {\n\n\t\t\t// There's only work to do if current dataType is non-auto\n\t\t\tif ( current === \"*\" ) {\n\n\t\t\t\tcurrent = prev;\n\n\t\t\t// Convert response if prev dataType is non-auto and differs from current\n\t\t\t} else if ( prev !== \"*\" && prev !== current ) {\n\n\t\t\t\t// Seek a direct converter\n\t\t\t\tconv = converters[ prev + \" \" + current ] || converters[ \"* \" + current ];\n\n\t\t\t\t// If none found, seek a pair\n\t\t\t\tif ( !conv ) {\n\t\t\t\t\tfor ( conv2 in converters ) {\n\n\t\t\t\t\t\t// If conv2 outputs current\n\t\t\t\t\t\ttmp = conv2.split( \" \" );\n\t\t\t\t\t\tif ( tmp[ 1 ] === current ) {\n\n\t\t\t\t\t\t\t// If prev can be converted to accepted input\n\t\t\t\t\t\t\tconv = converters[ prev + \" \" + tmp[ 0 ] ] ||\n\t\t\t\t\t\t\t\tconverters[ \"* \" + tmp[ 0 ] ];\n\t\t\t\t\t\t\tif ( conv ) {\n\n\t\t\t\t\t\t\t\t// Condense equivalence converters\n\t\t\t\t\t\t\t\tif ( conv === true ) {\n\t\t\t\t\t\t\t\t\tconv = converters[ conv2 ];\n\n\t\t\t\t\t\t\t\t// Otherwise, insert the intermediate dataType\n\t\t\t\t\t\t\t\t} else if ( converters[ conv2 ] !== true ) {\n\t\t\t\t\t\t\t\t\tcurrent = tmp[ 0 ];\n\t\t\t\t\t\t\t\t\tdataTypes.unshift( tmp[ 1 ] );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Apply converter (if not an equivalence)\n\t\t\t\tif ( conv !== true ) {\n\n\t\t\t\t\t// Unless errors are allowed to bubble, catch and return them\n\t\t\t\t\tif ( conv && s.throws ) {\n\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t\t} catch ( e ) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tstate: \"parsererror\",\n\t\t\t\t\t\t\t\terror: conv ? e : \"No conversion from \" + prev + \" to \" + current\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn { state: \"success\", data: response };\n}\n\njQuery.extend( {\n\n\t// Counter for holding the number of active queries\n\tactive: 0,\n\n\t// Last-Modified header cache for next request\n\tlastModified: {},\n\tetag: {},\n\n\tajaxSettings: {\n\t\turl: location.href,\n\t\ttype: \"GET\",\n\t\tisLocal: rlocalProtocol.test( location.protocol ),\n\t\tglobal: true,\n\t\tprocessData: true,\n\t\tasync: true,\n\t\tcontentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n\n\t\t/*\n\t\ttimeout: 0,\n\t\tdata: null,\n\t\tdataType: null,\n\t\tusername: null,\n\t\tpassword: null,\n\t\tcache: null,\n\t\tthrows: false,\n\t\ttraditional: false,\n\t\theaders: {},\n\t\t*/\n\n\t\taccepts: {\n\t\t\t\"*\": allTypes,\n\t\t\ttext: \"text/plain\",\n\t\t\thtml: \"text/html\",\n\t\t\txml: \"application/xml, text/xml\",\n\t\t\tjson: \"application/json, text/javascript\"\n\t\t},\n\n\t\tcontents: {\n\t\t\txml: /\\bxml\\b/,\n\t\t\thtml: /\\bhtml/,\n\t\t\tjson: /\\bjson\\b/\n\t\t},\n\n\t\tresponseFields: {\n\t\t\txml: \"responseXML\",\n\t\t\ttext: \"responseText\",\n\t\t\tjson: \"responseJSON\"\n\t\t},\n\n\t\t// Data converters\n\t\t// Keys separate source (or catchall \"*\") and destination types with a single space\n\t\tconverters: {\n\n\t\t\t// Convert anything to text\n\t\t\t\"* text\": String,\n\n\t\t\t// Text to html (true = no transformation)\n\t\t\t\"text html\": true,\n\n\t\t\t// Evaluate text as a json expression\n\t\t\t\"text json\": JSON.parse,\n\n\t\t\t// Parse text as xml\n\t\t\t\"text xml\": jQuery.parseXML\n\t\t},\n\n\t\t// For options that shouldn't be deep extended:\n\t\t// you can add your own custom options here if\n\t\t// and when you create one that shouldn't be\n\t\t// deep extended (see ajaxExtend)\n\t\tflatOptions: {\n\t\t\turl: true,\n\t\t\tcontext: true\n\t\t}\n\t},\n\n\t// Creates a full fledged settings object into target\n\t// with both ajaxSettings and settings fields.\n\t// If target is omitted, writes into ajaxSettings.\n\tajaxSetup: function( target, settings ) {\n\t\treturn settings ?\n\n\t\t\t// Building a settings object\n\t\t\tajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :\n\n\t\t\t// Extending ajaxSettings\n\t\t\tajaxExtend( jQuery.ajaxSettings, target );\n\t},\n\n\tajaxPrefilter: addToPrefiltersOrTransports( prefilters ),\n\tajaxTransport: addToPrefiltersOrTransports( transports ),\n\n\t// Main method\n\tajax: function( url, options ) {\n\n\t\t// If url is an object, simulate pre-1.5 signature\n\t\tif ( typeof url === \"object\" ) {\n\t\t\toptions = url;\n\t\t\turl = undefined;\n\t\t}\n\n\t\t// Force options to be an object\n\t\toptions = options || {};\n\n\t\tvar transport,\n\n\t\t\t// URL without anti-cache param\n\t\t\tcacheURL,\n\n\t\t\t// Response headers\n\t\t\tresponseHeadersString,\n\t\t\tresponseHeaders,\n\n\t\t\t// timeout handle\n\t\t\ttimeoutTimer,\n\n\t\t\t// Url cleanup var\n\t\t\turlAnchor,\n\n\t\t\t// Request state (becomes false upon send and true upon completion)\n\t\t\tcompleted,\n\n\t\t\t// To know if global events are to be dispatched\n\t\t\tfireGlobals,\n\n\t\t\t// Loop variable\n\t\t\ti,\n\n\t\t\t// uncached part of the url\n\t\t\tuncached,\n\n\t\t\t// Create the final options object\n\t\t\ts = jQuery.ajaxSetup( {}, options ),\n\n\t\t\t// Callbacks context\n\t\t\tcallbackContext = s.context || s,\n\n\t\t\t// Context for global events is callbackContext if it is a DOM node or jQuery collection\n\t\t\tglobalEventContext = s.context &&\n\t\t\t\t( callbackContext.nodeType || callbackContext.jquery ) ?\n\t\t\t\t\tjQuery( callbackContext ) :\n\t\t\t\t\tjQuery.event,\n\n\t\t\t// Deferreds\n\t\t\tdeferred = jQuery.Deferred(),\n\t\t\tcompleteDeferred = jQuery.Callbacks( \"once memory\" ),\n\n\t\t\t// Status-dependent callbacks\n\t\t\tstatusCode = s.statusCode || {},\n\n\t\t\t// Headers (they are sent all at once)\n\t\t\trequestHeaders = {},\n\t\t\trequestHeadersNames = {},\n\n\t\t\t// Default abort message\n\t\t\tstrAbort = \"canceled\",\n\n\t\t\t// Fake xhr\n\t\t\tjqXHR = {\n\t\t\t\treadyState: 0,\n\n\t\t\t\t// Builds headers hashtable if needed\n\t\t\t\tgetResponseHeader: function( key ) {\n\t\t\t\t\tvar match;\n\t\t\t\t\tif ( completed ) {\n\t\t\t\t\t\tif ( !responseHeaders ) {\n\t\t\t\t\t\t\tresponseHeaders = {};\n\t\t\t\t\t\t\twhile ( ( match = rheaders.exec( responseHeadersString ) ) ) {\n\t\t\t\t\t\t\t\tresponseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmatch = responseHeaders[ key.toLowerCase() ];\n\t\t\t\t\t}\n\t\t\t\t\treturn match == null ? null : match;\n\t\t\t\t},\n\n\t\t\t\t// Raw string\n\t\t\t\tgetAllResponseHeaders: function() {\n\t\t\t\t\treturn completed ? responseHeadersString : null;\n\t\t\t\t},\n\n\t\t\t\t// Caches the header\n\t\t\t\tsetRequestHeader: function( name, value ) {\n\t\t\t\t\tif ( completed == null ) {\n\t\t\t\t\t\tname = requestHeadersNames[ name.toLowerCase() ] =\n\t\t\t\t\t\t\trequestHeadersNames[ name.toLowerCase() ] || name;\n\t\t\t\t\t\trequestHeaders[ name ] = value;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Overrides response content-type header\n\t\t\t\toverrideMimeType: function( type ) {\n\t\t\t\t\tif ( completed == null ) {\n\t\t\t\t\t\ts.mimeType = type;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Status-dependent callbacks\n\t\t\t\tstatusCode: function( map ) {\n\t\t\t\t\tvar code;\n\t\t\t\t\tif ( map ) {\n\t\t\t\t\t\tif ( completed ) {\n\n\t\t\t\t\t\t\t// Execute the appropriate callbacks\n\t\t\t\t\t\t\tjqXHR.always( map[ jqXHR.status ] );\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// Lazy-add the new callbacks in a way that preserves old ones\n\t\t\t\t\t\t\tfor ( code in map ) {\n\t\t\t\t\t\t\t\tstatusCode[ code ] = [ statusCode[ code ], map[ code ] ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Cancel the request\n\t\t\t\tabort: function( statusText ) {\n\t\t\t\t\tvar finalText = statusText || strAbort;\n\t\t\t\t\tif ( transport ) {\n\t\t\t\t\t\ttransport.abort( finalText );\n\t\t\t\t\t}\n\t\t\t\t\tdone( 0, finalText );\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t};\n\n\t\t// Attach deferreds\n\t\tdeferred.promise( jqXHR );\n\n\t\t// Add protocol if not provided (prefilters might expect it)\n\t\t// Handle falsy url in the settings object (#10093: consistency with old signature)\n\t\t// We also use the url parameter if available\n\t\ts.url = ( ( url || s.url || location.href ) + \"\" )\n\t\t\t.replace( rprotocol, location.protocol + \"//\" );\n\n\t\t// Alias method option to type as per ticket #12004\n\t\ts.type = options.method || options.type || s.method || s.type;\n\n\t\t// Extract dataTypes list\n\t\ts.dataTypes = ( s.dataType || \"*\" ).toLowerCase().match( rnothtmlwhite ) || [ \"\" ];\n\n\t\t// A cross-domain request is in order when the origin doesn't match the current origin.\n\t\tif ( s.crossDomain == null ) {\n\t\t\turlAnchor = document.createElement( \"a\" );\n\n\t\t\t// Support: IE <=8 - 11, Edge 12 - 15\n\t\t\t// IE throws exception on accessing the href property if url is malformed,\n\t\t\t// e.g. http://example.com:80x/\n\t\t\ttry {\n\t\t\t\turlAnchor.href = s.url;\n\n\t\t\t\t// Support: IE <=8 - 11 only\n\t\t\t\t// Anchor's host property isn't correctly set when s.url is relative\n\t\t\t\turlAnchor.href = urlAnchor.href;\n\t\t\t\ts.crossDomain = originAnchor.protocol + \"//\" + originAnchor.host !==\n\t\t\t\t\turlAnchor.protocol + \"//\" + urlAnchor.host;\n\t\t\t} catch ( e ) {\n\n\t\t\t\t// If there is an error parsing the URL, assume it is crossDomain,\n\t\t\t\t// it can be rejected by the transport if it is invalid\n\t\t\t\ts.crossDomain = true;\n\t\t\t}\n\t\t}\n\n\t\t// Convert data if not already a string\n\t\tif ( s.data && s.processData && typeof s.data !== \"string\" ) {\n\t\t\ts.data = jQuery.param( s.data, s.traditional );\n\t\t}\n\n\t\t// Apply prefilters\n\t\tinspectPrefiltersOrTransports( prefilters, s, options, jqXHR );\n\n\t\t// If request was aborted inside a prefilter, stop there\n\t\tif ( completed ) {\n\t\t\treturn jqXHR;\n\t\t}\n\n\t\t// We can fire global events as of now if asked to\n\t\t// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)\n\t\tfireGlobals = jQuery.event && s.global;\n\n\t\t// Watch for a new set of requests\n\t\tif ( fireGlobals && jQuery.active++ === 0 ) {\n\t\t\tjQuery.event.trigger( \"ajaxStart\" );\n\t\t}\n\n\t\t// Uppercase the type\n\t\ts.type = s.type.toUpperCase();\n\n\t\t// Determine if request has content\n\t\ts.hasContent = !rnoContent.test( s.type );\n\n\t\t// Save the URL in case we're toying with the If-Modified-Since\n\t\t// and/or If-None-Match header later on\n\t\t// Remove hash to simplify url manipulation\n\t\tcacheURL = s.url.replace( rhash, \"\" );\n\n\t\t// More options handling for requests with no content\n\t\tif ( !s.hasContent ) {\n\n\t\t\t// Remember the hash so we can put it back\n\t\t\tuncached = s.url.slice( cacheURL.length );\n\n\t\t\t// If data is available and should be processed, append data to url\n\t\t\tif ( s.data && ( s.processData || typeof s.data === \"string\" ) ) {\n\t\t\t\tcacheURL += ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + s.data;\n\n\t\t\t\t// #9682: remove data so that it's not used in an eventual retry\n\t\t\t\tdelete s.data;\n\t\t\t}\n\n\t\t\t// Add or update anti-cache param if needed\n\t\t\tif ( s.cache === false ) {\n\t\t\t\tcacheURL = cacheURL.replace( rantiCache, \"$1\" );\n\t\t\t\tuncached = ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + \"_=\" + ( nonce++ ) + uncached;\n\t\t\t}\n\n\t\t\t// Put hash and anti-cache on the URL that will be requested (gh-1732)\n\t\t\ts.url = cacheURL + uncached;\n\n\t\t// Change '%20' to '+' if this is encoded form body content (gh-2658)\n\t\t} else if ( s.data && s.processData &&\n\t\t\t( s.contentType || \"\" ).indexOf( \"application/x-www-form-urlencoded\" ) === 0 ) {\n\t\t\ts.data = s.data.replace( r20, \"+\" );\n\t\t}\n\n\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\tif ( s.ifModified ) {\n\t\t\tif ( jQuery.lastModified[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( \"If-Modified-Since\", jQuery.lastModified[ cacheURL ] );\n\t\t\t}\n\t\t\tif ( jQuery.etag[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( \"If-None-Match\", jQuery.etag[ cacheURL ] );\n\t\t\t}\n\t\t}\n\n\t\t// Set the correct header, if data is being sent\n\t\tif ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {\n\t\t\tjqXHR.setRequestHeader( \"Content-Type\", s.contentType );\n\t\t}\n\n\t\t// Set the Accepts header for the server, depending on the dataType\n\t\tjqXHR.setRequestHeader(\n\t\t\t\"Accept\",\n\t\t\ts.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?\n\t\t\t\ts.accepts[ s.dataTypes[ 0 ] ] +\n\t\t\t\t\t( s.dataTypes[ 0 ] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\" ) :\n\t\t\t\ts.accepts[ \"*\" ]\n\t\t);\n\n\t\t// Check for headers option\n\t\tfor ( i in s.headers ) {\n\t\t\tjqXHR.setRequestHeader( i, s.headers[ i ] );\n\t\t}\n\n\t\t// Allow custom headers/mimetypes and early abort\n\t\tif ( s.beforeSend &&\n\t\t\t( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {\n\n\t\t\t// Abort if not done already and return\n\t\t\treturn jqXHR.abort();\n\t\t}\n\n\t\t// Aborting is no longer a cancellation\n\t\tstrAbort = \"abort\";\n\n\t\t// Install callbacks on deferreds\n\t\tcompleteDeferred.add( s.complete );\n\t\tjqXHR.done( s.success );\n\t\tjqXHR.fail( s.error );\n\n\t\t// Get transport\n\t\ttransport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );\n\n\t\t// If no transport, we auto-abort\n\t\tif ( !transport ) {\n\t\t\tdone( -1, \"No Transport\" );\n\t\t} else {\n\t\t\tjqXHR.readyState = 1;\n\n\t\t\t// Send global event\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajaxSend\", [ jqXHR, s ] );\n\t\t\t}\n\n\t\t\t// If request was aborted inside ajaxSend, stop there\n\t\t\tif ( completed ) {\n\t\t\t\treturn jqXHR;\n\t\t\t}\n\n\t\t\t// Timeout\n\t\t\tif ( s.async && s.timeout > 0 ) {\n\t\t\t\ttimeoutTimer = window.setTimeout( function() {\n\t\t\t\t\tjqXHR.abort( \"timeout\" );\n\t\t\t\t}, s.timeout );\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tcompleted = false;\n\t\t\t\ttransport.send( requestHeaders, done );\n\t\t\t} catch ( e ) {\n\n\t\t\t\t// Rethrow post-completion exceptions\n\t\t\t\tif ( completed ) {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\n\t\t\t\t// Propagate others as results\n\t\t\t\tdone( -1, e );\n\t\t\t}\n\t\t}\n\n\t\t// Callback for when everything is done\n\t\tfunction done( status, nativeStatusText, responses, headers ) {\n\t\t\tvar isSuccess, success, error, response, modified,\n\t\t\t\tstatusText = nativeStatusText;\n\n\t\t\t// Ignore repeat invocations\n\t\t\tif ( completed ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcompleted = true;\n\n\t\t\t// Clear timeout if it exists\n\t\t\tif ( timeoutTimer ) {\n\t\t\t\twindow.clearTimeout( timeoutTimer );\n\t\t\t}\n\n\t\t\t// Dereference transport for early garbage collection\n\t\t\t// (no matter how long the jqXHR object will be used)\n\t\t\ttransport = undefined;\n\n\t\t\t// Cache response headers\n\t\t\tresponseHeadersString = headers || \"\";\n\n\t\t\t// Set readyState\n\t\t\tjqXHR.readyState = status > 0 ? 4 : 0;\n\n\t\t\t// Determine if successful\n\t\t\tisSuccess = status >= 200 && status < 300 || status === 304;\n\n\t\t\t// Get response data\n\t\t\tif ( responses ) {\n\t\t\t\tresponse = ajaxHandleResponses( s, jqXHR, responses );\n\t\t\t}\n\n\t\t\t// Convert no matter what (that way responseXXX fields are always set)\n\t\t\tresponse = ajaxConvert( s, response, jqXHR, isSuccess );\n\n\t\t\t// If successful, handle type chaining\n\t\t\tif ( isSuccess ) {\n\n\t\t\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\t\t\tif ( s.ifModified ) {\n\t\t\t\t\tmodified = jqXHR.getResponseHeader( \"Last-Modified\" );\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.lastModified[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t\tmodified = jqXHR.getResponseHeader( \"etag\" );\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.etag[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// if no content\n\t\t\t\tif ( status === 204 || s.type === \"HEAD\" ) {\n\t\t\t\t\tstatusText = \"nocontent\";\n\n\t\t\t\t// if not modified\n\t\t\t\t} else if ( status === 304 ) {\n\t\t\t\t\tstatusText = \"notmodified\";\n\n\t\t\t\t// If we have data, let's convert it\n\t\t\t\t} else {\n\t\t\t\t\tstatusText = response.state;\n\t\t\t\t\tsuccess = response.data;\n\t\t\t\t\terror = response.error;\n\t\t\t\t\tisSuccess = !error;\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\t// Extract error from statusText and normalize for non-aborts\n\t\t\t\terror = statusText;\n\t\t\t\tif ( status || !statusText ) {\n\t\t\t\t\tstatusText = \"error\";\n\t\t\t\t\tif ( status < 0 ) {\n\t\t\t\t\t\tstatus = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set data for the fake xhr object\n\t\t\tjqXHR.status = status;\n\t\t\tjqXHR.statusText = ( nativeStatusText || statusText ) + \"\";\n\n\t\t\t// Success/Error\n\t\t\tif ( isSuccess ) {\n\t\t\t\tdeferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );\n\t\t\t} else {\n\t\t\t\tdeferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );\n\t\t\t}\n\n\t\t\t// Status-dependent callbacks\n\t\t\tjqXHR.statusCode( statusCode );\n\t\t\tstatusCode = undefined;\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( isSuccess ? \"ajaxSuccess\" : \"ajaxError\",\n\t\t\t\t\t[ jqXHR, s, isSuccess ? success : error ] );\n\t\t\t}\n\n\t\t\t// Complete\n\t\t\tcompleteDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajaxComplete\", [ jqXHR, s ] );\n\n\t\t\t\t// Handle the global AJAX counter\n\t\t\t\tif ( !( --jQuery.active ) ) {\n\t\t\t\t\tjQuery.event.trigger( \"ajaxStop\" );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn jqXHR;\n\t},\n\n\tgetJSON: function( url, data, callback ) {\n\t\treturn jQuery.get( url, data, callback, \"json\" );\n\t},\n\n\tgetScript: function( url, callback ) {\n\t\treturn jQuery.get( url, undefined, callback, \"script\" );\n\t}\n} );\n\njQuery.each( [ \"get\", \"post\" ], function( i, method ) {\n\tjQuery[ method ] = function( url, data, callback, type ) {\n\n\t\t// Shift arguments if data argument was omitted\n\t\tif ( isFunction( data ) ) {\n\t\t\ttype = type || callback;\n\t\t\tcallback = data;\n\t\t\tdata = undefined;\n\t\t}\n\n\t\t// The url can be an options object (which then must have .url)\n\t\treturn jQuery.ajax( jQuery.extend( {\n\t\t\turl: url,\n\t\t\ttype: method,\n\t\t\tdataType: type,\n\t\t\tdata: data,\n\t\t\tsuccess: callback\n\t\t}, jQuery.isPlainObject( url ) && url ) );\n\t};\n} );\n\n\njQuery._evalUrl = function( url ) {\n\treturn jQuery.ajax( {\n\t\turl: url,\n\n\t\t// Make this explicit, since user can override this through ajaxSetup (#11264)\n\t\ttype: \"GET\",\n\t\tdataType: \"script\",\n\t\tcache: true,\n\t\tasync: false,\n\t\tglobal: false,\n\t\t\"throws\": true\n\t} );\n};\n\n\njQuery.fn.extend( {\n\twrapAll: function( html ) {\n\t\tvar wrap;\n\n\t\tif ( this[ 0 ] ) {\n\t\t\tif ( isFunction( html ) ) {\n\t\t\t\thtml = html.call( this[ 0 ] );\n\t\t\t}\n\n\t\t\t// The elements to wrap the target around\n\t\t\twrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );\n\n\t\t\tif ( this[ 0 ].parentNode ) {\n\t\t\t\twrap.insertBefore( this[ 0 ] );\n\t\t\t}\n\n\t\t\twrap.map( function() {\n\t\t\t\tvar elem = this;\n\n\t\t\t\twhile ( elem.firstElementChild ) {\n\t\t\t\t\telem = elem.firstElementChild;\n\t\t\t\t}\n\n\t\t\t\treturn elem;\n\t\t\t} ).append( this );\n\t\t}\n\n\t\treturn this;\n\t},\n\n\twrapInner: function( html ) {\n\t\tif ( isFunction( html ) ) {\n\t\t\treturn this.each( function( i ) {\n\t\t\t\tjQuery( this ).wrapInner( html.call( this, i ) );\n\t\t\t} );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar self = jQuery( this ),\n\t\t\t\tcontents = self.contents();\n\n\t\t\tif ( contents.length ) {\n\t\t\t\tcontents.wrapAll( html );\n\n\t\t\t} else {\n\t\t\t\tself.append( html );\n\t\t\t}\n\t\t} );\n\t},\n\n\twrap: function( html ) {\n\t\tvar htmlIsFunction = isFunction( html );\n\n\t\treturn this.each( function( i ) {\n\t\t\tjQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );\n\t\t} );\n\t},\n\n\tunwrap: function( selector ) {\n\t\tthis.parent( selector ).not( \"body\" ).each( function() {\n\t\t\tjQuery( this ).replaceWith( this.childNodes );\n\t\t} );\n\t\treturn this;\n\t}\n} );\n\n\njQuery.expr.pseudos.hidden = function( elem ) {\n\treturn !jQuery.expr.pseudos.visible( elem );\n};\njQuery.expr.pseudos.visible = function( elem ) {\n\treturn !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );\n};\n\n\n\n\njQuery.ajaxSettings.xhr = function() {\n\ttry {\n\t\treturn new window.XMLHttpRequest();\n\t} catch ( e ) {}\n};\n\nvar xhrSuccessStatus = {\n\n\t\t// File protocol always yields status code 0, assume 200\n\t\t0: 200,\n\n\t\t// Support: IE <=9 only\n\t\t// #1450: sometimes IE returns 1223 when it should be 204\n\t\t1223: 204\n\t},\n\txhrSupported = jQuery.ajaxSettings.xhr();\n\nsupport.cors = !!xhrSupported && ( \"withCredentials\" in xhrSupported );\nsupport.ajax = xhrSupported = !!xhrSupported;\n\njQuery.ajaxTransport( function( options ) {\n\tvar callback, errorCallback;\n\n\t// Cross domain only allowed if supported through XMLHttpRequest\n\tif ( support.cors || xhrSupported && !options.crossDomain ) {\n\t\treturn {\n\t\t\tsend: function( headers, complete ) {\n\t\t\t\tvar i,\n\t\t\t\t\txhr = options.xhr();\n\n\t\t\t\txhr.open(\n\t\t\t\t\toptions.type,\n\t\t\t\t\toptions.url,\n\t\t\t\t\toptions.async,\n\t\t\t\t\toptions.username,\n\t\t\t\t\toptions.password\n\t\t\t\t);\n\n\t\t\t\t// Apply custom fields if provided\n\t\t\t\tif ( options.xhrFields ) {\n\t\t\t\t\tfor ( i in options.xhrFields ) {\n\t\t\t\t\t\txhr[ i ] = options.xhrFields[ i ];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Override mime type if needed\n\t\t\t\tif ( options.mimeType && xhr.overrideMimeType ) {\n\t\t\t\t\txhr.overrideMimeType( options.mimeType );\n\t\t\t\t}\n\n\t\t\t\t// X-Requested-With header\n\t\t\t\t// For cross-domain requests, seeing as conditions for a preflight are\n\t\t\t\t// akin to a jigsaw puzzle, we simply never set it to be sure.\n\t\t\t\t// (it can always be set on a per-request basis or even using ajaxSetup)\n\t\t\t\t// For same-domain requests, won't change header if already provided.\n\t\t\t\tif ( !options.crossDomain && !headers[ \"X-Requested-With\" ] ) {\n\t\t\t\t\theaders[ \"X-Requested-With\" ] = \"XMLHttpRequest\";\n\t\t\t\t}\n\n\t\t\t\t// Set headers\n\t\t\t\tfor ( i in headers ) {\n\t\t\t\t\txhr.setRequestHeader( i, headers[ i ] );\n\t\t\t\t}\n\n\t\t\t\t// Callback\n\t\t\t\tcallback = function( type ) {\n\t\t\t\t\treturn function() {\n\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\tcallback = errorCallback = xhr.onload =\n\t\t\t\t\t\t\t\txhr.onerror = xhr.onabort = xhr.ontimeout =\n\t\t\t\t\t\t\t\t\txhr.onreadystatechange = null;\n\n\t\t\t\t\t\t\tif ( type === \"abort\" ) {\n\t\t\t\t\t\t\t\txhr.abort();\n\t\t\t\t\t\t\t} else if ( type === \"error\" ) {\n\n\t\t\t\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t\t\t\t// On a manual native abort, IE9 throws\n\t\t\t\t\t\t\t\t// errors on any property access that is not readyState\n\t\t\t\t\t\t\t\tif ( typeof xhr.status !== \"number\" ) {\n\t\t\t\t\t\t\t\t\tcomplete( 0, \"error\" );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcomplete(\n\n\t\t\t\t\t\t\t\t\t\t// File: protocol always yields status 0; see #8605, #14207\n\t\t\t\t\t\t\t\t\t\txhr.status,\n\t\t\t\t\t\t\t\t\t\txhr.statusText\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcomplete(\n\t\t\t\t\t\t\t\t\txhrSuccessStatus[ xhr.status ] || xhr.status,\n\t\t\t\t\t\t\t\t\txhr.statusText,\n\n\t\t\t\t\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t\t\t\t\t// IE9 has no XHR2 but throws on binary (trac-11426)\n\t\t\t\t\t\t\t\t\t// For XHR2 non-text, let the caller handle it (gh-2498)\n\t\t\t\t\t\t\t\t\t( xhr.responseType || \"text\" ) !== \"text\"  ||\n\t\t\t\t\t\t\t\t\ttypeof xhr.responseText !== \"string\" ?\n\t\t\t\t\t\t\t\t\t\t{ binary: xhr.response } :\n\t\t\t\t\t\t\t\t\t\t{ text: xhr.responseText },\n\t\t\t\t\t\t\t\t\txhr.getAllResponseHeaders()\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t};\n\n\t\t\t\t// Listen to events\n\t\t\t\txhr.onload = callback();\n\t\t\t\terrorCallback = xhr.onerror = xhr.ontimeout = callback( \"error\" );\n\n\t\t\t\t// Support: IE 9 only\n\t\t\t\t// Use onreadystatechange to replace onabort\n\t\t\t\t// to handle uncaught aborts\n\t\t\t\tif ( xhr.onabort !== undefined ) {\n\t\t\t\t\txhr.onabort = errorCallback;\n\t\t\t\t} else {\n\t\t\t\t\txhr.onreadystatechange = function() {\n\n\t\t\t\t\t\t// Check readyState before timeout as it changes\n\t\t\t\t\t\tif ( xhr.readyState === 4 ) {\n\n\t\t\t\t\t\t\t// Allow onerror to be called first,\n\t\t\t\t\t\t\t// but that will not handle a native abort\n\t\t\t\t\t\t\t// Also, save errorCallback to a variable\n\t\t\t\t\t\t\t// as xhr.onerror cannot be accessed\n\t\t\t\t\t\t\twindow.setTimeout( function() {\n\t\t\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\t\t\terrorCallback();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t// Create the abort callback\n\t\t\t\tcallback = callback( \"abort\" );\n\n\t\t\t\ttry {\n\n\t\t\t\t\t// Do send the request (this may raise an exception)\n\t\t\t\t\txhr.send( options.hasContent && options.data || null );\n\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\t// #14683: Only rethrow if this hasn't been notified as an error yet\n\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tabort: function() {\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n} );\n\n\n\n\n// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)\njQuery.ajaxPrefilter( function( s ) {\n\tif ( s.crossDomain ) {\n\t\ts.contents.script = false;\n\t}\n} );\n\n// Install script dataType\njQuery.ajaxSetup( {\n\taccepts: {\n\t\tscript: \"text/javascript, application/javascript, \" +\n\t\t\t\"application/ecmascript, application/x-ecmascript\"\n\t},\n\tcontents: {\n\t\tscript: /\\b(?:java|ecma)script\\b/\n\t},\n\tconverters: {\n\t\t\"text script\": function( text ) {\n\t\t\tjQuery.globalEval( text );\n\t\t\treturn text;\n\t\t}\n\t}\n} );\n\n// Handle cache's special case and crossDomain\njQuery.ajaxPrefilter( \"script\", function( s ) {\n\tif ( s.cache === undefined ) {\n\t\ts.cache = false;\n\t}\n\tif ( s.crossDomain ) {\n\t\ts.type = \"GET\";\n\t}\n} );\n\n// Bind script tag hack transport\njQuery.ajaxTransport( \"script\", function( s ) {\n\n\t// This transport only deals with cross domain requests\n\tif ( s.crossDomain ) {\n\t\tvar script, callback;\n\t\treturn {\n\t\t\tsend: function( _, complete ) {\n\t\t\t\tscript = jQuery( \"<script>\" ).prop( {\n\t\t\t\t\tcharset: s.scriptCharset,\n\t\t\t\t\tsrc: s.url\n\t\t\t\t} ).on(\n\t\t\t\t\t\"load error\",\n\t\t\t\t\tcallback = function( evt ) {\n\t\t\t\t\t\tscript.remove();\n\t\t\t\t\t\tcallback = null;\n\t\t\t\t\t\tif ( evt ) {\n\t\t\t\t\t\t\tcomplete( evt.type === \"error\" ? 404 : 200, evt.type );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\t// Use native DOM manipulation to avoid our domManip AJAX trickery\n\t\t\t\tdocument.head.appendChild( script[ 0 ] );\n\t\t\t},\n\t\t\tabort: function() {\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n} );\n\n\n\n\nvar oldCallbacks = [],\n\trjsonp = /(=)\\?(?=&|$)|\\?\\?/;\n\n// Default jsonp settings\njQuery.ajaxSetup( {\n\tjsonp: \"callback\",\n\tjsonpCallback: function() {\n\t\tvar callback = oldCallbacks.pop() || ( jQuery.expando + \"_\" + ( nonce++ ) );\n\t\tthis[ callback ] = true;\n\t\treturn callback;\n\t}\n} );\n\n// Detect, normalize options and install callbacks for jsonp requests\njQuery.ajaxPrefilter( \"json jsonp\", function( s, originalSettings, jqXHR ) {\n\n\tvar callbackName, overwritten, responseContainer,\n\t\tjsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?\n\t\t\t\"url\" :\n\t\t\ttypeof s.data === \"string\" &&\n\t\t\t\t( s.contentType || \"\" )\n\t\t\t\t\t.indexOf( \"application/x-www-form-urlencoded\" ) === 0 &&\n\t\t\t\trjsonp.test( s.data ) && \"data\"\n\t\t);\n\n\t// Handle iff the expected data type is \"jsonp\" or we have a parameter to set\n\tif ( jsonProp || s.dataTypes[ 0 ] === \"jsonp\" ) {\n\n\t\t// Get callback name, remembering preexisting value associated with it\n\t\tcallbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?\n\t\t\ts.jsonpCallback() :\n\t\t\ts.jsonpCallback;\n\n\t\t// Insert callback into url or form data\n\t\tif ( jsonProp ) {\n\t\t\ts[ jsonProp ] = s[ jsonProp ].replace( rjsonp, \"$1\" + callbackName );\n\t\t} else if ( s.jsonp !== false ) {\n\t\t\ts.url += ( rquery.test( s.url ) ? \"&\" : \"?\" ) + s.jsonp + \"=\" + callbackName;\n\t\t}\n\n\t\t// Use data converter to retrieve json after script execution\n\t\ts.converters[ \"script json\" ] = function() {\n\t\t\tif ( !responseContainer ) {\n\t\t\t\tjQuery.error( callbackName + \" was not called\" );\n\t\t\t}\n\t\t\treturn responseContainer[ 0 ];\n\t\t};\n\n\t\t// Force json dataType\n\t\ts.dataTypes[ 0 ] = \"json\";\n\n\t\t// Install callback\n\t\toverwritten = window[ callbackName ];\n\t\twindow[ callbackName ] = function() {\n\t\t\tresponseContainer = arguments;\n\t\t};\n\n\t\t// Clean-up function (fires after converters)\n\t\tjqXHR.always( function() {\n\n\t\t\t// If previous value didn't exist - remove it\n\t\t\tif ( overwritten === undefined ) {\n\t\t\t\tjQuery( window ).removeProp( callbackName );\n\n\t\t\t// Otherwise restore preexisting value\n\t\t\t} else {\n\t\t\t\twindow[ callbackName ] = overwritten;\n\t\t\t}\n\n\t\t\t// Save back as free\n\t\t\tif ( s[ callbackName ] ) {\n\n\t\t\t\t// Make sure that re-using the options doesn't screw things around\n\t\t\t\ts.jsonpCallback = originalSettings.jsonpCallback;\n\n\t\t\t\t// Save the callback name for future use\n\t\t\t\toldCallbacks.push( callbackName );\n\t\t\t}\n\n\t\t\t// Call if it was a function and we have a response\n\t\t\tif ( responseContainer && isFunction( overwritten ) ) {\n\t\t\t\toverwritten( responseContainer[ 0 ] );\n\t\t\t}\n\n\t\t\tresponseContainer = overwritten = undefined;\n\t\t} );\n\n\t\t// Delegate to script\n\t\treturn \"script\";\n\t}\n} );\n\n\n\n\n// Support: Safari 8 only\n// In Safari 8 documents created via document.implementation.createHTMLDocument\n// collapse sibling forms: the second one becomes a child of the first one.\n// Because of that, this security measure has to be disabled in Safari 8.\n// https://bugs.webkit.org/show_bug.cgi?id=137337\nsupport.createHTMLDocument = ( function() {\n\tvar body = document.implementation.createHTMLDocument( \"\" ).body;\n\tbody.innerHTML = \"<form></form><form></form>\";\n\treturn body.childNodes.length === 2;\n} )();\n\n\n// Argument \"data\" should be string of html\n// context (optional): If specified, the fragment will be created in this context,\n// defaults to document\n// keepScripts (optional): If true, will include scripts passed in the html string\njQuery.parseHTML = function( data, context, keepScripts ) {\n\tif ( typeof data !== \"string\" ) {\n\t\treturn [];\n\t}\n\tif ( typeof context === \"boolean\" ) {\n\t\tkeepScripts = context;\n\t\tcontext = false;\n\t}\n\n\tvar base, parsed, scripts;\n\n\tif ( !context ) {\n\n\t\t// Stop scripts or inline event handlers from being executed immediately\n\t\t// by using document.implementation\n\t\tif ( support.createHTMLDocument ) {\n\t\t\tcontext = document.implementation.createHTMLDocument( \"\" );\n\n\t\t\t// Set the base href for the created document\n\t\t\t// so any parsed elements with URLs\n\t\t\t// are based on the document's URL (gh-2965)\n\t\t\tbase = context.createElement( \"base\" );\n\t\t\tbase.href = document.location.href;\n\t\t\tcontext.head.appendChild( base );\n\t\t} else {\n\t\t\tcontext = document;\n\t\t}\n\t}\n\n\tparsed = rsingleTag.exec( data );\n\tscripts = !keepScripts && [];\n\n\t// Single tag\n\tif ( parsed ) {\n\t\treturn [ context.createElement( parsed[ 1 ] ) ];\n\t}\n\n\tparsed = buildFragment( [ data ], context, scripts );\n\n\tif ( scripts && scripts.length ) {\n\t\tjQuery( scripts ).remove();\n\t}\n\n\treturn jQuery.merge( [], parsed.childNodes );\n};\n\n\n/**\n * Load a url into a page\n */\njQuery.fn.load = function( url, params, callback ) {\n\tvar selector, type, response,\n\t\tself = this,\n\t\toff = url.indexOf( \" \" );\n\n\tif ( off > -1 ) {\n\t\tselector = stripAndCollapse( url.slice( off ) );\n\t\turl = url.slice( 0, off );\n\t}\n\n\t// If it's a function\n\tif ( isFunction( params ) ) {\n\n\t\t// We assume that it's the callback\n\t\tcallback = params;\n\t\tparams = undefined;\n\n\t// Otherwise, build a param string\n\t} else if ( params && typeof params === \"object\" ) {\n\t\ttype = \"POST\";\n\t}\n\n\t// If we have elements to modify, make the request\n\tif ( self.length > 0 ) {\n\t\tjQuery.ajax( {\n\t\t\turl: url,\n\n\t\t\t// If \"type\" variable is undefined, then \"GET\" method will be used.\n\t\t\t// Make value of this field explicit since\n\t\t\t// user can override it through ajaxSetup method\n\t\t\ttype: type || \"GET\",\n\t\t\tdataType: \"html\",\n\t\t\tdata: params\n\t\t} ).done( function( responseText ) {\n\n\t\t\t// Save response for use in complete callback\n\t\t\tresponse = arguments;\n\n\t\t\tself.html( selector ?\n\n\t\t\t\t// If a selector was specified, locate the right elements in a dummy div\n\t\t\t\t// Exclude scripts to avoid IE 'Permission Denied' errors\n\t\t\t\tjQuery( \"<div>\" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :\n\n\t\t\t\t// Otherwise use the full result\n\t\t\t\tresponseText );\n\n\t\t// If the request succeeds, this function gets \"data\", \"status\", \"jqXHR\"\n\t\t// but they are ignored because response was set above.\n\t\t// If it fails, this function gets \"jqXHR\", \"status\", \"error\"\n\t\t} ).always( callback && function( jqXHR, status ) {\n\t\t\tself.each( function() {\n\t\t\t\tcallback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );\n\t\t\t} );\n\t\t} );\n\t}\n\n\treturn this;\n};\n\n\n\n\n// Attach a bunch of functions for handling common AJAX events\njQuery.each( [\n\t\"ajaxStart\",\n\t\"ajaxStop\",\n\t\"ajaxComplete\",\n\t\"ajaxError\",\n\t\"ajaxSuccess\",\n\t\"ajaxSend\"\n], function( i, type ) {\n\tjQuery.fn[ type ] = function( fn ) {\n\t\treturn this.on( type, fn );\n\t};\n} );\n\n\n\n\njQuery.expr.pseudos.animated = function( elem ) {\n\treturn jQuery.grep( jQuery.timers, function( fn ) {\n\t\treturn elem === fn.elem;\n\t} ).length;\n};\n\n\n\n\njQuery.offset = {\n\tsetOffset: function( elem, options, i ) {\n\t\tvar curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,\n\t\t\tposition = jQuery.css( elem, \"position\" ),\n\t\t\tcurElem = jQuery( elem ),\n\t\t\tprops = {};\n\n\t\t// Set position first, in-case top/left are set even on static elem\n\t\tif ( position === \"static\" ) {\n\t\t\telem.style.position = \"relative\";\n\t\t}\n\n\t\tcurOffset = curElem.offset();\n\t\tcurCSSTop = jQuery.css( elem, \"top\" );\n\t\tcurCSSLeft = jQuery.css( elem, \"left\" );\n\t\tcalculatePosition = ( position === \"absolute\" || position === \"fixed\" ) &&\n\t\t\t( curCSSTop + curCSSLeft ).indexOf( \"auto\" ) > -1;\n\n\t\t// Need to be able to calculate position if either\n\t\t// top or left is auto and position is either absolute or fixed\n\t\tif ( calculatePosition ) {\n\t\t\tcurPosition = curElem.position();\n\t\t\tcurTop = curPosition.top;\n\t\t\tcurLeft = curPosition.left;\n\n\t\t} else {\n\t\t\tcurTop = parseFloat( curCSSTop ) || 0;\n\t\t\tcurLeft = parseFloat( curCSSLeft ) || 0;\n\t\t}\n\n\t\tif ( isFunction( options ) ) {\n\n\t\t\t// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)\n\t\t\toptions = options.call( elem, i, jQuery.extend( {}, curOffset ) );\n\t\t}\n\n\t\tif ( options.top != null ) {\n\t\t\tprops.top = ( options.top - curOffset.top ) + curTop;\n\t\t}\n\t\tif ( options.left != null ) {\n\t\t\tprops.left = ( options.left - curOffset.left ) + curLeft;\n\t\t}\n\n\t\tif ( \"using\" in options ) {\n\t\t\toptions.using.call( elem, props );\n\n\t\t} else {\n\t\t\tcurElem.css( props );\n\t\t}\n\t}\n};\n\njQuery.fn.extend( {\n\n\t// offset() relates an element's border box to the document origin\n\toffset: function( options ) {\n\n\t\t// Preserve chaining for setter\n\t\tif ( arguments.length ) {\n\t\t\treturn options === undefined ?\n\t\t\t\tthis :\n\t\t\t\tthis.each( function( i ) {\n\t\t\t\t\tjQuery.offset.setOffset( this, options, i );\n\t\t\t\t} );\n\t\t}\n\n\t\tvar rect, win,\n\t\t\telem = this[ 0 ];\n\n\t\tif ( !elem ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Return zeros for disconnected and hidden (display: none) elements (gh-2310)\n\t\t// Support: IE <=11 only\n\t\t// Running getBoundingClientRect on a\n\t\t// disconnected node in IE throws an error\n\t\tif ( !elem.getClientRects().length ) {\n\t\t\treturn { top: 0, left: 0 };\n\t\t}\n\n\t\t// Get document-relative position by adding viewport scroll to viewport-relative gBCR\n\t\trect = elem.getBoundingClientRect();\n\t\twin = elem.ownerDocument.defaultView;\n\t\treturn {\n\t\t\ttop: rect.top + win.pageYOffset,\n\t\t\tleft: rect.left + win.pageXOffset\n\t\t};\n\t},\n\n\t// position() relates an element's margin box to its offset parent's padding box\n\t// This corresponds to the behavior of CSS absolute positioning\n\tposition: function() {\n\t\tif ( !this[ 0 ] ) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar offsetParent, offset, doc,\n\t\t\telem = this[ 0 ],\n\t\t\tparentOffset = { top: 0, left: 0 };\n\n\t\t// position:fixed elements are offset from the viewport, which itself always has zero offset\n\t\tif ( jQuery.css( elem, \"position\" ) === \"fixed\" ) {\n\n\t\t\t// Assume position:fixed implies availability of getBoundingClientRect\n\t\t\toffset = elem.getBoundingClientRect();\n\n\t\t} else {\n\t\t\toffset = this.offset();\n\n\t\t\t// Account for the *real* offset parent, which can be the document or its root element\n\t\t\t// when a statically positioned element is identified\n\t\t\tdoc = elem.ownerDocument;\n\t\t\toffsetParent = elem.offsetParent || doc.documentElement;\n\t\t\twhile ( offsetParent &&\n\t\t\t\t( offsetParent === doc.body || offsetParent === doc.documentElement ) &&\n\t\t\t\tjQuery.css( offsetParent, \"position\" ) === \"static\" ) {\n\n\t\t\t\toffsetParent = offsetParent.parentNode;\n\t\t\t}\n\t\t\tif ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {\n\n\t\t\t\t// Incorporate borders into its offset, since they are outside its content origin\n\t\t\t\tparentOffset = jQuery( offsetParent ).offset();\n\t\t\t\tparentOffset.top += jQuery.css( offsetParent, \"borderTopWidth\", true );\n\t\t\t\tparentOffset.left += jQuery.css( offsetParent, \"borderLeftWidth\", true );\n\t\t\t}\n\t\t}\n\n\t\t// Subtract parent offsets and element margins\n\t\treturn {\n\t\t\ttop: offset.top - parentOffset.top - jQuery.css( elem, \"marginTop\", true ),\n\t\t\tleft: offset.left - parentOffset.left - jQuery.css( elem, \"marginLeft\", true )\n\t\t};\n\t},\n\n\t// This method will return documentElement in the following cases:\n\t// 1) For the element inside the iframe without offsetParent, this method will return\n\t//    documentElement of the parent window\n\t// 2) For the hidden or detached element\n\t// 3) For body or html element, i.e. in case of the html node - it will return itself\n\t//\n\t// but those exceptions were never presented as a real life use-cases\n\t// and might be considered as more preferable results.\n\t//\n\t// This logic, however, is not guaranteed and can change at any point in the future\n\toffsetParent: function() {\n\t\treturn this.map( function() {\n\t\t\tvar offsetParent = this.offsetParent;\n\n\t\t\twhile ( offsetParent && jQuery.css( offsetParent, \"position\" ) === \"static\" ) {\n\t\t\t\toffsetParent = offsetParent.offsetParent;\n\t\t\t}\n\n\t\t\treturn offsetParent || documentElement;\n\t\t} );\n\t}\n} );\n\n// Create scrollLeft and scrollTop methods\njQuery.each( { scrollLeft: \"pageXOffset\", scrollTop: \"pageYOffset\" }, function( method, prop ) {\n\tvar top = \"pageYOffset\" === prop;\n\n\tjQuery.fn[ method ] = function( val ) {\n\t\treturn access( this, function( elem, method, val ) {\n\n\t\t\t// Coalesce documents and windows\n\t\t\tvar win;\n\t\t\tif ( isWindow( elem ) ) {\n\t\t\t\twin = elem;\n\t\t\t} else if ( elem.nodeType === 9 ) {\n\t\t\t\twin = elem.defaultView;\n\t\t\t}\n\n\t\t\tif ( val === undefined ) {\n\t\t\t\treturn win ? win[ prop ] : elem[ method ];\n\t\t\t}\n\n\t\t\tif ( win ) {\n\t\t\t\twin.scrollTo(\n\t\t\t\t\t!top ? val : win.pageXOffset,\n\t\t\t\t\ttop ? val : win.pageYOffset\n\t\t\t\t);\n\n\t\t\t} else {\n\t\t\t\telem[ method ] = val;\n\t\t\t}\n\t\t}, method, val, arguments.length );\n\t};\n} );\n\n// Support: Safari <=7 - 9.1, Chrome <=37 - 49\n// Add the top/left cssHooks using jQuery.fn.position\n// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\n// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347\n// getComputedStyle returns percent when specified for top/left/bottom/right;\n// rather than make the css module depend on the offset module, just check for it here\njQuery.each( [ \"top\", \"left\" ], function( i, prop ) {\n\tjQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,\n\t\tfunction( elem, computed ) {\n\t\t\tif ( computed ) {\n\t\t\t\tcomputed = curCSS( elem, prop );\n\n\t\t\t\t// If curCSS returns percentage, fallback to offset\n\t\t\t\treturn rnumnonpx.test( computed ) ?\n\t\t\t\t\tjQuery( elem ).position()[ prop ] + \"px\" :\n\t\t\t\t\tcomputed;\n\t\t\t}\n\t\t}\n\t);\n} );\n\n\n// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\njQuery.each( { Height: \"height\", Width: \"width\" }, function( name, type ) {\n\tjQuery.each( { padding: \"inner\" + name, content: type, \"\": \"outer\" + name },\n\t\tfunction( defaultExtra, funcName ) {\n\n\t\t// Margin is only for outerHeight, outerWidth\n\t\tjQuery.fn[ funcName ] = function( margin, value ) {\n\t\t\tvar chainable = arguments.length && ( defaultExtra || typeof margin !== \"boolean\" ),\n\t\t\t\textra = defaultExtra || ( margin === true || value === true ? \"margin\" : \"border\" );\n\n\t\t\treturn access( this, function( elem, type, value ) {\n\t\t\t\tvar doc;\n\n\t\t\t\tif ( isWindow( elem ) ) {\n\n\t\t\t\t\t// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)\n\t\t\t\t\treturn funcName.indexOf( \"outer\" ) === 0 ?\n\t\t\t\t\t\telem[ \"inner\" + name ] :\n\t\t\t\t\t\telem.document.documentElement[ \"client\" + name ];\n\t\t\t\t}\n\n\t\t\t\t// Get document width or height\n\t\t\t\tif ( elem.nodeType === 9 ) {\n\t\t\t\t\tdoc = elem.documentElement;\n\n\t\t\t\t\t// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\n\t\t\t\t\t// whichever is greatest\n\t\t\t\t\treturn Math.max(\n\t\t\t\t\t\telem.body[ \"scroll\" + name ], doc[ \"scroll\" + name ],\n\t\t\t\t\t\telem.body[ \"offset\" + name ], doc[ \"offset\" + name ],\n\t\t\t\t\t\tdoc[ \"client\" + name ]\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\treturn value === undefined ?\n\n\t\t\t\t\t// Get width or height on the element, requesting but not forcing parseFloat\n\t\t\t\t\tjQuery.css( elem, type, extra ) :\n\n\t\t\t\t\t// Set width or height on the element\n\t\t\t\t\tjQuery.style( elem, type, value, extra );\n\t\t\t}, type, chainable ? margin : undefined, chainable );\n\t\t};\n\t} );\n} );\n\n\njQuery.each( ( \"blur focus focusin focusout resize scroll click dblclick \" +\n\t\"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" +\n\t\"change select submit keydown keypress keyup contextmenu\" ).split( \" \" ),\n\tfunction( i, name ) {\n\n\t// Handle event binding\n\tjQuery.fn[ name ] = function( data, fn ) {\n\t\treturn arguments.length > 0 ?\n\t\t\tthis.on( name, null, data, fn ) :\n\t\t\tthis.trigger( name );\n\t};\n} );\n\njQuery.fn.extend( {\n\thover: function( fnOver, fnOut ) {\n\t\treturn this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );\n\t}\n} );\n\n\n\n\njQuery.fn.extend( {\n\n\tbind: function( types, data, fn ) {\n\t\treturn this.on( types, null, data, fn );\n\t},\n\tunbind: function( types, fn ) {\n\t\treturn this.off( types, null, fn );\n\t},\n\n\tdelegate: function( selector, types, data, fn ) {\n\t\treturn this.on( types, selector, data, fn );\n\t},\n\tundelegate: function( selector, types, fn ) {\n\n\t\t// ( namespace ) or ( selector, types [, fn] )\n\t\treturn arguments.length === 1 ?\n\t\t\tthis.off( selector, \"**\" ) :\n\t\t\tthis.off( types, selector || \"**\", fn );\n\t}\n} );\n\n// Bind a function to a context, optionally partially applying any\n// arguments.\n// jQuery.proxy is deprecated to promote standards (specifically Function#bind)\n// However, it is not slated for removal any time soon\njQuery.proxy = function( fn, context ) {\n\tvar tmp, args, proxy;\n\n\tif ( typeof context === \"string\" ) {\n\t\ttmp = fn[ context ];\n\t\tcontext = fn;\n\t\tfn = tmp;\n\t}\n\n\t// Quick check to determine if target is callable, in the spec\n\t// this throws a TypeError, but we will just return undefined.\n\tif ( !isFunction( fn ) ) {\n\t\treturn undefined;\n\t}\n\n\t// Simulated bind\n\targs = slice.call( arguments, 2 );\n\tproxy = function() {\n\t\treturn fn.apply( context || this, args.concat( slice.call( arguments ) ) );\n\t};\n\n\t// Set the guid of unique handler to the same of original handler, so it can be removed\n\tproxy.guid = fn.guid = fn.guid || jQuery.guid++;\n\n\treturn proxy;\n};\n\njQuery.holdReady = function( hold ) {\n\tif ( hold ) {\n\t\tjQuery.readyWait++;\n\t} else {\n\t\tjQuery.ready( true );\n\t}\n};\njQuery.isArray = Array.isArray;\njQuery.parseJSON = JSON.parse;\njQuery.nodeName = nodeName;\njQuery.isFunction = isFunction;\njQuery.isWindow = isWindow;\njQuery.camelCase = camelCase;\njQuery.type = toType;\n\njQuery.now = Date.now;\n\njQuery.isNumeric = function( obj ) {\n\n\t// As of jQuery 3.0, isNumeric is limited to\n\t// strings and numbers (primitives or objects)\n\t// that can be coerced to finite numbers (gh-2662)\n\tvar type = jQuery.type( obj );\n\treturn ( type === \"number\" || type === \"string\" ) &&\n\n\t\t// parseFloat NaNs numeric-cast false positives (\"\")\n\t\t// ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n\t\t// subtraction forces infinities to NaN\n\t\t!isNaN( obj - parseFloat( obj ) );\n};\n\n\n\n\n// Register as a named AMD module, since jQuery can be concatenated with other\n// files that may use define, but not via a proper concatenation script that\n// understands anonymous AMD modules. A named AMD is safest and most robust\n// way to register. Lowercase jquery is used because AMD module names are\n// derived from file names, and jQuery is normally delivered in a lowercase\n// file name. Do this after creating the global so that if an AMD module wants\n// to call noConflict to hide this version of jQuery, it will work.\n\n// Note that for maximum portability, libraries that are not jQuery should\n// declare themselves as anonymous modules, and avoid setting a global if an\n// AMD loader is present. jQuery is a special case. For more information, see\n// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon\n\nif ( true ) {\n\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {\n\t\treturn jQuery;\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n}\n\n\n\n\nvar\n\n\t// Map over jQuery in case of overwrite\n\t_jQuery = window.jQuery,\n\n\t// Map over the $ in case of overwrite\n\t_$ = window.$;\n\njQuery.noConflict = function( deep ) {\n\tif ( window.$ === jQuery ) {\n\t\twindow.$ = _$;\n\t}\n\n\tif ( deep && window.jQuery === jQuery ) {\n\t\twindow.jQuery = _jQuery;\n\t}\n\n\treturn jQuery;\n};\n\n// Expose jQuery and $ identifiers, even in AMD\n// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)\n// and CommonJS for browser emulators (#13566)\nif ( !noGlobal ) {\n\twindow.jQuery = window.$ = jQuery;\n}\n\n\n\n\nreturn jQuery;\n} );\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/jquery/dist/jquery.js\n// module id = 1\n// module chunks = 0\n\n//# sourceURL=webpack:///./~/jquery/dist/jquery.js?");

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nfunction makeEmptyFunction(arg) {\n  return function () {\n    return arg;\n  };\n}\n\n/**\n * This function accepts and discards inputs; it has no side effects. This is\n * primarily useful idiomatically for overridable function endpoints which\n * always need to be callable, since JS lacks a null-call idiom ala Cocoa.\n */\nvar emptyFunction = function emptyFunction() {};\n\nemptyFunction.thatReturns = makeEmptyFunction;\nemptyFunction.thatReturnsFalse = makeEmptyFunction(false);\nemptyFunction.thatReturnsTrue = makeEmptyFunction(true);\nemptyFunction.thatReturnsNull = makeEmptyFunction(null);\nemptyFunction.thatReturnsThis = function () {\n  return this;\n};\nemptyFunction.thatReturnsArgument = function (arg) {\n  return arg;\n};\n\nmodule.exports = emptyFunction;\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/fbjs/lib/emptyFunction.js\n// module id = 2\n// module chunks = 0\n\n//# sourceURL=webpack:///./~/fbjs/lib/emptyFunction.js?");

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n/**\n * Use invariant() to assert state which your program assumes to be true.\n *\n * Provide sprintf-style format (only %s is supported) and arguments\n * to provide information about what broke and what you were\n * expecting.\n *\n * The invariant message will be stripped in production, but the invariant\n * will remain to ensure logic does not differ in production.\n */\n\nvar validateFormat = function validateFormat(format) {};\n\nif (process.env.NODE_ENV !== 'production') {\n  validateFormat = function validateFormat(format) {\n    if (format === undefined) {\n      throw new Error('invariant requires an error message argument');\n    }\n  };\n}\n\nfunction invariant(condition, format, a, b, c, d, e, f) {\n  validateFormat(format);\n\n  if (!condition) {\n    var error;\n    if (format === undefined) {\n      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');\n    } else {\n      var args = [a, b, c, d, e, f];\n      var argIndex = 0;\n      error = new Error(format.replace(/%s/g, function () {\n        return args[argIndex++];\n      }));\n      error.name = 'Invariant Violation';\n    }\n\n    error.framesToPop = 1; // we don't care about invariant's own frame\n    throw error;\n  }\n}\n\nmodule.exports = invariant;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/fbjs/lib/invariant.js\n// module id = 3\n// module chunks = 0\n\n//# sourceURL=webpack:///./~/fbjs/lib/invariant.js?");

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';\n\nmodule.exports = ReactPropTypesSecret;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/prop-types/lib/ReactPropTypesSecret.js\n// module id = 4\n// module chunks = 0\n\n//# sourceURL=webpack:///./~/prop-types/lib/ReactPropTypesSecret.js?");

/***/ }),
/* 5 */
/***/ (function(module, exports) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === \"string\")\n\t\t\tmodules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === \"number\")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === 'function') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n\treturn '/*# ' + data + ' */';\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader/lib/css-base.js\n// module id = 5\n// module chunks = 0\n\n//# sourceURL=webpack:///./~/css-loader/lib/css-base.js?");

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\nvar emptyFunction = __webpack_require__(2);\n\n/**\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\nvar warning = emptyFunction;\n\nif (process.env.NODE_ENV !== 'production') {\n  var printWarning = function printWarning(format) {\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    var argIndex = 0;\n    var message = 'Warning: ' + format.replace(/%s/g, function () {\n      return args[argIndex++];\n    });\n    if (typeof console !== 'undefined') {\n      console.error(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) {}\n  };\n\n  warning = function warning(condition, format) {\n    if (format === undefined) {\n      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');\n    }\n\n    if (format.indexOf('Failed Composite propType: ') === 0) {\n      return; // Ignore CompositeComponent proptype check.\n    }\n\n    if (!condition) {\n      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n        args[_key2 - 2] = arguments[_key2];\n      }\n\n      printWarning.apply(undefined, [format].concat(args));\n    }\n  };\n}\n\nmodule.exports = warning;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/fbjs/lib/warning.js\n// module id = 6\n// module chunks = 0\n\n//# sourceURL=webpack:///./~/fbjs/lib/warning.js?");

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\nvar stylesInDom = {},\n\tmemoize = function(fn) {\n\t\tvar memo;\n\t\treturn function () {\n\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\t\treturn memo;\n\t\t};\n\t},\n\tisOldIE = memoize(function() {\n\t\t// Test for IE <= 9 as proposed by Browserhacks\n\t\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t\t// Tests for existence of standard globals is to allow style-loader \n\t\t// to operate correctly into non-standard environments\n\t\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\t\treturn window && document && document.all && !window.atob;\n\t}),\n\tgetElement = (function(fn) {\n\t\tvar memo = {};\n\t\treturn function(selector) {\n\t\t\tif (typeof memo[selector] === \"undefined\") {\n\t\t\t\tmemo[selector] = fn.call(this, selector);\n\t\t\t}\n\t\t\treturn memo[selector]\n\t\t};\n\t})(function (styleTarget) {\n\t\treturn document.querySelector(styleTarget)\n\t}),\n\tsingletonElement = null,\n\tsingletonCounter = 0,\n\tstyleElementsInsertedAtTop = [],\n\tfixUrls = __webpack_require__(22);\n\nmodule.exports = function(list, options) {\n\tif(typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\toptions.attrs = typeof options.attrs === \"object\" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n\tif (typeof options.insertInto === \"undefined\") options.insertInto = \"head\";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (typeof options.insertAt === \"undefined\") options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list, options);\n\taddStylesToDom(styles, options);\n\n\treturn function update(newList) {\n\t\tvar mayRemove = [];\n\t\tfor(var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList, options);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\t\tfor(var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\n\t\t\t\t\tdomStyle.parts[j]();\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom(styles, options) {\n\tfor(var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles(list, options) {\n\tvar styles = [];\n\tvar newStyles = {};\n\tfor(var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = options.base ? item[0] + options.base : item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\t\tif(!newStyles[id])\n\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse\n\t\t\tnewStyles[id].parts.push(part);\n\t}\n\treturn styles;\n}\n\nfunction insertStyleElement(options, styleElement) {\n\tvar styleTarget = getElement(options.insertInto)\n\tif (!styleTarget) {\n\t\tthrow new Error(\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\");\n\t}\n\tvar lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];\n\tif (options.insertAt === \"top\") {\n\t\tif(!lastStyleElementInsertedAtTop) {\n\t\t\tstyleTarget.insertBefore(styleElement, styleTarget.firstChild);\n\t\t} else if(lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\tstyleTarget.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\tstyleTarget.appendChild(styleElement);\n\t\t}\n\t\tstyleElementsInsertedAtTop.push(styleElement);\n\t} else if (options.insertAt === \"bottom\") {\n\t\tstyleTarget.appendChild(styleElement);\n\t} else {\n\t\tthrow new Error(\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\");\n\t}\n}\n\nfunction removeStyleElement(styleElement) {\n\tstyleElement.parentNode.removeChild(styleElement);\n\tvar idx = styleElementsInsertedAtTop.indexOf(styleElement);\n\tif(idx >= 0) {\n\t\tstyleElementsInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement(options) {\n\tvar styleElement = document.createElement(\"style\");\n\toptions.attrs.type = \"text/css\";\n\n\tattachTagAttrs(styleElement, options.attrs);\n\tinsertStyleElement(options, styleElement);\n\treturn styleElement;\n}\n\nfunction createLinkElement(options) {\n\tvar linkElement = document.createElement(\"link\");\n\toptions.attrs.type = \"text/css\";\n\toptions.attrs.rel = \"stylesheet\";\n\n\tattachTagAttrs(linkElement, options.attrs);\n\tinsertStyleElement(options, linkElement);\n\treturn linkElement;\n}\n\nfunction attachTagAttrs(element, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\telement.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction addStyle(obj, options) {\n\tvar styleElement, update, remove, transformResult;\n\n\t// If a transform function was defined, run it on the css\n\tif (options.transform && obj.css) {\n\t    transformResult = options.transform(obj.css);\n\t    \n\t    if (transformResult) {\n\t    \t// If transform returns a value, use that instead of the original css.\n\t    \t// This allows running runtime transformations on the css.\n\t    \tobj.css = transformResult;\n\t    } else {\n\t    \t// If the transform function returns a falsy value, don't add this css. \n\t    \t// This allows conditional loading of css\n\t    \treturn function() {\n\t    \t\t// noop\n\t    \t};\n\t    }\n\t}\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\t\tstyleElement = singletonElement || (singletonElement = createStyleElement(options));\n\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\n\t} else if(obj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\") {\n\t\tstyleElement = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, styleElement, options);\n\t\tremove = function() {\n\t\t\tremoveStyleElement(styleElement);\n\t\t\tif(styleElement.href)\n\t\t\t\tURL.revokeObjectURL(styleElement.href);\n\t\t};\n\t} else {\n\t\tstyleElement = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, styleElement);\n\t\tremove = function() {\n\t\t\tremoveStyleElement(styleElement);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle(newObj) {\n\t\tif(newObj) {\n\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\n\t\t\t\treturn;\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag(styleElement, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (styleElement.styleSheet) {\n\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = styleElement.childNodes;\n\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\n\t\tif (childNodes.length) {\n\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyleElement.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag(styleElement, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyleElement.setAttribute(\"media\", media)\n\t}\n\n\tif(styleElement.styleSheet) {\n\t\tstyleElement.styleSheet.cssText = css;\n\t} else {\n\t\twhile(styleElement.firstChild) {\n\t\t\tstyleElement.removeChild(styleElement.firstChild);\n\t\t}\n\t\tstyleElement.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink(linkElement, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/* If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled\n\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls){\n\t\tcss = fixUrls(css);\n\t}\n\n\tif(sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = linkElement.href;\n\n\tlinkElement.href = URL.createObjectURL(blob);\n\n\tif(oldSrc)\n\t\tURL.revokeObjectURL(oldSrc);\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/style-loader/addStyles.js\n// module id = 7\n// module chunks = 0\n\n//# sourceURL=webpack:///./~/style-loader/addStyles.js?");

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(__webpack_provided_window_dot_jQuery, jQuery) {/**\n * Owl Carousel v2.2.0\n * Copyright 2013-2016 David Deutsch\n * Licensed under MIT (https://github.com/OwlCarousel2/OwlCarousel2/blob/master/LICENSE)\n */\n/**\n * Owl carousel\n * @version 2.1.6\n * @author Bartosz Wojciechowski\n * @author David Deutsch\n * @license The MIT License (MIT)\n * @todo Lazy Load Icon\n * @todo prevent animationend bubling\n * @todo itemsScaleUp\n * @todo Test Zepto\n * @todo stagePadding calculate wrong active classes\n */\n;(function($, window, document, undefined) {\n\n\t/**\n\t * Creates a carousel.\n\t * @class The Owl Carousel.\n\t * @public\n\t * @param {HTMLElement|jQuery} element - The element to create the carousel for.\n\t * @param {Object} [options] - The options\n\t */\n\tfunction Owl(element, options) {\n\n\t\t/**\n\t\t * Current settings for the carousel.\n\t\t * @public\n\t\t */\n\t\tthis.settings = null;\n\n\t\t/**\n\t\t * Current options set by the caller including defaults.\n\t\t * @public\n\t\t */\n\t\tthis.options = $.extend({}, Owl.Defaults, options);\n\n\t\t/**\n\t\t * Plugin element.\n\t\t * @public\n\t\t */\n\t\tthis.$element = $(element);\n\n\t\t/**\n\t\t * Proxied event handlers.\n\t\t * @protected\n\t\t */\n\t\tthis._handlers = {};\n\n\t\t/**\n\t\t * References to the running plugins of this carousel.\n\t\t * @protected\n\t\t */\n\t\tthis._plugins = {};\n\n\t\t/**\n\t\t * Currently suppressed events to prevent them from beeing retriggered.\n\t\t * @protected\n\t\t */\n\t\tthis._supress = {};\n\n\t\t/**\n\t\t * Absolute current position.\n\t\t * @protected\n\t\t */\n\t\tthis._current = null;\n\n\t\t/**\n\t\t * Animation speed in milliseconds.\n\t\t * @protected\n\t\t */\n\t\tthis._speed = null;\n\n\t\t/**\n\t\t * Coordinates of all items in pixel.\n\t\t * @todo The name of this member is missleading.\n\t\t * @protected\n\t\t */\n\t\tthis._coordinates = [];\n\n\t\t/**\n\t\t * Current breakpoint.\n\t\t * @todo Real media queries would be nice.\n\t\t * @protected\n\t\t */\n\t\tthis._breakpoint = null;\n\n\t\t/**\n\t\t * Current width of the plugin element.\n\t\t */\n\t\tthis._width = null;\n\n\t\t/**\n\t\t * All real items.\n\t\t * @protected\n\t\t */\n\t\tthis._items = [];\n\n\t\t/**\n\t\t * All cloned items.\n\t\t * @protected\n\t\t */\n\t\tthis._clones = [];\n\n\t\t/**\n\t\t * Merge values of all items.\n\t\t * @todo Maybe this could be part of a plugin.\n\t\t * @protected\n\t\t */\n\t\tthis._mergers = [];\n\n\t\t/**\n\t\t * Widths of all items.\n\t\t */\n\t\tthis._widths = [];\n\n\t\t/**\n\t\t * Invalidated parts within the update process.\n\t\t * @protected\n\t\t */\n\t\tthis._invalidated = {};\n\n\t\t/**\n\t\t * Ordered list of workers for the update process.\n\t\t * @protected\n\t\t */\n\t\tthis._pipe = [];\n\n\t\t/**\n\t\t * Current state information for the drag operation.\n\t\t * @todo #261\n\t\t * @protected\n\t\t */\n\t\tthis._drag = {\n\t\t\ttime: null,\n\t\t\ttarget: null,\n\t\t\tpointer: null,\n\t\t\tstage: {\n\t\t\t\tstart: null,\n\t\t\t\tcurrent: null\n\t\t\t},\n\t\t\tdirection: null\n\t\t};\n\n\t\t/**\n\t\t * Current state information and their tags.\n\t\t * @type {Object}\n\t\t * @protected\n\t\t */\n\t\tthis._states = {\n\t\t\tcurrent: {},\n\t\t\ttags: {\n\t\t\t\t'initializing': [ 'busy' ],\n\t\t\t\t'animating': [ 'busy' ],\n\t\t\t\t'dragging': [ 'interacting' ]\n\t\t\t}\n\t\t};\n\n\t\t$.each([ 'onResize', 'onThrottledResize' ], $.proxy(function(i, handler) {\n\t\t\tthis._handlers[handler] = $.proxy(this[handler], this);\n\t\t}, this));\n\n\t\t$.each(Owl.Plugins, $.proxy(function(key, plugin) {\n\t\t\tthis._plugins[key.charAt(0).toLowerCase() + key.slice(1)]\n\t\t\t\t= new plugin(this);\n\t\t}, this));\n\n\t\t$.each(Owl.Workers, $.proxy(function(priority, worker) {\n\t\t\tthis._pipe.push({\n\t\t\t\t'filter': worker.filter,\n\t\t\t\t'run': $.proxy(worker.run, this)\n\t\t\t});\n\t\t}, this));\n\n\t\tthis.setup();\n\t\tthis.initialize();\n\t}\n\n\t/**\n\t * Default options for the carousel.\n\t * @public\n\t */\n\tOwl.Defaults = {\n\t\titems: 3,\n\t\tloop: false,\n\t\tcenter: false,\n\t\trewind: false,\n\n\t\tmouseDrag: true,\n\t\ttouchDrag: true,\n\t\tpullDrag: true,\n\t\tfreeDrag: false,\n\n\t\tmargin: 0,\n\t\tstagePadding: 0,\n\n\t\tmerge: false,\n\t\tmergeFit: true,\n\t\tautoWidth: false,\n\n\t\tstartPosition: 0,\n\t\trtl: false,\n\n\t\tsmartSpeed: 250,\n\t\tfluidSpeed: false,\n\t\tdragEndSpeed: false,\n\n\t\tresponsive: {},\n\t\tresponsiveRefreshRate: 200,\n\t\tresponsiveBaseElement: window,\n\n\t\tfallbackEasing: 'swing',\n\n\t\tinfo: false,\n\n\t\tnestedItemSelector: false,\n\t\titemElement: 'div',\n\t\tstageElement: 'div',\n\n\t\trefreshClass: 'owl-refresh',\n\t\tloadedClass: 'owl-loaded',\n\t\tloadingClass: 'owl-loading',\n\t\trtlClass: 'owl-rtl',\n\t\tresponsiveClass: 'owl-responsive',\n\t\tdragClass: 'owl-drag',\n\t\titemClass: 'owl-item',\n\t\tstageClass: 'owl-stage',\n\t\tstageOuterClass: 'owl-stage-outer',\n\t\tgrabClass: 'owl-grab'\n\t};\n\n\t/**\n\t * Enumeration for width.\n\t * @public\n\t * @readonly\n\t * @enum {String}\n\t */\n\tOwl.Width = {\n\t\tDefault: 'default',\n\t\tInner: 'inner',\n\t\tOuter: 'outer'\n\t};\n\n\t/**\n\t * Enumeration for types.\n\t * @public\n\t * @readonly\n\t * @enum {String}\n\t */\n\tOwl.Type = {\n\t\tEvent: 'event',\n\t\tState: 'state'\n\t};\n\n\t/**\n\t * Contains all registered plugins.\n\t * @public\n\t */\n\tOwl.Plugins = {};\n\n\t/**\n\t * List of workers involved in the update process.\n\t */\n\tOwl.Workers = [ {\n\t\tfilter: [ 'width', 'settings' ],\n\t\trun: function() {\n\t\t\tthis._width = this.$element.width();\n\t\t}\n\t}, {\n\t\tfilter: [ 'width', 'items', 'settings' ],\n\t\trun: function(cache) {\n\t\t\tcache.current = this._items && this._items[this.relative(this._current)];\n\t\t}\n\t}, {\n\t\tfilter: [ 'items', 'settings' ],\n\t\trun: function() {\n\t\t\tthis.$stage.children('.cloned').remove();\n\t\t}\n\t}, {\n\t\tfilter: [ 'width', 'items', 'settings' ],\n\t\trun: function(cache) {\n\t\t\tvar margin = this.settings.margin || '',\n\t\t\t\tgrid = !this.settings.autoWidth,\n\t\t\t\trtl = this.settings.rtl,\n\t\t\t\tcss = {\n\t\t\t\t\t'width': 'auto',\n\t\t\t\t\t'margin-left': rtl ? margin : '',\n\t\t\t\t\t'margin-right': rtl ? '' : margin\n\t\t\t\t};\n\n\t\t\t!grid && this.$stage.children().css(css);\n\n\t\t\tcache.css = css;\n\t\t}\n\t}, {\n\t\tfilter: [ 'width', 'items', 'settings' ],\n\t\trun: function(cache) {\n\t\t\tvar width = (this.width() / this.settings.items).toFixed(3) - this.settings.margin,\n\t\t\t\tmerge = null,\n\t\t\t\titerator = this._items.length,\n\t\t\t\tgrid = !this.settings.autoWidth,\n\t\t\t\twidths = [];\n\n\t\t\tcache.items = {\n\t\t\t\tmerge: false,\n\t\t\t\twidth: width\n\t\t\t};\n\n\t\t\twhile (iterator--) {\n\t\t\t\tmerge = this._mergers[iterator];\n\t\t\t\tmerge = this.settings.mergeFit && Math.min(merge, this.settings.items) || merge;\n\n\t\t\t\tcache.items.merge = merge > 1 || cache.items.merge;\n\n\t\t\t\twidths[iterator] = !grid ? this._items[iterator].width() : width * merge;\n\t\t\t}\n\n\t\t\tthis._widths = widths;\n\t\t}\n\t}, {\n\t\tfilter: [ 'items', 'settings' ],\n\t\trun: function() {\n\t\t\tvar clones = [],\n\t\t\t\titems = this._items,\n\t\t\t\tsettings = this.settings,\n\t\t\t\tview = Math.max(settings.items * 2, 4),\n\t\t\t\tsize = Math.ceil(items.length / 2) * 2,\n\t\t\t\trepeat = settings.loop && items.length ? settings.rewind ? view : Math.max(view, size) : 0,\n\t\t\t\tappend = '',\n\t\t\t\tprepend = '';\n\n\t\t\trepeat /= 2;\n\n\t\t\twhile (repeat--) {\n\t\t\t\tclones.push(this.normalize(clones.length / 2, true));\n\t\t\t\tappend = append + items[clones[clones.length - 1]][0].outerHTML;\n\t\t\t\tclones.push(this.normalize(items.length - 1 - (clones.length - 1) / 2, true));\n\t\t\t\tprepend = items[clones[clones.length - 1]][0].outerHTML + prepend;\n\t\t\t}\n\n\t\t\tthis._clones = clones;\n\n\t\t\t$(append).addClass('cloned').appendTo(this.$stage);\n\t\t\t$(prepend).addClass('cloned').prependTo(this.$stage);\n\t\t}\n\t}, {\n\t\tfilter: [ 'width', 'items', 'settings' ],\n\t\trun: function() {\n\t\t\tvar rtl = this.settings.rtl ? 1 : -1,\n\t\t\t\tsize = this._clones.length + this._items.length,\n\t\t\t\titerator = -1,\n\t\t\t\tprevious = 0,\n\t\t\t\tcurrent = 0,\n\t\t\t\tcoordinates = [];\n\n\t\t\twhile (++iterator < size) {\n\t\t\t\tprevious = coordinates[iterator - 1] || 0;\n\t\t\t\tcurrent = this._widths[this.relative(iterator)] + this.settings.margin;\n\t\t\t\tcoordinates.push(previous + current * rtl);\n\t\t\t}\n\n\t\t\tthis._coordinates = coordinates;\n\t\t}\n\t}, {\n\t\tfilter: [ 'width', 'items', 'settings' ],\n\t\trun: function() {\n\t\t\tvar padding = this.settings.stagePadding,\n\t\t\t\tcoordinates = this._coordinates,\n\t\t\t\tcss = {\n\t\t\t\t\t'width': Math.ceil(Math.abs(coordinates[coordinates.length - 1])) + padding * 2,\n\t\t\t\t\t'padding-left': padding || '',\n\t\t\t\t\t'padding-right': padding || ''\n\t\t\t\t};\n\n\t\t\tthis.$stage.css(css);\n\t\t}\n\t}, {\n\t\tfilter: [ 'width', 'items', 'settings' ],\n\t\trun: function(cache) {\n\t\t\tvar iterator = this._coordinates.length,\n\t\t\t\tgrid = !this.settings.autoWidth,\n\t\t\t\titems = this.$stage.children();\n\n\t\t\tif (grid && cache.items.merge) {\n\t\t\t\twhile (iterator--) {\n\t\t\t\t\tcache.css.width = this._widths[this.relative(iterator)];\n\t\t\t\t\titems.eq(iterator).css(cache.css);\n\t\t\t\t}\n\t\t\t} else if (grid) {\n\t\t\t\tcache.css.width = cache.items.width;\n\t\t\t\titems.css(cache.css);\n\t\t\t}\n\t\t}\n\t}, {\n\t\tfilter: [ 'items' ],\n\t\trun: function() {\n\t\t\tthis._coordinates.length < 1 && this.$stage.removeAttr('style');\n\t\t}\n\t}, {\n\t\tfilter: [ 'width', 'items', 'settings' ],\n\t\trun: function(cache) {\n\t\t\tcache.current = cache.current ? this.$stage.children().index(cache.current) : 0;\n\t\t\tcache.current = Math.max(this.minimum(), Math.min(this.maximum(), cache.current));\n\t\t\tthis.reset(cache.current);\n\t\t}\n\t}, {\n\t\tfilter: [ 'position' ],\n\t\trun: function() {\n\t\t\tthis.animate(this.coordinates(this._current));\n\t\t}\n\t}, {\n\t\tfilter: [ 'width', 'position', 'items', 'settings' ],\n\t\trun: function() {\n\t\t\tvar rtl = this.settings.rtl ? 1 : -1,\n\t\t\t\tpadding = this.settings.stagePadding * 2,\n\t\t\t\tbegin = this.coordinates(this.current()) + padding,\n\t\t\t\tend = begin + this.width() * rtl,\n\t\t\t\tinner, outer, matches = [], i, n;\n\n\t\t\tfor (i = 0, n = this._coordinates.length; i < n; i++) {\n\t\t\t\tinner = this._coordinates[i - 1] || 0;\n\t\t\t\touter = Math.abs(this._coordinates[i]) + padding * rtl;\n\n\t\t\t\tif ((this.op(inner, '<=', begin) && (this.op(inner, '>', end)))\n\t\t\t\t\t|| (this.op(outer, '<', begin) && this.op(outer, '>', end))) {\n\t\t\t\t\tmatches.push(i);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.$stage.children('.active').removeClass('active');\n\t\t\tthis.$stage.children(':eq(' + matches.join('), :eq(') + ')').addClass('active');\n\n\t\t\tif (this.settings.center) {\n\t\t\t\tthis.$stage.children('.center').removeClass('center');\n\t\t\t\tthis.$stage.children().eq(this.current()).addClass('center');\n\t\t\t}\n\t\t}\n\t} ];\n\n\t/**\n\t * Initializes the carousel.\n\t * @protected\n\t */\n\tOwl.prototype.initialize = function() {\n\t\tthis.enter('initializing');\n\t\tthis.trigger('initialize');\n\n\t\tthis.$element.toggleClass(this.settings.rtlClass, this.settings.rtl);\n\n\t\tif (this.settings.autoWidth && !this.is('pre-loading')) {\n\t\t\tvar imgs, nestedSelector, width;\n\t\t\timgs = this.$element.find('img');\n\t\t\tnestedSelector = this.settings.nestedItemSelector ? '.' + this.settings.nestedItemSelector : undefined;\n\t\t\twidth = this.$element.children(nestedSelector).width();\n\n\t\t\tif (imgs.length && width <= 0) {\n\t\t\t\tthis.preloadAutoWidthImages(imgs);\n\t\t\t}\n\t\t}\n\n\t\tthis.$element.addClass(this.options.loadingClass);\n\n\t\t// create stage\n\t\tthis.$stage = $('<' + this.settings.stageElement + ' class=\"' + this.settings.stageClass + '\"/>')\n\t\t\t.wrap('<div class=\"' + this.settings.stageOuterClass + '\"/>');\n\n\t\t// append stage\n\t\tthis.$element.append(this.$stage.parent());\n\n\t\t// append content\n\t\tthis.replace(this.$element.children().not(this.$stage.parent()));\n\n\t\t// check visibility\n\t\tif (this.$element.is(':visible')) {\n\t\t\t// update view\n\t\t\tthis.refresh();\n\t\t} else {\n\t\t\t// invalidate width\n\t\t\tthis.invalidate('width');\n\t\t}\n\n\t\tthis.$element\n\t\t\t.removeClass(this.options.loadingClass)\n\t\t\t.addClass(this.options.loadedClass);\n\n\t\t// register event handlers\n\t\tthis.registerEventHandlers();\n\n\t\tthis.leave('initializing');\n\t\tthis.trigger('initialized');\n\t};\n\n\t/**\n\t * Setups the current settings.\n\t * @todo Remove responsive classes. Why should adaptive designs be brought into IE8?\n\t * @todo Support for media queries by using `matchMedia` would be nice.\n\t * @public\n\t */\n\tOwl.prototype.setup = function() {\n\t\tvar viewport = this.viewport(),\n\t\t\toverwrites = this.options.responsive,\n\t\t\tmatch = -1,\n\t\t\tsettings = null;\n\n\t\tif (!overwrites) {\n\t\t\tsettings = $.extend({}, this.options);\n\t\t} else {\n\t\t\t$.each(overwrites, function(breakpoint) {\n\t\t\t\tif (breakpoint <= viewport && breakpoint > match) {\n\t\t\t\t\tmatch = Number(breakpoint);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tsettings = $.extend({}, this.options, overwrites[match]);\n\t\t\tif (typeof settings.stagePadding === 'function') {\n\t\t\t\tsettings.stagePadding = settings.stagePadding();\n\t\t\t}\n\t\t\tdelete settings.responsive;\n\n\t\t\t// responsive class\n\t\t\tif (settings.responsiveClass) {\n\t\t\t\tthis.$element.attr('class',\n\t\t\t\t\tthis.$element.attr('class').replace(new RegExp('(' + this.options.responsiveClass + '-)\\\\S+\\\\s', 'g'), '$1' + match)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tthis.trigger('change', { property: { name: 'settings', value: settings } });\n\t\tthis._breakpoint = match;\n\t\tthis.settings = settings;\n\t\tthis.invalidate('settings');\n\t\tthis.trigger('changed', { property: { name: 'settings', value: this.settings } });\n\t};\n\n\t/**\n\t * Updates option logic if necessery.\n\t * @protected\n\t */\n\tOwl.prototype.optionsLogic = function() {\n\t\tif (this.settings.autoWidth) {\n\t\t\tthis.settings.stagePadding = false;\n\t\t\tthis.settings.merge = false;\n\t\t}\n\t};\n\n\t/**\n\t * Prepares an item before add.\n\t * @todo Rename event parameter `content` to `item`.\n\t * @protected\n\t * @returns {jQuery|HTMLElement} - The item container.\n\t */\n\tOwl.prototype.prepare = function(item) {\n\t\tvar event = this.trigger('prepare', { content: item });\n\n\t\tif (!event.data) {\n\t\t\tevent.data = $('<' + this.settings.itemElement + '/>')\n\t\t\t\t.addClass(this.options.itemClass).append(item)\n\t\t}\n\n\t\tthis.trigger('prepared', { content: event.data });\n\n\t\treturn event.data;\n\t};\n\n\t/**\n\t * Updates the view.\n\t * @public\n\t */\n\tOwl.prototype.update = function() {\n\t\tvar i = 0,\n\t\t\tn = this._pipe.length,\n\t\t\tfilter = $.proxy(function(p) { return this[p] }, this._invalidated),\n\t\t\tcache = {};\n\n\t\twhile (i < n) {\n\t\t\tif (this._invalidated.all || $.grep(this._pipe[i].filter, filter).length > 0) {\n\t\t\t\tthis._pipe[i].run(cache);\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\n\t\tthis._invalidated = {};\n\n\t\t!this.is('valid') && this.enter('valid');\n\t};\n\n\t/**\n\t * Gets the width of the view.\n\t * @public\n\t * @param {Owl.Width} [dimension=Owl.Width.Default] - The dimension to return.\n\t * @returns {Number} - The width of the view in pixel.\n\t */\n\tOwl.prototype.width = function(dimension) {\n\t\tdimension = dimension || Owl.Width.Default;\n\t\tswitch (dimension) {\n\t\t\tcase Owl.Width.Inner:\n\t\t\tcase Owl.Width.Outer:\n\t\t\t\treturn this._width;\n\t\t\tdefault:\n\t\t\t\treturn this._width - this.settings.stagePadding * 2 + this.settings.margin;\n\t\t}\n\t};\n\n\t/**\n\t * Refreshes the carousel primarily for adaptive purposes.\n\t * @public\n\t */\n\tOwl.prototype.refresh = function() {\n\t\tthis.enter('refreshing');\n\t\tthis.trigger('refresh');\n\n\t\tthis.setup();\n\n\t\tthis.optionsLogic();\n\n\t\tthis.$element.addClass(this.options.refreshClass);\n\n\t\tthis.update();\n\n\t\tthis.$element.removeClass(this.options.refreshClass);\n\n\t\tthis.leave('refreshing');\n\t\tthis.trigger('refreshed');\n\t};\n\n\t/**\n\t * Checks window `resize` event.\n\t * @protected\n\t */\n\tOwl.prototype.onThrottledResize = function() {\n\t\twindow.clearTimeout(this.resizeTimer);\n\t\tthis.resizeTimer = window.setTimeout(this._handlers.onResize, this.settings.responsiveRefreshRate);\n\t};\n\n\t/**\n\t * Checks window `resize` event.\n\t * @protected\n\t */\n\tOwl.prototype.onResize = function() {\n\t\tif (!this._items.length) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (this._width === this.$element.width()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!this.$element.is(':visible')) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.enter('resizing');\n\n\t\tif (this.trigger('resize').isDefaultPrevented()) {\n\t\t\tthis.leave('resizing');\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.invalidate('width');\n\n\t\tthis.refresh();\n\n\t\tthis.leave('resizing');\n\t\tthis.trigger('resized');\n\t};\n\n\t/**\n\t * Registers event handlers.\n\t * @todo Check `msPointerEnabled`\n\t * @todo #261\n\t * @protected\n\t */\n\tOwl.prototype.registerEventHandlers = function() {\n\t\tif ($.support.transition) {\n\t\t\tthis.$stage.on($.support.transition.end + '.owl.core', $.proxy(this.onTransitionEnd, this));\n\t\t}\n\n\t\tif (this.settings.responsive !== false) {\n\t\t\tthis.on(window, 'resize', this._handlers.onThrottledResize);\n\t\t}\n\n\t\tif (this.settings.mouseDrag) {\n\t\t\tthis.$element.addClass(this.options.dragClass);\n\t\t\tthis.$stage.on('mousedown.owl.core', $.proxy(this.onDragStart, this));\n\t\t\tthis.$stage.on('dragstart.owl.core selectstart.owl.core', function() { return false });\n\t\t}\n\n\t\tif (this.settings.touchDrag){\n\t\t\tthis.$stage.on('touchstart.owl.core', $.proxy(this.onDragStart, this));\n\t\t\tthis.$stage.on('touchcancel.owl.core', $.proxy(this.onDragEnd, this));\n\t\t}\n\t};\n\n\t/**\n\t * Handles `touchstart` and `mousedown` events.\n\t * @todo Horizontal swipe threshold as option\n\t * @todo #261\n\t * @protected\n\t * @param {Event} event - The event arguments.\n\t */\n\tOwl.prototype.onDragStart = function(event) {\n\t\tvar stage = null;\n\n\t\tif (event.which === 3) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ($.support.transform) {\n\t\t\tstage = this.$stage.css('transform').replace(/.*\\(|\\)| /g, '').split(',');\n\t\t\tstage = {\n\t\t\t\tx: stage[stage.length === 16 ? 12 : 4],\n\t\t\t\ty: stage[stage.length === 16 ? 13 : 5]\n\t\t\t};\n\t\t} else {\n\t\t\tstage = this.$stage.position();\n\t\t\tstage = {\n\t\t\t\tx: this.settings.rtl ?\n\t\t\t\t\tstage.left + this.$stage.width() - this.width() + this.settings.margin :\n\t\t\t\t\tstage.left,\n\t\t\t\ty: stage.top\n\t\t\t};\n\t\t}\n\n\t\tif (this.is('animating')) {\n\t\t\t$.support.transform ? this.animate(stage.x) : this.$stage.stop()\n\t\t\tthis.invalidate('position');\n\t\t}\n\n\t\tthis.$element.toggleClass(this.options.grabClass, event.type === 'mousedown');\n\n\t\tthis.speed(0);\n\n\t\tthis._drag.time = new Date().getTime();\n\t\tthis._drag.target = $(event.target);\n\t\tthis._drag.stage.start = stage;\n\t\tthis._drag.stage.current = stage;\n\t\tthis._drag.pointer = this.pointer(event);\n\n\t\t$(document).on('mouseup.owl.core touchend.owl.core', $.proxy(this.onDragEnd, this));\n\n\t\t$(document).one('mousemove.owl.core touchmove.owl.core', $.proxy(function(event) {\n\t\t\tvar delta = this.difference(this._drag.pointer, this.pointer(event));\n\n\t\t\t$(document).on('mousemove.owl.core touchmove.owl.core', $.proxy(this.onDragMove, this));\n\n\t\t\tif (Math.abs(delta.x) < Math.abs(delta.y) && this.is('valid')) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tevent.preventDefault();\n\n\t\t\tthis.enter('dragging');\n\t\t\tthis.trigger('drag');\n\t\t}, this));\n\t};\n\n\t/**\n\t * Handles the `touchmove` and `mousemove` events.\n\t * @todo #261\n\t * @protected\n\t * @param {Event} event - The event arguments.\n\t */\n\tOwl.prototype.onDragMove = function(event) {\n\t\tvar minimum = null,\n\t\t\tmaximum = null,\n\t\t\tpull = null,\n\t\t\tdelta = this.difference(this._drag.pointer, this.pointer(event)),\n\t\t\tstage = this.difference(this._drag.stage.start, delta);\n\n\t\tif (!this.is('dragging')) {\n\t\t\treturn;\n\t\t}\n\n\t\tevent.preventDefault();\n\n\t\tif (this.settings.loop) {\n\t\t\tminimum = this.coordinates(this.minimum());\n\t\t\tmaximum = this.coordinates(this.maximum() + 1) - minimum;\n\t\t\tstage.x = (((stage.x - minimum) % maximum + maximum) % maximum) + minimum;\n\t\t} else {\n\t\t\tminimum = this.settings.rtl ? this.coordinates(this.maximum()) : this.coordinates(this.minimum());\n\t\t\tmaximum = this.settings.rtl ? this.coordinates(this.minimum()) : this.coordinates(this.maximum());\n\t\t\tpull = this.settings.pullDrag ? -1 * delta.x / 5 : 0;\n\t\t\tstage.x = Math.max(Math.min(stage.x, minimum + pull), maximum + pull);\n\t\t}\n\n\t\tthis._drag.stage.current = stage;\n\n\t\tthis.animate(stage.x);\n\t};\n\n\t/**\n\t * Handles the `touchend` and `mouseup` events.\n\t * @todo #261\n\t * @todo Threshold for click event\n\t * @protected\n\t * @param {Event} event - The event arguments.\n\t */\n\tOwl.prototype.onDragEnd = function(event) {\n\t\tvar delta = this.difference(this._drag.pointer, this.pointer(event)),\n\t\t\tstage = this._drag.stage.current,\n\t\t\tdirection = delta.x > 0 ^ this.settings.rtl ? 'left' : 'right';\n\n\t\t$(document).off('.owl.core');\n\n\t\tthis.$element.removeClass(this.options.grabClass);\n\n\t\tif (delta.x !== 0 && this.is('dragging') || !this.is('valid')) {\n\t\t\tthis.speed(this.settings.dragEndSpeed || this.settings.smartSpeed);\n\t\t\tthis.current(this.closest(stage.x, delta.x !== 0 ? direction : this._drag.direction));\n\t\t\tthis.invalidate('position');\n\t\t\tthis.update();\n\n\t\t\tthis._drag.direction = direction;\n\n\t\t\tif (Math.abs(delta.x) > 3 || new Date().getTime() - this._drag.time > 300) {\n\t\t\t\tthis._drag.target.one('click.owl.core', function() { return false; });\n\t\t\t}\n\t\t}\n\n\t\tif (!this.is('dragging')) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.leave('dragging');\n\t\tthis.trigger('dragged');\n\t};\n\n\t/**\n\t * Gets absolute position of the closest item for a coordinate.\n\t * @todo Setting `freeDrag` makes `closest` not reusable. See #165.\n\t * @protected\n\t * @param {Number} coordinate - The coordinate in pixel.\n\t * @param {String} direction - The direction to check for the closest item. Ether `left` or `right`.\n\t * @return {Number} - The absolute position of the closest item.\n\t */\n\tOwl.prototype.closest = function(coordinate, direction) {\n\t\tvar position = -1,\n\t\t\tpull = 30,\n\t\t\twidth = this.width(),\n\t\t\tcoordinates = this.coordinates();\n\n\t\tif (!this.settings.freeDrag) {\n\t\t\t// check closest item\n\t\t\t$.each(coordinates, $.proxy(function(index, value) {\n\t\t\t\t// on a left pull, check on current index\n\t\t\t\tif (direction === 'left' && coordinate > value - pull && coordinate < value + pull) {\n\t\t\t\t\tposition = index;\n\t\t\t\t// on a right pull, check on previous index\n\t\t\t\t// to do so, subtract width from value and set position = index + 1\n\t\t\t\t} else if (direction === 'right' && coordinate > value - width - pull && coordinate < value - width + pull) {\n\t\t\t\t\tposition = index + 1;\n\t\t\t\t} else if (this.op(coordinate, '<', value)\n\t\t\t\t\t&& this.op(coordinate, '>', coordinates[index + 1] || value - width)) {\n\t\t\t\t\tposition = direction === 'left' ? index + 1 : index;\n\t\t\t\t}\n\t\t\t\treturn position === -1;\n\t\t\t}, this));\n\t\t}\n\n\t\tif (!this.settings.loop) {\n\t\t\t// non loop boundries\n\t\t\tif (this.op(coordinate, '>', coordinates[this.minimum()])) {\n\t\t\t\tposition = coordinate = this.minimum();\n\t\t\t} else if (this.op(coordinate, '<', coordinates[this.maximum()])) {\n\t\t\t\tposition = coordinate = this.maximum();\n\t\t\t}\n\t\t}\n\n\t\treturn position;\n\t};\n\n\t/**\n\t * Animates the stage.\n\t * @todo #270\n\t * @public\n\t * @param {Number} coordinate - The coordinate in pixels.\n\t */\n\tOwl.prototype.animate = function(coordinate) {\n\t\tvar animate = this.speed() > 0;\n\n\t\tthis.is('animating') && this.onTransitionEnd();\n\n\t\tif (animate) {\n\t\t\tthis.enter('animating');\n\t\t\tthis.trigger('translate');\n\t\t}\n\n\t\tif ($.support.transform3d && $.support.transition) {\n\t\t\tthis.$stage.css({\n\t\t\t\ttransform: 'translate3d(' + coordinate + 'px,0px,0px)',\n\t\t\t\ttransition: (this.speed() / 1000) + 's'\n\t\t\t});\n\t\t} else if (animate) {\n\t\t\tthis.$stage.animate({\n\t\t\t\tleft: coordinate + 'px'\n\t\t\t}, this.speed(), this.settings.fallbackEasing, $.proxy(this.onTransitionEnd, this));\n\t\t} else {\n\t\t\tthis.$stage.css({\n\t\t\t\tleft: coordinate + 'px'\n\t\t\t});\n\t\t}\n\t};\n\n\t/**\n\t * Checks whether the carousel is in a specific state or not.\n\t * @param {String} state - The state to check.\n\t * @returns {Boolean} - The flag which indicates if the carousel is busy.\n\t */\n\tOwl.prototype.is = function(state) {\n\t\treturn this._states.current[state] && this._states.current[state] > 0;\n\t};\n\n\t/**\n\t * Sets the absolute position of the current item.\n\t * @public\n\t * @param {Number} [position] - The new absolute position or nothing to leave it unchanged.\n\t * @returns {Number} - The absolute position of the current item.\n\t */\n\tOwl.prototype.current = function(position) {\n\t\tif (position === undefined) {\n\t\t\treturn this._current;\n\t\t}\n\n\t\tif (this._items.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tposition = this.normalize(position);\n\n\t\tif (this._current !== position) {\n\t\t\tvar event = this.trigger('change', { property: { name: 'position', value: position } });\n\n\t\t\tif (event.data !== undefined) {\n\t\t\t\tposition = this.normalize(event.data);\n\t\t\t}\n\n\t\t\tthis._current = position;\n\n\t\t\tthis.invalidate('position');\n\n\t\t\tthis.trigger('changed', { property: { name: 'position', value: this._current } });\n\t\t}\n\n\t\treturn this._current;\n\t};\n\n\t/**\n\t * Invalidates the given part of the update routine.\n\t * @param {String} [part] - The part to invalidate.\n\t * @returns {Array.<String>} - The invalidated parts.\n\t */\n\tOwl.prototype.invalidate = function(part) {\n\t\tif ($.type(part) === 'string') {\n\t\t\tthis._invalidated[part] = true;\n\t\t\tthis.is('valid') && this.leave('valid');\n\t\t}\n\t\treturn $.map(this._invalidated, function(v, i) { return i });\n\t};\n\n\t/**\n\t * Resets the absolute position of the current item.\n\t * @public\n\t * @param {Number} position - The absolute position of the new item.\n\t */\n\tOwl.prototype.reset = function(position) {\n\t\tposition = this.normalize(position);\n\n\t\tif (position === undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._speed = 0;\n\t\tthis._current = position;\n\n\t\tthis.suppress([ 'translate', 'translated' ]);\n\n\t\tthis.animate(this.coordinates(position));\n\n\t\tthis.release([ 'translate', 'translated' ]);\n\t};\n\n\t/**\n\t * Normalizes an absolute or a relative position of an item.\n\t * @public\n\t * @param {Number} position - The absolute or relative position to normalize.\n\t * @param {Boolean} [relative=false] - Whether the given position is relative or not.\n\t * @returns {Number} - The normalized position.\n\t */\n\tOwl.prototype.normalize = function(position, relative) {\n\t\tvar n = this._items.length,\n\t\t\tm = relative ? 0 : this._clones.length;\n\n\t\tif (!this.isNumeric(position) || n < 1) {\n\t\t\tposition = undefined;\n\t\t} else if (position < 0 || position >= n + m) {\n\t\t\tposition = ((position - m / 2) % n + n) % n + m / 2;\n\t\t}\n\n\t\treturn position;\n\t};\n\n\t/**\n\t * Converts an absolute position of an item into a relative one.\n\t * @public\n\t * @param {Number} position - The absolute position to convert.\n\t * @returns {Number} - The converted position.\n\t */\n\tOwl.prototype.relative = function(position) {\n\t\tposition -= this._clones.length / 2;\n\t\treturn this.normalize(position, true);\n\t};\n\n\t/**\n\t * Gets the maximum position for the current item.\n\t * @public\n\t * @param {Boolean} [relative=false] - Whether to return an absolute position or a relative position.\n\t * @returns {Number}\n\t */\n\tOwl.prototype.maximum = function(relative) {\n\t\tvar settings = this.settings,\n\t\t\tmaximum = this._coordinates.length,\n\t\t\titerator,\n\t\t\treciprocalItemsWidth,\n\t\t\telementWidth;\n\n\t\tif (settings.loop) {\n\t\t\tmaximum = this._clones.length / 2 + this._items.length - 1;\n\t\t} else if (settings.autoWidth || settings.merge) {\n\t\t\titerator = this._items.length;\n\t\t\treciprocalItemsWidth = this._items[--iterator].width();\n\t\t\telementWidth = this.$element.width();\n\t\t\twhile (iterator--) {\n\t\t\t\treciprocalItemsWidth += this._items[iterator].width() + this.settings.margin;\n\t\t\t\tif (reciprocalItemsWidth > elementWidth) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmaximum = iterator + 1;\n\t\t} else if (settings.center) {\n\t\t\tmaximum = this._items.length - 1;\n\t\t} else {\n\t\t\tmaximum = this._items.length - settings.items;\n\t\t}\n\n\t\tif (relative) {\n\t\t\tmaximum -= this._clones.length / 2;\n\t\t}\n\n\t\treturn Math.max(maximum, 0);\n\t};\n\n\t/**\n\t * Gets the minimum position for the current item.\n\t * @public\n\t * @param {Boolean} [relative=false] - Whether to return an absolute position or a relative position.\n\t * @returns {Number}\n\t */\n\tOwl.prototype.minimum = function(relative) {\n\t\treturn relative ? 0 : this._clones.length / 2;\n\t};\n\n\t/**\n\t * Gets an item at the specified relative position.\n\t * @public\n\t * @param {Number} [position] - The relative position of the item.\n\t * @return {jQuery|Array.<jQuery>} - The item at the given position or all items if no position was given.\n\t */\n\tOwl.prototype.items = function(position) {\n\t\tif (position === undefined) {\n\t\t\treturn this._items.slice();\n\t\t}\n\n\t\tposition = this.normalize(position, true);\n\t\treturn this._items[position];\n\t};\n\n\t/**\n\t * Gets an item at the specified relative position.\n\t * @public\n\t * @param {Number} [position] - The relative position of the item.\n\t * @return {jQuery|Array.<jQuery>} - The item at the given position or all items if no position was given.\n\t */\n\tOwl.prototype.mergers = function(position) {\n\t\tif (position === undefined) {\n\t\t\treturn this._mergers.slice();\n\t\t}\n\n\t\tposition = this.normalize(position, true);\n\t\treturn this._mergers[position];\n\t};\n\n\t/**\n\t * Gets the absolute positions of clones for an item.\n\t * @public\n\t * @param {Number} [position] - The relative position of the item.\n\t * @returns {Array.<Number>} - The absolute positions of clones for the item or all if no position was given.\n\t */\n\tOwl.prototype.clones = function(position) {\n\t\tvar odd = this._clones.length / 2,\n\t\t\teven = odd + this._items.length,\n\t\t\tmap = function(index) { return index % 2 === 0 ? even + index / 2 : odd - (index + 1) / 2 };\n\n\t\tif (position === undefined) {\n\t\t\treturn $.map(this._clones, function(v, i) { return map(i) });\n\t\t}\n\n\t\treturn $.map(this._clones, function(v, i) { return v === position ? map(i) : null });\n\t};\n\n\t/**\n\t * Sets the current animation speed.\n\t * @public\n\t * @param {Number} [speed] - The animation speed in milliseconds or nothing to leave it unchanged.\n\t * @returns {Number} - The current animation speed in milliseconds.\n\t */\n\tOwl.prototype.speed = function(speed) {\n\t\tif (speed !== undefined) {\n\t\t\tthis._speed = speed;\n\t\t}\n\n\t\treturn this._speed;\n\t};\n\n\t/**\n\t * Gets the coordinate of an item.\n\t * @todo The name of this method is missleanding.\n\t * @public\n\t * @param {Number} position - The absolute position of the item within `minimum()` and `maximum()`.\n\t * @returns {Number|Array.<Number>} - The coordinate of the item in pixel or all coordinates.\n\t */\n\tOwl.prototype.coordinates = function(position) {\n\t\tvar multiplier = 1,\n\t\t\tnewPosition = position - 1,\n\t\t\tcoordinate;\n\n\t\tif (position === undefined) {\n\t\t\treturn $.map(this._coordinates, $.proxy(function(coordinate, index) {\n\t\t\t\treturn this.coordinates(index);\n\t\t\t}, this));\n\t\t}\n\n\t\tif (this.settings.center) {\n\t\t\tif (this.settings.rtl) {\n\t\t\t\tmultiplier = -1;\n\t\t\t\tnewPosition = position + 1;\n\t\t\t}\n\n\t\t\tcoordinate = this._coordinates[position];\n\t\t\tcoordinate += (this.width() - coordinate + (this._coordinates[newPosition] || 0)) / 2 * multiplier;\n\t\t} else {\n\t\t\tcoordinate = this._coordinates[newPosition] || 0;\n\t\t}\n\n\t\tcoordinate = Math.ceil(coordinate);\n\n\t\treturn coordinate;\n\t};\n\n\t/**\n\t * Calculates the speed for a translation.\n\t * @protected\n\t * @param {Number} from - The absolute position of the start item.\n\t * @param {Number} to - The absolute position of the target item.\n\t * @param {Number} [factor=undefined] - The time factor in milliseconds.\n\t * @returns {Number} - The time in milliseconds for the translation.\n\t */\n\tOwl.prototype.duration = function(from, to, factor) {\n\t\tif (factor === 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn Math.min(Math.max(Math.abs(to - from), 1), 6) * Math.abs((factor || this.settings.smartSpeed));\n\t};\n\n\t/**\n\t * Slides to the specified item.\n\t * @public\n\t * @param {Number} position - The position of the item.\n\t * @param {Number} [speed] - The time in milliseconds for the transition.\n\t */\n\tOwl.prototype.to = function(position, speed) {\n\t\tvar current = this.current(),\n\t\t\trevert = null,\n\t\t\tdistance = position - this.relative(current),\n\t\t\tdirection = (distance > 0) - (distance < 0),\n\t\t\titems = this._items.length,\n\t\t\tminimum = this.minimum(),\n\t\t\tmaximum = this.maximum();\n\n\t\tif (this.settings.loop) {\n\t\t\tif (!this.settings.rewind && Math.abs(distance) > items / 2) {\n\t\t\t\tdistance += direction * -1 * items;\n\t\t\t}\n\n\t\t\tposition = current + distance;\n\t\t\trevert = ((position - minimum) % items + items) % items + minimum;\n\n\t\t\tif (revert !== position && revert - distance <= maximum && revert - distance > 0) {\n\t\t\t\tcurrent = revert - distance;\n\t\t\t\tposition = revert;\n\t\t\t\tthis.reset(current);\n\t\t\t}\n\t\t} else if (this.settings.rewind) {\n\t\t\tmaximum += 1;\n\t\t\tposition = (position % maximum + maximum) % maximum;\n\t\t} else {\n\t\t\tposition = Math.max(minimum, Math.min(maximum, position));\n\t\t}\n\n\t\tthis.speed(this.duration(current, position, speed));\n\t\tthis.current(position);\n\n\t\tif (this.$element.is(':visible')) {\n\t\t\tthis.update();\n\t\t}\n\t};\n\n\t/**\n\t * Slides to the next item.\n\t * @public\n\t * @param {Number} [speed] - The time in milliseconds for the transition.\n\t */\n\tOwl.prototype.next = function(speed) {\n\t\tspeed = speed || false;\n\t\tthis.to(this.relative(this.current()) + 1, speed);\n\t};\n\n\t/**\n\t * Slides to the previous item.\n\t * @public\n\t * @param {Number} [speed] - The time in milliseconds for the transition.\n\t */\n\tOwl.prototype.prev = function(speed) {\n\t\tspeed = speed || false;\n\t\tthis.to(this.relative(this.current()) - 1, speed);\n\t};\n\n\t/**\n\t * Handles the end of an animation.\n\t * @protected\n\t * @param {Event} event - The event arguments.\n\t */\n\tOwl.prototype.onTransitionEnd = function(event) {\n\n\t\t// if css2 animation then event object is undefined\n\t\tif (event !== undefined) {\n\t\t\tevent.stopPropagation();\n\n\t\t\t// Catch only owl-stage transitionEnd event\n\t\t\tif ((event.target || event.srcElement || event.originalTarget) !== this.$stage.get(0)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tthis.leave('animating');\n\t\tthis.trigger('translated');\n\t};\n\n\t/**\n\t * Gets viewport width.\n\t * @protected\n\t * @return {Number} - The width in pixel.\n\t */\n\tOwl.prototype.viewport = function() {\n\t\tvar width;\n\t\tif (this.options.responsiveBaseElement !== window) {\n\t\t\twidth = $(this.options.responsiveBaseElement).width();\n\t\t} else if (window.innerWidth) {\n\t\t\twidth = window.innerWidth;\n\t\t} else if (document.documentElement && document.documentElement.clientWidth) {\n\t\t\twidth = document.documentElement.clientWidth;\n\t\t} else {\n\t\t\tthrow 'Can not detect viewport width.';\n\t\t}\n\t\treturn width;\n\t};\n\n\t/**\n\t * Replaces the current content.\n\t * @public\n\t * @param {HTMLElement|jQuery|String} content - The new content.\n\t */\n\tOwl.prototype.replace = function(content) {\n\t\tthis.$stage.empty();\n\t\tthis._items = [];\n\n\t\tif (content) {\n\t\t\tcontent = (content instanceof jQuery) ? content : $(content);\n\t\t}\n\n\t\tif (this.settings.nestedItemSelector) {\n\t\t\tcontent = content.find('.' + this.settings.nestedItemSelector);\n\t\t}\n\n\t\tcontent.filter(function() {\n\t\t\treturn this.nodeType === 1;\n\t\t}).each($.proxy(function(index, item) {\n\t\t\titem = this.prepare(item);\n\t\t\tthis.$stage.append(item);\n\t\t\tthis._items.push(item);\n\t\t\tthis._mergers.push(item.find('[data-merge]').addBack('[data-merge]').attr('data-merge') * 1 || 1);\n\t\t}, this));\n\n\t\tthis.reset(this.isNumeric(this.settings.startPosition) ? this.settings.startPosition : 0);\n\n\t\tthis.invalidate('items');\n\t};\n\n\t/**\n\t * Adds an item.\n\t * @todo Use `item` instead of `content` for the event arguments.\n\t * @public\n\t * @param {HTMLElement|jQuery|String} content - The item content to add.\n\t * @param {Number} [position] - The relative position at which to insert the item otherwise the item will be added to the end.\n\t */\n\tOwl.prototype.add = function(content, position) {\n\t\tvar current = this.relative(this._current);\n\n\t\tposition = position === undefined ? this._items.length : this.normalize(position, true);\n\t\tcontent = content instanceof jQuery ? content : $(content);\n\n\t\tthis.trigger('add', { content: content, position: position });\n\n\t\tcontent = this.prepare(content);\n\n\t\tif (this._items.length === 0 || position === this._items.length) {\n\t\t\tthis._items.length === 0 && this.$stage.append(content);\n\t\t\tthis._items.length !== 0 && this._items[position - 1].after(content);\n\t\t\tthis._items.push(content);\n\t\t\tthis._mergers.push(content.find('[data-merge]').addBack('[data-merge]').attr('data-merge') * 1 || 1);\n\t\t} else {\n\t\t\tthis._items[position].before(content);\n\t\t\tthis._items.splice(position, 0, content);\n\t\t\tthis._mergers.splice(position, 0, content.find('[data-merge]').addBack('[data-merge]').attr('data-merge') * 1 || 1);\n\t\t}\n\n\t\tthis._items[current] && this.reset(this._items[current].index());\n\n\t\tthis.invalidate('items');\n\n\t\tthis.trigger('added', { content: content, position: position });\n\t};\n\n\t/**\n\t * Removes an item by its position.\n\t * @todo Use `item` instead of `content` for the event arguments.\n\t * @public\n\t * @param {Number} position - The relative position of the item to remove.\n\t */\n\tOwl.prototype.remove = function(position) {\n\t\tposition = this.normalize(position, true);\n\n\t\tif (position === undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.trigger('remove', { content: this._items[position], position: position });\n\n\t\tthis._items[position].remove();\n\t\tthis._items.splice(position, 1);\n\t\tthis._mergers.splice(position, 1);\n\n\t\tthis.invalidate('items');\n\n\t\tthis.trigger('removed', { content: null, position: position });\n\t};\n\n\t/**\n\t * Preloads images with auto width.\n\t * @todo Replace by a more generic approach\n\t * @protected\n\t */\n\tOwl.prototype.preloadAutoWidthImages = function(images) {\n\t\timages.each($.proxy(function(i, element) {\n\t\t\tthis.enter('pre-loading');\n\t\t\telement = $(element);\n\t\t\t$(new Image()).one('load', $.proxy(function(e) {\n\t\t\t\telement.attr('src', e.target.src);\n\t\t\t\telement.css('opacity', 1);\n\t\t\t\tthis.leave('pre-loading');\n\t\t\t\t!this.is('pre-loading') && !this.is('initializing') && this.refresh();\n\t\t\t}, this)).attr('src', element.attr('src') || element.attr('data-src') || element.attr('data-src-retina'));\n\t\t}, this));\n\t};\n\n\t/**\n\t * Destroys the carousel.\n\t * @public\n\t */\n\tOwl.prototype.destroy = function() {\n\n\t\tthis.$element.off('.owl.core');\n\t\tthis.$stage.off('.owl.core');\n\t\t$(document).off('.owl.core');\n\n\t\tif (this.settings.responsive !== false) {\n\t\t\twindow.clearTimeout(this.resizeTimer);\n\t\t\tthis.off(window, 'resize', this._handlers.onThrottledResize);\n\t\t}\n\n\t\tfor (var i in this._plugins) {\n\t\t\tthis._plugins[i].destroy();\n\t\t}\n\n\t\tthis.$stage.children('.cloned').remove();\n\n\t\tthis.$stage.unwrap();\n\t\tthis.$stage.children().contents().unwrap();\n\t\tthis.$stage.children().unwrap();\n\n\t\tthis.$element\n\t\t\t.removeClass(this.options.refreshClass)\n\t\t\t.removeClass(this.options.loadingClass)\n\t\t\t.removeClass(this.options.loadedClass)\n\t\t\t.removeClass(this.options.rtlClass)\n\t\t\t.removeClass(this.options.dragClass)\n\t\t\t.removeClass(this.options.grabClass)\n\t\t\t.attr('class', this.$element.attr('class').replace(new RegExp(this.options.responsiveClass + '-\\\\S+\\\\s', 'g'), ''))\n\t\t\t.removeData('owl.carousel');\n\t};\n\n\t/**\n\t * Operators to calculate right-to-left and left-to-right.\n\t * @protected\n\t * @param {Number} [a] - The left side operand.\n\t * @param {String} [o] - The operator.\n\t * @param {Number} [b] - The right side operand.\n\t */\n\tOwl.prototype.op = function(a, o, b) {\n\t\tvar rtl = this.settings.rtl;\n\t\tswitch (o) {\n\t\t\tcase '<':\n\t\t\t\treturn rtl ? a > b : a < b;\n\t\t\tcase '>':\n\t\t\t\treturn rtl ? a < b : a > b;\n\t\t\tcase '>=':\n\t\t\t\treturn rtl ? a <= b : a >= b;\n\t\t\tcase '<=':\n\t\t\t\treturn rtl ? a >= b : a <= b;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t};\n\n\t/**\n\t * Attaches to an internal event.\n\t * @protected\n\t * @param {HTMLElement} element - The event source.\n\t * @param {String} event - The event name.\n\t * @param {Function} listener - The event handler to attach.\n\t * @param {Boolean} capture - Wether the event should be handled at the capturing phase or not.\n\t */\n\tOwl.prototype.on = function(element, event, listener, capture) {\n\t\tif (element.addEventListener) {\n\t\t\telement.addEventListener(event, listener, capture);\n\t\t} else if (element.attachEvent) {\n\t\t\telement.attachEvent('on' + event, listener);\n\t\t}\n\t};\n\n\t/**\n\t * Detaches from an internal event.\n\t * @protected\n\t * @param {HTMLElement} element - The event source.\n\t * @param {String} event - The event name.\n\t * @param {Function} listener - The attached event handler to detach.\n\t * @param {Boolean} capture - Wether the attached event handler was registered as a capturing listener or not.\n\t */\n\tOwl.prototype.off = function(element, event, listener, capture) {\n\t\tif (element.removeEventListener) {\n\t\t\telement.removeEventListener(event, listener, capture);\n\t\t} else if (element.detachEvent) {\n\t\t\telement.detachEvent('on' + event, listener);\n\t\t}\n\t};\n\n\t/**\n\t * Triggers a public event.\n\t * @todo Remove `status`, `relatedTarget` should be used instead.\n\t * @protected\n\t * @param {String} name - The event name.\n\t * @param {*} [data=null] - The event data.\n\t * @param {String} [namespace=carousel] - The event namespace.\n\t * @param {String} [state] - The state which is associated with the event.\n\t * @param {Boolean} [enter=false] - Indicates if the call enters the specified state or not.\n\t * @returns {Event} - The event arguments.\n\t */\n\tOwl.prototype.trigger = function(name, data, namespace, state, enter) {\n\t\tvar status = {\n\t\t\titem: { count: this._items.length, index: this.current() }\n\t\t}, handler = $.camelCase(\n\t\t\t$.grep([ 'on', name, namespace ], function(v) { return v })\n\t\t\t\t.join('-').toLowerCase()\n\t\t), event = $.Event(\n\t\t\t[ name, 'owl', namespace || 'carousel' ].join('.').toLowerCase(),\n\t\t\t$.extend({ relatedTarget: this }, status, data)\n\t\t);\n\n\t\tif (!this._supress[name]) {\n\t\t\t$.each(this._plugins, function(name, plugin) {\n\t\t\t\tif (plugin.onTrigger) {\n\t\t\t\t\tplugin.onTrigger(event);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tthis.register({ type: Owl.Type.Event, name: name });\n\t\t\tthis.$element.trigger(event);\n\n\t\t\tif (this.settings && typeof this.settings[handler] === 'function') {\n\t\t\t\tthis.settings[handler].call(this, event);\n\t\t\t}\n\t\t}\n\n\t\treturn event;\n\t};\n\n\t/**\n\t * Enters a state.\n\t * @param name - The state name.\n\t */\n\tOwl.prototype.enter = function(name) {\n\t\t$.each([ name ].concat(this._states.tags[name] || []), $.proxy(function(i, name) {\n\t\t\tif (this._states.current[name] === undefined) {\n\t\t\t\tthis._states.current[name] = 0;\n\t\t\t}\n\n\t\t\tthis._states.current[name]++;\n\t\t}, this));\n\t};\n\n\t/**\n\t * Leaves a state.\n\t * @param name - The state name.\n\t */\n\tOwl.prototype.leave = function(name) {\n\t\t$.each([ name ].concat(this._states.tags[name] || []), $.proxy(function(i, name) {\n\t\t\tthis._states.current[name]--;\n\t\t}, this));\n\t};\n\n\t/**\n\t * Registers an event or state.\n\t * @public\n\t * @param {Object} object - The event or state to register.\n\t */\n\tOwl.prototype.register = function(object) {\n\t\tif (object.type === Owl.Type.Event) {\n\t\t\tif (!$.event.special[object.name]) {\n\t\t\t\t$.event.special[object.name] = {};\n\t\t\t}\n\n\t\t\tif (!$.event.special[object.name].owl) {\n\t\t\t\tvar _default = $.event.special[object.name]._default;\n\t\t\t\t$.event.special[object.name]._default = function(e) {\n\t\t\t\t\tif (_default && _default.apply && (!e.namespace || e.namespace.indexOf('owl') === -1)) {\n\t\t\t\t\t\treturn _default.apply(this, arguments);\n\t\t\t\t\t}\n\t\t\t\t\treturn e.namespace && e.namespace.indexOf('owl') > -1;\n\t\t\t\t};\n\t\t\t\t$.event.special[object.name].owl = true;\n\t\t\t}\n\t\t} else if (object.type === Owl.Type.State) {\n\t\t\tif (!this._states.tags[object.name]) {\n\t\t\t\tthis._states.tags[object.name] = object.tags;\n\t\t\t} else {\n\t\t\t\tthis._states.tags[object.name] = this._states.tags[object.name].concat(object.tags);\n\t\t\t}\n\n\t\t\tthis._states.tags[object.name] = $.grep(this._states.tags[object.name], $.proxy(function(tag, i) {\n\t\t\t\treturn $.inArray(tag, this._states.tags[object.name]) === i;\n\t\t\t}, this));\n\t\t}\n\t};\n\n\t/**\n\t * Suppresses events.\n\t * @protected\n\t * @param {Array.<String>} events - The events to suppress.\n\t */\n\tOwl.prototype.suppress = function(events) {\n\t\t$.each(events, $.proxy(function(index, event) {\n\t\t\tthis._supress[event] = true;\n\t\t}, this));\n\t};\n\n\t/**\n\t * Releases suppressed events.\n\t * @protected\n\t * @param {Array.<String>} events - The events to release.\n\t */\n\tOwl.prototype.release = function(events) {\n\t\t$.each(events, $.proxy(function(index, event) {\n\t\t\tdelete this._supress[event];\n\t\t}, this));\n\t};\n\n\t/**\n\t * Gets unified pointer coordinates from event.\n\t * @todo #261\n\t * @protected\n\t * @param {Event} - The `mousedown` or `touchstart` event.\n\t * @returns {Object} - Contains `x` and `y` coordinates of current pointer position.\n\t */\n\tOwl.prototype.pointer = function(event) {\n\t\tvar result = { x: null, y: null };\n\n\t\tevent = event.originalEvent || event || window.event;\n\n\t\tevent = event.touches && event.touches.length ?\n\t\t\tevent.touches[0] : event.changedTouches && event.changedTouches.length ?\n\t\t\t\tevent.changedTouches[0] : event;\n\n\t\tif (event.pageX) {\n\t\t\tresult.x = event.pageX;\n\t\t\tresult.y = event.pageY;\n\t\t} else {\n\t\t\tresult.x = event.clientX;\n\t\t\tresult.y = event.clientY;\n\t\t}\n\n\t\treturn result;\n\t};\n\n\t/**\n\t * Determines if the input is a Number or something that can be coerced to a Number\n\t * @protected\n\t * @param {Number|String|Object|Array|Boolean|RegExp|Function|Symbol} - The input to be tested\n\t * @returns {Boolean} - An indication if the input is a Number or can be coerced to a Number\n\t */\n\tOwl.prototype.isNumeric = function(number) {\n\t\treturn !isNaN(parseFloat(number));\n\t};\n\n\t/**\n\t * Gets the difference of two vectors.\n\t * @todo #261\n\t * @protected\n\t * @param {Object} - The first vector.\n\t * @param {Object} - The second vector.\n\t * @returns {Object} - The difference.\n\t */\n\tOwl.prototype.difference = function(first, second) {\n\t\treturn {\n\t\t\tx: first.x - second.x,\n\t\t\ty: first.y - second.y\n\t\t};\n\t};\n\n\t/**\n\t * The jQuery Plugin for the Owl Carousel\n\t * @todo Navigation plugin `next` and `prev`\n\t * @public\n\t */\n\t$.fn.owlCarousel = function(option) {\n\t\tvar args = Array.prototype.slice.call(arguments, 1);\n\n\t\treturn this.each(function() {\n\t\t\tvar $this = $(this),\n\t\t\t\tdata = $this.data('owl.carousel');\n\n\t\t\tif (!data) {\n\t\t\t\tdata = new Owl(this, typeof option == 'object' && option);\n\t\t\t\t$this.data('owl.carousel', data);\n\n\t\t\t\t$.each([\n\t\t\t\t\t'next', 'prev', 'to', 'destroy', 'refresh', 'replace', 'add', 'remove'\n\t\t\t\t], function(i, event) {\n\t\t\t\t\tdata.register({ type: Owl.Type.Event, name: event });\n\t\t\t\t\tdata.$element.on(event + '.owl.carousel.core', $.proxy(function(e) {\n\t\t\t\t\t\tif (e.namespace && e.relatedTarget !== this) {\n\t\t\t\t\t\t\tthis.suppress([ event ]);\n\t\t\t\t\t\t\tdata[event].apply(this, [].slice.call(arguments, 1));\n\t\t\t\t\t\t\tthis.release([ event ]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}, data));\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (typeof option == 'string' && option.charAt(0) !== '_') {\n\t\t\t\tdata[option].apply(data, args);\n\t\t\t}\n\t\t});\n\t};\n\n\t/**\n\t * The constructor for the jQuery Plugin\n\t * @public\n\t */\n\t$.fn.owlCarousel.Constructor = Owl;\n\n})(window.Zepto || __webpack_provided_window_dot_jQuery, window, document);\n\n/**\n * AutoRefresh Plugin\n * @version 2.1.0\n * @author Artus Kolanowski\n * @author David Deutsch\n * @license The MIT License (MIT)\n */\n;(function($, window, document, undefined) {\n\n\t/**\n\t * Creates the auto refresh plugin.\n\t * @class The Auto Refresh Plugin\n\t * @param {Owl} carousel - The Owl Carousel\n\t */\n\tvar AutoRefresh = function(carousel) {\n\t\t/**\n\t\t * Reference to the core.\n\t\t * @protected\n\t\t * @type {Owl}\n\t\t */\n\t\tthis._core = carousel;\n\n\t\t/**\n\t\t * Refresh interval.\n\t\t * @protected\n\t\t * @type {number}\n\t\t */\n\t\tthis._interval = null;\n\n\t\t/**\n\t\t * Whether the element is currently visible or not.\n\t\t * @protected\n\t\t * @type {Boolean}\n\t\t */\n\t\tthis._visible = null;\n\n\t\t/**\n\t\t * All event handlers.\n\t\t * @protected\n\t\t * @type {Object}\n\t\t */\n\t\tthis._handlers = {\n\t\t\t'initialized.owl.carousel': $.proxy(function(e) {\n\t\t\t\tif (e.namespace && this._core.settings.autoRefresh) {\n\t\t\t\t\tthis.watch();\n\t\t\t\t}\n\t\t\t}, this)\n\t\t};\n\n\t\t// set default options\n\t\tthis._core.options = $.extend({}, AutoRefresh.Defaults, this._core.options);\n\n\t\t// register event handlers\n\t\tthis._core.$element.on(this._handlers);\n\t};\n\n\t/**\n\t * Default options.\n\t * @public\n\t */\n\tAutoRefresh.Defaults = {\n\t\tautoRefresh: true,\n\t\tautoRefreshInterval: 500\n\t};\n\n\t/**\n\t * Watches the element.\n\t */\n\tAutoRefresh.prototype.watch = function() {\n\t\tif (this._interval) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._visible = this._core.$element.is(':visible');\n\t\tthis._interval = window.setInterval($.proxy(this.refresh, this), this._core.settings.autoRefreshInterval);\n\t};\n\n\t/**\n\t * Refreshes the element.\n\t */\n\tAutoRefresh.prototype.refresh = function() {\n\t\tif (this._core.$element.is(':visible') === this._visible) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._visible = !this._visible;\n\n\t\tthis._core.$element.toggleClass('owl-hidden', !this._visible);\n\n\t\tthis._visible && (this._core.invalidate('width') && this._core.refresh());\n\t};\n\n\t/**\n\t * Destroys the plugin.\n\t */\n\tAutoRefresh.prototype.destroy = function() {\n\t\tvar handler, property;\n\n\t\twindow.clearInterval(this._interval);\n\n\t\tfor (handler in this._handlers) {\n\t\t\tthis._core.$element.off(handler, this._handlers[handler]);\n\t\t}\n\t\tfor (property in Object.getOwnPropertyNames(this)) {\n\t\t\ttypeof this[property] != 'function' && (this[property] = null);\n\t\t}\n\t};\n\n\t$.fn.owlCarousel.Constructor.Plugins.AutoRefresh = AutoRefresh;\n\n})(window.Zepto || __webpack_provided_window_dot_jQuery, window, document);\n\n/**\n * Lazy Plugin\n * @version 2.1.0\n * @author Bartosz Wojciechowski\n * @author David Deutsch\n * @license The MIT License (MIT)\n */\n;(function($, window, document, undefined) {\n\n\t/**\n\t * Creates the lazy plugin.\n\t * @class The Lazy Plugin\n\t * @param {Owl} carousel - The Owl Carousel\n\t */\n\tvar Lazy = function(carousel) {\n\n\t\t/**\n\t\t * Reference to the core.\n\t\t * @protected\n\t\t * @type {Owl}\n\t\t */\n\t\tthis._core = carousel;\n\n\t\t/**\n\t\t * Already loaded items.\n\t\t * @protected\n\t\t * @type {Array.<jQuery>}\n\t\t */\n\t\tthis._loaded = [];\n\n\t\t/**\n\t\t * Event handlers.\n\t\t * @protected\n\t\t * @type {Object}\n\t\t */\n\t\tthis._handlers = {\n\t\t\t'initialized.owl.carousel change.owl.carousel resized.owl.carousel': $.proxy(function(e) {\n\t\t\t\tif (!e.namespace) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (!this._core.settings || !this._core.settings.lazyLoad) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif ((e.property && e.property.name == 'position') || e.type == 'initialized') {\n\t\t\t\t\tvar settings = this._core.settings,\n\t\t\t\t\t\tn = (settings.center && Math.ceil(settings.items / 2) || settings.items),\n\t\t\t\t\t\ti = ((settings.center && n * -1) || 0),\n\t\t\t\t\t\tposition = (e.property && e.property.value !== undefined ? e.property.value : this._core.current()) + i,\n\t\t\t\t\t\tclones = this._core.clones().length,\n\t\t\t\t\t\tload = $.proxy(function(i, v) { this.load(v) }, this);\n\n\t\t\t\t\twhile (i++ < n) {\n\t\t\t\t\t\tthis.load(clones / 2 + this._core.relative(position));\n\t\t\t\t\t\tclones && $.each(this._core.clones(this._core.relative(position)), load);\n\t\t\t\t\t\tposition++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, this)\n\t\t};\n\n\t\t// set the default options\n\t\tthis._core.options = $.extend({}, Lazy.Defaults, this._core.options);\n\n\t\t// register event handler\n\t\tthis._core.$element.on(this._handlers);\n\t};\n\n\t/**\n\t * Default options.\n\t * @public\n\t */\n\tLazy.Defaults = {\n\t\tlazyLoad: false\n\t};\n\n\t/**\n\t * Loads all resources of an item at the specified position.\n\t * @param {Number} position - The absolute position of the item.\n\t * @protected\n\t */\n\tLazy.prototype.load = function(position) {\n\t\tvar $item = this._core.$stage.children().eq(position),\n\t\t\t$elements = $item && $item.find('.owl-lazy');\n\n\t\tif (!$elements || $.inArray($item.get(0), this._loaded) > -1) {\n\t\t\treturn;\n\t\t}\n\n\t\t$elements.each($.proxy(function(index, element) {\n\t\t\tvar $element = $(element), image,\n\t\t\t\turl = (window.devicePixelRatio > 1 && $element.attr('data-src-retina')) || $element.attr('data-src');\n\n\t\t\tthis._core.trigger('load', { element: $element, url: url }, 'lazy');\n\n\t\t\tif ($element.is('img')) {\n\t\t\t\t$element.one('load.owl.lazy', $.proxy(function() {\n\t\t\t\t\t$element.css('opacity', 1);\n\t\t\t\t\tthis._core.trigger('loaded', { element: $element, url: url }, 'lazy');\n\t\t\t\t}, this)).attr('src', url);\n\t\t\t} else {\n\t\t\t\timage = new Image();\n\t\t\t\timage.onload = $.proxy(function() {\n\t\t\t\t\t$element.css({\n\t\t\t\t\t\t'background-image': 'url(' + url + ')',\n\t\t\t\t\t\t'opacity': '1'\n\t\t\t\t\t});\n\t\t\t\t\tthis._core.trigger('loaded', { element: $element, url: url }, 'lazy');\n\t\t\t\t}, this);\n\t\t\t\timage.src = url;\n\t\t\t}\n\t\t}, this));\n\n\t\tthis._loaded.push($item.get(0));\n\t};\n\n\t/**\n\t * Destroys the plugin.\n\t * @public\n\t */\n\tLazy.prototype.destroy = function() {\n\t\tvar handler, property;\n\n\t\tfor (handler in this.handlers) {\n\t\t\tthis._core.$element.off(handler, this.handlers[handler]);\n\t\t}\n\t\tfor (property in Object.getOwnPropertyNames(this)) {\n\t\t\ttypeof this[property] != 'function' && (this[property] = null);\n\t\t}\n\t};\n\n\t$.fn.owlCarousel.Constructor.Plugins.Lazy = Lazy;\n\n})(window.Zepto || __webpack_provided_window_dot_jQuery, window, document);\n\n/**\n * AutoHeight Plugin\n * @version 2.1.0\n * @author Bartosz Wojciechowski\n * @author David Deutsch\n * @license The MIT License (MIT)\n */\n;(function($, window, document, undefined) {\n\n\t/**\n\t * Creates the auto height plugin.\n\t * @class The Auto Height Plugin\n\t * @param {Owl} carousel - The Owl Carousel\n\t */\n\tvar AutoHeight = function(carousel) {\n\t\t/**\n\t\t * Reference to the core.\n\t\t * @protected\n\t\t * @type {Owl}\n\t\t */\n\t\tthis._core = carousel;\n\n\t\t/**\n\t\t * All event handlers.\n\t\t * @protected\n\t\t * @type {Object}\n\t\t */\n\t\tthis._handlers = {\n\t\t\t'initialized.owl.carousel refreshed.owl.carousel': $.proxy(function(e) {\n\t\t\t\tif (e.namespace && this._core.settings.autoHeight) {\n\t\t\t\t\tthis.update();\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'changed.owl.carousel': $.proxy(function(e) {\n\t\t\t\tif (e.namespace && this._core.settings.autoHeight && e.property.name == 'position'){\n\t\t\t\t\tthis.update();\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'loaded.owl.lazy': $.proxy(function(e) {\n\t\t\t\tif (e.namespace && this._core.settings.autoHeight\n\t\t\t\t\t&& e.element.closest('.' + this._core.settings.itemClass).index() === this._core.current()) {\n\t\t\t\t\tthis.update();\n\t\t\t\t}\n\t\t\t}, this)\n\t\t};\n\n\t\t// set default options\n\t\tthis._core.options = $.extend({}, AutoHeight.Defaults, this._core.options);\n\n\t\t// register event handlers\n\t\tthis._core.$element.on(this._handlers);\n\t};\n\n\t/**\n\t * Default options.\n\t * @public\n\t */\n\tAutoHeight.Defaults = {\n\t\tautoHeight: false,\n\t\tautoHeightClass: 'owl-height'\n\t};\n\n\t/**\n\t * Updates the view.\n\t */\n\tAutoHeight.prototype.update = function() {\n\t\tvar start = this._core._current,\n\t\t\tend = start + this._core.settings.items,\n\t\t\tvisible = this._core.$stage.children().toArray().slice(start, end),\n\t\t\theights = [],\n\t\t\tmaxheight = 0;\n\n\t\t$.each(visible, function(index, item) {\n\t\t\theights.push($(item).height());\n\t\t});\n\n\t\tmaxheight = Math.max.apply(null, heights);\n\n\t\tthis._core.$stage.parent()\n\t\t\t.height(maxheight)\n\t\t\t.addClass(this._core.settings.autoHeightClass);\n\t};\n\n\tAutoHeight.prototype.destroy = function() {\n\t\tvar handler, property;\n\n\t\tfor (handler in this._handlers) {\n\t\t\tthis._core.$element.off(handler, this._handlers[handler]);\n\t\t}\n\t\tfor (property in Object.getOwnPropertyNames(this)) {\n\t\t\ttypeof this[property] != 'function' && (this[property] = null);\n\t\t}\n\t};\n\n\t$.fn.owlCarousel.Constructor.Plugins.AutoHeight = AutoHeight;\n\n})(window.Zepto || __webpack_provided_window_dot_jQuery, window, document);\n\n/**\n * Video Plugin\n * @version 2.1.0\n * @author Bartosz Wojciechowski\n * @author David Deutsch\n * @license The MIT License (MIT)\n */\n;(function($, window, document, undefined) {\n\n\t/**\n\t * Creates the video plugin.\n\t * @class The Video Plugin\n\t * @param {Owl} carousel - The Owl Carousel\n\t */\n\tvar Video = function(carousel) {\n\t\t/**\n\t\t * Reference to the core.\n\t\t * @protected\n\t\t * @type {Owl}\n\t\t */\n\t\tthis._core = carousel;\n\n\t\t/**\n\t\t * Cache all video URLs.\n\t\t * @protected\n\t\t * @type {Object}\n\t\t */\n\t\tthis._videos = {};\n\n\t\t/**\n\t\t * Current playing item.\n\t\t * @protected\n\t\t * @type {jQuery}\n\t\t */\n\t\tthis._playing = null;\n\n\t\t/**\n\t\t * All event handlers.\n\t\t * @todo The cloned content removale is too late\n\t\t * @protected\n\t\t * @type {Object}\n\t\t */\n\t\tthis._handlers = {\n\t\t\t'initialized.owl.carousel': $.proxy(function(e) {\n\t\t\t\tif (e.namespace) {\n\t\t\t\t\tthis._core.register({ type: 'state', name: 'playing', tags: [ 'interacting' ] });\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'resize.owl.carousel': $.proxy(function(e) {\n\t\t\t\tif (e.namespace && this._core.settings.video && this.isInFullScreen()) {\n\t\t\t\t\te.preventDefault();\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'refreshed.owl.carousel': $.proxy(function(e) {\n\t\t\t\tif (e.namespace && this._core.is('resizing')) {\n\t\t\t\t\tthis._core.$stage.find('.cloned .owl-video-frame').remove();\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'changed.owl.carousel': $.proxy(function(e) {\n\t\t\t\tif (e.namespace && e.property.name === 'position' && this._playing) {\n\t\t\t\t\tthis.stop();\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'prepared.owl.carousel': $.proxy(function(e) {\n\t\t\t\tif (!e.namespace) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar $element = $(e.content).find('.owl-video');\n\n\t\t\t\tif ($element.length) {\n\t\t\t\t\t$element.css('display', 'none');\n\t\t\t\t\tthis.fetch($element, $(e.content));\n\t\t\t\t}\n\t\t\t}, this)\n\t\t};\n\n\t\t// set default options\n\t\tthis._core.options = $.extend({}, Video.Defaults, this._core.options);\n\n\t\t// register event handlers\n\t\tthis._core.$element.on(this._handlers);\n\n\t\tthis._core.$element.on('click.owl.video', '.owl-video-play-icon', $.proxy(function(e) {\n\t\t\tthis.play(e);\n\t\t}, this));\n\t};\n\n\t/**\n\t * Default options.\n\t * @public\n\t */\n\tVideo.Defaults = {\n\t\tvideo: false,\n\t\tvideoHeight: false,\n\t\tvideoWidth: false\n\t};\n\n\t/**\n\t * Gets the video ID and the type (YouTube/Vimeo/vzaar only).\n\t * @protected\n\t * @param {jQuery} target - The target containing the video data.\n\t * @param {jQuery} item - The item containing the video.\n\t */\n\tVideo.prototype.fetch = function(target, item) {\n\t\t\tvar type = (function() {\n\t\t\t\t\tif (target.attr('data-vimeo-id')) {\n\t\t\t\t\t\treturn 'vimeo';\n\t\t\t\t\t} else if (target.attr('data-vzaar-id')) {\n\t\t\t\t\t\treturn 'vzaar'\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn 'youtube';\n\t\t\t\t\t}\n\t\t\t\t})(),\n\t\t\t\tid = target.attr('data-vimeo-id') || target.attr('data-youtube-id') || target.attr('data-vzaar-id'),\n\t\t\t\twidth = target.attr('data-width') || this._core.settings.videoWidth,\n\t\t\t\theight = target.attr('data-height') || this._core.settings.videoHeight,\n\t\t\t\turl = target.attr('href');\n\n\t\tif (url) {\n\n\t\t\t/*\n\t\t\t\t\tParses the id's out of the following urls (and probably more):\n\t\t\t\t\thttps://www.youtube.com/watch?v=:id\n\t\t\t\t\thttps://youtu.be/:id\n\t\t\t\t\thttps://vimeo.com/:id\n\t\t\t\t\thttps://vimeo.com/channels/:channel/:id\n\t\t\t\t\thttps://vimeo.com/groups/:group/videos/:id\n\t\t\t\t\thttps://app.vzaar.com/videos/:id\n\n\t\t\t\t\tVisual example: https://regexper.com/#(http%3A%7Chttps%3A%7C)%5C%2F%5C%2F(player.%7Cwww.%7Capp.)%3F(vimeo%5C.com%7Cyoutu(be%5C.com%7C%5C.be%7Cbe%5C.googleapis%5C.com)%7Cvzaar%5C.com)%5C%2F(video%5C%2F%7Cvideos%5C%2F%7Cembed%5C%2F%7Cchannels%5C%2F.%2B%5C%2F%7Cgroups%5C%2F.%2B%5C%2F%7Cwatch%5C%3Fv%3D%7Cv%5C%2F)%3F(%5BA-Za-z0-9._%25-%5D*)(%5C%26%5CS%2B)%3F\n\t\t\t*/\n\n\t\t\tid = url.match(/(http:|https:|)\\/\\/(player.|www.|app.)?(vimeo\\.com|youtu(be\\.com|\\.be|be\\.googleapis\\.com)|vzaar\\.com)\\/(video\\/|videos\\/|embed\\/|channels\\/.+\\/|groups\\/.+\\/|watch\\?v=|v\\/)?([A-Za-z0-9._%-]*)(\\&\\S+)?/);\n\n\t\t\tif (id[3].indexOf('youtu') > -1) {\n\t\t\t\ttype = 'youtube';\n\t\t\t} else if (id[3].indexOf('vimeo') > -1) {\n\t\t\t\ttype = 'vimeo';\n\t\t\t} else if (id[3].indexOf('vzaar') > -1) {\n\t\t\t\ttype = 'vzaar';\n\t\t\t} else {\n\t\t\t\tthrow new Error('Video URL not supported.');\n\t\t\t}\n\t\t\tid = id[6];\n\t\t} else {\n\t\t\tthrow new Error('Missing video URL.');\n\t\t}\n\n\t\tthis._videos[url] = {\n\t\t\ttype: type,\n\t\t\tid: id,\n\t\t\twidth: width,\n\t\t\theight: height\n\t\t};\n\n\t\titem.attr('data-video', url);\n\n\t\tthis.thumbnail(target, this._videos[url]);\n\t};\n\n\t/**\n\t * Creates video thumbnail.\n\t * @protected\n\t * @param {jQuery} target - The target containing the video data.\n\t * @param {Object} info - The video info object.\n\t * @see `fetch`\n\t */\n\tVideo.prototype.thumbnail = function(target, video) {\n\t\tvar tnLink,\n\t\t\ticon,\n\t\t\tpath,\n\t\t\tdimensions = video.width && video.height ? 'style=\"width:' + video.width + 'px;height:' + video.height + 'px;\"' : '',\n\t\t\tcustomTn = target.find('img'),\n\t\t\tsrcType = 'src',\n\t\t\tlazyClass = '',\n\t\t\tsettings = this._core.settings,\n\t\t\tcreate = function(path) {\n\t\t\t\ticon = '<div class=\"owl-video-play-icon\"></div>';\n\n\t\t\t\tif (settings.lazyLoad) {\n\t\t\t\t\ttnLink = '<div class=\"owl-video-tn ' + lazyClass + '\" ' + srcType + '=\"' + path + '\"></div>';\n\t\t\t\t} else {\n\t\t\t\t\ttnLink = '<div class=\"owl-video-tn\" style=\"opacity:1;background-image:url(' + path + ')\"></div>';\n\t\t\t\t}\n\t\t\t\ttarget.after(tnLink);\n\t\t\t\ttarget.after(icon);\n\t\t\t};\n\n\t\t// wrap video content into owl-video-wrapper div\n\t\ttarget.wrap('<div class=\"owl-video-wrapper\"' + dimensions + '></div>');\n\n\t\tif (this._core.settings.lazyLoad) {\n\t\t\tsrcType = 'data-src';\n\t\t\tlazyClass = 'owl-lazy';\n\t\t}\n\n\t\t// custom thumbnail\n\t\tif (customTn.length) {\n\t\t\tcreate(customTn.attr(srcType));\n\t\t\tcustomTn.remove();\n\t\t\treturn false;\n\t\t}\n\n\t\tif (video.type === 'youtube') {\n\t\t\tpath = \"//img.youtube.com/vi/\" + video.id + \"/hqdefault.jpg\";\n\t\t\tcreate(path);\n\t\t} else if (video.type === 'vimeo') {\n\t\t\t$.ajax({\n\t\t\t\ttype: 'GET',\n\t\t\t\turl: '//vimeo.com/api/v2/video/' + video.id + '.json',\n\t\t\t\tjsonp: 'callback',\n\t\t\t\tdataType: 'jsonp',\n\t\t\t\tsuccess: function(data) {\n\t\t\t\t\tpath = data[0].thumbnail_large;\n\t\t\t\t\tcreate(path);\n\t\t\t\t}\n\t\t\t});\n\t\t} else if (video.type === 'vzaar') {\n\t\t\t$.ajax({\n\t\t\t\ttype: 'GET',\n\t\t\t\turl: '//vzaar.com/api/videos/' + video.id + '.json',\n\t\t\t\tjsonp: 'callback',\n\t\t\t\tdataType: 'jsonp',\n\t\t\t\tsuccess: function(data) {\n\t\t\t\t\tpath = data.framegrab_url;\n\t\t\t\t\tcreate(path);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t};\n\n\t/**\n\t * Stops the current video.\n\t * @public\n\t */\n\tVideo.prototype.stop = function() {\n\t\tthis._core.trigger('stop', null, 'video');\n\t\tthis._playing.find('.owl-video-frame').remove();\n\t\tthis._playing.removeClass('owl-video-playing');\n\t\tthis._playing = null;\n\t\tthis._core.leave('playing');\n\t\tthis._core.trigger('stopped', null, 'video');\n\t};\n\n\t/**\n\t * Starts the current video.\n\t * @public\n\t * @param {Event} event - The event arguments.\n\t */\n\tVideo.prototype.play = function(event) {\n\t\tvar target = $(event.target),\n\t\t\titem = target.closest('.' + this._core.settings.itemClass),\n\t\t\tvideo = this._videos[item.attr('data-video')],\n\t\t\twidth = video.width || '100%',\n\t\t\theight = video.height || this._core.$stage.height(),\n\t\t\thtml;\n\n\t\tif (this._playing) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._core.enter('playing');\n\t\tthis._core.trigger('play', null, 'video');\n\n\t\titem = this._core.items(this._core.relative(item.index()));\n\n\t\tthis._core.reset(item.index());\n\n\t\tif (video.type === 'youtube') {\n\t\t\thtml = '<iframe width=\"' + width + '\" height=\"' + height + '\" src=\"//www.youtube.com/embed/' +\n\t\t\t\tvideo.id + '?autoplay=1&v=' + video.id + '\" frameborder=\"0\" allowfullscreen></iframe>';\n\t\t} else if (video.type === 'vimeo') {\n\t\t\thtml = '<iframe src=\"//player.vimeo.com/video/' + video.id +\n\t\t\t\t'?autoplay=1\" width=\"' + width + '\" height=\"' + height +\n\t\t\t\t'\" frameborder=\"0\" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>';\n\t\t} else if (video.type === 'vzaar') {\n\t\t\thtml = '<iframe frameborder=\"0\"' + 'height=\"' + height + '\"' + 'width=\"' + width +\n\t\t\t\t'\" allowfullscreen mozallowfullscreen webkitAllowFullScreen ' +\n\t\t\t\t'src=\"//view.vzaar.com/' + video.id + '/player?autoplay=true\"></iframe>';\n\t\t}\n\n\t\t$('<div class=\"owl-video-frame\">' + html + '</div>').insertAfter(item.find('.owl-video'));\n\n\t\tthis._playing = item.addClass('owl-video-playing');\n\t};\n\n\t/**\n\t * Checks whether an video is currently in full screen mode or not.\n\t * @todo Bad style because looks like a readonly method but changes members.\n\t * @protected\n\t * @returns {Boolean}\n\t */\n\tVideo.prototype.isInFullScreen = function() {\n\t\tvar element = document.fullscreenElement || document.mozFullScreenElement ||\n\t\t\t\tdocument.webkitFullscreenElement;\n\n\t\treturn element && $(element).parent().hasClass('owl-video-frame');\n\t};\n\n\t/**\n\t * Destroys the plugin.\n\t */\n\tVideo.prototype.destroy = function() {\n\t\tvar handler, property;\n\n\t\tthis._core.$element.off('click.owl.video');\n\n\t\tfor (handler in this._handlers) {\n\t\t\tthis._core.$element.off(handler, this._handlers[handler]);\n\t\t}\n\t\tfor (property in Object.getOwnPropertyNames(this)) {\n\t\t\ttypeof this[property] != 'function' && (this[property] = null);\n\t\t}\n\t};\n\n\t$.fn.owlCarousel.Constructor.Plugins.Video = Video;\n\n})(window.Zepto || __webpack_provided_window_dot_jQuery, window, document);\n\n/**\n * Animate Plugin\n * @version 2.1.0\n * @author Bartosz Wojciechowski\n * @author David Deutsch\n * @license The MIT License (MIT)\n */\n;(function($, window, document, undefined) {\n\n\t/**\n\t * Creates the animate plugin.\n\t * @class The Navigation Plugin\n\t * @param {Owl} scope - The Owl Carousel\n\t */\n\tvar Animate = function(scope) {\n\t\tthis.core = scope;\n\t\tthis.core.options = $.extend({}, Animate.Defaults, this.core.options);\n\t\tthis.swapping = true;\n\t\tthis.previous = undefined;\n\t\tthis.next = undefined;\n\n\t\tthis.handlers = {\n\t\t\t'change.owl.carousel': $.proxy(function(e) {\n\t\t\t\tif (e.namespace && e.property.name == 'position') {\n\t\t\t\t\tthis.previous = this.core.current();\n\t\t\t\t\tthis.next = e.property.value;\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'drag.owl.carousel dragged.owl.carousel translated.owl.carousel': $.proxy(function(e) {\n\t\t\t\tif (e.namespace) {\n\t\t\t\t\tthis.swapping = e.type == 'translated';\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'translate.owl.carousel': $.proxy(function(e) {\n\t\t\t\tif (e.namespace && this.swapping && (this.core.options.animateOut || this.core.options.animateIn)) {\n\t\t\t\t\tthis.swap();\n\t\t\t\t}\n\t\t\t}, this)\n\t\t};\n\n\t\tthis.core.$element.on(this.handlers);\n\t};\n\n\t/**\n\t * Default options.\n\t * @public\n\t */\n\tAnimate.Defaults = {\n\t\tanimateOut: false,\n\t\tanimateIn: false\n\t};\n\n\t/**\n\t * Toggles the animation classes whenever an translations starts.\n\t * @protected\n\t * @returns {Boolean|undefined}\n\t */\n\tAnimate.prototype.swap = function() {\n\n\t\tif (this.core.settings.items !== 1) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!$.support.animation || !$.support.transition) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.core.speed(0);\n\n\t\tvar left,\n\t\t\tclear = $.proxy(this.clear, this),\n\t\t\tprevious = this.core.$stage.children().eq(this.previous),\n\t\t\tnext = this.core.$stage.children().eq(this.next),\n\t\t\tincoming = this.core.settings.animateIn,\n\t\t\toutgoing = this.core.settings.animateOut;\n\n\t\tif (this.core.current() === this.previous) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (outgoing) {\n\t\t\tleft = this.core.coordinates(this.previous) - this.core.coordinates(this.next);\n\t\t\tprevious.one($.support.animation.end, clear)\n\t\t\t\t.css( { 'left': left + 'px' } )\n\t\t\t\t.addClass('animated owl-animated-out')\n\t\t\t\t.addClass(outgoing);\n\t\t}\n\n\t\tif (incoming) {\n\t\t\tnext.one($.support.animation.end, clear)\n\t\t\t\t.addClass('animated owl-animated-in')\n\t\t\t\t.addClass(incoming);\n\t\t}\n\t};\n\n\tAnimate.prototype.clear = function(e) {\n\t\t$(e.target).css( { 'left': '' } )\n\t\t\t.removeClass('animated owl-animated-out owl-animated-in')\n\t\t\t.removeClass(this.core.settings.animateIn)\n\t\t\t.removeClass(this.core.settings.animateOut);\n\t\tthis.core.onTransitionEnd();\n\t};\n\n\t/**\n\t * Destroys the plugin.\n\t * @public\n\t */\n\tAnimate.prototype.destroy = function() {\n\t\tvar handler, property;\n\n\t\tfor (handler in this.handlers) {\n\t\t\tthis.core.$element.off(handler, this.handlers[handler]);\n\t\t}\n\t\tfor (property in Object.getOwnPropertyNames(this)) {\n\t\t\ttypeof this[property] != 'function' && (this[property] = null);\n\t\t}\n\t};\n\n\t$.fn.owlCarousel.Constructor.Plugins.Animate = Animate;\n\n})(window.Zepto || __webpack_provided_window_dot_jQuery, window, document);\n\n/**\n * Autoplay Plugin\n * @version 2.1.0\n * @author Bartosz Wojciechowski\n * @author Artus Kolanowski\n * @author David Deutsch\n * @license The MIT License (MIT)\n */\n;(function($, window, document, undefined) {\n\n\t/**\n\t * Creates the autoplay plugin.\n\t * @class The Autoplay Plugin\n\t * @param {Owl} scope - The Owl Carousel\n\t */\n\tvar Autoplay = function(carousel) {\n\t\t/**\n\t\t * Reference to the core.\n\t\t * @protected\n\t\t * @type {Owl}\n\t\t */\n\t\tthis._core = carousel;\n\n\t\t/**\n\t\t * The autoplay timeout.\n\t\t * @type {Timeout}\n\t\t */\n\t\tthis._timeout = null;\n\n\t\t/**\n\t\t * Indicates whenever the autoplay is paused.\n\t\t * @type {Boolean}\n\t\t */\n\t\tthis._paused = false;\n\n\t\t/**\n\t\t * All event handlers.\n\t\t * @protected\n\t\t * @type {Object}\n\t\t */\n\t\tthis._handlers = {\n\t\t\t'changed.owl.carousel': $.proxy(function(e) {\n\t\t\t\tif (e.namespace && e.property.name === 'settings') {\n\t\t\t\t\tif (this._core.settings.autoplay) {\n\t\t\t\t\t\tthis.play();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.stop();\n\t\t\t\t\t}\n\t\t\t\t} else if (e.namespace && e.property.name === 'position') {\n\t\t\t\t\t//console.log('play?', e);\n\t\t\t\t\tif (this._core.settings.autoplay) {\n\t\t\t\t\t\tthis._setAutoPlayInterval();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'initialized.owl.carousel': $.proxy(function(e) {\n\t\t\t\tif (e.namespace && this._core.settings.autoplay) {\n\t\t\t\t\tthis.play();\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'play.owl.autoplay': $.proxy(function(e, t, s) {\n\t\t\t\tif (e.namespace) {\n\t\t\t\t\tthis.play(t, s);\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'stop.owl.autoplay': $.proxy(function(e) {\n\t\t\t\tif (e.namespace) {\n\t\t\t\t\tthis.stop();\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'mouseover.owl.autoplay': $.proxy(function() {\n\t\t\t\tif (this._core.settings.autoplayHoverPause && this._core.is('rotating')) {\n\t\t\t\t\tthis.pause();\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'mouseleave.owl.autoplay': $.proxy(function() {\n\t\t\t\tif (this._core.settings.autoplayHoverPause && this._core.is('rotating')) {\n\t\t\t\t\tthis.play();\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'touchstart.owl.core': $.proxy(function() {\n\t\t\t\tif (this._core.settings.autoplayHoverPause && this._core.is('rotating')) {\n\t\t\t\t\tthis.pause();\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'touchend.owl.core': $.proxy(function() {\n\t\t\t\tif (this._core.settings.autoplayHoverPause) {\n\t\t\t\t\tthis.play();\n\t\t\t\t}\n\t\t\t}, this)\n\t\t};\n\n\t\t// register event handlers\n\t\tthis._core.$element.on(this._handlers);\n\n\t\t// set default options\n\t\tthis._core.options = $.extend({}, Autoplay.Defaults, this._core.options);\n\t};\n\n\t/**\n\t * Default options.\n\t * @public\n\t */\n\tAutoplay.Defaults = {\n\t\tautoplay: false,\n\t\tautoplayTimeout: 5000,\n\t\tautoplayHoverPause: false,\n\t\tautoplaySpeed: false\n\t};\n\n\t/**\n\t * Starts the autoplay.\n\t * @public\n\t * @param {Number} [timeout] - The interval before the next animation starts.\n\t * @param {Number} [speed] - The animation speed for the animations.\n\t */\n\tAutoplay.prototype.play = function(timeout, speed) {\n\t\tthis._paused = false;\n\n\t\tif (this._core.is('rotating')) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._core.enter('rotating');\n\n\t\tthis._setAutoPlayInterval();\n\t};\n\n\t/**\n\t * Gets a new timeout\n\t * @private\n\t * @param {Number} [timeout] - The interval before the next animation starts.\n\t * @param {Number} [speed] - The animation speed for the animations.\n\t * @return {Timeout}\n\t */\n\tAutoplay.prototype._getNextTimeout = function(timeout, speed) {\n\t\tif ( this._timeout ) {\n\t\t\twindow.clearTimeout(this._timeout);\n\t\t}\n\t\treturn window.setTimeout($.proxy(function() {\n\t\t\tif (this._paused || this._core.is('busy') || this._core.is('interacting') || document.hidden) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis._core.next(speed || this._core.settings.autoplaySpeed);\n\t\t}, this), timeout || this._core.settings.autoplayTimeout);\n\t};\n\n\t/**\n\t * Sets autoplay in motion.\n\t * @private\n\t */\n\tAutoplay.prototype._setAutoPlayInterval = function() {\n\t\tthis._timeout = this._getNextTimeout();\n\t};\n\n\t/**\n\t * Stops the autoplay.\n\t * @public\n\t */\n\tAutoplay.prototype.stop = function() {\n\t\tif (!this._core.is('rotating')) {\n\t\t\treturn;\n\t\t}\n\n\t\twindow.clearTimeout(this._timeout);\n\t\tthis._core.leave('rotating');\n\t};\n\n\t/**\n\t * Stops the autoplay.\n\t * @public\n\t */\n\tAutoplay.prototype.pause = function() {\n\t\tif (!this._core.is('rotating')) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._paused = true;\n\t};\n\n\t/**\n\t * Destroys the plugin.\n\t */\n\tAutoplay.prototype.destroy = function() {\n\t\tvar handler, property;\n\n\t\tthis.stop();\n\n\t\tfor (handler in this._handlers) {\n\t\t\tthis._core.$element.off(handler, this._handlers[handler]);\n\t\t}\n\t\tfor (property in Object.getOwnPropertyNames(this)) {\n\t\t\ttypeof this[property] != 'function' && (this[property] = null);\n\t\t}\n\t};\n\n\t$.fn.owlCarousel.Constructor.Plugins.autoplay = Autoplay;\n\n})(window.Zepto || __webpack_provided_window_dot_jQuery, window, document);\n\n/**\n * Navigation Plugin\n * @version 2.1.0\n * @author Artus Kolanowski\n * @author David Deutsch\n * @license The MIT License (MIT)\n */\n;(function($, window, document, undefined) {\n\t'use strict';\n\n\t/**\n\t * Creates the navigation plugin.\n\t * @class The Navigation Plugin\n\t * @param {Owl} carousel - The Owl Carousel.\n\t */\n\tvar Navigation = function(carousel) {\n\t\t/**\n\t\t * Reference to the core.\n\t\t * @protected\n\t\t * @type {Owl}\n\t\t */\n\t\tthis._core = carousel;\n\n\t\t/**\n\t\t * Indicates whether the plugin is initialized or not.\n\t\t * @protected\n\t\t * @type {Boolean}\n\t\t */\n\t\tthis._initialized = false;\n\n\t\t/**\n\t\t * The current paging indexes.\n\t\t * @protected\n\t\t * @type {Array}\n\t\t */\n\t\tthis._pages = [];\n\n\t\t/**\n\t\t * All DOM elements of the user interface.\n\t\t * @protected\n\t\t * @type {Object}\n\t\t */\n\t\tthis._controls = {};\n\n\t\t/**\n\t\t * Markup for an indicator.\n\t\t * @protected\n\t\t * @type {Array.<String>}\n\t\t */\n\t\tthis._templates = [];\n\n\t\t/**\n\t\t * The carousel element.\n\t\t * @type {jQuery}\n\t\t */\n\t\tthis.$element = this._core.$element;\n\n\t\t/**\n\t\t * Overridden methods of the carousel.\n\t\t * @protected\n\t\t * @type {Object}\n\t\t */\n\t\tthis._overrides = {\n\t\t\tnext: this._core.next,\n\t\t\tprev: this._core.prev,\n\t\t\tto: this._core.to\n\t\t};\n\n\t\t/**\n\t\t * All event handlers.\n\t\t * @protected\n\t\t * @type {Object}\n\t\t */\n\t\tthis._handlers = {\n\t\t\t'prepared.owl.carousel': $.proxy(function(e) {\n\t\t\t\tif (e.namespace && this._core.settings.dotsData) {\n\t\t\t\t\tthis._templates.push('<div class=\"' + this._core.settings.dotClass + '\">' +\n\t\t\t\t\t\t$(e.content).find('[data-dot]').addBack('[data-dot]').attr('data-dot') + '</div>');\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'added.owl.carousel': $.proxy(function(e) {\n\t\t\t\tif (e.namespace && this._core.settings.dotsData) {\n\t\t\t\t\tthis._templates.splice(e.position, 0, this._templates.pop());\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'remove.owl.carousel': $.proxy(function(e) {\n\t\t\t\tif (e.namespace && this._core.settings.dotsData) {\n\t\t\t\t\tthis._templates.splice(e.position, 1);\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'changed.owl.carousel': $.proxy(function(e) {\n\t\t\t\tif (e.namespace && e.property.name == 'position') {\n\t\t\t\t\tthis.draw();\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'initialized.owl.carousel': $.proxy(function(e) {\n\t\t\t\tif (e.namespace && !this._initialized) {\n\t\t\t\t\tthis._core.trigger('initialize', null, 'navigation');\n\t\t\t\t\tthis.initialize();\n\t\t\t\t\tthis.update();\n\t\t\t\t\tthis.draw();\n\t\t\t\t\tthis._initialized = true;\n\t\t\t\t\tthis._core.trigger('initialized', null, 'navigation');\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'refreshed.owl.carousel': $.proxy(function(e) {\n\t\t\t\tif (e.namespace && this._initialized) {\n\t\t\t\t\tthis._core.trigger('refresh', null, 'navigation');\n\t\t\t\t\tthis.update();\n\t\t\t\t\tthis.draw();\n\t\t\t\t\tthis._core.trigger('refreshed', null, 'navigation');\n\t\t\t\t}\n\t\t\t}, this)\n\t\t};\n\n\t\t// set default options\n\t\tthis._core.options = $.extend({}, Navigation.Defaults, this._core.options);\n\n\t\t// register event handlers\n\t\tthis.$element.on(this._handlers);\n\t};\n\n\t/**\n\t * Default options.\n\t * @public\n\t * @todo Rename `slideBy` to `navBy`\n\t */\n\tNavigation.Defaults = {\n\t\tnav: false,\n\t\tnavText: [ 'prev', 'next' ],\n\t\tnavSpeed: false,\n\t\tnavElement: 'div',\n\t\tnavContainer: false,\n\t\tnavContainerClass: 'owl-nav',\n\t\tnavClass: [ 'owl-prev', 'owl-next' ],\n\t\tslideBy: 1,\n\t\tdotClass: 'owl-dot',\n\t\tdotsClass: 'owl-dots',\n\t\tdots: true,\n\t\tdotsEach: false,\n\t\tdotsData: false,\n\t\tdotsSpeed: false,\n\t\tdotsContainer: false\n\t};\n\n\t/**\n\t * Initializes the layout of the plugin and extends the carousel.\n\t * @protected\n\t */\n\tNavigation.prototype.initialize = function() {\n\t\tvar override,\n\t\t\tsettings = this._core.settings;\n\n\t\t// create DOM structure for relative navigation\n\t\tthis._controls.$relative = (settings.navContainer ? $(settings.navContainer)\n\t\t\t: $('<div>').addClass(settings.navContainerClass).appendTo(this.$element)).addClass('disabled');\n\n\t\tthis._controls.$previous = $('<' + settings.navElement + '>')\n\t\t\t.addClass(settings.navClass[0])\n\t\t\t.html(settings.navText[0])\n\t\t\t.prependTo(this._controls.$relative)\n\t\t\t.on('click', $.proxy(function(e) {\n\t\t\t\tthis.prev(settings.navSpeed);\n\t\t\t}, this));\n\t\tthis._controls.$next = $('<' + settings.navElement + '>')\n\t\t\t.addClass(settings.navClass[1])\n\t\t\t.html(settings.navText[1])\n\t\t\t.appendTo(this._controls.$relative)\n\t\t\t.on('click', $.proxy(function(e) {\n\t\t\t\tthis.next(settings.navSpeed);\n\t\t\t}, this));\n\n\t\t// create DOM structure for absolute navigation\n\t\tif (!settings.dotsData) {\n\t\t\tthis._templates = [ $('<div>')\n\t\t\t\t.addClass(settings.dotClass)\n\t\t\t\t.append($('<span>'))\n\t\t\t\t.prop('outerHTML') ];\n\t\t}\n\n\t\tthis._controls.$absolute = (settings.dotsContainer ? $(settings.dotsContainer)\n\t\t\t: $('<div>').addClass(settings.dotsClass).appendTo(this.$element)).addClass('disabled');\n\n\t\tthis._controls.$absolute.on('click', 'div', $.proxy(function(e) {\n\t\t\tvar index = $(e.target).parent().is(this._controls.$absolute)\n\t\t\t\t? $(e.target).index() : $(e.target).parent().index();\n\n\t\t\te.preventDefault();\n\n\t\t\tthis.to(index, settings.dotsSpeed);\n\t\t}, this));\n\n\t\t// override public methods of the carousel\n\t\tfor (override in this._overrides) {\n\t\t\tthis._core[override] = $.proxy(this[override], this);\n\t\t}\n\t};\n\n\t/**\n\t * Destroys the plugin.\n\t * @protected\n\t */\n\tNavigation.prototype.destroy = function() {\n\t\tvar handler, control, property, override;\n\n\t\tfor (handler in this._handlers) {\n\t\t\tthis.$element.off(handler, this._handlers[handler]);\n\t\t}\n\t\tfor (control in this._controls) {\n\t\t\tthis._controls[control].remove();\n\t\t}\n\t\tfor (override in this.overides) {\n\t\t\tthis._core[override] = this._overrides[override];\n\t\t}\n\t\tfor (property in Object.getOwnPropertyNames(this)) {\n\t\t\ttypeof this[property] != 'function' && (this[property] = null);\n\t\t}\n\t};\n\n\t/**\n\t * Updates the internal state.\n\t * @protected\n\t */\n\tNavigation.prototype.update = function() {\n\t\tvar i, j, k,\n\t\t\tlower = this._core.clones().length / 2,\n\t\t\tupper = lower + this._core.items().length,\n\t\t\tmaximum = this._core.maximum(true),\n\t\t\tsettings = this._core.settings,\n\t\t\tsize = settings.center || settings.autoWidth || settings.dotsData\n\t\t\t\t? 1 : settings.dotsEach || settings.items;\n\n\t\tif (settings.slideBy !== 'page') {\n\t\t\tsettings.slideBy = Math.min(settings.slideBy, settings.items);\n\t\t}\n\n\t\tif (settings.dots || settings.slideBy == 'page') {\n\t\t\tthis._pages = [];\n\n\t\t\tfor (i = lower, j = 0, k = 0; i < upper; i++) {\n\t\t\t\tif (j >= size || j === 0) {\n\t\t\t\t\tthis._pages.push({\n\t\t\t\t\t\tstart: Math.min(maximum, i - lower),\n\t\t\t\t\t\tend: i - lower + size - 1\n\t\t\t\t\t});\n\t\t\t\t\tif (Math.min(maximum, i - lower) === maximum) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tj = 0, ++k;\n\t\t\t\t}\n\t\t\t\tj += this._core.mergers(this._core.relative(i));\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Draws the user interface.\n\t * @todo The option `dotsData` wont work.\n\t * @protected\n\t */\n\tNavigation.prototype.draw = function() {\n\t\tvar difference,\n\t\t\tsettings = this._core.settings,\n\t\t\tdisabled = this._core.items().length <= settings.items,\n\t\t\tindex = this._core.relative(this._core.current()),\n\t\t\tloop = settings.loop || settings.rewind;\n\n\t\tthis._controls.$relative.toggleClass('disabled', !settings.nav || disabled);\n\n\t\tif (settings.nav) {\n\t\t\tthis._controls.$previous.toggleClass('disabled', !loop && index <= this._core.minimum(true));\n\t\t\tthis._controls.$next.toggleClass('disabled', !loop && index >= this._core.maximum(true));\n\t\t}\n\n\t\tthis._controls.$absolute.toggleClass('disabled', !settings.dots || disabled);\n\n\t\tif (settings.dots) {\n\t\t\tdifference = this._pages.length - this._controls.$absolute.children().length;\n\n\t\t\tif (settings.dotsData && difference !== 0) {\n\t\t\t\tthis._controls.$absolute.html(this._templates.join(''));\n\t\t\t} else if (difference > 0) {\n\t\t\t\tthis._controls.$absolute.append(new Array(difference + 1).join(this._templates[0]));\n\t\t\t} else if (difference < 0) {\n\t\t\t\tthis._controls.$absolute.children().slice(difference).remove();\n\t\t\t}\n\n\t\t\tthis._controls.$absolute.find('.active').removeClass('active');\n\t\t\tthis._controls.$absolute.children().eq($.inArray(this.current(), this._pages)).addClass('active');\n\t\t}\n\t};\n\n\t/**\n\t * Extends event data.\n\t * @protected\n\t * @param {Event} event - The event object which gets thrown.\n\t */\n\tNavigation.prototype.onTrigger = function(event) {\n\t\tvar settings = this._core.settings;\n\n\t\tevent.page = {\n\t\t\tindex: $.inArray(this.current(), this._pages),\n\t\t\tcount: this._pages.length,\n\t\t\tsize: settings && (settings.center || settings.autoWidth || settings.dotsData\n\t\t\t\t? 1 : settings.dotsEach || settings.items)\n\t\t};\n\t};\n\n\t/**\n\t * Gets the current page position of the carousel.\n\t * @protected\n\t * @returns {Number}\n\t */\n\tNavigation.prototype.current = function() {\n\t\tvar current = this._core.relative(this._core.current());\n\t\treturn $.grep(this._pages, $.proxy(function(page, index) {\n\t\t\treturn page.start <= current && page.end >= current;\n\t\t}, this)).pop();\n\t};\n\n\t/**\n\t * Gets the current succesor/predecessor position.\n\t * @protected\n\t * @returns {Number}\n\t */\n\tNavigation.prototype.getPosition = function(successor) {\n\t\tvar position, length,\n\t\t\tsettings = this._core.settings;\n\n\t\tif (settings.slideBy == 'page') {\n\t\t\tposition = $.inArray(this.current(), this._pages);\n\t\t\tlength = this._pages.length;\n\t\t\tsuccessor ? ++position : --position;\n\t\t\tposition = this._pages[((position % length) + length) % length].start;\n\t\t} else {\n\t\t\tposition = this._core.relative(this._core.current());\n\t\t\tlength = this._core.items().length;\n\t\t\tsuccessor ? position += settings.slideBy : position -= settings.slideBy;\n\t\t}\n\n\t\treturn position;\n\t};\n\n\t/**\n\t * Slides to the next item or page.\n\t * @public\n\t * @param {Number} [speed=false] - The time in milliseconds for the transition.\n\t */\n\tNavigation.prototype.next = function(speed) {\n\t\t$.proxy(this._overrides.to, this._core)(this.getPosition(true), speed);\n\t};\n\n\t/**\n\t * Slides to the previous item or page.\n\t * @public\n\t * @param {Number} [speed=false] - The time in milliseconds for the transition.\n\t */\n\tNavigation.prototype.prev = function(speed) {\n\t\t$.proxy(this._overrides.to, this._core)(this.getPosition(false), speed);\n\t};\n\n\t/**\n\t * Slides to the specified item or page.\n\t * @public\n\t * @param {Number} position - The position of the item or page.\n\t * @param {Number} [speed] - The time in milliseconds for the transition.\n\t * @param {Boolean} [standard=false] - Whether to use the standard behaviour or not.\n\t */\n\tNavigation.prototype.to = function(position, speed, standard) {\n\t\tvar length;\n\n\t\tif (!standard && this._pages.length) {\n\t\t\tlength = this._pages.length;\n\t\t\t$.proxy(this._overrides.to, this._core)(this._pages[((position % length) + length) % length].start, speed);\n\t\t} else {\n\t\t\t$.proxy(this._overrides.to, this._core)(position, speed);\n\t\t}\n\t};\n\n\t$.fn.owlCarousel.Constructor.Plugins.Navigation = Navigation;\n\n})(window.Zepto || __webpack_provided_window_dot_jQuery, window, document);\n\n/**\n * Hash Plugin\n * @version 2.1.0\n * @author Artus Kolanowski\n * @author David Deutsch\n * @license The MIT License (MIT)\n */\n;(function($, window, document, undefined) {\n\t'use strict';\n\n\t/**\n\t * Creates the hash plugin.\n\t * @class The Hash Plugin\n\t * @param {Owl} carousel - The Owl Carousel\n\t */\n\tvar Hash = function(carousel) {\n\t\t/**\n\t\t * Reference to the core.\n\t\t * @protected\n\t\t * @type {Owl}\n\t\t */\n\t\tthis._core = carousel;\n\n\t\t/**\n\t\t * Hash index for the items.\n\t\t * @protected\n\t\t * @type {Object}\n\t\t */\n\t\tthis._hashes = {};\n\n\t\t/**\n\t\t * The carousel element.\n\t\t * @type {jQuery}\n\t\t */\n\t\tthis.$element = this._core.$element;\n\n\t\t/**\n\t\t * All event handlers.\n\t\t * @protected\n\t\t * @type {Object}\n\t\t */\n\t\tthis._handlers = {\n\t\t\t'initialized.owl.carousel': $.proxy(function(e) {\n\t\t\t\tif (e.namespace && this._core.settings.startPosition === 'URLHash') {\n\t\t\t\t\t$(window).trigger('hashchange.owl.navigation');\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'prepared.owl.carousel': $.proxy(function(e) {\n\t\t\t\tif (e.namespace) {\n\t\t\t\t\tvar hash = $(e.content).find('[data-hash]').addBack('[data-hash]').attr('data-hash');\n\n\t\t\t\t\tif (!hash) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._hashes[hash] = e.content;\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'changed.owl.carousel': $.proxy(function(e) {\n\t\t\t\tif (e.namespace && e.property.name === 'position') {\n\t\t\t\t\tvar current = this._core.items(this._core.relative(this._core.current())),\n\t\t\t\t\t\thash = $.map(this._hashes, function(item, hash) {\n\t\t\t\t\t\t\treturn item === current ? hash : null;\n\t\t\t\t\t\t}).join();\n\n\t\t\t\t\tif (!hash || window.location.hash.slice(1) === hash) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\twindow.location.hash = hash;\n\t\t\t\t}\n\t\t\t}, this)\n\t\t};\n\n\t\t// set default options\n\t\tthis._core.options = $.extend({}, Hash.Defaults, this._core.options);\n\n\t\t// register the event handlers\n\t\tthis.$element.on(this._handlers);\n\n\t\t// register event listener for hash navigation\n\t\t$(window).on('hashchange.owl.navigation', $.proxy(function(e) {\n\t\t\tvar hash = window.location.hash.substring(1),\n\t\t\t\titems = this._core.$stage.children(),\n\t\t\t\tposition = this._hashes[hash] && items.index(this._hashes[hash]);\n\n\t\t\tif (position === undefined || position === this._core.current()) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._core.to(this._core.relative(position), false, true);\n\t\t}, this));\n\t};\n\n\t/**\n\t * Default options.\n\t * @public\n\t */\n\tHash.Defaults = {\n\t\tURLhashListener: false\n\t};\n\n\t/**\n\t * Destroys the plugin.\n\t * @public\n\t */\n\tHash.prototype.destroy = function() {\n\t\tvar handler, property;\n\n\t\t$(window).off('hashchange.owl.navigation');\n\n\t\tfor (handler in this._handlers) {\n\t\t\tthis._core.$element.off(handler, this._handlers[handler]);\n\t\t}\n\t\tfor (property in Object.getOwnPropertyNames(this)) {\n\t\t\ttypeof this[property] != 'function' && (this[property] = null);\n\t\t}\n\t};\n\n\t$.fn.owlCarousel.Constructor.Plugins.Hash = Hash;\n\n})(window.Zepto || __webpack_provided_window_dot_jQuery, window, document);\n\n/**\n * Support Plugin\n *\n * @version 2.1.0\n * @author Vivid Planet Software GmbH\n * @author Artus Kolanowski\n * @author David Deutsch\n * @license The MIT License (MIT)\n */\n;(function($, window, document, undefined) {\n\n\tvar style = $('<support>').get(0).style,\n\t\tprefixes = 'Webkit Moz O ms'.split(' '),\n\t\tevents = {\n\t\t\ttransition: {\n\t\t\t\tend: {\n\t\t\t\t\tWebkitTransition: 'webkitTransitionEnd',\n\t\t\t\t\tMozTransition: 'transitionend',\n\t\t\t\t\tOTransition: 'oTransitionEnd',\n\t\t\t\t\ttransition: 'transitionend'\n\t\t\t\t}\n\t\t\t},\n\t\t\tanimation: {\n\t\t\t\tend: {\n\t\t\t\t\tWebkitAnimation: 'webkitAnimationEnd',\n\t\t\t\t\tMozAnimation: 'animationend',\n\t\t\t\t\tOAnimation: 'oAnimationEnd',\n\t\t\t\t\tanimation: 'animationend'\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\ttests = {\n\t\t\tcsstransforms: function() {\n\t\t\t\treturn !!test('transform');\n\t\t\t},\n\t\t\tcsstransforms3d: function() {\n\t\t\t\treturn !!test('perspective');\n\t\t\t},\n\t\t\tcsstransitions: function() {\n\t\t\t\treturn !!test('transition');\n\t\t\t},\n\t\t\tcssanimations: function() {\n\t\t\t\treturn !!test('animation');\n\t\t\t}\n\t\t};\n\n\tfunction test(property, prefixed) {\n\t\tvar result = false,\n\t\t\tupper = property.charAt(0).toUpperCase() + property.slice(1);\n\n\t\t$.each((property + ' ' + prefixes.join(upper + ' ') + upper).split(' '), function(i, property) {\n\t\t\tif (style[property] !== undefined) {\n\t\t\t\tresult = prefixed ? property : true;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t});\n\n\t\treturn result;\n\t}\n\n\tfunction prefixed(property) {\n\t\treturn test(property, true);\n\t}\n\n\tif (tests.csstransitions()) {\n\t\t/* jshint -W053 */\n\t\t$.support.transition = new String(prefixed('transition'))\n\t\t$.support.transition.end = events.transition.end[ $.support.transition ];\n\t}\n\n\tif (tests.cssanimations()) {\n\t\t/* jshint -W053 */\n\t\t$.support.animation = new String(prefixed('animation'))\n\t\t$.support.animation.end = events.animation.end[ $.support.animation ];\n\t}\n\n\tif (tests.csstransforms()) {\n\t\t/* jshint -W053 */\n\t\t$.support.transform = new String(prefixed('transform'));\n\t\t$.support.transform3d = tests.csstransforms3d();\n\t}\n\n})(window.Zepto || __webpack_provided_window_dot_jQuery, window, document);\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1), __webpack_require__(1)))\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/owl.carousel/dist/owl.carousel.js\n// module id = 8\n// module chunks = 0\n\n//# sourceURL=webpack:///./~/owl.carousel/dist/owl.carousel.js?");

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nif (process.env.NODE_ENV !== 'production') {\n  var REACT_ELEMENT_TYPE = (typeof Symbol === 'function' &&\n    Symbol.for &&\n    Symbol.for('react.element')) ||\n    0xeac7;\n\n  var isValidElement = function(object) {\n    return typeof object === 'object' &&\n      object !== null &&\n      object.$$typeof === REACT_ELEMENT_TYPE;\n  };\n\n  // By explicitly using `prop-types` you are opting into new development behavior.\n  // http://fb.me/prop-types-in-prod\n  var throwOnDirectAccess = true;\n  module.exports = __webpack_require__(21)(isValidElement, throwOnDirectAccess);\n} else {\n  // By explicitly using `prop-types` you are opting into new production behavior.\n  // http://fb.me/prop-types-in-prod\n  module.exports = __webpack_require__(20)();\n}\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/prop-types/index.js\n// module id = 9\n// module chunks = 0\n\n//# sourceURL=webpack:///./~/prop-types/index.js?");

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(14);\nif(typeof content === 'string') content = [[module.i, content, '']];\n// Prepare cssTransformation\nvar transform;\n\nvar options = {}\noptions.transform = transform\n// add the styles to the DOM\nvar update = __webpack_require__(7)(content, options);\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(false) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!../../../css-loader/index.js!./owl.carousel.min.css\", function() {\n\t\t\tvar newContent = require(\"!!../../../css-loader/index.js!./owl.carousel.min.css\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/owl.carousel/dist/assets/owl.carousel.min.css\n// module id = 10\n// module chunks = 0\n\n//# sourceURL=webpack:///./~/owl.carousel/dist/assets/owl.carousel.min.css?");

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(15);\nif(typeof content === 'string') content = [[module.i, content, '']];\n// Prepare cssTransformation\nvar transform;\n\nvar options = {}\noptions.transform = transform\n// add the styles to the DOM\nvar update = __webpack_require__(7)(content, options);\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(false) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!../../../css-loader/index.js!./owl.theme.default.min.css\", function() {\n\t\t\tvar newContent = require(\"!!../../../css-loader/index.js!./owl.theme.default.min.css\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/owl.carousel/dist/assets/owl.theme.default.min.css\n// module id = 11\n// module chunks = 0\n\n//# sourceURL=webpack:///./~/owl.carousel/dist/assets/owl.theme.default.min.css?");

/***/ }),
/* 12 */
/***/ (function(module, exports) {

eval("module.exports = __WEBPACK_EXTERNAL_MODULE_12__;\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"root\":\"React\",\"commonjs2\":\"react\",\"commonjs\":\"react\",\"amd\":\"react\"}\n// module id = 12\n// module chunks = 0\n\n//# sourceURL=webpack:///external_%7B%22root%22:%22React%22,%22commonjs2%22:%22react%22,%22commonjs%22:%22react%22,%22amd%22:%22react%22%7D?");

/***/ }),
/* 13 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* WEBPACK VAR INJECTION */(function($) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(12);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types__ = __webpack_require__(9);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_prop_types__);\n\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\nvar Owl_Carousel_Options = {\n\n    // options\n    items: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number,\n    margin: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number,\n    loop: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,\n    center: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,\n    mouseDrag: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,\n    touchDrag: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,\n    pullDrag: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,\n    freeDrag: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,\n    stagePadding: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number,\n    merge: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,\n    mergeFit: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,\n    autoWidth: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,\n    startPosition: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string]),\n    URLhashListener: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,\n    nav: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,\n    rewind: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,\n    navText: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.arrayOf(__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string), __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.arrayOf(__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.element)]),\n    navElement: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,\n    slideBy: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string]),\n    dots: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,\n    dotsEach: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool]),\n    dotData: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,\n    lazyLoad: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,\n    lazyContent: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,\n    autoplay: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,\n    autoplayTimeout: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number,\n    autoplayHoverPause: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,\n    smartSpeed: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number,\n    fluidSpeed: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,\n    autoplaySpeed: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool]),\n    navSpeed: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool]),\n    dotsSpeed: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool]),\n    dragEndSpeed: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool]),\n    callbacks: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,\n    responsive: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,\n    responsiveRefreshRate: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number,\n    responsiveBaseElement: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.element,\n    video: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,\n    videoHeight: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool]),\n    videoWidth: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.number, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool]),\n    animateOut: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool]),\n    animateIn: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool]),\n    fallbackEasing: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,\n    info: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool]),\n    nestedItemSelector: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool]),\n    itemElement: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,\n    stageElement: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,\n    navContainer: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool]),\n    dotsContainer: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool]),\n\n    // dom class\n    refreshClass: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,\n    loadingClass: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,\n    loadedClass: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,\n    rtlClass: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,\n    dragClass: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,\n    grabClass: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,\n    stageClass: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,\n    stageOuterClass: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,\n    navContainerClass: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,\n    navClass: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.arrayOf(__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string),\n    controlsClass: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,\n    dotClass: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,\n    dotsClass: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,\n    autoHeightClass: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,\n    responsiveClass: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool]),\n\n    // event\n    onInitialize: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,\n    onInitialized: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,\n    onResize: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,\n    onResized: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,\n    onRefresh: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,\n    onRefreshed: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,\n    onDrag: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,\n    onDragged: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,\n    onTranslate: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,\n    onTranslated: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,\n    onChange: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,\n    onChanged: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,\n    onLoadLazy: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,\n    onLoadedLazy: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,\n    onStopVideo: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,\n    onPlayVideo: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func\n};\n\nvar OwlCarousel = function (_Component) {\n    _inherits(OwlCarousel, _Component);\n\n    function OwlCarousel(props, context) {\n        _classCallCheck(this, OwlCarousel);\n\n        var _this = _possibleConstructorReturn(this, (OwlCarousel.__proto__ || Object.getPrototypeOf(OwlCarousel)).call(this, props, context));\n\n        _this.next = _this.next.bind(_this);\n        _this.prev = _this.prev.bind(_this);\n        _this.to = _this.to.bind(_this);\n        _this.create = _this.create.bind(_this);\n        _this.destory = _this.destory.bind(_this);\n        _this.play = _this.play.bind(_this);\n        _this.stop = _this.stop.bind(_this);\n        return _this;\n    }\n\n    _createClass(OwlCarousel, [{\n        key: 'componentWillMount',\n        value: function componentWillMount() {\n            __webpack_require__(10);\n            __webpack_require__(11);\n            __webpack_require__(8);\n\n            this._filterProps(this.props);\n        }\n    }, {\n        key: 'componentDidMount',\n        value: function componentDidMount() {\n            this.owlCarousel = $(this.inst);\n            this.owlCarousel.owlCarousel(this.options);\n        }\n    }, {\n        key: 'componentWillReceiveProps',\n        value: function componentWillReceiveProps(nextProps) {\n            this._filterProps(nextProps);\n            this.destory();\n        }\n    }, {\n        key: 'componentDidUpdate',\n        value: function componentDidUpdate() {\n            this.owlCarousel = $(this.inst);\n            this.owlCarousel.owlCarousel(this.options);\n        }\n    }, {\n        key: 'componentWillUnmount',\n        value: function componentWillUnmount() {\n            this.destory();\n        }\n    }, {\n        key: 'next',\n        value: function next(speed) {\n            if (typeof speed == 'number') {\n                this.owlCarousel.trigger('next.owl.carousel', [speed]);\n            } else {\n                this.owlCarousel.trigger('next.owl.carousel');\n            }\n        }\n    }, {\n        key: 'prev',\n        value: function prev(speed) {\n            if (typeof speed == 'number') {\n                this.owlCarousel.trigger('prev.owl.carousel', [speed]);\n            } else {\n                this.owlCarousel.trigger('prev.owl.carousel');\n            }\n        }\n\n        // refresh(event, speed) {\n        // }\n\n    }, {\n        key: 'to',\n        value: function to(position, speed) {\n            if (typeof position == 'number' && typeof speed == 'number') {\n                this.owlCarousel.trigger('to.owl.carousel', [position, speed]);\n            } else {\n                this.owlCarousel.trigger('to.owl.carousel');\n            }\n        }\n    }, {\n        key: 'create',\n        value: function create() {\n            this.owlCarousel.owlCarousel(this.options);\n        }\n    }, {\n        key: 'destory',\n        value: function destory() {\n            this.owlCarousel.trigger('destroy.owl.carousel');\n        }\n\n        // replace(data) {\n\n        // }\n\n        // add(data, position) {\n\n        // }\n\n        // remove(position) {\n\n        // }\n\n    }, {\n        key: 'play',\n        value: function play(timeout, speed) {\n            if (typeof timeout == 'number' && typeof speed == 'number') {\n                this.owlCarousel.trigger('play.owl.autoplay', [timeout, speed]);\n            } else {\n                this.owlCarousel.trigger('play.owl.autoplay');\n            }\n        }\n    }, {\n        key: 'stop',\n        value: function stop() {\n            this.owlCarousel.trigger('stop.owl.autoplay');\n        }\n    }, {\n        key: '_filterProps',\n        value: function _filterProps(props) {\n            var _this2 = this;\n\n            this.options = {};\n            this.propsWithoutOptions = {};\n            Object.keys(props).forEach(function (key) {\n                if (Owl_Carousel_Options.hasOwnProperty(key)) {\n                    _this2.options[key] = props[key];\n                } else {\n                    _this2.propsWithoutOptions[key] = props[key];\n                }\n            });\n        }\n    }, {\n        key: 'render',\n        value: function render() {\n            var _this3 = this;\n\n            var _propsWithoutOptions = this.propsWithoutOptions,\n                className = _propsWithoutOptions.className,\n                children = _propsWithoutOptions.children,\n                props = _objectWithoutProperties(_propsWithoutOptions, ['className', 'children']);\n\n            return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(\n                'div',\n                _extends({\n                    className: 'owl-carousel ' + className,\n                    ref: function ref(inst) {\n                        return _this3.inst = inst;\n                    }\n                }, props),\n                children\n            );\n        }\n    }]);\n\n    return OwlCarousel;\n}(__WEBPACK_IMPORTED_MODULE_0_react__[\"Component\"]);\n\nOwlCarousel.propTypes = Owl_Carousel_Options;\n\nOwlCarousel.defaultProps = {\n    className: ''\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (OwlCarousel);\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(1)))\n\n//////////////////\n// WEBPACK FOOTER\n// ./components/OwlCarousel.jsx\n// module id = 13\n// module chunks = 0\n\n//# sourceURL=webpack:///./components/OwlCarousel.jsx?");

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

eval("var escape = __webpack_require__(16);\nexports = module.exports = __webpack_require__(5)(false);\n// imports\n\n\n// module\nexports.push([module.i, \"/**\\n * Owl Carousel v2.2.0\\n * Copyright 2013-2016 David Deutsch\\n * Licensed under MIT (https://github.com/OwlCarousel2/OwlCarousel2/blob/master/LICENSE)\\n */\\n.owl-carousel,.owl-carousel .owl-item{-webkit-tap-highlight-color:transparent;position:relative}.owl-carousel{display:none;width:100%;z-index:1}.owl-carousel .owl-stage{position:relative;-ms-touch-action:pan-Y}.owl-carousel .owl-stage:after{content:\\\".\\\";display:block;clear:both;visibility:hidden;line-height:0;height:0}.owl-carousel .owl-stage-outer{position:relative;overflow:hidden;-webkit-transform:translate3d(0,0,0)}.owl-carousel .owl-item{min-height:1px;float:left;-webkit-backface-visibility:hidden;-webkit-touch-callout:none}.owl-carousel .owl-item img{display:block;width:100%;-webkit-transform-style:preserve-3d}.owl-carousel .owl-dots.disabled,.owl-carousel .owl-nav.disabled{display:none}.no-js .owl-carousel,.owl-carousel.owl-loaded{display:block}.owl-carousel .owl-dot,.owl-carousel .owl-nav .owl-next,.owl-carousel .owl-nav .owl-prev{cursor:pointer;cursor:hand;-webkit-user-select:none;-khtml-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.owl-carousel.owl-loading{opacity:0;display:block}.owl-carousel.owl-hidden{opacity:0}.owl-carousel.owl-refresh .owl-item{visibility:hidden}.owl-carousel.owl-drag .owl-item{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.owl-carousel.owl-grab{cursor:move;cursor:grab}.owl-carousel.owl-rtl{direction:rtl}.owl-carousel.owl-rtl .owl-item{float:right}.owl-carousel .animated{-webkit-animation-duration:1s;animation-duration:1s;-webkit-animation-fill-mode:both;animation-fill-mode:both}.owl-carousel .owl-animated-in{z-index:0}.owl-carousel .owl-animated-out{z-index:1}.owl-carousel .fadeOut{-webkit-animation-name:fadeOut;animation-name:fadeOut}@-webkit-keyframes fadeOut{0%{opacity:1}100%{opacity:0}}@keyframes fadeOut{0%{opacity:1}100%{opacity:0}}.owl-height{transition:height .5s ease-in-out}.owl-carousel .owl-item .owl-lazy{opacity:0;transition:opacity .4s ease}.owl-carousel .owl-item img.owl-lazy{-webkit-transform-style:preserve-3d;transform-style:preserve-3d}.owl-carousel .owl-video-wrapper{position:relative;height:100%;background:#000}.owl-carousel .owl-video-play-icon{position:absolute;height:80px;width:80px;left:50%;top:50%;margin-left:-40px;margin-top:-40px;background:url(\" + escape(__webpack_require__(17)) + \") no-repeat;cursor:pointer;z-index:1;-webkit-backface-visibility:hidden;transition:-webkit-transform .1s ease;transition:transform .1s ease}.owl-carousel .owl-video-play-icon:hover{-webkit-transform:scale(1.3,1.3);-ms-transform:scale(1.3,1.3);transform:scale(1.3,1.3)}.owl-carousel .owl-video-playing .owl-video-play-icon,.owl-carousel .owl-video-playing .owl-video-tn{display:none}.owl-carousel .owl-video-tn{opacity:0;height:100%;background-position:center center;background-repeat:no-repeat;background-size:contain;transition:opacity .4s ease}.owl-carousel .owl-video-frame{position:relative;z-index:1;height:100%;width:100%}\", \"\"]);\n\n// exports\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader!./~/owl.carousel/dist/assets/owl.carousel.min.css\n// module id = 14\n// module chunks = 0\n\n//# sourceURL=webpack:///./~/owl.carousel/dist/assets/owl.carousel.min.css?./~/css-loader");

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(5)(false);\n// imports\n\n\n// module\nexports.push([module.i, \"/**\\n * Owl Carousel v2.2.0\\n * Copyright 2013-2016 David Deutsch\\n * Licensed under MIT (https://github.com/OwlCarousel2/OwlCarousel2/blob/master/LICENSE)\\n */\\n.owl-theme .owl-dots,.owl-theme .owl-nav{text-align:center;-webkit-tap-highlight-color:transparent}.owl-theme .owl-nav{margin-top:10px}.owl-theme .owl-nav [class*=owl-]{color:#FFF;font-size:14px;margin:5px;padding:4px 7px;background:#D6D6D6;display:inline-block;cursor:pointer;border-radius:3px}.owl-theme .owl-nav [class*=owl-]:hover{background:#869791;color:#FFF;text-decoration:none}.owl-theme .owl-nav .disabled{opacity:.5;cursor:default}.owl-theme .owl-nav.disabled+.owl-dots{margin-top:10px}.owl-theme .owl-dots .owl-dot{display:inline-block;zoom:1}.owl-theme .owl-dots .owl-dot span{width:10px;height:10px;margin:5px 7px;background:#D6D6D6;display:block;-webkit-backface-visibility:visible;transition:opacity .2s ease;border-radius:30px}.owl-theme .owl-dots .owl-dot.active span,.owl-theme .owl-dots .owl-dot:hover span{background:#869791}\", \"\"]);\n\n// exports\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader!./~/owl.carousel/dist/assets/owl.theme.default.min.css\n// module id = 15\n// module chunks = 0\n\n//# sourceURL=webpack:///./~/owl.carousel/dist/assets/owl.theme.default.min.css?./~/css-loader");

/***/ }),
/* 16 */
/***/ (function(module, exports) {

eval("module.exports = function escape(url) {\n    if (typeof url !== 'string') {\n        return url\n    }\n    // If url is already wrapped in quotes, remove them\n    if (/^['\"].*['\"]$/.test(url)) {\n        url = url.slice(1, -1);\n    }\n    // Should url be wrapped?\n    // See https://drafts.csswg.org/css-values-3/#urls\n    if (/[\"'() \\t\\n]/.test(url)) {\n        return '\"' + url.replace(/\"/g, '\\\\\"').replace(/\\n/g, '\\\\n') + '\"'\n    }\n\n    return url\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader/lib/url/escape.js\n// module id = 16\n// module chunks = 0\n\n//# sourceURL=webpack:///./~/css-loader/lib/url/escape.js?");

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"4a37f8008959c75f619bf0a3a4e2d7a2.png\";\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/owl.carousel/dist/assets/owl.video.play.png\n// module id = 17\n// module chunks = 0\n\n//# sourceURL=webpack:///./~/owl.carousel/dist/assets/owl.video.play.png?");

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\n\n\n/* eslint-disable no-unused-vars */\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction shouldUseNative() {\n\ttry {\n\t\tif (!Object.assign) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\tvar test1 = new String('abc');  // eslint-disable-line no-new-wrappers\n\t\ttest1[5] = 'de';\n\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test2 = {};\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t}\n\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\treturn test2[n];\n\t\t});\n\t\tif (order2.join('') !== '0123456789') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test3 = {};\n\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\ttest3[letter] = letter;\n\t\t});\n\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (err) {\n\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\treturn false;\n\t}\n}\n\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n\tvar from;\n\tvar to = toObject(target);\n\tvar symbols;\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = Object(arguments[s]);\n\n\t\tfor (var key in from) {\n\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\tto[key] = from[key];\n\t\t\t}\n\t\t}\n\n\t\tif (getOwnPropertySymbols) {\n\t\t\tsymbols = getOwnPropertySymbols(from);\n\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/object-assign/index.js\n// module id = 18\n// module chunks = 0\n\n//# sourceURL=webpack:///./~/object-assign/index.js?");

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (process.env.NODE_ENV !== 'production') {\n  var invariant = __webpack_require__(3);\n  var warning = __webpack_require__(6);\n  var ReactPropTypesSecret = __webpack_require__(4);\n  var loggedTypeFailures = {};\n}\n\n/**\n * Assert that the values match with the type specs.\n * Error messages are memorized and will only be shown once.\n *\n * @param {object} typeSpecs Map of name to a ReactPropType\n * @param {object} values Runtime values that need to be type-checked\n * @param {string} location e.g. \"prop\", \"context\", \"child context\"\n * @param {string} componentName Name of the component for error messages.\n * @param {?Function} getStack Returns the component stack.\n * @private\n */\nfunction checkPropTypes(typeSpecs, values, location, componentName, getStack) {\n  if (process.env.NODE_ENV !== 'production') {\n    for (var typeSpecName in typeSpecs) {\n      if (typeSpecs.hasOwnProperty(typeSpecName)) {\n        var error;\n        // Prop type validation may throw. In case they do, we don't want to\n        // fail the render phase where it didn't fail before. So we log it.\n        // After these have been cleaned up, we'll let them throw.\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          invariant(typeof typeSpecs[typeSpecName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'the `prop-types` package, but received `%s`.', componentName || 'React class', location, typeSpecName, typeof typeSpecs[typeSpecName]);\n          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);\n        } catch (ex) {\n          error = ex;\n        }\n        warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error);\n        if (error instanceof Error && !(error.message in loggedTypeFailures)) {\n          // Only monitor this failure once because there tends to be a lot of the\n          // same error.\n          loggedTypeFailures[error.message] = true;\n\n          var stack = getStack ? getStack() : '';\n\n          warning(false, 'Failed %s type: %s%s', location, error.message, stack != null ? stack : '');\n        }\n      }\n    }\n  }\n}\n\nmodule.exports = checkPropTypes;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/prop-types/checkPropTypes.js\n// module id = 19\n// module chunks = 0\n\n//# sourceURL=webpack:///./~/prop-types/checkPropTypes.js?");

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar emptyFunction = __webpack_require__(2);\nvar invariant = __webpack_require__(3);\nvar ReactPropTypesSecret = __webpack_require__(4);\n\nmodule.exports = function() {\n  function shim(props, propName, componentName, location, propFullName, secret) {\n    if (secret === ReactPropTypesSecret) {\n      // It is still safe when called from React.\n      return;\n    }\n    invariant(\n      false,\n      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +\n      'Use PropTypes.checkPropTypes() to call them. ' +\n      'Read more at http://fb.me/use-check-prop-types'\n    );\n  };\n  shim.isRequired = shim;\n  function getShim() {\n    return shim;\n  };\n  // Important!\n  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.\n  var ReactPropTypes = {\n    array: shim,\n    bool: shim,\n    func: shim,\n    number: shim,\n    object: shim,\n    string: shim,\n    symbol: shim,\n\n    any: shim,\n    arrayOf: getShim,\n    element: shim,\n    instanceOf: getShim,\n    node: shim,\n    objectOf: getShim,\n    oneOf: getShim,\n    oneOfType: getShim,\n    shape: getShim,\n    exact: getShim\n  };\n\n  ReactPropTypes.checkPropTypes = emptyFunction;\n  ReactPropTypes.PropTypes = ReactPropTypes;\n\n  return ReactPropTypes;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/prop-types/factoryWithThrowingShims.js\n// module id = 20\n// module chunks = 0\n\n//# sourceURL=webpack:///./~/prop-types/factoryWithThrowingShims.js?");

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar emptyFunction = __webpack_require__(2);\nvar invariant = __webpack_require__(3);\nvar warning = __webpack_require__(6);\nvar assign = __webpack_require__(18);\n\nvar ReactPropTypesSecret = __webpack_require__(4);\nvar checkPropTypes = __webpack_require__(19);\n\nmodule.exports = function(isValidElement, throwOnDirectAccess) {\n  /* global Symbol */\n  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\n  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.\n\n  /**\n   * Returns the iterator method function contained on the iterable object.\n   *\n   * Be sure to invoke the function with the iterable as context:\n   *\n   *     var iteratorFn = getIteratorFn(myIterable);\n   *     if (iteratorFn) {\n   *       var iterator = iteratorFn.call(myIterable);\n   *       ...\n   *     }\n   *\n   * @param {?object} maybeIterable\n   * @return {?function}\n   */\n  function getIteratorFn(maybeIterable) {\n    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);\n    if (typeof iteratorFn === 'function') {\n      return iteratorFn;\n    }\n  }\n\n  /**\n   * Collection of methods that allow declaration and validation of props that are\n   * supplied to React components. Example usage:\n   *\n   *   var Props = require('ReactPropTypes');\n   *   var MyArticle = React.createClass({\n   *     propTypes: {\n   *       // An optional string prop named \"description\".\n   *       description: Props.string,\n   *\n   *       // A required enum prop named \"category\".\n   *       category: Props.oneOf(['News','Photos']).isRequired,\n   *\n   *       // A prop named \"dialog\" that requires an instance of Dialog.\n   *       dialog: Props.instanceOf(Dialog).isRequired\n   *     },\n   *     render: function() { ... }\n   *   });\n   *\n   * A more formal specification of how these methods are used:\n   *\n   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)\n   *   decl := ReactPropTypes.{type}(.isRequired)?\n   *\n   * Each and every declaration produces a function with the same signature. This\n   * allows the creation of custom validation functions. For example:\n   *\n   *  var MyLink = React.createClass({\n   *    propTypes: {\n   *      // An optional string or URI prop named \"href\".\n   *      href: function(props, propName, componentName) {\n   *        var propValue = props[propName];\n   *        if (propValue != null && typeof propValue !== 'string' &&\n   *            !(propValue instanceof URI)) {\n   *          return new Error(\n   *            'Expected a string or an URI for ' + propName + ' in ' +\n   *            componentName\n   *          );\n   *        }\n   *      }\n   *    },\n   *    render: function() {...}\n   *  });\n   *\n   * @internal\n   */\n\n  var ANONYMOUS = '<<anonymous>>';\n\n  // Important!\n  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.\n  var ReactPropTypes = {\n    array: createPrimitiveTypeChecker('array'),\n    bool: createPrimitiveTypeChecker('boolean'),\n    func: createPrimitiveTypeChecker('function'),\n    number: createPrimitiveTypeChecker('number'),\n    object: createPrimitiveTypeChecker('object'),\n    string: createPrimitiveTypeChecker('string'),\n    symbol: createPrimitiveTypeChecker('symbol'),\n\n    any: createAnyTypeChecker(),\n    arrayOf: createArrayOfTypeChecker,\n    element: createElementTypeChecker(),\n    instanceOf: createInstanceTypeChecker,\n    node: createNodeChecker(),\n    objectOf: createObjectOfTypeChecker,\n    oneOf: createEnumTypeChecker,\n    oneOfType: createUnionTypeChecker,\n    shape: createShapeTypeChecker,\n    exact: createStrictShapeTypeChecker,\n  };\n\n  /**\n   * inlined Object.is polyfill to avoid requiring consumers ship their own\n   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n   */\n  /*eslint-disable no-self-compare*/\n  function is(x, y) {\n    // SameValue algorithm\n    if (x === y) {\n      // Steps 1-5, 7-10\n      // Steps 6.b-6.e: +0 != -0\n      return x !== 0 || 1 / x === 1 / y;\n    } else {\n      // Step 6.a: NaN == NaN\n      return x !== x && y !== y;\n    }\n  }\n  /*eslint-enable no-self-compare*/\n\n  /**\n   * We use an Error-like object for backward compatibility as people may call\n   * PropTypes directly and inspect their output. However, we don't use real\n   * Errors anymore. We don't inspect their stack anyway, and creating them\n   * is prohibitively expensive if they are created too often, such as what\n   * happens in oneOfType() for any type before the one that matched.\n   */\n  function PropTypeError(message) {\n    this.message = message;\n    this.stack = '';\n  }\n  // Make `instanceof Error` still work for returned errors.\n  PropTypeError.prototype = Error.prototype;\n\n  function createChainableTypeChecker(validate) {\n    if (process.env.NODE_ENV !== 'production') {\n      var manualPropTypeCallCache = {};\n      var manualPropTypeWarningCount = 0;\n    }\n    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {\n      componentName = componentName || ANONYMOUS;\n      propFullName = propFullName || propName;\n\n      if (secret !== ReactPropTypesSecret) {\n        if (throwOnDirectAccess) {\n          // New behavior only for users of `prop-types` package\n          invariant(\n            false,\n            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +\n            'Use `PropTypes.checkPropTypes()` to call them. ' +\n            'Read more at http://fb.me/use-check-prop-types'\n          );\n        } else if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined') {\n          // Old behavior for people using React.PropTypes\n          var cacheKey = componentName + ':' + propName;\n          if (\n            !manualPropTypeCallCache[cacheKey] &&\n            // Avoid spamming the console because they are often not actionable except for lib authors\n            manualPropTypeWarningCount < 3\n          ) {\n            warning(\n              false,\n              'You are manually calling a React.PropTypes validation ' +\n              'function for the `%s` prop on `%s`. This is deprecated ' +\n              'and will throw in the standalone `prop-types` package. ' +\n              'You may be seeing this warning due to a third-party PropTypes ' +\n              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.',\n              propFullName,\n              componentName\n            );\n            manualPropTypeCallCache[cacheKey] = true;\n            manualPropTypeWarningCount++;\n          }\n        }\n      }\n      if (props[propName] == null) {\n        if (isRequired) {\n          if (props[propName] === null) {\n            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));\n          }\n          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));\n        }\n        return null;\n      } else {\n        return validate(props, propName, componentName, location, propFullName);\n      }\n    }\n\n    var chainedCheckType = checkType.bind(null, false);\n    chainedCheckType.isRequired = checkType.bind(null, true);\n\n    return chainedCheckType;\n  }\n\n  function createPrimitiveTypeChecker(expectedType) {\n    function validate(props, propName, componentName, location, propFullName, secret) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== expectedType) {\n        // `propValue` being instance of, say, date/regexp, pass the 'object'\n        // check, but we can offer a more precise error message here rather than\n        // 'of type `object`'.\n        var preciseType = getPreciseType(propValue);\n\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createAnyTypeChecker() {\n    return createChainableTypeChecker(emptyFunction.thatReturnsNull);\n  }\n\n  function createArrayOfTypeChecker(typeChecker) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (typeof typeChecker !== 'function') {\n        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');\n      }\n      var propValue = props[propName];\n      if (!Array.isArray(propValue)) {\n        var propType = getPropType(propValue);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));\n      }\n      for (var i = 0; i < propValue.length; i++) {\n        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);\n        if (error instanceof Error) {\n          return error;\n        }\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createElementTypeChecker() {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      if (!isValidElement(propValue)) {\n        var propType = getPropType(propValue);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createInstanceTypeChecker(expectedClass) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (!(props[propName] instanceof expectedClass)) {\n        var expectedClassName = expectedClass.name || ANONYMOUS;\n        var actualClassName = getClassName(props[propName]);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createEnumTypeChecker(expectedValues) {\n    if (!Array.isArray(expectedValues)) {\n      process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOf, expected an instance of array.') : void 0;\n      return emptyFunction.thatReturnsNull;\n    }\n\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      for (var i = 0; i < expectedValues.length; i++) {\n        if (is(propValue, expectedValues[i])) {\n          return null;\n        }\n      }\n\n      var valuesString = JSON.stringify(expectedValues);\n      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createObjectOfTypeChecker(typeChecker) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (typeof typeChecker !== 'function') {\n        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');\n      }\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));\n      }\n      for (var key in propValue) {\n        if (propValue.hasOwnProperty(key)) {\n          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n          if (error instanceof Error) {\n            return error;\n          }\n        }\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createUnionTypeChecker(arrayOfTypeCheckers) {\n    if (!Array.isArray(arrayOfTypeCheckers)) {\n      process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;\n      return emptyFunction.thatReturnsNull;\n    }\n\n    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {\n      var checker = arrayOfTypeCheckers[i];\n      if (typeof checker !== 'function') {\n        warning(\n          false,\n          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +\n          'received %s at index %s.',\n          getPostfixForTypeWarning(checker),\n          i\n        );\n        return emptyFunction.thatReturnsNull;\n      }\n    }\n\n    function validate(props, propName, componentName, location, propFullName) {\n      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {\n        var checker = arrayOfTypeCheckers[i];\n        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {\n          return null;\n        }\n      }\n\n      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createNodeChecker() {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (!isNode(props[propName])) {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createShapeTypeChecker(shapeTypes) {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));\n      }\n      for (var key in shapeTypes) {\n        var checker = shapeTypes[key];\n        if (!checker) {\n          continue;\n        }\n        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n        if (error) {\n          return error;\n        }\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createStrictShapeTypeChecker(shapeTypes) {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));\n      }\n      // We need to check all keys in case some are required but missing from\n      // props.\n      var allKeys = assign({}, props[propName], shapeTypes);\n      for (var key in allKeys) {\n        var checker = shapeTypes[key];\n        if (!checker) {\n          return new PropTypeError(\n            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +\n            '\\nBad object: ' + JSON.stringify(props[propName], null, '  ') +\n            '\\nValid keys: ' +  JSON.stringify(Object.keys(shapeTypes), null, '  ')\n          );\n        }\n        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n        if (error) {\n          return error;\n        }\n      }\n      return null;\n    }\n\n    return createChainableTypeChecker(validate);\n  }\n\n  function isNode(propValue) {\n    switch (typeof propValue) {\n      case 'number':\n      case 'string':\n      case 'undefined':\n        return true;\n      case 'boolean':\n        return !propValue;\n      case 'object':\n        if (Array.isArray(propValue)) {\n          return propValue.every(isNode);\n        }\n        if (propValue === null || isValidElement(propValue)) {\n          return true;\n        }\n\n        var iteratorFn = getIteratorFn(propValue);\n        if (iteratorFn) {\n          var iterator = iteratorFn.call(propValue);\n          var step;\n          if (iteratorFn !== propValue.entries) {\n            while (!(step = iterator.next()).done) {\n              if (!isNode(step.value)) {\n                return false;\n              }\n            }\n          } else {\n            // Iterator will provide entry [k,v] tuples rather than values.\n            while (!(step = iterator.next()).done) {\n              var entry = step.value;\n              if (entry) {\n                if (!isNode(entry[1])) {\n                  return false;\n                }\n              }\n            }\n          }\n        } else {\n          return false;\n        }\n\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  function isSymbol(propType, propValue) {\n    // Native Symbol.\n    if (propType === 'symbol') {\n      return true;\n    }\n\n    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'\n    if (propValue['@@toStringTag'] === 'Symbol') {\n      return true;\n    }\n\n    // Fallback for non-spec compliant Symbols which are polyfilled.\n    if (typeof Symbol === 'function' && propValue instanceof Symbol) {\n      return true;\n    }\n\n    return false;\n  }\n\n  // Equivalent of `typeof` but with special handling for array and regexp.\n  function getPropType(propValue) {\n    var propType = typeof propValue;\n    if (Array.isArray(propValue)) {\n      return 'array';\n    }\n    if (propValue instanceof RegExp) {\n      // Old webkits (at least until Android 4.0) return 'function' rather than\n      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/\n      // passes PropTypes.object.\n      return 'object';\n    }\n    if (isSymbol(propType, propValue)) {\n      return 'symbol';\n    }\n    return propType;\n  }\n\n  // This handles more types than `getPropType`. Only used for error messages.\n  // See `createPrimitiveTypeChecker`.\n  function getPreciseType(propValue) {\n    if (typeof propValue === 'undefined' || propValue === null) {\n      return '' + propValue;\n    }\n    var propType = getPropType(propValue);\n    if (propType === 'object') {\n      if (propValue instanceof Date) {\n        return 'date';\n      } else if (propValue instanceof RegExp) {\n        return 'regexp';\n      }\n    }\n    return propType;\n  }\n\n  // Returns a string that is postfixed to a warning about an invalid type.\n  // For example, \"undefined\" or \"of type array\"\n  function getPostfixForTypeWarning(value) {\n    var type = getPreciseType(value);\n    switch (type) {\n      case 'array':\n      case 'object':\n        return 'an ' + type;\n      case 'boolean':\n      case 'date':\n      case 'regexp':\n        return 'a ' + type;\n      default:\n        return type;\n    }\n  }\n\n  // Returns class name of the object, if any.\n  function getClassName(propValue) {\n    if (!propValue.constructor || !propValue.constructor.name) {\n      return ANONYMOUS;\n    }\n    return propValue.constructor.name;\n  }\n\n  ReactPropTypes.checkPropTypes = checkPropTypes;\n  ReactPropTypes.PropTypes = ReactPropTypes;\n\n  return ReactPropTypes;\n};\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/prop-types/factoryWithTypeCheckers.js\n// module id = 21\n// module chunks = 0\n\n//# sourceURL=webpack:///./~/prop-types/factoryWithTypeCheckers.js?");

/***/ }),
/* 22 */
/***/ (function(module, exports) {

eval("\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function \"fixes\" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n  // get current location\n  var location = typeof window !== \"undefined\" && window.location;\n\n  if (!location) {\n    throw new Error(\"fixUrls requires window.location\");\n  }\n\n\t// blank or null?\n\tif (!css || typeof css !== \"string\") {\n\t  return css;\n  }\n\n  var baseUrl = location.protocol + \"//\" + location.host;\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, \"/\");\n\n\t// convert each url(...)\n\t/*\n\tThis regular expression is just a way to recursively match brackets within\n\ta string.\n\n\t /url\\s*\\(  = Match on the word \"url\" with any whitespace after it and then a parens\n\t   (  = Start a capturing group\n\t     (?:  = Start a non-capturing group\n\t         [^)(]  = Match anything that isn't a parentheses\n\t         |  = OR\n\t         \\(  = Match a start parentheses\n\t             (?:  = Start another non-capturing groups\n\t                 [^)(]+  = Match anything that isn't a parentheses\n\t                 |  = OR\n\t                 \\(  = Match a start parentheses\n\t                     [^)(]*  = Match anything that isn't a parentheses\n\t                 \\)  = Match a end parentheses\n\t             )  = End Group\n              *\\) = Match anything and then a close parens\n          )  = Close non-capturing group\n          *  = Match anything\n       )  = Close capturing group\n\t \\)  = Match a close parens\n\n\t /gi  = Get all matches, not the first.  Be case insensitive.\n\t */\n\tvar fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl\n\t\t\t.trim()\n\t\t\t.replace(/^\"(.*)\"$/, function(o, $1){ return $1; })\n\t\t\t.replace(/^'(.*)'$/, function(o, $1){ return $1; });\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/)/i.test(unquotedOrigUrl)) {\n\t\t  return fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf(\"//\") === 0) {\n\t\t  \t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf(\"/\") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with '/'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, \"\"); // Strip leading './'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn \"url(\" + JSON.stringify(newUrl) + \")\";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/style-loader/fixUrls.js\n// module id = 22\n// module chunks = 0\n\n//# sourceURL=webpack:///./~/style-loader/fixUrls.js?");

/***/ })
/******/ ]);
});

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RhdGljL2NodW5rcy9ub2RlX21vZHVsZXNfcmVhY3Qtb3dsLWNhcm91c2VsM19saWJfT3dsQ2Fyb3VzZWxfanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBLElBQUksSUFBeUQ7QUFDN0QsMkJBQTJCLG1CQUFPLENBQUMsNENBQU87QUFDMUMsTUFBTSxFQUtnRDtBQUN0RCxDQUFDO0FBQ0QscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDhCQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSw4QkFBbUI7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQjtBQUM3QjtBQUNBO0FBQ0EsVUFBVSw4QkFBbUI7QUFDN0I7QUFDQTtBQUNBLFVBQVUsOEJBQW1CLHVCQUF1QjtBQUNwRDtBQUNBO0FBQ0EsVUFBVSw4QkFBbUI7QUFDN0IsZUFBZSw4QkFBbUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQjtBQUM3QjtBQUNBLG9DQUFvQyw0QkFBNEI7QUFDaEUsMENBQTBDO0FBQzFDLFdBQVcsOEJBQW1CO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw4QkFBbUIsa0NBQWtDO0FBQy9EO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQjtBQUM3QjtBQUNBO0FBQ0EsaUJBQWlCLDhCQUFtQixDQUFDLDhCQUFtQjtBQUN4RCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSxzVUFBc1UseUJBQXlCLGlDQUFpQyx5REFBeUQsR0FBRyxtQ0FBbUMsMkRBQTJELEdBQUcsZ0JBQWdCLFdBQVcsaURBQWlELDRDQUE0QyxZQUFZLE1BQU0sa0RBQWtELFdBQVcsUUFBUSxXQUFX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LE9BQU8sb0hBQW9ILG9CQUFvQixPQUFPLGdKQUFnSixvQkFBb0IsT0FBTyxxQkFBcUIsS0FBSyxvSEFBb0gsc0NBQXNDLHFDQUFxQyx1QkFBdUIsT0FBTyx3Q0FBd0MsNE5BQTROLE9BQU8sMENBQTBDLHdCQUF3QixPQUFPLHNCQUFzQixLQUFLLGtLQUFrSyxtRUFBbUUsOEJBQThCLE9BQU8sNENBQTRDLGtDQUFrQyx3Q0FBd0Msd0JBQXdCLFVBQVUsdUNBQXVDLDBCQUEwQixTQUFTLE9BQU8sc0JBQXNCLEtBQUssbUxBQW1MLHVDQUF1QyxxQkFBcUIseUVBQXlFLDhGQUE4RixzQ0FBc0MsT0FBTyxLQUFLLHdGQUF3RixrRUFBa0UseUJBQXlCLE9BQU8sd0NBQXdDLEtBQUsscURBQXFELDhDQUE4Qyw0QkFBNEIsSUFBSSxnQ0FBZ0M7QUFDOThuQjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxra0JBQWtrQixpR0FBaUcsc0JBQXNCLDREQUE0RCxLQUFLLG1FQUFtRSxpQkFBaUIsS0FBSywrREFBK0QsK0VBQStFLG9xQ0FBb3FDLHVJQUF1SSxZQUFZLCtDQUErQyxZQUFZLEVBQUUsZ0lBQWdJLHlCQUF5QixPQUFPLHlEQUF5RCxvREFBb0QsMEVBQTBFLFFBQVEsZ0RBQWdELDhGQUE4RixrQ0FBa0MsTUFBTSwrSEFBK0gsNEJBQTRCLDhGQUE4RixLQUFLLEVBQUUsb0RBQW9ELElBQUk7QUFDbHFHO0FBQ0EsT0FBTztBQUNQO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3Qtb3dsLWNhcm91c2VsMy9saWIvT3dsQ2Fyb3VzZWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcclxuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXHJcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcInJlYWN0XCIpKTtcclxuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcclxuXHRcdGRlZmluZShbXCJyZWFjdFwiXSwgZmFjdG9yeSk7XHJcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXHJcblx0XHRleHBvcnRzW1wicmVhY3Qtb3dsLWNhcm91c2VsXCJdID0gZmFjdG9yeShyZXF1aXJlKFwicmVhY3RcIikpO1xyXG5cdGVsc2VcclxuXHRcdHJvb3RbXCJyZWFjdC1vd2wtY2Fyb3VzZWxcIl0gPSBmYWN0b3J5KHJvb3RbXCJSZWFjdFwiXSk7XHJcbn0pKHRoaXMsIGZ1bmN0aW9uKF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMTJfXykge1xyXG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxyXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcclxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXHJcbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXHJcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xyXG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcclxuLyoqKioqKi8gXHRcdH1cclxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXHJcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XHJcbi8qKioqKiovIFx0XHRcdGk6IG1vZHVsZUlkLFxyXG4vKioqKioqLyBcdFx0XHRsOiBmYWxzZSxcclxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cclxuLyoqKioqKi8gXHRcdH07XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cclxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxyXG4vKioqKioqLyBcdFx0bW9kdWxlLmwgPSB0cnVlO1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcclxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcclxuLyoqKioqKi8gXHR9XHJcbi8qKioqKiovXHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcclxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXHJcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHQvLyBpZGVudGl0eSBmdW5jdGlvbiBmb3IgY2FsbGluZyBoYXJtb255IGltcG9ydHMgd2l0aCB0aGUgY29ycmVjdCBjb250ZXh0XHJcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5pID0gZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIHZhbHVlOyB9O1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xyXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xyXG4vKioqKioqLyBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xyXG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xyXG4vKioqKioqLyBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXHJcbi8qKioqKiovIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuLyoqKioqKi8gXHRcdFx0XHRnZXQ6IGdldHRlclxyXG4vKioqKioqLyBcdFx0XHR9KTtcclxuLyoqKioqKi8gXHRcdH1cclxuLyoqKioqKi8gXHR9O1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXHJcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XHJcbi8qKioqKiovIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cclxuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcclxuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcclxuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcclxuLyoqKioqKi8gXHRcdHJldHVybiBnZXR0ZXI7XHJcbi8qKioqKiovIFx0fTtcclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcclxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cclxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xyXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDEzKTtcclxuLyoqKioqKi8gfSlcclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuLyoqKioqKi8gKFtcclxuLyogMCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5ldmFsKFwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXFxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xcblxcbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxcblxcbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XFxuXFxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcXG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XFxufVxcbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xcbn1cXG4oZnVuY3Rpb24gKCkge1xcbiAgICB0cnkge1xcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xcbiAgICAgICAgfVxcbiAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcXG4gICAgfVxcbiAgICB0cnkge1xcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XFxuICAgICAgICB9XFxuICAgIH0gY2F0Y2ggKGUpIHtcXG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XFxuICAgIH1cXG59ICgpKVxcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XFxuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XFxuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XFxuICAgIH1cXG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XFxuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XFxuICAgIH1cXG4gICAgdHJ5IHtcXG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XFxuICAgIH0gY2F0Y2goZSl7XFxuICAgICAgICB0cnkge1xcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcXG4gICAgICAgIH0gY2F0Y2goZSl7XFxuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XFxuICAgICAgICB9XFxuICAgIH1cXG5cXG5cXG59XFxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcXG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xcbiAgICB9XFxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XFxuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XFxuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XFxuICAgIH1cXG4gICAgdHJ5IHtcXG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcXG4gICAgfSBjYXRjaCAoZSl7XFxuICAgICAgICB0cnkge1xcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcXG4gICAgICAgIH0gY2F0Y2ggKGUpe1xcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxcbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcXG4gICAgICAgIH1cXG4gICAgfVxcblxcblxcblxcbn1cXG52YXIgcXVldWUgPSBbXTtcXG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcXG52YXIgY3VycmVudFF1ZXVlO1xcbnZhciBxdWV1ZUluZGV4ID0gLTE7XFxuXFxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgfVxcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcXG4gICAgfVxcbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XFxuICAgICAgICBkcmFpblF1ZXVlKCk7XFxuICAgIH1cXG59XFxuXFxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcXG4gICAgaWYgKGRyYWluaW5nKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgIH1cXG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XFxuICAgIGRyYWluaW5nID0gdHJ1ZTtcXG5cXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcXG4gICAgd2hpbGUobGVuKSB7XFxuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcXG4gICAgICAgIHF1ZXVlID0gW107XFxuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XFxuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xcbiAgICB9XFxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XFxuICAgIGRyYWluaW5nID0gZmFsc2U7XFxuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcXG59XFxuXFxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcXG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XFxuICAgICAgICB9XFxuICAgIH1cXG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcXG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcXG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XFxuICAgIH1cXG59O1xcblxcbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcXG4gICAgdGhpcy5mdW4gPSBmdW47XFxuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcXG59XFxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcXG59O1xcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XFxucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcXG5wcm9jZXNzLmVudiA9IHt9O1xcbnByb2Nlc3MuYXJndiA9IFtdO1xcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcXG5cXG5mdW5jdGlvbiBub29wKCkge31cXG5cXG5wcm9jZXNzLm9uID0gbm9vcDtcXG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcXG5wcm9jZXNzLm9uY2UgPSBub29wO1xcbnByb2Nlc3Mub2ZmID0gbm9vcDtcXG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcXG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XFxucHJvY2Vzcy5lbWl0ID0gbm9vcDtcXG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XFxucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcXG5cXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XFxuXFxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcXG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xcbn07XFxuXFxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcXG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xcbn07XFxucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcXG5cXG5cXG4vLy8vLy8vLy8vLy8vLy8vLy9cXG4vLyBXRUJQQUNLIEZPT1RFUlxcbi8vIC4vfi9ub2RlLWxpYnMtYnJvd3Nlci9+L3Byb2Nlc3MvYnJvd3Nlci5qc1xcbi8vIG1vZHVsZSBpZCA9IDBcXG4vLyBtb2R1bGUgY2h1bmtzID0gMFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL34vbm9kZS1saWJzLWJyb3dzZXIvfi9wcm9jZXNzL2Jyb3dzZXIuanM/XCIpO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDEgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuZXZhbChcInZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzsvKiFcXG4gKiBqUXVlcnkgSmF2YVNjcmlwdCBMaWJyYXJ5IHYzLjMuMVxcbiAqIGh0dHBzOi8vanF1ZXJ5LmNvbS9cXG4gKlxcbiAqIEluY2x1ZGVzIFNpenpsZS5qc1xcbiAqIGh0dHBzOi8vc2l6emxlanMuY29tL1xcbiAqXFxuICogQ29weXJpZ2h0IEpTIEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxcbiAqIGh0dHBzOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXFxuICpcXG4gKiBEYXRlOiAyMDE4LTAxLTIwVDE3OjI0WlxcbiAqL1xcbiggZnVuY3Rpb24oIGdsb2JhbCwgZmFjdG9yeSApIHtcXG5cXG5cXHRcXFwidXNlIHN0cmljdFxcXCI7XFxuXFxuXFx0aWYgKCB0eXBlb2YgbW9kdWxlID09PSBcXFwib2JqZWN0XFxcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFxcXCJvYmplY3RcXFwiICkge1xcblxcblxcdFxcdC8vIEZvciBDb21tb25KUyBhbmQgQ29tbW9uSlMtbGlrZSBlbnZpcm9ubWVudHMgd2hlcmUgYSBwcm9wZXIgYHdpbmRvd2BcXG5cXHRcXHQvLyBpcyBwcmVzZW50LCBleGVjdXRlIHRoZSBmYWN0b3J5IGFuZCBnZXQgalF1ZXJ5LlxcblxcdFxcdC8vIEZvciBlbnZpcm9ubWVudHMgdGhhdCBkbyBub3QgaGF2ZSBhIGB3aW5kb3dgIHdpdGggYSBgZG9jdW1lbnRgXFxuXFx0XFx0Ly8gKHN1Y2ggYXMgTm9kZS5qcyksIGV4cG9zZSBhIGZhY3RvcnkgYXMgbW9kdWxlLmV4cG9ydHMuXFxuXFx0XFx0Ly8gVGhpcyBhY2NlbnR1YXRlcyB0aGUgbmVlZCBmb3IgdGhlIGNyZWF0aW9uIG9mIGEgcmVhbCBgd2luZG93YC5cXG5cXHRcXHQvLyBlLmcuIHZhciBqUXVlcnkgPSByZXF1aXJlKFxcXCJqcXVlcnlcXFwiKSh3aW5kb3cpO1xcblxcdFxcdC8vIFNlZSB0aWNrZXQgIzE0NTQ5IGZvciBtb3JlIGluZm8uXFxuXFx0XFx0bW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwuZG9jdW1lbnQgP1xcblxcdFxcdFxcdGZhY3RvcnkoIGdsb2JhbCwgdHJ1ZSApIDpcXG5cXHRcXHRcXHRmdW5jdGlvbiggdyApIHtcXG5cXHRcXHRcXHRcXHRpZiAoICF3LmRvY3VtZW50ICkge1xcblxcdFxcdFxcdFxcdFxcdHRocm93IG5ldyBFcnJvciggXFxcImpRdWVyeSByZXF1aXJlcyBhIHdpbmRvdyB3aXRoIGEgZG9jdW1lbnRcXFwiICk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHJldHVybiBmYWN0b3J5KCB3ICk7XFxuXFx0XFx0XFx0fTtcXG5cXHR9IGVsc2Uge1xcblxcdFxcdGZhY3RvcnkoIGdsb2JhbCApO1xcblxcdH1cXG5cXG4vLyBQYXNzIHRoaXMgaWYgd2luZG93IGlzIG5vdCBkZWZpbmVkIHlldFxcbn0gKSggdHlwZW9mIHdpbmRvdyAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyB3aW5kb3cgOiB0aGlzLCBmdW5jdGlvbiggd2luZG93LCBub0dsb2JhbCApIHtcXG5cXG4vLyBFZGdlIDw9IDEyIC0gMTMrLCBGaXJlZm94IDw9MTggLSA0NSssIElFIDEwIC0gMTEsIFNhZmFyaSA1LjEgLSA5KywgaU9TIDYgLSA5LjFcXG4vLyB0aHJvdyBleGNlcHRpb25zIHdoZW4gbm9uLXN0cmljdCBjb2RlIChlLmcuLCBBU1AuTkVUIDQuNSkgYWNjZXNzZXMgc3RyaWN0IG1vZGVcXG4vLyBhcmd1bWVudHMuY2FsbGVlLmNhbGxlciAodHJhYy0xMzMzNSkuIEJ1dCBhcyBvZiBqUXVlcnkgMy4wICgyMDE2KSwgc3RyaWN0IG1vZGUgc2hvdWxkIGJlIGNvbW1vblxcbi8vIGVub3VnaCB0aGF0IGFsbCBzdWNoIGF0dGVtcHRzIGFyZSBndWFyZGVkIGluIGEgdHJ5IGJsb2NrLlxcblxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXG52YXIgYXJyID0gW107XFxuXFxudmFyIGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50O1xcblxcbnZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcXG5cXG52YXIgc2xpY2UgPSBhcnIuc2xpY2U7XFxuXFxudmFyIGNvbmNhdCA9IGFyci5jb25jYXQ7XFxuXFxudmFyIHB1c2ggPSBhcnIucHVzaDtcXG5cXG52YXIgaW5kZXhPZiA9IGFyci5pbmRleE9mO1xcblxcbnZhciBjbGFzczJ0eXBlID0ge307XFxuXFxudmFyIHRvU3RyaW5nID0gY2xhc3MydHlwZS50b1N0cmluZztcXG5cXG52YXIgaGFzT3duID0gY2xhc3MydHlwZS5oYXNPd25Qcm9wZXJ0eTtcXG5cXG52YXIgZm5Ub1N0cmluZyA9IGhhc093bi50b1N0cmluZztcXG5cXG52YXIgT2JqZWN0RnVuY3Rpb25TdHJpbmcgPSBmblRvU3RyaW5nLmNhbGwoIE9iamVjdCApO1xcblxcbnZhciBzdXBwb3J0ID0ge307XFxuXFxudmFyIGlzRnVuY3Rpb24gPSBmdW5jdGlvbiBpc0Z1bmN0aW9uKCBvYmogKSB7XFxuXFxuICAgICAgLy8gU3VwcG9ydDogQ2hyb21lIDw9NTcsIEZpcmVmb3ggPD01MlxcbiAgICAgIC8vIEluIHNvbWUgYnJvd3NlcnMsIHR5cGVvZiByZXR1cm5zIFxcXCJmdW5jdGlvblxcXCIgZm9yIEhUTUwgPG9iamVjdD4gZWxlbWVudHNcXG4gICAgICAvLyAoaS5lLiwgYHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcXFwib2JqZWN0XFxcIiApID09PSBcXFwiZnVuY3Rpb25cXFwiYCkuXFxuICAgICAgLy8gV2UgZG9uJ3Qgd2FudCB0byBjbGFzc2lmeSAqYW55KiBET00gbm9kZSBhcyBhIGZ1bmN0aW9uLlxcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIHR5cGVvZiBvYmoubm9kZVR5cGUgIT09IFxcXCJudW1iZXJcXFwiO1xcbiAgfTtcXG5cXG5cXG52YXIgaXNXaW5kb3cgPSBmdW5jdGlvbiBpc1dpbmRvdyggb2JqICkge1xcblxcdFxcdHJldHVybiBvYmogIT0gbnVsbCAmJiBvYmogPT09IG9iai53aW5kb3c7XFxuXFx0fTtcXG5cXG5cXG5cXG5cXG5cXHR2YXIgcHJlc2VydmVkU2NyaXB0QXR0cmlidXRlcyA9IHtcXG5cXHRcXHR0eXBlOiB0cnVlLFxcblxcdFxcdHNyYzogdHJ1ZSxcXG5cXHRcXHRub01vZHVsZTogdHJ1ZVxcblxcdH07XFxuXFxuXFx0ZnVuY3Rpb24gRE9NRXZhbCggY29kZSwgZG9jLCBub2RlICkge1xcblxcdFxcdGRvYyA9IGRvYyB8fCBkb2N1bWVudDtcXG5cXG5cXHRcXHR2YXIgaSxcXG5cXHRcXHRcXHRzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudCggXFxcInNjcmlwdFxcXCIgKTtcXG5cXG5cXHRcXHRzY3JpcHQudGV4dCA9IGNvZGU7XFxuXFx0XFx0aWYgKCBub2RlICkge1xcblxcdFxcdFxcdGZvciAoIGkgaW4gcHJlc2VydmVkU2NyaXB0QXR0cmlidXRlcyApIHtcXG5cXHRcXHRcXHRcXHRpZiAoIG5vZGVbIGkgXSApIHtcXG5cXHRcXHRcXHRcXHRcXHRzY3JpcHRbIGkgXSA9IG5vZGVbIGkgXTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHRcXHRkb2MuaGVhZC5hcHBlbmRDaGlsZCggc2NyaXB0ICkucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggc2NyaXB0ICk7XFxuXFx0fVxcblxcblxcbmZ1bmN0aW9uIHRvVHlwZSggb2JqICkge1xcblxcdGlmICggb2JqID09IG51bGwgKSB7XFxuXFx0XFx0cmV0dXJuIG9iaiArIFxcXCJcXFwiO1xcblxcdH1cXG5cXG5cXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9Mi4zIG9ubHkgKGZ1bmN0aW9uaXNoIFJlZ0V4cClcXG5cXHRyZXR1cm4gdHlwZW9mIG9iaiA9PT0gXFxcIm9iamVjdFxcXCIgfHwgdHlwZW9mIG9iaiA9PT0gXFxcImZ1bmN0aW9uXFxcIiA/XFxuXFx0XFx0Y2xhc3MydHlwZVsgdG9TdHJpbmcuY2FsbCggb2JqICkgXSB8fCBcXFwib2JqZWN0XFxcIiA6XFxuXFx0XFx0dHlwZW9mIG9iajtcXG59XFxuLyogZ2xvYmFsIFN5bWJvbCAqL1xcbi8vIERlZmluaW5nIHRoaXMgZ2xvYmFsIGluIC5lc2xpbnRyYy5qc29uIHdvdWxkIGNyZWF0ZSBhIGRhbmdlciBvZiB1c2luZyB0aGUgZ2xvYmFsXFxuLy8gdW5ndWFyZGVkIGluIGFub3RoZXIgcGxhY2UsIGl0IHNlZW1zIHNhZmVyIHRvIGRlZmluZSBnbG9iYWwgb25seSBmb3IgdGhpcyBtb2R1bGVcXG5cXG5cXG5cXG52YXJcXG5cXHR2ZXJzaW9uID0gXFxcIjMuMy4xXFxcIixcXG5cXG5cXHQvLyBEZWZpbmUgYSBsb2NhbCBjb3B5IG9mIGpRdWVyeVxcblxcdGpRdWVyeSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcXG5cXG5cXHRcXHQvLyBUaGUgalF1ZXJ5IG9iamVjdCBpcyBhY3R1YWxseSBqdXN0IHRoZSBpbml0IGNvbnN0cnVjdG9yICdlbmhhbmNlZCdcXG5cXHRcXHQvLyBOZWVkIGluaXQgaWYgalF1ZXJ5IGlzIGNhbGxlZCAoanVzdCBhbGxvdyBlcnJvciB0byBiZSB0aHJvd24gaWYgbm90IGluY2x1ZGVkKVxcblxcdFxcdHJldHVybiBuZXcgalF1ZXJ5LmZuLmluaXQoIHNlbGVjdG9yLCBjb250ZXh0ICk7XFxuXFx0fSxcXG5cXG5cXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHlcXG5cXHQvLyBNYWtlIHN1cmUgd2UgdHJpbSBCT00gYW5kIE5CU1BcXG5cXHRydHJpbSA9IC9eW1xcXFxzXFxcXHVGRUZGXFxcXHhBMF0rfFtcXFxcc1xcXFx1RkVGRlxcXFx4QTBdKyQvZztcXG5cXG5qUXVlcnkuZm4gPSBqUXVlcnkucHJvdG90eXBlID0ge1xcblxcblxcdC8vIFRoZSBjdXJyZW50IHZlcnNpb24gb2YgalF1ZXJ5IGJlaW5nIHVzZWRcXG5cXHRqcXVlcnk6IHZlcnNpb24sXFxuXFxuXFx0Y29uc3RydWN0b3I6IGpRdWVyeSxcXG5cXG5cXHQvLyBUaGUgZGVmYXVsdCBsZW5ndGggb2YgYSBqUXVlcnkgb2JqZWN0IGlzIDBcXG5cXHRsZW5ndGg6IDAsXFxuXFxuXFx0dG9BcnJheTogZnVuY3Rpb24oKSB7XFxuXFx0XFx0cmV0dXJuIHNsaWNlLmNhbGwoIHRoaXMgKTtcXG5cXHR9LFxcblxcblxcdC8vIEdldCB0aGUgTnRoIGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgZWxlbWVudCBzZXQgT1JcXG5cXHQvLyBHZXQgdGhlIHdob2xlIG1hdGNoZWQgZWxlbWVudCBzZXQgYXMgYSBjbGVhbiBhcnJheVxcblxcdGdldDogZnVuY3Rpb24oIG51bSApIHtcXG5cXG5cXHRcXHQvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyBpbiBhIGNsZWFuIGFycmF5XFxuXFx0XFx0aWYgKCBudW0gPT0gbnVsbCApIHtcXG5cXHRcXHRcXHRyZXR1cm4gc2xpY2UuY2FsbCggdGhpcyApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBSZXR1cm4ganVzdCB0aGUgb25lIGVsZW1lbnQgZnJvbSB0aGUgc2V0XFxuXFx0XFx0cmV0dXJuIG51bSA8IDAgPyB0aGlzWyBudW0gKyB0aGlzLmxlbmd0aCBdIDogdGhpc1sgbnVtIF07XFxuXFx0fSxcXG5cXG5cXHQvLyBUYWtlIGFuIGFycmF5IG9mIGVsZW1lbnRzIGFuZCBwdXNoIGl0IG9udG8gdGhlIHN0YWNrXFxuXFx0Ly8gKHJldHVybmluZyB0aGUgbmV3IG1hdGNoZWQgZWxlbWVudCBzZXQpXFxuXFx0cHVzaFN0YWNrOiBmdW5jdGlvbiggZWxlbXMgKSB7XFxuXFxuXFx0XFx0Ly8gQnVpbGQgYSBuZXcgalF1ZXJ5IG1hdGNoZWQgZWxlbWVudCBzZXRcXG5cXHRcXHR2YXIgcmV0ID0galF1ZXJ5Lm1lcmdlKCB0aGlzLmNvbnN0cnVjdG9yKCksIGVsZW1zICk7XFxuXFxuXFx0XFx0Ly8gQWRkIHRoZSBvbGQgb2JqZWN0IG9udG8gdGhlIHN0YWNrIChhcyBhIHJlZmVyZW5jZSlcXG5cXHRcXHRyZXQucHJldk9iamVjdCA9IHRoaXM7XFxuXFxuXFx0XFx0Ly8gUmV0dXJuIHRoZSBuZXdseS1mb3JtZWQgZWxlbWVudCBzZXRcXG5cXHRcXHRyZXR1cm4gcmV0O1xcblxcdH0sXFxuXFxuXFx0Ly8gRXhlY3V0ZSBhIGNhbGxiYWNrIGZvciBldmVyeSBlbGVtZW50IGluIHRoZSBtYXRjaGVkIHNldC5cXG5cXHRlYWNoOiBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XFxuXFx0XFx0cmV0dXJuIGpRdWVyeS5lYWNoKCB0aGlzLCBjYWxsYmFjayApO1xcblxcdH0sXFxuXFxuXFx0bWFwOiBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XFxuXFx0XFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkubWFwKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgaSApIHtcXG5cXHRcXHRcXHRyZXR1cm4gY2FsbGJhY2suY2FsbCggZWxlbSwgaSwgZWxlbSApO1xcblxcdFxcdH0gKSApO1xcblxcdH0sXFxuXFxuXFx0c2xpY2U6IGZ1bmN0aW9uKCkge1xcblxcdFxcdHJldHVybiB0aGlzLnB1c2hTdGFjayggc2xpY2UuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApICk7XFxuXFx0fSxcXG5cXG5cXHRmaXJzdDogZnVuY3Rpb24oKSB7XFxuXFx0XFx0cmV0dXJuIHRoaXMuZXEoIDAgKTtcXG5cXHR9LFxcblxcblxcdGxhc3Q6IGZ1bmN0aW9uKCkge1xcblxcdFxcdHJldHVybiB0aGlzLmVxKCAtMSApO1xcblxcdH0sXFxuXFxuXFx0ZXE6IGZ1bmN0aW9uKCBpICkge1xcblxcdFxcdHZhciBsZW4gPSB0aGlzLmxlbmd0aCxcXG5cXHRcXHRcXHRqID0gK2kgKyAoIGkgPCAwID8gbGVuIDogMCApO1xcblxcdFxcdHJldHVybiB0aGlzLnB1c2hTdGFjayggaiA+PSAwICYmIGogPCBsZW4gPyBbIHRoaXNbIGogXSBdIDogW10gKTtcXG5cXHR9LFxcblxcblxcdGVuZDogZnVuY3Rpb24oKSB7XFxuXFx0XFx0cmV0dXJuIHRoaXMucHJldk9iamVjdCB8fCB0aGlzLmNvbnN0cnVjdG9yKCk7XFxuXFx0fSxcXG5cXG5cXHQvLyBGb3IgaW50ZXJuYWwgdXNlIG9ubHkuXFxuXFx0Ly8gQmVoYXZlcyBsaWtlIGFuIEFycmF5J3MgbWV0aG9kLCBub3QgbGlrZSBhIGpRdWVyeSBtZXRob2QuXFxuXFx0cHVzaDogcHVzaCxcXG5cXHRzb3J0OiBhcnIuc29ydCxcXG5cXHRzcGxpY2U6IGFyci5zcGxpY2VcXG59O1xcblxcbmpRdWVyeS5leHRlbmQgPSBqUXVlcnkuZm4uZXh0ZW5kID0gZnVuY3Rpb24oKSB7XFxuXFx0dmFyIG9wdGlvbnMsIG5hbWUsIHNyYywgY29weSwgY29weUlzQXJyYXksIGNsb25lLFxcblxcdFxcdHRhcmdldCA9IGFyZ3VtZW50c1sgMCBdIHx8IHt9LFxcblxcdFxcdGkgPSAxLFxcblxcdFxcdGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXFxuXFx0XFx0ZGVlcCA9IGZhbHNlO1xcblxcblxcdC8vIEhhbmRsZSBhIGRlZXAgY29weSBzaXR1YXRpb25cXG5cXHRpZiAoIHR5cGVvZiB0YXJnZXQgPT09IFxcXCJib29sZWFuXFxcIiApIHtcXG5cXHRcXHRkZWVwID0gdGFyZ2V0O1xcblxcblxcdFxcdC8vIFNraXAgdGhlIGJvb2xlYW4gYW5kIHRoZSB0YXJnZXRcXG5cXHRcXHR0YXJnZXQgPSBhcmd1bWVudHNbIGkgXSB8fCB7fTtcXG5cXHRcXHRpKys7XFxuXFx0fVxcblxcblxcdC8vIEhhbmRsZSBjYXNlIHdoZW4gdGFyZ2V0IGlzIGEgc3RyaW5nIG9yIHNvbWV0aGluZyAocG9zc2libGUgaW4gZGVlcCBjb3B5KVxcblxcdGlmICggdHlwZW9mIHRhcmdldCAhPT0gXFxcIm9iamVjdFxcXCIgJiYgIWlzRnVuY3Rpb24oIHRhcmdldCApICkge1xcblxcdFxcdHRhcmdldCA9IHt9O1xcblxcdH1cXG5cXG5cXHQvLyBFeHRlbmQgalF1ZXJ5IGl0c2VsZiBpZiBvbmx5IG9uZSBhcmd1bWVudCBpcyBwYXNzZWRcXG5cXHRpZiAoIGkgPT09IGxlbmd0aCApIHtcXG5cXHRcXHR0YXJnZXQgPSB0aGlzO1xcblxcdFxcdGktLTtcXG5cXHR9XFxuXFxuXFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XFxuXFxuXFx0XFx0Ly8gT25seSBkZWFsIHdpdGggbm9uLW51bGwvdW5kZWZpbmVkIHZhbHVlc1xcblxcdFxcdGlmICggKCBvcHRpb25zID0gYXJndW1lbnRzWyBpIF0gKSAhPSBudWxsICkge1xcblxcblxcdFxcdFxcdC8vIEV4dGVuZCB0aGUgYmFzZSBvYmplY3RcXG5cXHRcXHRcXHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XFxuXFx0XFx0XFx0XFx0c3JjID0gdGFyZ2V0WyBuYW1lIF07XFxuXFx0XFx0XFx0XFx0Y29weSA9IG9wdGlvbnNbIG5hbWUgXTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBQcmV2ZW50IG5ldmVyLWVuZGluZyBsb29wXFxuXFx0XFx0XFx0XFx0aWYgKCB0YXJnZXQgPT09IGNvcHkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0Y29udGludWU7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIFJlY3Vyc2UgaWYgd2UncmUgbWVyZ2luZyBwbGFpbiBvYmplY3RzIG9yIGFycmF5c1xcblxcdFxcdFxcdFxcdGlmICggZGVlcCAmJiBjb3B5ICYmICggalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGNvcHkgKSB8fFxcblxcdFxcdFxcdFxcdFxcdCggY29weUlzQXJyYXkgPSBBcnJheS5pc0FycmF5KCBjb3B5ICkgKSApICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggY29weUlzQXJyYXkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y29weUlzQXJyYXkgPSBmYWxzZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRjbG9uZSA9IHNyYyAmJiBBcnJheS5pc0FycmF5KCBzcmMgKSA/IHNyYyA6IFtdO1xcblxcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2xvbmUgPSBzcmMgJiYgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIHNyYyApID8gc3JjIDoge307XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdC8vIE5ldmVyIG1vdmUgb3JpZ2luYWwgb2JqZWN0cywgY2xvbmUgdGhlbVxcblxcdFxcdFxcdFxcdFxcdHRhcmdldFsgbmFtZSBdID0galF1ZXJ5LmV4dGVuZCggZGVlcCwgY2xvbmUsIGNvcHkgKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBEb24ndCBicmluZyBpbiB1bmRlZmluZWQgdmFsdWVzXFxuXFx0XFx0XFx0XFx0fSBlbHNlIGlmICggY29weSAhPT0gdW5kZWZpbmVkICkge1xcblxcdFxcdFxcdFxcdFxcdHRhcmdldFsgbmFtZSBdID0gY29weTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9XFxuXFxuXFx0Ly8gUmV0dXJuIHRoZSBtb2RpZmllZCBvYmplY3RcXG5cXHRyZXR1cm4gdGFyZ2V0O1xcbn07XFxuXFxualF1ZXJ5LmV4dGVuZCgge1xcblxcblxcdC8vIFVuaXF1ZSBmb3IgZWFjaCBjb3B5IG9mIGpRdWVyeSBvbiB0aGUgcGFnZVxcblxcdGV4cGFuZG86IFxcXCJqUXVlcnlcXFwiICsgKCB2ZXJzaW9uICsgTWF0aC5yYW5kb20oKSApLnJlcGxhY2UoIC9cXFxcRC9nLCBcXFwiXFxcIiApLFxcblxcblxcdC8vIEFzc3VtZSBqUXVlcnkgaXMgcmVhZHkgd2l0aG91dCB0aGUgcmVhZHkgbW9kdWxlXFxuXFx0aXNSZWFkeTogdHJ1ZSxcXG5cXG5cXHRlcnJvcjogZnVuY3Rpb24oIG1zZyApIHtcXG5cXHRcXHR0aHJvdyBuZXcgRXJyb3IoIG1zZyApO1xcblxcdH0sXFxuXFxuXFx0bm9vcDogZnVuY3Rpb24oKSB7fSxcXG5cXG5cXHRpc1BsYWluT2JqZWN0OiBmdW5jdGlvbiggb2JqICkge1xcblxcdFxcdHZhciBwcm90bywgQ3RvcjtcXG5cXG5cXHRcXHQvLyBEZXRlY3Qgb2J2aW91cyBuZWdhdGl2ZXNcXG5cXHRcXHQvLyBVc2UgdG9TdHJpbmcgaW5zdGVhZCBvZiBqUXVlcnkudHlwZSB0byBjYXRjaCBob3N0IG9iamVjdHNcXG5cXHRcXHRpZiAoICFvYmogfHwgdG9TdHJpbmcuY2FsbCggb2JqICkgIT09IFxcXCJbb2JqZWN0IE9iamVjdF1cXFwiICkge1xcblxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cHJvdG8gPSBnZXRQcm90byggb2JqICk7XFxuXFxuXFx0XFx0Ly8gT2JqZWN0cyB3aXRoIG5vIHByb3RvdHlwZSAoZS5nLiwgYE9iamVjdC5jcmVhdGUoIG51bGwgKWApIGFyZSBwbGFpblxcblxcdFxcdGlmICggIXByb3RvICkge1xcblxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBPYmplY3RzIHdpdGggcHJvdG90eXBlIGFyZSBwbGFpbiBpZmYgdGhleSB3ZXJlIGNvbnN0cnVjdGVkIGJ5IGEgZ2xvYmFsIE9iamVjdCBmdW5jdGlvblxcblxcdFxcdEN0b3IgPSBoYXNPd24uY2FsbCggcHJvdG8sIFxcXCJjb25zdHJ1Y3RvclxcXCIgKSAmJiBwcm90by5jb25zdHJ1Y3RvcjtcXG5cXHRcXHRyZXR1cm4gdHlwZW9mIEN0b3IgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgZm5Ub1N0cmluZy5jYWxsKCBDdG9yICkgPT09IE9iamVjdEZ1bmN0aW9uU3RyaW5nO1xcblxcdH0sXFxuXFxuXFx0aXNFbXB0eU9iamVjdDogZnVuY3Rpb24oIG9iaiApIHtcXG5cXG5cXHRcXHQvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xcblxcdFxcdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZXNsaW50L2VzbGludC9pc3N1ZXMvNjEyNVxcblxcdFxcdHZhciBuYW1lO1xcblxcblxcdFxcdGZvciAoIG5hbWUgaW4gb2JqICkge1xcblxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHR9XFxuXFx0XFx0cmV0dXJuIHRydWU7XFxuXFx0fSxcXG5cXG5cXHQvLyBFdmFsdWF0ZXMgYSBzY3JpcHQgaW4gYSBnbG9iYWwgY29udGV4dFxcblxcdGdsb2JhbEV2YWw6IGZ1bmN0aW9uKCBjb2RlICkge1xcblxcdFxcdERPTUV2YWwoIGNvZGUgKTtcXG5cXHR9LFxcblxcblxcdGVhY2g6IGZ1bmN0aW9uKCBvYmosIGNhbGxiYWNrICkge1xcblxcdFxcdHZhciBsZW5ndGgsIGkgPSAwO1xcblxcblxcdFxcdGlmICggaXNBcnJheUxpa2UoIG9iaiApICkge1xcblxcdFxcdFxcdGxlbmd0aCA9IG9iai5sZW5ndGg7XFxuXFx0XFx0XFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCBjYWxsYmFjay5jYWxsKCBvYmpbIGkgXSwgaSwgb2JqWyBpIF0gKSA9PT0gZmFsc2UgKSB7XFxuXFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdGZvciAoIGkgaW4gb2JqICkge1xcblxcdFxcdFxcdFxcdGlmICggY2FsbGJhY2suY2FsbCggb2JqWyBpIF0sIGksIG9ialsgaSBdICkgPT09IGZhbHNlICkge1xcblxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiBvYmo7XFxuXFx0fSxcXG5cXG5cXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHlcXG5cXHR0cmltOiBmdW5jdGlvbiggdGV4dCApIHtcXG5cXHRcXHRyZXR1cm4gdGV4dCA9PSBudWxsID9cXG5cXHRcXHRcXHRcXFwiXFxcIiA6XFxuXFx0XFx0XFx0KCB0ZXh0ICsgXFxcIlxcXCIgKS5yZXBsYWNlKCBydHJpbSwgXFxcIlxcXCIgKTtcXG5cXHR9LFxcblxcblxcdC8vIHJlc3VsdHMgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcXG5cXHRtYWtlQXJyYXk6IGZ1bmN0aW9uKCBhcnIsIHJlc3VsdHMgKSB7XFxuXFx0XFx0dmFyIHJldCA9IHJlc3VsdHMgfHwgW107XFxuXFxuXFx0XFx0aWYgKCBhcnIgIT0gbnVsbCApIHtcXG5cXHRcXHRcXHRpZiAoIGlzQXJyYXlMaWtlKCBPYmplY3QoIGFyciApICkgKSB7XFxuXFx0XFx0XFx0XFx0alF1ZXJ5Lm1lcmdlKCByZXQsXFxuXFx0XFx0XFx0XFx0XFx0dHlwZW9mIGFyciA9PT0gXFxcInN0cmluZ1xcXCIgP1xcblxcdFxcdFxcdFxcdFxcdFsgYXJyIF0gOiBhcnJcXG5cXHRcXHRcXHRcXHQpO1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0cHVzaC5jYWxsKCByZXQsIGFyciApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIHJldDtcXG5cXHR9LFxcblxcblxcdGluQXJyYXk6IGZ1bmN0aW9uKCBlbGVtLCBhcnIsIGkgKSB7XFxuXFx0XFx0cmV0dXJuIGFyciA9PSBudWxsID8gLTEgOiBpbmRleE9mLmNhbGwoIGFyciwgZWxlbSwgaSApO1xcblxcdH0sXFxuXFxuXFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XFxuXFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxcblxcdG1lcmdlOiBmdW5jdGlvbiggZmlyc3QsIHNlY29uZCApIHtcXG5cXHRcXHR2YXIgbGVuID0gK3NlY29uZC5sZW5ndGgsXFxuXFx0XFx0XFx0aiA9IDAsXFxuXFx0XFx0XFx0aSA9IGZpcnN0Lmxlbmd0aDtcXG5cXG5cXHRcXHRmb3IgKCA7IGogPCBsZW47IGorKyApIHtcXG5cXHRcXHRcXHRmaXJzdFsgaSsrIF0gPSBzZWNvbmRbIGogXTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Zmlyc3QubGVuZ3RoID0gaTtcXG5cXG5cXHRcXHRyZXR1cm4gZmlyc3Q7XFxuXFx0fSxcXG5cXG5cXHRncmVwOiBmdW5jdGlvbiggZWxlbXMsIGNhbGxiYWNrLCBpbnZlcnQgKSB7XFxuXFx0XFx0dmFyIGNhbGxiYWNrSW52ZXJzZSxcXG5cXHRcXHRcXHRtYXRjaGVzID0gW10sXFxuXFx0XFx0XFx0aSA9IDAsXFxuXFx0XFx0XFx0bGVuZ3RoID0gZWxlbXMubGVuZ3RoLFxcblxcdFxcdFxcdGNhbGxiYWNrRXhwZWN0ID0gIWludmVydDtcXG5cXG5cXHRcXHQvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgb25seSBzYXZpbmcgdGhlIGl0ZW1zXFxuXFx0XFx0Ly8gdGhhdCBwYXNzIHRoZSB2YWxpZGF0b3IgZnVuY3Rpb25cXG5cXHRcXHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcXG5cXHRcXHRcXHRjYWxsYmFja0ludmVyc2UgPSAhY2FsbGJhY2soIGVsZW1zWyBpIF0sIGkgKTtcXG5cXHRcXHRcXHRpZiAoIGNhbGxiYWNrSW52ZXJzZSAhPT0gY2FsbGJhY2tFeHBlY3QgKSB7XFxuXFx0XFx0XFx0XFx0bWF0Y2hlcy5wdXNoKCBlbGVtc1sgaSBdICk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gbWF0Y2hlcztcXG5cXHR9LFxcblxcblxcdC8vIGFyZyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxcblxcdG1hcDogZnVuY3Rpb24oIGVsZW1zLCBjYWxsYmFjaywgYXJnICkge1xcblxcdFxcdHZhciBsZW5ndGgsIHZhbHVlLFxcblxcdFxcdFxcdGkgPSAwLFxcblxcdFxcdFxcdHJldCA9IFtdO1xcblxcblxcdFxcdC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCB0cmFuc2xhdGluZyBlYWNoIG9mIHRoZSBpdGVtcyB0byB0aGVpciBuZXcgdmFsdWVzXFxuXFx0XFx0aWYgKCBpc0FycmF5TGlrZSggZWxlbXMgKSApIHtcXG5cXHRcXHRcXHRsZW5ndGggPSBlbGVtcy5sZW5ndGg7XFxuXFx0XFx0XFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XFxuXFx0XFx0XFx0XFx0dmFsdWUgPSBjYWxsYmFjayggZWxlbXNbIGkgXSwgaSwgYXJnICk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCB2YWx1ZSAhPSBudWxsICkge1xcblxcdFxcdFxcdFxcdFxcdHJldC5wdXNoKCB2YWx1ZSApO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0Ly8gR28gdGhyb3VnaCBldmVyeSBrZXkgb24gdGhlIG9iamVjdCxcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdGZvciAoIGkgaW4gZWxlbXMgKSB7XFxuXFx0XFx0XFx0XFx0dmFsdWUgPSBjYWxsYmFjayggZWxlbXNbIGkgXSwgaSwgYXJnICk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCB2YWx1ZSAhPSBudWxsICkge1xcblxcdFxcdFxcdFxcdFxcdHJldC5wdXNoKCB2YWx1ZSApO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIEZsYXR0ZW4gYW55IG5lc3RlZCBhcnJheXNcXG5cXHRcXHRyZXR1cm4gY29uY2F0LmFwcGx5KCBbXSwgcmV0ICk7XFxuXFx0fSxcXG5cXG5cXHQvLyBBIGdsb2JhbCBHVUlEIGNvdW50ZXIgZm9yIG9iamVjdHNcXG5cXHRndWlkOiAxLFxcblxcblxcdC8vIGpRdWVyeS5zdXBwb3J0IGlzIG5vdCB1c2VkIGluIENvcmUgYnV0IG90aGVyIHByb2plY3RzIGF0dGFjaCB0aGVpclxcblxcdC8vIHByb3BlcnRpZXMgdG8gaXQgc28gaXQgbmVlZHMgdG8gZXhpc3QuXFxuXFx0c3VwcG9ydDogc3VwcG9ydFxcbn0gKTtcXG5cXG5pZiAoIHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgKSB7XFxuXFx0alF1ZXJ5LmZuWyBTeW1ib2wuaXRlcmF0b3IgXSA9IGFyclsgU3ltYm9sLml0ZXJhdG9yIF07XFxufVxcblxcbi8vIFBvcHVsYXRlIHRoZSBjbGFzczJ0eXBlIG1hcFxcbmpRdWVyeS5lYWNoKCBcXFwiQm9vbGVhbiBOdW1iZXIgU3RyaW5nIEZ1bmN0aW9uIEFycmF5IERhdGUgUmVnRXhwIE9iamVjdCBFcnJvciBTeW1ib2xcXFwiLnNwbGl0KCBcXFwiIFxcXCIgKSxcXG5mdW5jdGlvbiggaSwgbmFtZSApIHtcXG5cXHRjbGFzczJ0eXBlWyBcXFwiW29iamVjdCBcXFwiICsgbmFtZSArIFxcXCJdXFxcIiBdID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xcbn0gKTtcXG5cXG5mdW5jdGlvbiBpc0FycmF5TGlrZSggb2JqICkge1xcblxcblxcdC8vIFN1cHBvcnQ6IHJlYWwgaU9TIDguMiBvbmx5IChub3QgcmVwcm9kdWNpYmxlIGluIHNpbXVsYXRvcilcXG5cXHQvLyBgaW5gIGNoZWNrIHVzZWQgdG8gcHJldmVudCBKSVQgZXJyb3IgKGdoLTIxNDUpXFxuXFx0Ly8gaGFzT3duIGlzbid0IHVzZWQgaGVyZSBkdWUgdG8gZmFsc2UgbmVnYXRpdmVzXFxuXFx0Ly8gcmVnYXJkaW5nIE5vZGVsaXN0IGxlbmd0aCBpbiBJRVxcblxcdHZhciBsZW5ndGggPSAhIW9iaiAmJiBcXFwibGVuZ3RoXFxcIiBpbiBvYmogJiYgb2JqLmxlbmd0aCxcXG5cXHRcXHR0eXBlID0gdG9UeXBlKCBvYmogKTtcXG5cXG5cXHRpZiAoIGlzRnVuY3Rpb24oIG9iaiApIHx8IGlzV2luZG93KCBvYmogKSApIHtcXG5cXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0fVxcblxcblxcdHJldHVybiB0eXBlID09PSBcXFwiYXJyYXlcXFwiIHx8IGxlbmd0aCA9PT0gMCB8fFxcblxcdFxcdHR5cGVvZiBsZW5ndGggPT09IFxcXCJudW1iZXJcXFwiICYmIGxlbmd0aCA+IDAgJiYgKCBsZW5ndGggLSAxICkgaW4gb2JqO1xcbn1cXG52YXIgU2l6emxlID1cXG4vKiFcXG4gKiBTaXp6bGUgQ1NTIFNlbGVjdG9yIEVuZ2luZSB2Mi4zLjNcXG4gKiBodHRwczovL3NpenpsZWpzLmNvbS9cXG4gKlxcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXFxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXFxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxcbiAqXFxuICogRGF0ZTogMjAxNi0wOC0wOFxcbiAqL1xcbihmdW5jdGlvbiggd2luZG93ICkge1xcblxcbnZhciBpLFxcblxcdHN1cHBvcnQsXFxuXFx0RXhwcixcXG5cXHRnZXRUZXh0LFxcblxcdGlzWE1MLFxcblxcdHRva2VuaXplLFxcblxcdGNvbXBpbGUsXFxuXFx0c2VsZWN0LFxcblxcdG91dGVybW9zdENvbnRleHQsXFxuXFx0c29ydElucHV0LFxcblxcdGhhc0R1cGxpY2F0ZSxcXG5cXG5cXHQvLyBMb2NhbCBkb2N1bWVudCB2YXJzXFxuXFx0c2V0RG9jdW1lbnQsXFxuXFx0ZG9jdW1lbnQsXFxuXFx0ZG9jRWxlbSxcXG5cXHRkb2N1bWVudElzSFRNTCxcXG5cXHRyYnVnZ3lRU0EsXFxuXFx0cmJ1Z2d5TWF0Y2hlcyxcXG5cXHRtYXRjaGVzLFxcblxcdGNvbnRhaW5zLFxcblxcblxcdC8vIEluc3RhbmNlLXNwZWNpZmljIGRhdGFcXG5cXHRleHBhbmRvID0gXFxcInNpenpsZVxcXCIgKyAxICogbmV3IERhdGUoKSxcXG5cXHRwcmVmZXJyZWREb2MgPSB3aW5kb3cuZG9jdW1lbnQsXFxuXFx0ZGlycnVucyA9IDAsXFxuXFx0ZG9uZSA9IDAsXFxuXFx0Y2xhc3NDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXFxuXFx0dG9rZW5DYWNoZSA9IGNyZWF0ZUNhY2hlKCksXFxuXFx0Y29tcGlsZXJDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXFxuXFx0c29ydE9yZGVyID0gZnVuY3Rpb24oIGEsIGIgKSB7XFxuXFx0XFx0aWYgKCBhID09PSBiICkge1xcblxcdFxcdFxcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XFxuXFx0XFx0fVxcblxcdFxcdHJldHVybiAwO1xcblxcdH0sXFxuXFxuXFx0Ly8gSW5zdGFuY2UgbWV0aG9kc1xcblxcdGhhc093biA9ICh7fSkuaGFzT3duUHJvcGVydHksXFxuXFx0YXJyID0gW10sXFxuXFx0cG9wID0gYXJyLnBvcCxcXG5cXHRwdXNoX25hdGl2ZSA9IGFyci5wdXNoLFxcblxcdHB1c2ggPSBhcnIucHVzaCxcXG5cXHRzbGljZSA9IGFyci5zbGljZSxcXG5cXHQvLyBVc2UgYSBzdHJpcHBlZC1kb3duIGluZGV4T2YgYXMgaXQncyBmYXN0ZXIgdGhhbiBuYXRpdmVcXG5cXHQvLyBodHRwczovL2pzcGVyZi5jb20vdGhvci1pbmRleG9mLXZzLWZvci81XFxuXFx0aW5kZXhPZiA9IGZ1bmN0aW9uKCBsaXN0LCBlbGVtICkge1xcblxcdFxcdHZhciBpID0gMCxcXG5cXHRcXHRcXHRsZW4gPSBsaXN0Lmxlbmd0aDtcXG5cXHRcXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcXG5cXHRcXHRcXHRpZiAoIGxpc3RbaV0gPT09IGVsZW0gKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHRcXHRyZXR1cm4gLTE7XFxuXFx0fSxcXG5cXG5cXHRib29sZWFucyA9IFxcXCJjaGVja2VkfHNlbGVjdGVkfGFzeW5jfGF1dG9mb2N1c3xhdXRvcGxheXxjb250cm9sc3xkZWZlcnxkaXNhYmxlZHxoaWRkZW58aXNtYXB8bG9vcHxtdWx0aXBsZXxvcGVufHJlYWRvbmx5fHJlcXVpcmVkfHNjb3BlZFxcXCIsXFxuXFxuXFx0Ly8gUmVndWxhciBleHByZXNzaW9uc1xcblxcblxcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtc2VsZWN0b3JzLyN3aGl0ZXNwYWNlXFxuXFx0d2hpdGVzcGFjZSA9IFxcXCJbXFxcXFxcXFx4MjBcXFxcXFxcXHRcXFxcXFxcXHJcXFxcXFxcXG5cXFxcXFxcXGZdXFxcIixcXG5cXG5cXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9DU1MyMS9zeW5kYXRhLmh0bWwjdmFsdWUtZGVmLWlkZW50aWZpZXJcXG5cXHRpZGVudGlmaWVyID0gXFxcIig/OlxcXFxcXFxcXFxcXFxcXFwufFtcXFxcXFxcXHctXXxbXlxcXFwwLVxcXFxcXFxceGEwXSkrXFxcIixcXG5cXG5cXHQvLyBBdHRyaWJ1dGUgc2VsZWN0b3JzOiBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2F0dHJpYnV0ZS1zZWxlY3RvcnNcXG5cXHRhdHRyaWJ1dGVzID0gXFxcIlxcXFxcXFxcW1xcXCIgKyB3aGl0ZXNwYWNlICsgXFxcIiooXFxcIiArIGlkZW50aWZpZXIgKyBcXFwiKSg/OlxcXCIgKyB3aGl0ZXNwYWNlICtcXG5cXHRcXHQvLyBPcGVyYXRvciAoY2FwdHVyZSAyKVxcblxcdFxcdFxcXCIqKFsqXiR8IX5dPz0pXFxcIiArIHdoaXRlc3BhY2UgK1xcblxcdFxcdC8vIFxcXCJBdHRyaWJ1dGUgdmFsdWVzIG11c3QgYmUgQ1NTIGlkZW50aWZpZXJzIFtjYXB0dXJlIDVdIG9yIHN0cmluZ3MgW2NhcHR1cmUgMyBvciBjYXB0dXJlIDRdXFxcIlxcblxcdFxcdFxcXCIqKD86JygoPzpcXFxcXFxcXFxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcXFxcXFwnXSkqKSd8XFxcXFxcXCIoKD86XFxcXFxcXFxcXFxcXFxcXC58W15cXFxcXFxcXFxcXFxcXFxcXFxcXFxcXCJdKSopXFxcXFxcXCJ8KFxcXCIgKyBpZGVudGlmaWVyICsgXFxcIikpfClcXFwiICsgd2hpdGVzcGFjZSArXFxuXFx0XFx0XFxcIipcXFxcXFxcXF1cXFwiLFxcblxcblxcdHBzZXVkb3MgPSBcXFwiOihcXFwiICsgaWRlbnRpZmllciArIFxcXCIpKD86XFxcXFxcXFwoKFxcXCIgK1xcblxcdFxcdC8vIFRvIHJlZHVjZSB0aGUgbnVtYmVyIG9mIHNlbGVjdG9ycyBuZWVkaW5nIHRva2VuaXplIGluIHRoZSBwcmVGaWx0ZXIsIHByZWZlciBhcmd1bWVudHM6XFxuXFx0XFx0Ly8gMS4gcXVvdGVkIChjYXB0dXJlIDM7IGNhcHR1cmUgNCBvciBjYXB0dXJlIDUpXFxuXFx0XFx0XFxcIignKCg/OlxcXFxcXFxcXFxcXFxcXFwufFteXFxcXFxcXFxcXFxcXFxcXCddKSopJ3xcXFxcXFxcIigoPzpcXFxcXFxcXFxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcIl0pKilcXFxcXFxcIil8XFxcIiArXFxuXFx0XFx0Ly8gMi4gc2ltcGxlIChjYXB0dXJlIDYpXFxuXFx0XFx0XFxcIigoPzpcXFxcXFxcXFxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcXFxcXFwoKVtcXFxcXFxcXF1dfFxcXCIgKyBhdHRyaWJ1dGVzICsgXFxcIikqKXxcXFwiICtcXG5cXHRcXHQvLyAzLiBhbnl0aGluZyBlbHNlIChjYXB0dXJlIDIpXFxuXFx0XFx0XFxcIi4qXFxcIiArXFxuXFx0XFx0XFxcIilcXFxcXFxcXCl8KVxcXCIsXFxuXFxuXFx0Ly8gTGVhZGluZyBhbmQgbm9uLWVzY2FwZWQgdHJhaWxpbmcgd2hpdGVzcGFjZSwgY2FwdHVyaW5nIHNvbWUgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVycyBwcmVjZWRpbmcgdGhlIGxhdHRlclxcblxcdHJ3aGl0ZXNwYWNlID0gbmV3IFJlZ0V4cCggd2hpdGVzcGFjZSArIFxcXCIrXFxcIiwgXFxcImdcXFwiICksXFxuXFx0cnRyaW0gPSBuZXcgUmVnRXhwKCBcXFwiXlxcXCIgKyB3aGl0ZXNwYWNlICsgXFxcIit8KCg/Ol58W15cXFxcXFxcXFxcXFxcXFxcXSkoPzpcXFxcXFxcXFxcXFxcXFxcLikqKVxcXCIgKyB3aGl0ZXNwYWNlICsgXFxcIiskXFxcIiwgXFxcImdcXFwiICksXFxuXFxuXFx0cmNvbW1hID0gbmV3IFJlZ0V4cCggXFxcIl5cXFwiICsgd2hpdGVzcGFjZSArIFxcXCIqLFxcXCIgKyB3aGl0ZXNwYWNlICsgXFxcIipcXFwiICksXFxuXFx0cmNvbWJpbmF0b3JzID0gbmV3IFJlZ0V4cCggXFxcIl5cXFwiICsgd2hpdGVzcGFjZSArIFxcXCIqKFs+K35dfFxcXCIgKyB3aGl0ZXNwYWNlICsgXFxcIilcXFwiICsgd2hpdGVzcGFjZSArIFxcXCIqXFxcIiApLFxcblxcblxcdHJhdHRyaWJ1dGVRdW90ZXMgPSBuZXcgUmVnRXhwKCBcXFwiPVxcXCIgKyB3aGl0ZXNwYWNlICsgXFxcIiooW15cXFxcXFxcXF0nXFxcXFxcXCJdKj8pXFxcIiArIHdoaXRlc3BhY2UgKyBcXFwiKlxcXFxcXFxcXVxcXCIsIFxcXCJnXFxcIiApLFxcblxcblxcdHJwc2V1ZG8gPSBuZXcgUmVnRXhwKCBwc2V1ZG9zICksXFxuXFx0cmlkZW50aWZpZXIgPSBuZXcgUmVnRXhwKCBcXFwiXlxcXCIgKyBpZGVudGlmaWVyICsgXFxcIiRcXFwiICksXFxuXFxuXFx0bWF0Y2hFeHByID0ge1xcblxcdFxcdFxcXCJJRFxcXCI6IG5ldyBSZWdFeHAoIFxcXCJeIyhcXFwiICsgaWRlbnRpZmllciArIFxcXCIpXFxcIiApLFxcblxcdFxcdFxcXCJDTEFTU1xcXCI6IG5ldyBSZWdFeHAoIFxcXCJeXFxcXFxcXFwuKFxcXCIgKyBpZGVudGlmaWVyICsgXFxcIilcXFwiICksXFxuXFx0XFx0XFxcIlRBR1xcXCI6IG5ldyBSZWdFeHAoIFxcXCJeKFxcXCIgKyBpZGVudGlmaWVyICsgXFxcInxbKl0pXFxcIiApLFxcblxcdFxcdFxcXCJBVFRSXFxcIjogbmV3IFJlZ0V4cCggXFxcIl5cXFwiICsgYXR0cmlidXRlcyApLFxcblxcdFxcdFxcXCJQU0VVRE9cXFwiOiBuZXcgUmVnRXhwKCBcXFwiXlxcXCIgKyBwc2V1ZG9zICksXFxuXFx0XFx0XFxcIkNISUxEXFxcIjogbmV3IFJlZ0V4cCggXFxcIl46KG9ubHl8Zmlyc3R8bGFzdHxudGh8bnRoLWxhc3QpLShjaGlsZHxvZi10eXBlKSg/OlxcXFxcXFxcKFxcXCIgKyB3aGl0ZXNwYWNlICtcXG5cXHRcXHRcXHRcXFwiKihldmVufG9kZHwoKFsrLV18KShcXFxcXFxcXGQqKW58KVxcXCIgKyB3aGl0ZXNwYWNlICsgXFxcIiooPzooWystXXwpXFxcIiArIHdoaXRlc3BhY2UgK1xcblxcdFxcdFxcdFxcXCIqKFxcXFxcXFxcZCspfCkpXFxcIiArIHdoaXRlc3BhY2UgKyBcXFwiKlxcXFxcXFxcKXwpXFxcIiwgXFxcImlcXFwiICksXFxuXFx0XFx0XFxcImJvb2xcXFwiOiBuZXcgUmVnRXhwKCBcXFwiXig/OlxcXCIgKyBib29sZWFucyArIFxcXCIpJFxcXCIsIFxcXCJpXFxcIiApLFxcblxcdFxcdC8vIEZvciB1c2UgaW4gbGlicmFyaWVzIGltcGxlbWVudGluZyAuaXMoKVxcblxcdFxcdC8vIFdlIHVzZSB0aGlzIGZvciBQT1MgbWF0Y2hpbmcgaW4gYHNlbGVjdGBcXG5cXHRcXHRcXFwibmVlZHNDb250ZXh0XFxcIjogbmV3IFJlZ0V4cCggXFxcIl5cXFwiICsgd2hpdGVzcGFjZSArIFxcXCIqWz4rfl18OihldmVufG9kZHxlcXxndHxsdHxudGh8Zmlyc3R8bGFzdCkoPzpcXFxcXFxcXChcXFwiICtcXG5cXHRcXHRcXHR3aGl0ZXNwYWNlICsgXFxcIiooKD86LVxcXFxcXFxcZCk/XFxcXFxcXFxkKilcXFwiICsgd2hpdGVzcGFjZSArIFxcXCIqXFxcXFxcXFwpfCkoPz1bXi1dfCQpXFxcIiwgXFxcImlcXFwiIClcXG5cXHR9LFxcblxcblxcdHJpbnB1dHMgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLFxcblxcdHJoZWFkZXIgPSAvXmhcXFxcZCQvaSxcXG5cXG5cXHRybmF0aXZlID0gL15bXntdK1xcXFx7XFxcXHMqXFxcXFtuYXRpdmUgXFxcXHcvLFxcblxcblxcdC8vIEVhc2lseS1wYXJzZWFibGUvcmV0cmlldmFibGUgSUQgb3IgVEFHIG9yIENMQVNTIHNlbGVjdG9yc1xcblxcdHJxdWlja0V4cHIgPSAvXig/OiMoW1xcXFx3LV0rKXwoXFxcXHcrKXxcXFxcLihbXFxcXHctXSspKSQvLFxcblxcblxcdHJzaWJsaW5nID0gL1srfl0vLFxcblxcblxcdC8vIENTUyBlc2NhcGVzXFxuXFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI2VzY2FwZWQtY2hhcmFjdGVyc1xcblxcdHJ1bmVzY2FwZSA9IG5ldyBSZWdFeHAoIFxcXCJcXFxcXFxcXFxcXFxcXFxcKFtcXFxcXFxcXGRhLWZdezEsNn1cXFwiICsgd2hpdGVzcGFjZSArIFxcXCI/fChcXFwiICsgd2hpdGVzcGFjZSArIFxcXCIpfC4pXFxcIiwgXFxcImlnXFxcIiApLFxcblxcdGZ1bmVzY2FwZSA9IGZ1bmN0aW9uKCBfLCBlc2NhcGVkLCBlc2NhcGVkV2hpdGVzcGFjZSApIHtcXG5cXHRcXHR2YXIgaGlnaCA9IFxcXCIweFxcXCIgKyBlc2NhcGVkIC0gMHgxMDAwMDtcXG5cXHRcXHQvLyBOYU4gbWVhbnMgbm9uLWNvZGVwb2ludFxcblxcdFxcdC8vIFN1cHBvcnQ6IEZpcmVmb3g8MjRcXG5cXHRcXHQvLyBXb3JrYXJvdW5kIGVycm9uZW91cyBudW1lcmljIGludGVycHJldGF0aW9uIG9mICtcXFwiMHhcXFwiXFxuXFx0XFx0cmV0dXJuIGhpZ2ggIT09IGhpZ2ggfHwgZXNjYXBlZFdoaXRlc3BhY2UgP1xcblxcdFxcdFxcdGVzY2FwZWQgOlxcblxcdFxcdFxcdGhpZ2ggPCAwID9cXG5cXHRcXHRcXHRcXHQvLyBCTVAgY29kZXBvaW50XFxuXFx0XFx0XFx0XFx0U3RyaW5nLmZyb21DaGFyQ29kZSggaGlnaCArIDB4MTAwMDAgKSA6XFxuXFx0XFx0XFx0XFx0Ly8gU3VwcGxlbWVudGFsIFBsYW5lIGNvZGVwb2ludCAoc3Vycm9nYXRlIHBhaXIpXFxuXFx0XFx0XFx0XFx0U3RyaW5nLmZyb21DaGFyQ29kZSggaGlnaCA+PiAxMCB8IDB4RDgwMCwgaGlnaCAmIDB4M0ZGIHwgMHhEQzAwICk7XFxuXFx0fSxcXG5cXG5cXHQvLyBDU1Mgc3RyaW5nL2lkZW50aWZpZXIgc2VyaWFsaXphdGlvblxcblxcdC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS8jY29tbW9uLXNlcmlhbGl6aW5nLWlkaW9tc1xcblxcdHJjc3Nlc2NhcGUgPSAvKFtcXFxcMC1cXFxceDFmXFxcXHg3Zl18Xi0/XFxcXGQpfF4tJHxbXlxcXFwwLVxcXFx4MWZcXFxceDdmLVxcXFx1RkZGRlxcXFx3LV0vZyxcXG5cXHRmY3NzZXNjYXBlID0gZnVuY3Rpb24oIGNoLCBhc0NvZGVQb2ludCApIHtcXG5cXHRcXHRpZiAoIGFzQ29kZVBvaW50ICkge1xcblxcblxcdFxcdFxcdC8vIFUrMDAwMCBOVUxMIGJlY29tZXMgVStGRkZEIFJFUExBQ0VNRU5UIENIQVJBQ1RFUlxcblxcdFxcdFxcdGlmICggY2ggPT09IFxcXCJcXFxcMFxcXCIgKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIFxcXCJcXFxcdUZGRkRcXFwiO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBDb250cm9sIGNoYXJhY3RlcnMgYW5kIChkZXBlbmRlbnQgdXBvbiBwb3NpdGlvbikgbnVtYmVycyBnZXQgZXNjYXBlZCBhcyBjb2RlIHBvaW50c1xcblxcdFxcdFxcdHJldHVybiBjaC5zbGljZSggMCwgLTEgKSArIFxcXCJcXFxcXFxcXFxcXCIgKyBjaC5jaGFyQ29kZUF0KCBjaC5sZW5ndGggLSAxICkudG9TdHJpbmcoIDE2ICkgKyBcXFwiIFxcXCI7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIE90aGVyIHBvdGVudGlhbGx5LXNwZWNpYWwgQVNDSUkgY2hhcmFjdGVycyBnZXQgYmFja3NsYXNoLWVzY2FwZWRcXG5cXHRcXHRyZXR1cm4gXFxcIlxcXFxcXFxcXFxcIiArIGNoO1xcblxcdH0sXFxuXFxuXFx0Ly8gVXNlZCBmb3IgaWZyYW1lc1xcblxcdC8vIFNlZSBzZXREb2N1bWVudCgpXFxuXFx0Ly8gUmVtb3ZpbmcgdGhlIGZ1bmN0aW9uIHdyYXBwZXIgY2F1c2VzIGEgXFxcIlBlcm1pc3Npb24gRGVuaWVkXFxcIlxcblxcdC8vIGVycm9yIGluIElFXFxuXFx0dW5sb2FkSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xcblxcdFxcdHNldERvY3VtZW50KCk7XFxuXFx0fSxcXG5cXG5cXHRkaXNhYmxlZEFuY2VzdG9yID0gYWRkQ29tYmluYXRvcihcXG5cXHRcXHRmdW5jdGlvbiggZWxlbSApIHtcXG5cXHRcXHRcXHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gdHJ1ZSAmJiAoXFxcImZvcm1cXFwiIGluIGVsZW0gfHwgXFxcImxhYmVsXFxcIiBpbiBlbGVtKTtcXG5cXHRcXHR9LFxcblxcdFxcdHsgZGlyOiBcXFwicGFyZW50Tm9kZVxcXCIsIG5leHQ6IFxcXCJsZWdlbmRcXFwiIH1cXG5cXHQpO1xcblxcbi8vIE9wdGltaXplIGZvciBwdXNoLmFwcGx5KCBfLCBOb2RlTGlzdCApXFxudHJ5IHtcXG5cXHRwdXNoLmFwcGx5KFxcblxcdFxcdChhcnIgPSBzbGljZS5jYWxsKCBwcmVmZXJyZWREb2MuY2hpbGROb2RlcyApKSxcXG5cXHRcXHRwcmVmZXJyZWREb2MuY2hpbGROb2Rlc1xcblxcdCk7XFxuXFx0Ly8gU3VwcG9ydDogQW5kcm9pZDw0LjBcXG5cXHQvLyBEZXRlY3Qgc2lsZW50bHkgZmFpbGluZyBwdXNoLmFwcGx5XFxuXFx0YXJyWyBwcmVmZXJyZWREb2MuY2hpbGROb2Rlcy5sZW5ndGggXS5ub2RlVHlwZTtcXG59IGNhdGNoICggZSApIHtcXG5cXHRwdXNoID0geyBhcHBseTogYXJyLmxlbmd0aCA/XFxuXFxuXFx0XFx0Ly8gTGV2ZXJhZ2Ugc2xpY2UgaWYgcG9zc2libGVcXG5cXHRcXHRmdW5jdGlvbiggdGFyZ2V0LCBlbHMgKSB7XFxuXFx0XFx0XFx0cHVzaF9uYXRpdmUuYXBwbHkoIHRhcmdldCwgc2xpY2UuY2FsbChlbHMpICk7XFxuXFx0XFx0fSA6XFxuXFxuXFx0XFx0Ly8gU3VwcG9ydDogSUU8OVxcblxcdFxcdC8vIE90aGVyd2lzZSBhcHBlbmQgZGlyZWN0bHlcXG5cXHRcXHRmdW5jdGlvbiggdGFyZ2V0LCBlbHMgKSB7XFxuXFx0XFx0XFx0dmFyIGogPSB0YXJnZXQubGVuZ3RoLFxcblxcdFxcdFxcdFxcdGkgPSAwO1xcblxcdFxcdFxcdC8vIENhbid0IHRydXN0IE5vZGVMaXN0Lmxlbmd0aFxcblxcdFxcdFxcdHdoaWxlICggKHRhcmdldFtqKytdID0gZWxzW2krK10pICkge31cXG5cXHRcXHRcXHR0YXJnZXQubGVuZ3RoID0gaiAtIDE7XFxuXFx0XFx0fVxcblxcdH07XFxufVxcblxcbmZ1bmN0aW9uIFNpenpsZSggc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKSB7XFxuXFx0dmFyIG0sIGksIGVsZW0sIG5pZCwgbWF0Y2gsIGdyb3VwcywgbmV3U2VsZWN0b3IsXFxuXFx0XFx0bmV3Q29udGV4dCA9IGNvbnRleHQgJiYgY29udGV4dC5vd25lckRvY3VtZW50LFxcblxcblxcdFxcdC8vIG5vZGVUeXBlIGRlZmF1bHRzIHRvIDksIHNpbmNlIGNvbnRleHQgZGVmYXVsdHMgdG8gZG9jdW1lbnRcXG5cXHRcXHRub2RlVHlwZSA9IGNvbnRleHQgPyBjb250ZXh0Lm5vZGVUeXBlIDogOTtcXG5cXG5cXHRyZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcXG5cXG5cXHQvLyBSZXR1cm4gZWFybHkgZnJvbSBjYWxscyB3aXRoIGludmFsaWQgc2VsZWN0b3Igb3IgY29udGV4dFxcblxcdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcXFwic3RyaW5nXFxcIiB8fCAhc2VsZWN0b3IgfHxcXG5cXHRcXHRub2RlVHlwZSAhPT0gMSAmJiBub2RlVHlwZSAhPT0gOSAmJiBub2RlVHlwZSAhPT0gMTEgKSB7XFxuXFxuXFx0XFx0cmV0dXJuIHJlc3VsdHM7XFxuXFx0fVxcblxcblxcdC8vIFRyeSB0byBzaG9ydGN1dCBmaW5kIG9wZXJhdGlvbnMgKGFzIG9wcG9zZWQgdG8gZmlsdGVycykgaW4gSFRNTCBkb2N1bWVudHNcXG5cXHRpZiAoICFzZWVkICkge1xcblxcblxcdFxcdGlmICggKCBjb250ZXh0ID8gY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgOiBwcmVmZXJyZWREb2MgKSAhPT0gZG9jdW1lbnQgKSB7XFxuXFx0XFx0XFx0c2V0RG9jdW1lbnQoIGNvbnRleHQgKTtcXG5cXHRcXHR9XFxuXFx0XFx0Y29udGV4dCA9IGNvbnRleHQgfHwgZG9jdW1lbnQ7XFxuXFxuXFx0XFx0aWYgKCBkb2N1bWVudElzSFRNTCApIHtcXG5cXG5cXHRcXHRcXHQvLyBJZiB0aGUgc2VsZWN0b3IgaXMgc3VmZmljaWVudGx5IHNpbXBsZSwgdHJ5IHVzaW5nIGEgXFxcImdldCpCeSpcXFwiIERPTSBtZXRob2RcXG5cXHRcXHRcXHQvLyAoZXhjZXB0aW5nIERvY3VtZW50RnJhZ21lbnQgY29udGV4dCwgd2hlcmUgdGhlIG1ldGhvZHMgZG9uJ3QgZXhpc3QpXFxuXFx0XFx0XFx0aWYgKCBub2RlVHlwZSAhPT0gMTEgJiYgKG1hdGNoID0gcnF1aWNrRXhwci5leGVjKCBzZWxlY3RvciApKSApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBJRCBzZWxlY3RvclxcblxcdFxcdFxcdFxcdGlmICggKG0gPSBtYXRjaFsxXSkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gRG9jdW1lbnQgY29udGV4dFxcblxcdFxcdFxcdFxcdFxcdGlmICggbm9kZVR5cGUgPT09IDkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCAoZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIG0gKSkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gU3VwcG9ydDogSUUsIE9wZXJhLCBXZWJraXRcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBUT0RPOiBpZGVudGlmeSB2ZXJzaW9uc1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIGdldEVsZW1lbnRCeUlkIGNhbiBtYXRjaCBlbGVtZW50cyBieSBuYW1lIGluc3RlYWQgb2YgSURcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGVsZW0uaWQgPT09IG0gKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHJlc3VsdHM7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHJlc3VsdHM7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdC8vIEVsZW1lbnQgY29udGV4dFxcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gU3VwcG9ydDogSUUsIE9wZXJhLCBXZWJraXRcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBUT0RPOiBpZGVudGlmeSB2ZXJzaW9uc1xcblxcdFxcdFxcdFxcdFxcdFxcdC8vIGdldEVsZW1lbnRCeUlkIGNhbiBtYXRjaCBlbGVtZW50cyBieSBuYW1lIGluc3RlYWQgb2YgSURcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIG5ld0NvbnRleHQgJiYgKGVsZW0gPSBuZXdDb250ZXh0LmdldEVsZW1lbnRCeUlkKCBtICkpICYmXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Y29udGFpbnMoIGNvbnRleHQsIGVsZW0gKSAmJlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGVsZW0uaWQgPT09IG0gKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHJlc3VsdHM7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBUeXBlIHNlbGVjdG9yXFxuXFx0XFx0XFx0XFx0fSBlbHNlIGlmICggbWF0Y2hbMl0gKSB7XFxuXFx0XFx0XFx0XFx0XFx0cHVzaC5hcHBseSggcmVzdWx0cywgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggc2VsZWN0b3IgKSApO1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiByZXN1bHRzO1xcblxcblxcdFxcdFxcdFxcdC8vIENsYXNzIHNlbGVjdG9yXFxuXFx0XFx0XFx0XFx0fSBlbHNlIGlmICggKG0gPSBtYXRjaFszXSkgJiYgc3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmXFxuXFx0XFx0XFx0XFx0XFx0Y29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHB1c2guYXBwbHkoIHJlc3VsdHMsIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggbSApICk7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHJlc3VsdHM7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBUYWtlIGFkdmFudGFnZSBvZiBxdWVyeVNlbGVjdG9yQWxsXFxuXFx0XFx0XFx0aWYgKCBzdXBwb3J0LnFzYSAmJlxcblxcdFxcdFxcdFxcdCFjb21waWxlckNhY2hlWyBzZWxlY3RvciArIFxcXCIgXFxcIiBdICYmXFxuXFx0XFx0XFx0XFx0KCFyYnVnZ3lRU0EgfHwgIXJidWdneVFTQS50ZXN0KCBzZWxlY3RvciApKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIG5vZGVUeXBlICE9PSAxICkge1xcblxcdFxcdFxcdFxcdFxcdG5ld0NvbnRleHQgPSBjb250ZXh0O1xcblxcdFxcdFxcdFxcdFxcdG5ld1NlbGVjdG9yID0gc2VsZWN0b3I7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gcVNBIGxvb2tzIG91dHNpZGUgRWxlbWVudCBjb250ZXh0LCB3aGljaCBpcyBub3Qgd2hhdCB3ZSB3YW50XFxuXFx0XFx0XFx0XFx0Ly8gVGhhbmtzIHRvIEFuZHJldyBEdXBvbnQgZm9yIHRoaXMgd29ya2Fyb3VuZCB0ZWNobmlxdWVcXG5cXHRcXHRcXHRcXHQvLyBTdXBwb3J0OiBJRSA8PThcXG5cXHRcXHRcXHRcXHQvLyBFeGNsdWRlIG9iamVjdCBlbGVtZW50c1xcblxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoIGNvbnRleHQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gXFxcIm9iamVjdFxcXCIgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gQ2FwdHVyZSB0aGUgY29udGV4dCBJRCwgc2V0dGluZyBpdCBmaXJzdCBpZiBuZWNlc3NhcnlcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIChuaWQgPSBjb250ZXh0LmdldEF0dHJpYnV0ZSggXFxcImlkXFxcIiApKSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRuaWQgPSBuaWQucmVwbGFjZSggcmNzc2VzY2FwZSwgZmNzc2VzY2FwZSApO1xcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y29udGV4dC5zZXRBdHRyaWJ1dGUoIFxcXCJpZFxcXCIsIChuaWQgPSBleHBhbmRvKSApO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBQcmVmaXggZXZlcnkgc2VsZWN0b3IgaW4gdGhlIGxpc3RcXG5cXHRcXHRcXHRcXHRcXHRncm91cHMgPSB0b2tlbml6ZSggc2VsZWN0b3IgKTtcXG5cXHRcXHRcXHRcXHRcXHRpID0gZ3JvdXBzLmxlbmd0aDtcXG5cXHRcXHRcXHRcXHRcXHR3aGlsZSAoIGktLSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRncm91cHNbaV0gPSBcXFwiI1xcXCIgKyBuaWQgKyBcXFwiIFxcXCIgKyB0b1NlbGVjdG9yKCBncm91cHNbaV0gKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0bmV3U2VsZWN0b3IgPSBncm91cHMuam9pbiggXFxcIixcXFwiICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gRXhwYW5kIGNvbnRleHQgZm9yIHNpYmxpbmcgc2VsZWN0b3JzXFxuXFx0XFx0XFx0XFx0XFx0bmV3Q29udGV4dCA9IHJzaWJsaW5nLnRlc3QoIHNlbGVjdG9yICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y29udGV4dDtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBuZXdTZWxlY3RvciApIHtcXG5cXHRcXHRcXHRcXHRcXHR0cnkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHB1c2guYXBwbHkoIHJlc3VsdHMsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0bmV3Q29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCBuZXdTZWxlY3RvciApXFxuXFx0XFx0XFx0XFx0XFx0XFx0KTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gcmVzdWx0cztcXG5cXHRcXHRcXHRcXHRcXHR9IGNhdGNoICggcXNhRXJyb3IgKSB7XFxuXFx0XFx0XFx0XFx0XFx0fSBmaW5hbGx5IHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIG5pZCA9PT0gZXhwYW5kbyApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRjb250ZXh0LnJlbW92ZUF0dHJpYnV0ZSggXFxcImlkXFxcIiApO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fVxcblxcblxcdC8vIEFsbCBvdGhlcnNcXG5cXHRyZXR1cm4gc2VsZWN0KCBzZWxlY3Rvci5yZXBsYWNlKCBydHJpbSwgXFxcIiQxXFxcIiApLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICk7XFxufVxcblxcbi8qKlxcbiAqIENyZWF0ZSBrZXktdmFsdWUgY2FjaGVzIG9mIGxpbWl0ZWQgc2l6ZVxcbiAqIEByZXR1cm5zIHtmdW5jdGlvbihzdHJpbmcsIG9iamVjdCl9IFJldHVybnMgdGhlIE9iamVjdCBkYXRhIGFmdGVyIHN0b3JpbmcgaXQgb24gaXRzZWxmIHdpdGhcXG4gKlxcdHByb3BlcnR5IG5hbWUgdGhlIChzcGFjZS1zdWZmaXhlZCkgc3RyaW5nIGFuZCAoaWYgdGhlIGNhY2hlIGlzIGxhcmdlciB0aGFuIEV4cHIuY2FjaGVMZW5ndGgpXFxuICpcXHRkZWxldGluZyB0aGUgb2xkZXN0IGVudHJ5XFxuICovXFxuZnVuY3Rpb24gY3JlYXRlQ2FjaGUoKSB7XFxuXFx0dmFyIGtleXMgPSBbXTtcXG5cXG5cXHRmdW5jdGlvbiBjYWNoZSgga2V5LCB2YWx1ZSApIHtcXG5cXHRcXHQvLyBVc2UgKGtleSArIFxcXCIgXFxcIikgdG8gYXZvaWQgY29sbGlzaW9uIHdpdGggbmF0aXZlIHByb3RvdHlwZSBwcm9wZXJ0aWVzIChzZWUgSXNzdWUgIzE1NylcXG5cXHRcXHRpZiAoIGtleXMucHVzaCgga2V5ICsgXFxcIiBcXFwiICkgPiBFeHByLmNhY2hlTGVuZ3RoICkge1xcblxcdFxcdFxcdC8vIE9ubHkga2VlcCB0aGUgbW9zdCByZWNlbnQgZW50cmllc1xcblxcdFxcdFxcdGRlbGV0ZSBjYWNoZVsga2V5cy5zaGlmdCgpIF07XFxuXFx0XFx0fVxcblxcdFxcdHJldHVybiAoY2FjaGVbIGtleSArIFxcXCIgXFxcIiBdID0gdmFsdWUpO1xcblxcdH1cXG5cXHRyZXR1cm4gY2FjaGU7XFxufVxcblxcbi8qKlxcbiAqIE1hcmsgYSBmdW5jdGlvbiBmb3Igc3BlY2lhbCB1c2UgYnkgU2l6emxlXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIG1hcmtcXG4gKi9cXG5mdW5jdGlvbiBtYXJrRnVuY3Rpb24oIGZuICkge1xcblxcdGZuWyBleHBhbmRvIF0gPSB0cnVlO1xcblxcdHJldHVybiBmbjtcXG59XFxuXFxuLyoqXFxuICogU3VwcG9ydCB0ZXN0aW5nIHVzaW5nIGFuIGVsZW1lbnRcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBQYXNzZWQgdGhlIGNyZWF0ZWQgZWxlbWVudCBhbmQgcmV0dXJucyBhIGJvb2xlYW4gcmVzdWx0XFxuICovXFxuZnVuY3Rpb24gYXNzZXJ0KCBmbiApIHtcXG5cXHR2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFxcXCJmaWVsZHNldFxcXCIpO1xcblxcblxcdHRyeSB7XFxuXFx0XFx0cmV0dXJuICEhZm4oIGVsICk7XFxuXFx0fSBjYXRjaCAoZSkge1xcblxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHR9IGZpbmFsbHkge1xcblxcdFxcdC8vIFJlbW92ZSBmcm9tIGl0cyBwYXJlbnQgYnkgZGVmYXVsdFxcblxcdFxcdGlmICggZWwucGFyZW50Tm9kZSApIHtcXG5cXHRcXHRcXHRlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBlbCApO1xcblxcdFxcdH1cXG5cXHRcXHQvLyByZWxlYXNlIG1lbW9yeSBpbiBJRVxcblxcdFxcdGVsID0gbnVsbDtcXG5cXHR9XFxufVxcblxcbi8qKlxcbiAqIEFkZHMgdGhlIHNhbWUgaGFuZGxlciBmb3IgYWxsIG9mIHRoZSBzcGVjaWZpZWQgYXR0cnNcXG4gKiBAcGFyYW0ge1N0cmluZ30gYXR0cnMgUGlwZS1zZXBhcmF0ZWQgbGlzdCBvZiBhdHRyaWJ1dGVzXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBUaGUgbWV0aG9kIHRoYXQgd2lsbCBiZSBhcHBsaWVkXFxuICovXFxuZnVuY3Rpb24gYWRkSGFuZGxlKCBhdHRycywgaGFuZGxlciApIHtcXG5cXHR2YXIgYXJyID0gYXR0cnMuc3BsaXQoXFxcInxcXFwiKSxcXG5cXHRcXHRpID0gYXJyLmxlbmd0aDtcXG5cXG5cXHR3aGlsZSAoIGktLSApIHtcXG5cXHRcXHRFeHByLmF0dHJIYW5kbGVbIGFycltpXSBdID0gaGFuZGxlcjtcXG5cXHR9XFxufVxcblxcbi8qKlxcbiAqIENoZWNrcyBkb2N1bWVudCBvcmRlciBvZiB0d28gc2libGluZ3NcXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGFcXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGJcXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBSZXR1cm5zIGxlc3MgdGhhbiAwIGlmIGEgcHJlY2VkZXMgYiwgZ3JlYXRlciB0aGFuIDAgaWYgYSBmb2xsb3dzIGJcXG4gKi9cXG5mdW5jdGlvbiBzaWJsaW5nQ2hlY2soIGEsIGIgKSB7XFxuXFx0dmFyIGN1ciA9IGIgJiYgYSxcXG5cXHRcXHRkaWZmID0gY3VyICYmIGEubm9kZVR5cGUgPT09IDEgJiYgYi5ub2RlVHlwZSA9PT0gMSAmJlxcblxcdFxcdFxcdGEuc291cmNlSW5kZXggLSBiLnNvdXJjZUluZGV4O1xcblxcblxcdC8vIFVzZSBJRSBzb3VyY2VJbmRleCBpZiBhdmFpbGFibGUgb24gYm90aCBub2Rlc1xcblxcdGlmICggZGlmZiApIHtcXG5cXHRcXHRyZXR1cm4gZGlmZjtcXG5cXHR9XFxuXFxuXFx0Ly8gQ2hlY2sgaWYgYiBmb2xsb3dzIGFcXG5cXHRpZiAoIGN1ciApIHtcXG5cXHRcXHR3aGlsZSAoIChjdXIgPSBjdXIubmV4dFNpYmxpbmcpICkge1xcblxcdFxcdFxcdGlmICggY3VyID09PSBiICkge1xcblxcdFxcdFxcdFxcdHJldHVybiAtMTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdH1cXG5cXG5cXHRyZXR1cm4gYSA/IDEgOiAtMTtcXG59XFxuXFxuLyoqXFxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBpbnB1dCB0eXBlc1xcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXFxuICovXFxuZnVuY3Rpb24gY3JlYXRlSW5wdXRQc2V1ZG8oIHR5cGUgKSB7XFxuXFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xcblxcdFxcdHJldHVybiBuYW1lID09PSBcXFwiaW5wdXRcXFwiICYmIGVsZW0udHlwZSA9PT0gdHlwZTtcXG5cXHR9O1xcbn1cXG5cXG4vKipcXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIGJ1dHRvbnNcXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxcbiAqL1xcbmZ1bmN0aW9uIGNyZWF0ZUJ1dHRvblBzZXVkbyggdHlwZSApIHtcXG5cXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0XFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XFxuXFx0XFx0cmV0dXJuIChuYW1lID09PSBcXFwiaW5wdXRcXFwiIHx8IG5hbWUgPT09IFxcXCJidXR0b25cXFwiKSAmJiBlbGVtLnR5cGUgPT09IHR5cGU7XFxuXFx0fTtcXG59XFxuXFxuLyoqXFxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciA6ZW5hYmxlZC86ZGlzYWJsZWRcXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGRpc2FibGVkIHRydWUgZm9yIDpkaXNhYmxlZDsgZmFsc2UgZm9yIDplbmFibGVkXFxuICovXFxuZnVuY3Rpb24gY3JlYXRlRGlzYWJsZWRQc2V1ZG8oIGRpc2FibGVkICkge1xcblxcblxcdC8vIEtub3duIDpkaXNhYmxlZCBmYWxzZSBwb3NpdGl2ZXM6IGZpZWxkc2V0W2Rpc2FibGVkXSA+IGxlZ2VuZDpudGgtb2YtdHlwZShuKzIpIDpjYW4tZGlzYWJsZVxcblxcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcXG5cXG5cXHRcXHQvLyBPbmx5IGNlcnRhaW4gZWxlbWVudHMgY2FuIG1hdGNoIDplbmFibGVkIG9yIDpkaXNhYmxlZFxcblxcdFxcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NjcmlwdGluZy5odG1sI3NlbGVjdG9yLWVuYWJsZWRcXG5cXHRcXHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zY3JpcHRpbmcuaHRtbCNzZWxlY3Rvci1kaXNhYmxlZFxcblxcdFxcdGlmICggXFxcImZvcm1cXFwiIGluIGVsZW0gKSB7XFxuXFxuXFx0XFx0XFx0Ly8gQ2hlY2sgZm9yIGluaGVyaXRlZCBkaXNhYmxlZG5lc3Mgb24gcmVsZXZhbnQgbm9uLWRpc2FibGVkIGVsZW1lbnRzOlxcblxcdFxcdFxcdC8vICogbGlzdGVkIGZvcm0tYXNzb2NpYXRlZCBlbGVtZW50cyBpbiBhIGRpc2FibGVkIGZpZWxkc2V0XFxuXFx0XFx0XFx0Ly8gICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3Jtcy5odG1sI2NhdGVnb3J5LWxpc3RlZFxcblxcdFxcdFxcdC8vICAgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybXMuaHRtbCNjb25jZXB0LWZlLWRpc2FibGVkXFxuXFx0XFx0XFx0Ly8gKiBvcHRpb24gZWxlbWVudHMgaW4gYSBkaXNhYmxlZCBvcHRncm91cFxcblxcdFxcdFxcdC8vICAgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybXMuaHRtbCNjb25jZXB0LW9wdGlvbi1kaXNhYmxlZFxcblxcdFxcdFxcdC8vIEFsbCBzdWNoIGVsZW1lbnRzIGhhdmUgYSBcXFwiZm9ybVxcXCIgcHJvcGVydHkuXFxuXFx0XFx0XFx0aWYgKCBlbGVtLnBhcmVudE5vZGUgJiYgZWxlbS5kaXNhYmxlZCA9PT0gZmFsc2UgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gT3B0aW9uIGVsZW1lbnRzIGRlZmVyIHRvIGEgcGFyZW50IG9wdGdyb3VwIGlmIHByZXNlbnRcXG5cXHRcXHRcXHRcXHRpZiAoIFxcXCJsYWJlbFxcXCIgaW4gZWxlbSApIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIFxcXCJsYWJlbFxcXCIgaW4gZWxlbS5wYXJlbnROb2RlICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBlbGVtLnBhcmVudE5vZGUuZGlzYWJsZWQgPT09IGRpc2FibGVkO1xcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGRpc2FibGVkO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gU3VwcG9ydDogSUUgNiAtIDExXFxuXFx0XFx0XFx0XFx0Ly8gVXNlIHRoZSBpc0Rpc2FibGVkIHNob3J0Y3V0IHByb3BlcnR5IHRvIGNoZWNrIGZvciBkaXNhYmxlZCBmaWVsZHNldCBhbmNlc3RvcnNcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZWxlbS5pc0Rpc2FibGVkID09PSBkaXNhYmxlZCB8fFxcblxcblxcdFxcdFxcdFxcdFxcdC8vIFdoZXJlIHRoZXJlIGlzIG5vIGlzRGlzYWJsZWQsIGNoZWNrIG1hbnVhbGx5XFxuXFx0XFx0XFx0XFx0XFx0LyoganNoaW50IC1XMDE4ICovXFxuXFx0XFx0XFx0XFx0XFx0ZWxlbS5pc0Rpc2FibGVkICE9PSAhZGlzYWJsZWQgJiZcXG5cXHRcXHRcXHRcXHRcXHRcXHRkaXNhYmxlZEFuY2VzdG9yKCBlbGVtICkgPT09IGRpc2FibGVkO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XFxuXFxuXFx0XFx0Ly8gVHJ5IHRvIHdpbm5vdyBvdXQgZWxlbWVudHMgdGhhdCBjYW4ndCBiZSBkaXNhYmxlZCBiZWZvcmUgdHJ1c3RpbmcgdGhlIGRpc2FibGVkIHByb3BlcnR5LlxcblxcdFxcdC8vIFNvbWUgdmljdGltcyBnZXQgY2F1Z2h0IGluIG91ciBuZXQgKGxhYmVsLCBsZWdlbmQsIG1lbnUsIHRyYWNrKSwgYnV0IGl0IHNob3VsZG4ndFxcblxcdFxcdC8vIGV2ZW4gZXhpc3Qgb24gdGhlbSwgbGV0IGFsb25lIGhhdmUgYSBib29sZWFuIHZhbHVlLlxcblxcdFxcdH0gZWxzZSBpZiAoIFxcXCJsYWJlbFxcXCIgaW4gZWxlbSApIHtcXG5cXHRcXHRcXHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIFJlbWFpbmluZyBlbGVtZW50cyBhcmUgbmVpdGhlciA6ZW5hYmxlZCBub3IgOmRpc2FibGVkXFxuXFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdH07XFxufVxcblxcbi8qKlxcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgcG9zaXRpb25hbHNcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAqL1xcbmZ1bmN0aW9uIGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZuICkge1xcblxcdHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIGFyZ3VtZW50ICkge1xcblxcdFxcdGFyZ3VtZW50ID0gK2FyZ3VtZW50O1xcblxcdFxcdHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMgKSB7XFxuXFx0XFx0XFx0dmFyIGosXFxuXFx0XFx0XFx0XFx0bWF0Y2hJbmRleGVzID0gZm4oIFtdLCBzZWVkLmxlbmd0aCwgYXJndW1lbnQgKSxcXG5cXHRcXHRcXHRcXHRpID0gbWF0Y2hJbmRleGVzLmxlbmd0aDtcXG5cXG5cXHRcXHRcXHQvLyBNYXRjaCBlbGVtZW50cyBmb3VuZCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4ZXNcXG5cXHRcXHRcXHR3aGlsZSAoIGktLSApIHtcXG5cXHRcXHRcXHRcXHRpZiAoIHNlZWRbIChqID0gbWF0Y2hJbmRleGVzW2ldKSBdICkge1xcblxcdFxcdFxcdFxcdFxcdHNlZWRbal0gPSAhKG1hdGNoZXNbal0gPSBzZWVkW2pdKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0pO1xcblxcdH0pO1xcbn1cXG5cXG4vKipcXG4gKiBDaGVja3MgYSBub2RlIGZvciB2YWxpZGl0eSBhcyBhIFNpenpsZSBjb250ZXh0XFxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdD19IGNvbnRleHRcXG4gKiBAcmV0dXJucyB7RWxlbWVudHxPYmplY3R8Qm9vbGVhbn0gVGhlIGlucHV0IG5vZGUgaWYgYWNjZXB0YWJsZSwgb3RoZXJ3aXNlIGEgZmFsc3kgdmFsdWVcXG4gKi9cXG5mdW5jdGlvbiB0ZXN0Q29udGV4dCggY29udGV4dCApIHtcXG5cXHRyZXR1cm4gY29udGV4dCAmJiB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXFxcInVuZGVmaW5lZFxcXCIgJiYgY29udGV4dDtcXG59XFxuXFxuLy8gRXhwb3NlIHN1cHBvcnQgdmFycyBmb3IgY29udmVuaWVuY2VcXG5zdXBwb3J0ID0gU2l6emxlLnN1cHBvcnQgPSB7fTtcXG5cXG4vKipcXG4gKiBEZXRlY3RzIFhNTCBub2Rlc1xcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IGVsZW0gQW4gZWxlbWVudCBvciBhIGRvY3VtZW50XFxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWZmIGVsZW0gaXMgYSBub24tSFRNTCBYTUwgbm9kZVxcbiAqL1xcbmlzWE1MID0gU2l6emxlLmlzWE1MID0gZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0Ly8gZG9jdW1lbnRFbGVtZW50IGlzIHZlcmlmaWVkIGZvciBjYXNlcyB3aGVyZSBpdCBkb2Vzbid0IHlldCBleGlzdFxcblxcdC8vIChzdWNoIGFzIGxvYWRpbmcgaWZyYW1lcyBpbiBJRSAtICM0ODMzKVxcblxcdHZhciBkb2N1bWVudEVsZW1lbnQgPSBlbGVtICYmIChlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSkuZG9jdW1lbnRFbGVtZW50O1xcblxcdHJldHVybiBkb2N1bWVudEVsZW1lbnQgPyBkb2N1bWVudEVsZW1lbnQubm9kZU5hbWUgIT09IFxcXCJIVE1MXFxcIiA6IGZhbHNlO1xcbn07XFxuXFxuLyoqXFxuICogU2V0cyBkb2N1bWVudC1yZWxhdGVkIHZhcmlhYmxlcyBvbmNlIGJhc2VkIG9uIHRoZSBjdXJyZW50IGRvY3VtZW50XFxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gW2RvY10gQW4gZWxlbWVudCBvciBkb2N1bWVudCBvYmplY3QgdG8gdXNlIHRvIHNldCB0aGUgZG9jdW1lbnRcXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjdXJyZW50IGRvY3VtZW50XFxuICovXFxuc2V0RG9jdW1lbnQgPSBTaXp6bGUuc2V0RG9jdW1lbnQgPSBmdW5jdGlvbiggbm9kZSApIHtcXG5cXHR2YXIgaGFzQ29tcGFyZSwgc3ViV2luZG93LFxcblxcdFxcdGRvYyA9IG5vZGUgPyBub2RlLm93bmVyRG9jdW1lbnQgfHwgbm9kZSA6IHByZWZlcnJlZERvYztcXG5cXG5cXHQvLyBSZXR1cm4gZWFybHkgaWYgZG9jIGlzIGludmFsaWQgb3IgYWxyZWFkeSBzZWxlY3RlZFxcblxcdGlmICggZG9jID09PSBkb2N1bWVudCB8fCBkb2Mubm9kZVR5cGUgIT09IDkgfHwgIWRvYy5kb2N1bWVudEVsZW1lbnQgKSB7XFxuXFx0XFx0cmV0dXJuIGRvY3VtZW50O1xcblxcdH1cXG5cXG5cXHQvLyBVcGRhdGUgZ2xvYmFsIHZhcmlhYmxlc1xcblxcdGRvY3VtZW50ID0gZG9jO1xcblxcdGRvY0VsZW0gPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XFxuXFx0ZG9jdW1lbnRJc0hUTUwgPSAhaXNYTUwoIGRvY3VtZW50ICk7XFxuXFxuXFx0Ly8gU3VwcG9ydDogSUUgOS0xMSwgRWRnZVxcblxcdC8vIEFjY2Vzc2luZyBpZnJhbWUgZG9jdW1lbnRzIGFmdGVyIHVubG9hZCB0aHJvd3MgXFxcInBlcm1pc3Npb24gZGVuaWVkXFxcIiBlcnJvcnMgKGpRdWVyeSAjMTM5MzYpXFxuXFx0aWYgKCBwcmVmZXJyZWREb2MgIT09IGRvY3VtZW50ICYmXFxuXFx0XFx0KHN1YldpbmRvdyA9IGRvY3VtZW50LmRlZmF1bHRWaWV3KSAmJiBzdWJXaW5kb3cudG9wICE9PSBzdWJXaW5kb3cgKSB7XFxuXFxuXFx0XFx0Ly8gU3VwcG9ydDogSUUgMTEsIEVkZ2VcXG5cXHRcXHRpZiAoIHN1YldpbmRvdy5hZGRFdmVudExpc3RlbmVyICkge1xcblxcdFxcdFxcdHN1YldpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBcXFwidW5sb2FkXFxcIiwgdW5sb2FkSGFuZGxlciwgZmFsc2UgKTtcXG5cXG5cXHRcXHQvLyBTdXBwb3J0OiBJRSA5IC0gMTAgb25seVxcblxcdFxcdH0gZWxzZSBpZiAoIHN1YldpbmRvdy5hdHRhY2hFdmVudCApIHtcXG5cXHRcXHRcXHRzdWJXaW5kb3cuYXR0YWNoRXZlbnQoIFxcXCJvbnVubG9hZFxcXCIsIHVubG9hZEhhbmRsZXIgKTtcXG5cXHRcXHR9XFxuXFx0fVxcblxcblxcdC8qIEF0dHJpYnV0ZXNcXG5cXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXFxuXFxuXFx0Ly8gU3VwcG9ydDogSUU8OFxcblxcdC8vIFZlcmlmeSB0aGF0IGdldEF0dHJpYnV0ZSByZWFsbHkgcmV0dXJucyBhdHRyaWJ1dGVzIGFuZCBub3QgcHJvcGVydGllc1xcblxcdC8vIChleGNlcHRpbmcgSUU4IGJvb2xlYW5zKVxcblxcdHN1cHBvcnQuYXR0cmlidXRlcyA9IGFzc2VydChmdW5jdGlvbiggZWwgKSB7XFxuXFx0XFx0ZWwuY2xhc3NOYW1lID0gXFxcImlcXFwiO1xcblxcdFxcdHJldHVybiAhZWwuZ2V0QXR0cmlidXRlKFxcXCJjbGFzc05hbWVcXFwiKTtcXG5cXHR9KTtcXG5cXG5cXHQvKiBnZXRFbGVtZW50KHMpQnkqXFxuXFx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xcblxcblxcdC8vIENoZWNrIGlmIGdldEVsZW1lbnRzQnlUYWdOYW1lKFxcXCIqXFxcIikgcmV0dXJucyBvbmx5IGVsZW1lbnRzXFxuXFx0c3VwcG9ydC5nZXRFbGVtZW50c0J5VGFnTmFtZSA9IGFzc2VydChmdW5jdGlvbiggZWwgKSB7XFxuXFx0XFx0ZWwuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoXFxcIlxcXCIpICk7XFxuXFx0XFx0cmV0dXJuICFlbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcXFwiKlxcXCIpLmxlbmd0aDtcXG5cXHR9KTtcXG5cXG5cXHQvLyBTdXBwb3J0OiBJRTw5XFxuXFx0c3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lID0gcm5hdGl2ZS50ZXN0KCBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICk7XFxuXFxuXFx0Ly8gU3VwcG9ydDogSUU8MTBcXG5cXHQvLyBDaGVjayBpZiBnZXRFbGVtZW50QnlJZCByZXR1cm5zIGVsZW1lbnRzIGJ5IG5hbWVcXG5cXHQvLyBUaGUgYnJva2VuIGdldEVsZW1lbnRCeUlkIG1ldGhvZHMgZG9uJ3QgcGljayB1cCBwcm9ncmFtbWF0aWNhbGx5LXNldCBuYW1lcyxcXG5cXHQvLyBzbyB1c2UgYSByb3VuZGFib3V0IGdldEVsZW1lbnRzQnlOYW1lIHRlc3RcXG5cXHRzdXBwb3J0LmdldEJ5SWQgPSBhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xcblxcdFxcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGVsICkuaWQgPSBleHBhbmRvO1xcblxcdFxcdHJldHVybiAhZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUgfHwgIWRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKCBleHBhbmRvICkubGVuZ3RoO1xcblxcdH0pO1xcblxcblxcdC8vIElEIGZpbHRlciBhbmQgZmluZFxcblxcdGlmICggc3VwcG9ydC5nZXRCeUlkICkge1xcblxcdFxcdEV4cHIuZmlsdGVyW1xcXCJJRFxcXCJdID0gZnVuY3Rpb24oIGlkICkge1xcblxcdFxcdFxcdHZhciBhdHRySWQgPSBpZC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoXFxcImlkXFxcIikgPT09IGF0dHJJZDtcXG5cXHRcXHRcXHR9O1xcblxcdFxcdH07XFxuXFx0XFx0RXhwci5maW5kW1xcXCJJRFxcXCJdID0gZnVuY3Rpb24oIGlkLCBjb250ZXh0ICkge1xcblxcdFxcdFxcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQgIT09IFxcXCJ1bmRlZmluZWRcXFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xcblxcdFxcdFxcdFxcdHZhciBlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggaWQgKTtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZWxlbSA/IFsgZWxlbSBdIDogW107XFxuXFx0XFx0XFx0fVxcblxcdFxcdH07XFxuXFx0fSBlbHNlIHtcXG5cXHRcXHRFeHByLmZpbHRlcltcXFwiSURcXFwiXSA9ICBmdW5jdGlvbiggaWQgKSB7XFxuXFx0XFx0XFx0dmFyIGF0dHJJZCA9IGlkLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdFxcdFxcdHZhciBub2RlID0gdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlTm9kZSAhPT0gXFxcInVuZGVmaW5lZFxcXCIgJiZcXG5cXHRcXHRcXHRcXHRcXHRlbGVtLmdldEF0dHJpYnV0ZU5vZGUoXFxcImlkXFxcIik7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gYXR0cklkO1xcblxcdFxcdFxcdH07XFxuXFx0XFx0fTtcXG5cXG5cXHRcXHQvLyBTdXBwb3J0OiBJRSA2IC0gNyBvbmx5XFxuXFx0XFx0Ly8gZ2V0RWxlbWVudEJ5SWQgaXMgbm90IHJlbGlhYmxlIGFzIGEgZmluZCBzaG9ydGN1dFxcblxcdFxcdEV4cHIuZmluZFtcXFwiSURcXFwiXSA9IGZ1bmN0aW9uKCBpZCwgY29udGV4dCApIHtcXG5cXHRcXHRcXHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRCeUlkICE9PSBcXFwidW5kZWZpbmVkXFxcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcXG5cXHRcXHRcXHRcXHR2YXIgbm9kZSwgaSwgZWxlbXMsXFxuXFx0XFx0XFx0XFx0XFx0ZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIGlkICk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBlbGVtICkge1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIFZlcmlmeSB0aGUgaWQgYXR0cmlidXRlXFxuXFx0XFx0XFx0XFx0XFx0bm9kZSA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZShcXFwiaWRcXFwiKTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gaWQgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIFsgZWxlbSBdO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBGYWxsIGJhY2sgb24gZ2V0RWxlbWVudHNCeU5hbWVcXG5cXHRcXHRcXHRcXHRcXHRlbGVtcyA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeU5hbWUoIGlkICk7XFxuXFx0XFx0XFx0XFx0XFx0aSA9IDA7XFxuXFx0XFx0XFx0XFx0XFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1zW2krK10pICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdG5vZGUgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoXFxcImlkXFxcIik7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBub2RlICYmIG5vZGUudmFsdWUgPT09IGlkICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBbIGVsZW0gXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gW107XFxuXFx0XFx0XFx0fVxcblxcdFxcdH07XFxuXFx0fVxcblxcblxcdC8vIFRhZ1xcblxcdEV4cHIuZmluZFtcXFwiVEFHXFxcIl0gPSBzdXBwb3J0LmdldEVsZW1lbnRzQnlUYWdOYW1lID9cXG5cXHRcXHRmdW5jdGlvbiggdGFnLCBjb250ZXh0ICkge1xcblxcdFxcdFxcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFxcXCJ1bmRlZmluZWRcXFwiICkge1xcblxcdFxcdFxcdFxcdHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgKTtcXG5cXG5cXHRcXHRcXHQvLyBEb2N1bWVudEZyYWdtZW50IG5vZGVzIGRvbid0IGhhdmUgZ0VCVE5cXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCBzdXBwb3J0LnFzYSApIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCB0YWcgKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSA6XFxuXFxuXFx0XFx0ZnVuY3Rpb24oIHRhZywgY29udGV4dCApIHtcXG5cXHRcXHRcXHR2YXIgZWxlbSxcXG5cXHRcXHRcXHRcXHR0bXAgPSBbXSxcXG5cXHRcXHRcXHRcXHRpID0gMCxcXG5cXHRcXHRcXHRcXHQvLyBCeSBoYXBweSBjb2luY2lkZW5jZSwgYSAoYnJva2VuKSBnRUJUTiBhcHBlYXJzIG9uIERvY3VtZW50RnJhZ21lbnQgbm9kZXMgdG9vXFxuXFx0XFx0XFx0XFx0cmVzdWx0cyA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyApO1xcblxcblxcdFxcdFxcdC8vIEZpbHRlciBvdXQgcG9zc2libGUgY29tbWVudHNcXG5cXHRcXHRcXHRpZiAoIHRhZyA9PT0gXFxcIipcXFwiICkge1xcblxcdFxcdFxcdFxcdHdoaWxlICggKGVsZW0gPSByZXN1bHRzW2krK10pICkge1xcblxcdFxcdFxcdFxcdFxcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0bXAucHVzaCggZWxlbSApO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRtcDtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cmV0dXJuIHJlc3VsdHM7XFxuXFx0XFx0fTtcXG5cXG5cXHQvLyBDbGFzc1xcblxcdEV4cHIuZmluZFtcXFwiQ0xBU1NcXFwiXSA9IHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJiBmdW5jdGlvbiggY2xhc3NOYW1lLCBjb250ZXh0ICkge1xcblxcdFxcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAhPT0gXFxcInVuZGVmaW5lZFxcXCIgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XFxuXFx0XFx0XFx0cmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggY2xhc3NOYW1lICk7XFxuXFx0XFx0fVxcblxcdH07XFxuXFxuXFx0LyogUVNBL21hdGNoZXNTZWxlY3RvclxcblxcdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cXG5cXG5cXHQvLyBRU0EgYW5kIG1hdGNoZXNTZWxlY3RvciBzdXBwb3J0XFxuXFxuXFx0Ly8gbWF0Y2hlc1NlbGVjdG9yKDphY3RpdmUpIHJlcG9ydHMgZmFsc2Ugd2hlbiB0cnVlIChJRTkvT3BlcmEgMTEuNSlcXG5cXHRyYnVnZ3lNYXRjaGVzID0gW107XFxuXFxuXFx0Ly8gcVNhKDpmb2N1cykgcmVwb3J0cyBmYWxzZSB3aGVuIHRydWUgKENocm9tZSAyMSlcXG5cXHQvLyBXZSBhbGxvdyB0aGlzIGJlY2F1c2Ugb2YgYSBidWcgaW4gSUU4LzkgdGhhdCB0aHJvd3MgYW4gZXJyb3JcXG5cXHQvLyB3aGVuZXZlciBgZG9jdW1lbnQuYWN0aXZlRWxlbWVudGAgaXMgYWNjZXNzZWQgb24gYW4gaWZyYW1lXFxuXFx0Ly8gU28sIHdlIGFsbG93IDpmb2N1cyB0byBwYXNzIHRocm91Z2ggUVNBIGFsbCB0aGUgdGltZSB0byBhdm9pZCB0aGUgSUUgZXJyb3JcXG5cXHQvLyBTZWUgaHR0cHM6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEzMzc4XFxuXFx0cmJ1Z2d5UVNBID0gW107XFxuXFxuXFx0aWYgKCAoc3VwcG9ydC5xc2EgPSBybmF0aXZlLnRlc3QoIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwgKSkgKSB7XFxuXFx0XFx0Ly8gQnVpbGQgUVNBIHJlZ2V4XFxuXFx0XFx0Ly8gUmVnZXggc3RyYXRlZ3kgYWRvcHRlZCBmcm9tIERpZWdvIFBlcmluaVxcblxcdFxcdGFzc2VydChmdW5jdGlvbiggZWwgKSB7XFxuXFx0XFx0XFx0Ly8gU2VsZWN0IGlzIHNldCB0byBlbXB0eSBzdHJpbmcgb24gcHVycG9zZVxcblxcdFxcdFxcdC8vIFRoaXMgaXMgdG8gdGVzdCBJRSdzIHRyZWF0bWVudCBvZiBub3QgZXhwbGljaXRseVxcblxcdFxcdFxcdC8vIHNldHRpbmcgYSBib29sZWFuIGNvbnRlbnQgYXR0cmlidXRlLFxcblxcdFxcdFxcdC8vIHNpbmNlIGl0cyBwcmVzZW5jZSBzaG91bGQgYmUgZW5vdWdoXFxuXFx0XFx0XFx0Ly8gaHR0cHM6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEyMzU5XFxuXFx0XFx0XFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZWwgKS5pbm5lckhUTUwgPSBcXFwiPGEgaWQ9J1xcXCIgKyBleHBhbmRvICsgXFxcIic+PC9hPlxcXCIgK1xcblxcdFxcdFxcdFxcdFxcXCI8c2VsZWN0IGlkPSdcXFwiICsgZXhwYW5kbyArIFxcXCItXFxcXHJcXFxcXFxcXCcgbXNhbGxvd2NhcHR1cmU9Jyc+XFxcIiArXFxuXFx0XFx0XFx0XFx0XFxcIjxvcHRpb24gc2VsZWN0ZWQ9Jyc+PC9vcHRpb24+PC9zZWxlY3Q+XFxcIjtcXG5cXG5cXHRcXHRcXHQvLyBTdXBwb3J0OiBJRTgsIE9wZXJhIDExLTEyLjE2XFxuXFx0XFx0XFx0Ly8gTm90aGluZyBzaG91bGQgYmUgc2VsZWN0ZWQgd2hlbiBlbXB0eSBzdHJpbmdzIGZvbGxvdyBePSBvciAkPSBvciAqPVxcblxcdFxcdFxcdC8vIFRoZSB0ZXN0IGF0dHJpYnV0ZSBtdXN0IGJlIHVua25vd24gaW4gT3BlcmEgYnV0IFxcXCJzYWZlXFxcIiBmb3IgV2luUlRcXG5cXHRcXHRcXHQvLyBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2hoNDY1Mzg4LmFzcHgjYXR0cmlidXRlX3NlY3Rpb25cXG5cXHRcXHRcXHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXFxcIlttc2FsbG93Y2FwdHVyZV49JyddXFxcIikubGVuZ3RoICkge1xcblxcdFxcdFxcdFxcdHJidWdneVFTQS5wdXNoKCBcXFwiWypeJF09XFxcIiArIHdoaXRlc3BhY2UgKyBcXFwiKig/OicnfFxcXFxcXFwiXFxcXFxcXCIpXFxcIiApO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBTdXBwb3J0OiBJRThcXG5cXHRcXHRcXHQvLyBCb29sZWFuIGF0dHJpYnV0ZXMgYW5kIFxcXCJ2YWx1ZVxcXCIgYXJlIG5vdCB0cmVhdGVkIGNvcnJlY3RseVxcblxcdFxcdFxcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoXFxcIltzZWxlY3RlZF1cXFwiKS5sZW5ndGggKSB7XFxuXFx0XFx0XFx0XFx0cmJ1Z2d5UVNBLnB1c2goIFxcXCJcXFxcXFxcXFtcXFwiICsgd2hpdGVzcGFjZSArIFxcXCIqKD86dmFsdWV8XFxcIiArIGJvb2xlYW5zICsgXFxcIilcXFwiICk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIFN1cHBvcnQ6IENocm9tZTwyOSwgQW5kcm9pZDw0LjQsIFNhZmFyaTw3LjArLCBpT1M8Ny4wKywgUGhhbnRvbUpTPDEuOS44K1xcblxcdFxcdFxcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFxcXCJbaWR+PVxcXCIgKyBleHBhbmRvICsgXFxcIi1dXFxcIiApLmxlbmd0aCApIHtcXG5cXHRcXHRcXHRcXHRyYnVnZ3lRU0EucHVzaChcXFwifj1cXFwiKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gV2Via2l0L09wZXJhIC0gOmNoZWNrZWQgc2hvdWxkIHJldHVybiBzZWxlY3RlZCBvcHRpb24gZWxlbWVudHNcXG5cXHRcXHRcXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDExL1JFQy1jc3MzLXNlbGVjdG9ycy0yMDExMDkyOS8jY2hlY2tlZFxcblxcdFxcdFxcdC8vIElFOCB0aHJvd3MgZXJyb3IgaGVyZSBhbmQgd2lsbCBub3Qgc2VlIGxhdGVyIHRlc3RzXFxuXFx0XFx0XFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbChcXFwiOmNoZWNrZWRcXFwiKS5sZW5ndGggKSB7XFxuXFx0XFx0XFx0XFx0cmJ1Z2d5UVNBLnB1c2goXFxcIjpjaGVja2VkXFxcIik7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIFN1cHBvcnQ6IFNhZmFyaSA4KywgaU9TIDgrXFxuXFx0XFx0XFx0Ly8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEzNjg1MVxcblxcdFxcdFxcdC8vIEluLXBhZ2UgYHNlbGVjdG9yI2lkIHNpYmxpbmctY29tYmluYXRvciBzZWxlY3RvcmAgZmFpbHNcXG5cXHRcXHRcXHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKCBcXFwiYSNcXFwiICsgZXhwYW5kbyArIFxcXCIrKlxcXCIgKS5sZW5ndGggKSB7XFxuXFx0XFx0XFx0XFx0cmJ1Z2d5UVNBLnB1c2goXFxcIi4jLitbK35dXFxcIik7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0pO1xcblxcblxcdFxcdGFzc2VydChmdW5jdGlvbiggZWwgKSB7XFxuXFx0XFx0XFx0ZWwuaW5uZXJIVE1MID0gXFxcIjxhIGhyZWY9JycgZGlzYWJsZWQ9J2Rpc2FibGVkJz48L2E+XFxcIiArXFxuXFx0XFx0XFx0XFx0XFxcIjxzZWxlY3QgZGlzYWJsZWQ9J2Rpc2FibGVkJz48b3B0aW9uLz48L3NlbGVjdD5cXFwiO1xcblxcblxcdFxcdFxcdC8vIFN1cHBvcnQ6IFdpbmRvd3MgOCBOYXRpdmUgQXBwc1xcblxcdFxcdFxcdC8vIFRoZSB0eXBlIGFuZCBuYW1lIGF0dHJpYnV0ZXMgYXJlIHJlc3RyaWN0ZWQgZHVyaW5nIC5pbm5lckhUTUwgYXNzaWdubWVudFxcblxcdFxcdFxcdHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXFxcImlucHV0XFxcIik7XFxuXFx0XFx0XFx0aW5wdXQuc2V0QXR0cmlidXRlKCBcXFwidHlwZVxcXCIsIFxcXCJoaWRkZW5cXFwiICk7XFxuXFx0XFx0XFx0ZWwuYXBwZW5kQ2hpbGQoIGlucHV0ICkuc2V0QXR0cmlidXRlKCBcXFwibmFtZVxcXCIsIFxcXCJEXFxcIiApO1xcblxcblxcdFxcdFxcdC8vIFN1cHBvcnQ6IElFOFxcblxcdFxcdFxcdC8vIEVuZm9yY2UgY2FzZS1zZW5zaXRpdml0eSBvZiBuYW1lIGF0dHJpYnV0ZVxcblxcdFxcdFxcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbChcXFwiW25hbWU9ZF1cXFwiKS5sZW5ndGggKSB7XFxuXFx0XFx0XFx0XFx0cmJ1Z2d5UVNBLnB1c2goIFxcXCJuYW1lXFxcIiArIHdoaXRlc3BhY2UgKyBcXFwiKlsqXiR8IX5dPz1cXFwiICk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIEZGIDMuNSAtIDplbmFibGVkLzpkaXNhYmxlZCBhbmQgaGlkZGVuIGVsZW1lbnRzIChoaWRkZW4gZWxlbWVudHMgYXJlIHN0aWxsIGVuYWJsZWQpXFxuXFx0XFx0XFx0Ly8gSUU4IHRocm93cyBlcnJvciBoZXJlIGFuZCB3aWxsIG5vdCBzZWUgbGF0ZXIgdGVzdHNcXG5cXHRcXHRcXHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXFxcIjplbmFibGVkXFxcIikubGVuZ3RoICE9PSAyICkge1xcblxcdFxcdFxcdFxcdHJidWdneVFTQS5wdXNoKCBcXFwiOmVuYWJsZWRcXFwiLCBcXFwiOmRpc2FibGVkXFxcIiApO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBTdXBwb3J0OiBJRTktMTErXFxuXFx0XFx0XFx0Ly8gSUUncyA6ZGlzYWJsZWQgc2VsZWN0b3IgZG9lcyBub3QgcGljayB1cCB0aGUgY2hpbGRyZW4gb2YgZGlzYWJsZWQgZmllbGRzZXRzXFxuXFx0XFx0XFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZWwgKS5kaXNhYmxlZCA9IHRydWU7XFxuXFx0XFx0XFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKFxcXCI6ZGlzYWJsZWRcXFwiKS5sZW5ndGggIT09IDIgKSB7XFxuXFx0XFx0XFx0XFx0cmJ1Z2d5UVNBLnB1c2goIFxcXCI6ZW5hYmxlZFxcXCIsIFxcXCI6ZGlzYWJsZWRcXFwiICk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIE9wZXJhIDEwLTExIGRvZXMgbm90IHRocm93IG9uIHBvc3QtY29tbWEgaW52YWxpZCBwc2V1ZG9zXFxuXFx0XFx0XFx0ZWwucXVlcnlTZWxlY3RvckFsbChcXFwiKiw6eFxcXCIpO1xcblxcdFxcdFxcdHJidWdneVFTQS5wdXNoKFxcXCIsLio6XFxcIik7XFxuXFx0XFx0fSk7XFxuXFx0fVxcblxcblxcdGlmICggKHN1cHBvcnQubWF0Y2hlc1NlbGVjdG9yID0gcm5hdGl2ZS50ZXN0KCAobWF0Y2hlcyA9IGRvY0VsZW0ubWF0Y2hlcyB8fFxcblxcdFxcdGRvY0VsZW0ud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8XFxuXFx0XFx0ZG9jRWxlbS5tb3pNYXRjaGVzU2VsZWN0b3IgfHxcXG5cXHRcXHRkb2NFbGVtLm9NYXRjaGVzU2VsZWN0b3IgfHxcXG5cXHRcXHRkb2NFbGVtLm1zTWF0Y2hlc1NlbGVjdG9yKSApKSApIHtcXG5cXG5cXHRcXHRhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xcblxcdFxcdFxcdC8vIENoZWNrIHRvIHNlZSBpZiBpdCdzIHBvc3NpYmxlIHRvIGRvIG1hdGNoZXNTZWxlY3RvclxcblxcdFxcdFxcdC8vIG9uIGEgZGlzY29ubmVjdGVkIG5vZGUgKElFIDkpXFxuXFx0XFx0XFx0c3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCA9IG1hdGNoZXMuY2FsbCggZWwsIFxcXCIqXFxcIiApO1xcblxcblxcdFxcdFxcdC8vIFRoaXMgc2hvdWxkIGZhaWwgd2l0aCBhbiBleGNlcHRpb25cXG5cXHRcXHRcXHQvLyBHZWNrbyBkb2VzIG5vdCBlcnJvciwgcmV0dXJucyBmYWxzZSBpbnN0ZWFkXFxuXFx0XFx0XFx0bWF0Y2hlcy5jYWxsKCBlbCwgXFxcIltzIT0nJ106eFxcXCIgKTtcXG5cXHRcXHRcXHRyYnVnZ3lNYXRjaGVzLnB1c2goIFxcXCIhPVxcXCIsIHBzZXVkb3MgKTtcXG5cXHRcXHR9KTtcXG5cXHR9XFxuXFxuXFx0cmJ1Z2d5UVNBID0gcmJ1Z2d5UVNBLmxlbmd0aCAmJiBuZXcgUmVnRXhwKCByYnVnZ3lRU0Euam9pbihcXFwifFxcXCIpICk7XFxuXFx0cmJ1Z2d5TWF0Y2hlcyA9IHJidWdneU1hdGNoZXMubGVuZ3RoICYmIG5ldyBSZWdFeHAoIHJidWdneU1hdGNoZXMuam9pbihcXFwifFxcXCIpICk7XFxuXFxuXFx0LyogQ29udGFpbnNcXG5cXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXFxuXFx0aGFzQ29tcGFyZSA9IHJuYXRpdmUudGVzdCggZG9jRWxlbS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiApO1xcblxcblxcdC8vIEVsZW1lbnQgY29udGFpbnMgYW5vdGhlclxcblxcdC8vIFB1cnBvc2VmdWxseSBzZWxmLWV4Y2x1c2l2ZVxcblxcdC8vIEFzIGluLCBhbiBlbGVtZW50IGRvZXMgbm90IGNvbnRhaW4gaXRzZWxmXFxuXFx0Y29udGFpbnMgPSBoYXNDb21wYXJlIHx8IHJuYXRpdmUudGVzdCggZG9jRWxlbS5jb250YWlucyApID9cXG5cXHRcXHRmdW5jdGlvbiggYSwgYiApIHtcXG5cXHRcXHRcXHR2YXIgYWRvd24gPSBhLm5vZGVUeXBlID09PSA5ID8gYS5kb2N1bWVudEVsZW1lbnQgOiBhLFxcblxcdFxcdFxcdFxcdGJ1cCA9IGIgJiYgYi5wYXJlbnROb2RlO1xcblxcdFxcdFxcdHJldHVybiBhID09PSBidXAgfHwgISEoIGJ1cCAmJiBidXAubm9kZVR5cGUgPT09IDEgJiYgKFxcblxcdFxcdFxcdFxcdGFkb3duLmNvbnRhaW5zID9cXG5cXHRcXHRcXHRcXHRcXHRhZG93bi5jb250YWlucyggYnVwICkgOlxcblxcdFxcdFxcdFxcdFxcdGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gJiYgYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYnVwICkgJiAxNlxcblxcdFxcdFxcdCkpO1xcblxcdFxcdH0gOlxcblxcdFxcdGZ1bmN0aW9uKCBhLCBiICkge1xcblxcdFxcdFxcdGlmICggYiApIHtcXG5cXHRcXHRcXHRcXHR3aGlsZSAoIChiID0gYi5wYXJlbnROb2RlKSApIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGIgPT09IGEgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRydWU7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdH07XFxuXFxuXFx0LyogU29ydGluZ1xcblxcdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cXG5cXG5cXHQvLyBEb2N1bWVudCBvcmRlciBzb3J0aW5nXFxuXFx0c29ydE9yZGVyID0gaGFzQ29tcGFyZSA/XFxuXFx0ZnVuY3Rpb24oIGEsIGIgKSB7XFxuXFxuXFx0XFx0Ly8gRmxhZyBmb3IgZHVwbGljYXRlIHJlbW92YWxcXG5cXHRcXHRpZiAoIGEgPT09IGIgKSB7XFxuXFx0XFx0XFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcXG5cXHRcXHRcXHRyZXR1cm4gMDtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gU29ydCBvbiBtZXRob2QgZXhpc3RlbmNlIGlmIG9ubHkgb25lIGlucHV0IGhhcyBjb21wYXJlRG9jdW1lbnRQb3NpdGlvblxcblxcdFxcdHZhciBjb21wYXJlID0gIWEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gLSAhYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbjtcXG5cXHRcXHRpZiAoIGNvbXBhcmUgKSB7XFxuXFx0XFx0XFx0cmV0dXJuIGNvbXBhcmU7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIENhbGN1bGF0ZSBwb3NpdGlvbiBpZiBib3RoIGlucHV0cyBiZWxvbmcgdG8gdGhlIHNhbWUgZG9jdW1lbnRcXG5cXHRcXHRjb21wYXJlID0gKCBhLm93bmVyRG9jdW1lbnQgfHwgYSApID09PSAoIGIub3duZXJEb2N1bWVudCB8fCBiICkgP1xcblxcdFxcdFxcdGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGIgKSA6XFxuXFxuXFx0XFx0XFx0Ly8gT3RoZXJ3aXNlIHdlIGtub3cgdGhleSBhcmUgZGlzY29ubmVjdGVkXFxuXFx0XFx0XFx0MTtcXG5cXG5cXHRcXHQvLyBEaXNjb25uZWN0ZWQgbm9kZXNcXG5cXHRcXHRpZiAoIGNvbXBhcmUgJiAxIHx8XFxuXFx0XFx0XFx0KCFzdXBwb3J0LnNvcnREZXRhY2hlZCAmJiBiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBhICkgPT09IGNvbXBhcmUpICkge1xcblxcblxcdFxcdFxcdC8vIENob29zZSB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IGlzIHJlbGF0ZWQgdG8gb3VyIHByZWZlcnJlZCBkb2N1bWVudFxcblxcdFxcdFxcdGlmICggYSA9PT0gZG9jdW1lbnQgfHwgYS5vd25lckRvY3VtZW50ID09PSBwcmVmZXJyZWREb2MgJiYgY29udGFpbnMocHJlZmVycmVkRG9jLCBhKSApIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gLTE7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmICggYiA9PT0gZG9jdW1lbnQgfHwgYi5vd25lckRvY3VtZW50ID09PSBwcmVmZXJyZWREb2MgJiYgY29udGFpbnMocHJlZmVycmVkRG9jLCBiKSApIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gMTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gTWFpbnRhaW4gb3JpZ2luYWwgb3JkZXJcXG5cXHRcXHRcXHRyZXR1cm4gc29ydElucHV0ID9cXG5cXHRcXHRcXHRcXHQoIGluZGV4T2YoIHNvcnRJbnB1dCwgYSApIC0gaW5kZXhPZiggc29ydElucHV0LCBiICkgKSA6XFxuXFx0XFx0XFx0XFx0MDtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIGNvbXBhcmUgJiA0ID8gLTEgOiAxO1xcblxcdH0gOlxcblxcdGZ1bmN0aW9uKCBhLCBiICkge1xcblxcdFxcdC8vIEV4aXQgZWFybHkgaWYgdGhlIG5vZGVzIGFyZSBpZGVudGljYWxcXG5cXHRcXHRpZiAoIGEgPT09IGIgKSB7XFxuXFx0XFx0XFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcXG5cXHRcXHRcXHRyZXR1cm4gMDtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0dmFyIGN1cixcXG5cXHRcXHRcXHRpID0gMCxcXG5cXHRcXHRcXHRhdXAgPSBhLnBhcmVudE5vZGUsXFxuXFx0XFx0XFx0YnVwID0gYi5wYXJlbnROb2RlLFxcblxcdFxcdFxcdGFwID0gWyBhIF0sXFxuXFx0XFx0XFx0YnAgPSBbIGIgXTtcXG5cXG5cXHRcXHQvLyBQYXJlbnRsZXNzIG5vZGVzIGFyZSBlaXRoZXIgZG9jdW1lbnRzIG9yIGRpc2Nvbm5lY3RlZFxcblxcdFxcdGlmICggIWF1cCB8fCAhYnVwICkge1xcblxcdFxcdFxcdHJldHVybiBhID09PSBkb2N1bWVudCA/IC0xIDpcXG5cXHRcXHRcXHRcXHRiID09PSBkb2N1bWVudCA/IDEgOlxcblxcdFxcdFxcdFxcdGF1cCA/IC0xIDpcXG5cXHRcXHRcXHRcXHRidXAgPyAxIDpcXG5cXHRcXHRcXHRcXHRzb3J0SW5wdXQgP1xcblxcdFxcdFxcdFxcdCggaW5kZXhPZiggc29ydElucHV0LCBhICkgLSBpbmRleE9mKCBzb3J0SW5wdXQsIGIgKSApIDpcXG5cXHRcXHRcXHRcXHQwO1xcblxcblxcdFxcdC8vIElmIHRoZSBub2RlcyBhcmUgc2libGluZ3MsIHdlIGNhbiBkbyBhIHF1aWNrIGNoZWNrXFxuXFx0XFx0fSBlbHNlIGlmICggYXVwID09PSBidXAgKSB7XFxuXFx0XFx0XFx0cmV0dXJuIHNpYmxpbmdDaGVjayggYSwgYiApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBPdGhlcndpc2Ugd2UgbmVlZCBmdWxsIGxpc3RzIG9mIHRoZWlyIGFuY2VzdG9ycyBmb3IgY29tcGFyaXNvblxcblxcdFxcdGN1ciA9IGE7XFxuXFx0XFx0d2hpbGUgKCAoY3VyID0gY3VyLnBhcmVudE5vZGUpICkge1xcblxcdFxcdFxcdGFwLnVuc2hpZnQoIGN1ciApO1xcblxcdFxcdH1cXG5cXHRcXHRjdXIgPSBiO1xcblxcdFxcdHdoaWxlICggKGN1ciA9IGN1ci5wYXJlbnROb2RlKSApIHtcXG5cXHRcXHRcXHRicC51bnNoaWZ0KCBjdXIgKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gV2FsayBkb3duIHRoZSB0cmVlIGxvb2tpbmcgZm9yIGEgZGlzY3JlcGFuY3lcXG5cXHRcXHR3aGlsZSAoIGFwW2ldID09PSBicFtpXSApIHtcXG5cXHRcXHRcXHRpKys7XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiBpID9cXG5cXHRcXHRcXHQvLyBEbyBhIHNpYmxpbmcgY2hlY2sgaWYgdGhlIG5vZGVzIGhhdmUgYSBjb21tb24gYW5jZXN0b3JcXG5cXHRcXHRcXHRzaWJsaW5nQ2hlY2soIGFwW2ldLCBicFtpXSApIDpcXG5cXG5cXHRcXHRcXHQvLyBPdGhlcndpc2Ugbm9kZXMgaW4gb3VyIGRvY3VtZW50IHNvcnQgZmlyc3RcXG5cXHRcXHRcXHRhcFtpXSA9PT0gcHJlZmVycmVkRG9jID8gLTEgOlxcblxcdFxcdFxcdGJwW2ldID09PSBwcmVmZXJyZWREb2MgPyAxIDpcXG5cXHRcXHRcXHQwO1xcblxcdH07XFxuXFxuXFx0cmV0dXJuIGRvY3VtZW50O1xcbn07XFxuXFxuU2l6emxlLm1hdGNoZXMgPSBmdW5jdGlvbiggZXhwciwgZWxlbWVudHMgKSB7XFxuXFx0cmV0dXJuIFNpenpsZSggZXhwciwgbnVsbCwgbnVsbCwgZWxlbWVudHMgKTtcXG59O1xcblxcblNpenpsZS5tYXRjaGVzU2VsZWN0b3IgPSBmdW5jdGlvbiggZWxlbSwgZXhwciApIHtcXG5cXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcXG5cXHRpZiAoICggZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0gKSAhPT0gZG9jdW1lbnQgKSB7XFxuXFx0XFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcXG5cXHR9XFxuXFxuXFx0Ly8gTWFrZSBzdXJlIHRoYXQgYXR0cmlidXRlIHNlbGVjdG9ycyBhcmUgcXVvdGVkXFxuXFx0ZXhwciA9IGV4cHIucmVwbGFjZSggcmF0dHJpYnV0ZVF1b3RlcywgXFxcIj0nJDEnXVxcXCIgKTtcXG5cXG5cXHRpZiAoIHN1cHBvcnQubWF0Y2hlc1NlbGVjdG9yICYmIGRvY3VtZW50SXNIVE1MICYmXFxuXFx0XFx0IWNvbXBpbGVyQ2FjaGVbIGV4cHIgKyBcXFwiIFxcXCIgXSAmJlxcblxcdFxcdCggIXJidWdneU1hdGNoZXMgfHwgIXJidWdneU1hdGNoZXMudGVzdCggZXhwciApICkgJiZcXG5cXHRcXHQoICFyYnVnZ3lRU0EgICAgIHx8ICFyYnVnZ3lRU0EudGVzdCggZXhwciApICkgKSB7XFxuXFxuXFx0XFx0dHJ5IHtcXG5cXHRcXHRcXHR2YXIgcmV0ID0gbWF0Y2hlcy5jYWxsKCBlbGVtLCBleHByICk7XFxuXFxuXFx0XFx0XFx0Ly8gSUUgOSdzIG1hdGNoZXNTZWxlY3RvciByZXR1cm5zIGZhbHNlIG9uIGRpc2Nvbm5lY3RlZCBub2Rlc1xcblxcdFxcdFxcdGlmICggcmV0IHx8IHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggfHxcXG5cXHRcXHRcXHRcXHRcXHQvLyBBcyB3ZWxsLCBkaXNjb25uZWN0ZWQgbm9kZXMgYXJlIHNhaWQgdG8gYmUgaW4gYSBkb2N1bWVudFxcblxcdFxcdFxcdFxcdFxcdC8vIGZyYWdtZW50IGluIElFIDlcXG5cXHRcXHRcXHRcXHRcXHRlbGVtLmRvY3VtZW50ICYmIGVsZW0uZG9jdW1lbnQubm9kZVR5cGUgIT09IDExICkge1xcblxcdFxcdFxcdFxcdHJldHVybiByZXQ7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0gY2F0Y2ggKGUpIHt9XFxuXFx0fVxcblxcblxcdHJldHVybiBTaXp6bGUoIGV4cHIsIGRvY3VtZW50LCBudWxsLCBbIGVsZW0gXSApLmxlbmd0aCA+IDA7XFxufTtcXG5cXG5TaXp6bGUuY29udGFpbnMgPSBmdW5jdGlvbiggY29udGV4dCwgZWxlbSApIHtcXG5cXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcXG5cXHRpZiAoICggY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgKSAhPT0gZG9jdW1lbnQgKSB7XFxuXFx0XFx0c2V0RG9jdW1lbnQoIGNvbnRleHQgKTtcXG5cXHR9XFxuXFx0cmV0dXJuIGNvbnRhaW5zKCBjb250ZXh0LCBlbGVtICk7XFxufTtcXG5cXG5TaXp6bGUuYXR0ciA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xcblxcdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxcblxcdGlmICggKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSApICE9PSBkb2N1bWVudCApIHtcXG5cXHRcXHRzZXREb2N1bWVudCggZWxlbSApO1xcblxcdH1cXG5cXG5cXHR2YXIgZm4gPSBFeHByLmF0dHJIYW5kbGVbIG5hbWUudG9Mb3dlckNhc2UoKSBdLFxcblxcdFxcdC8vIERvbid0IGdldCBmb29sZWQgYnkgT2JqZWN0LnByb3RvdHlwZSBwcm9wZXJ0aWVzIChqUXVlcnkgIzEzODA3KVxcblxcdFxcdHZhbCA9IGZuICYmIGhhc093bi5jYWxsKCBFeHByLmF0dHJIYW5kbGUsIG5hbWUudG9Mb3dlckNhc2UoKSApID9cXG5cXHRcXHRcXHRmbiggZWxlbSwgbmFtZSwgIWRvY3VtZW50SXNIVE1MICkgOlxcblxcdFxcdFxcdHVuZGVmaW5lZDtcXG5cXG5cXHRyZXR1cm4gdmFsICE9PSB1bmRlZmluZWQgP1xcblxcdFxcdHZhbCA6XFxuXFx0XFx0c3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFkb2N1bWVudElzSFRNTCA/XFxuXFx0XFx0XFx0ZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUgKSA6XFxuXFx0XFx0XFx0KHZhbCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZShuYW1lKSkgJiYgdmFsLnNwZWNpZmllZCA/XFxuXFx0XFx0XFx0XFx0dmFsLnZhbHVlIDpcXG5cXHRcXHRcXHRcXHRudWxsO1xcbn07XFxuXFxuU2l6emxlLmVzY2FwZSA9IGZ1bmN0aW9uKCBzZWwgKSB7XFxuXFx0cmV0dXJuIChzZWwgKyBcXFwiXFxcIikucmVwbGFjZSggcmNzc2VzY2FwZSwgZmNzc2VzY2FwZSApO1xcbn07XFxuXFxuU2l6emxlLmVycm9yID0gZnVuY3Rpb24oIG1zZyApIHtcXG5cXHR0aHJvdyBuZXcgRXJyb3IoIFxcXCJTeW50YXggZXJyb3IsIHVucmVjb2duaXplZCBleHByZXNzaW9uOiBcXFwiICsgbXNnICk7XFxufTtcXG5cXG4vKipcXG4gKiBEb2N1bWVudCBzb3J0aW5nIGFuZCByZW1vdmluZyBkdXBsaWNhdGVzXFxuICogQHBhcmFtIHtBcnJheUxpa2V9IHJlc3VsdHNcXG4gKi9cXG5TaXp6bGUudW5pcXVlU29ydCA9IGZ1bmN0aW9uKCByZXN1bHRzICkge1xcblxcdHZhciBlbGVtLFxcblxcdFxcdGR1cGxpY2F0ZXMgPSBbXSxcXG5cXHRcXHRqID0gMCxcXG5cXHRcXHRpID0gMDtcXG5cXG5cXHQvLyBVbmxlc3Mgd2UgKmtub3cqIHdlIGNhbiBkZXRlY3QgZHVwbGljYXRlcywgYXNzdW1lIHRoZWlyIHByZXNlbmNlXFxuXFx0aGFzRHVwbGljYXRlID0gIXN1cHBvcnQuZGV0ZWN0RHVwbGljYXRlcztcXG5cXHRzb3J0SW5wdXQgPSAhc3VwcG9ydC5zb3J0U3RhYmxlICYmIHJlc3VsdHMuc2xpY2UoIDAgKTtcXG5cXHRyZXN1bHRzLnNvcnQoIHNvcnRPcmRlciApO1xcblxcblxcdGlmICggaGFzRHVwbGljYXRlICkge1xcblxcdFxcdHdoaWxlICggKGVsZW0gPSByZXN1bHRzW2krK10pICkge1xcblxcdFxcdFxcdGlmICggZWxlbSA9PT0gcmVzdWx0c1sgaSBdICkge1xcblxcdFxcdFxcdFxcdGogPSBkdXBsaWNhdGVzLnB1c2goIGkgKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdFxcdHdoaWxlICggai0tICkge1xcblxcdFxcdFxcdHJlc3VsdHMuc3BsaWNlKCBkdXBsaWNhdGVzWyBqIF0sIDEgKTtcXG5cXHRcXHR9XFxuXFx0fVxcblxcblxcdC8vIENsZWFyIGlucHV0IGFmdGVyIHNvcnRpbmcgdG8gcmVsZWFzZSBvYmplY3RzXFxuXFx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvc2l6emxlL3B1bGwvMjI1XFxuXFx0c29ydElucHV0ID0gbnVsbDtcXG5cXG5cXHRyZXR1cm4gcmVzdWx0cztcXG59O1xcblxcbi8qKlxcbiAqIFV0aWxpdHkgZnVuY3Rpb24gZm9yIHJldHJpZXZpbmcgdGhlIHRleHQgdmFsdWUgb2YgYW4gYXJyYXkgb2YgRE9NIG5vZGVzXFxuICogQHBhcmFtIHtBcnJheXxFbGVtZW50fSBlbGVtXFxuICovXFxuZ2V0VGV4dCA9IFNpenpsZS5nZXRUZXh0ID0gZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0dmFyIG5vZGUsXFxuXFx0XFx0cmV0ID0gXFxcIlxcXCIsXFxuXFx0XFx0aSA9IDAsXFxuXFx0XFx0bm9kZVR5cGUgPSBlbGVtLm5vZGVUeXBlO1xcblxcblxcdGlmICggIW5vZGVUeXBlICkge1xcblxcdFxcdC8vIElmIG5vIG5vZGVUeXBlLCB0aGlzIGlzIGV4cGVjdGVkIHRvIGJlIGFuIGFycmF5XFxuXFx0XFx0d2hpbGUgKCAobm9kZSA9IGVsZW1baSsrXSkgKSB7XFxuXFx0XFx0XFx0Ly8gRG8gbm90IHRyYXZlcnNlIGNvbW1lbnQgbm9kZXNcXG5cXHRcXHRcXHRyZXQgKz0gZ2V0VGV4dCggbm9kZSApO1xcblxcdFxcdH1cXG5cXHR9IGVsc2UgaWYgKCBub2RlVHlwZSA9PT0gMSB8fCBub2RlVHlwZSA9PT0gOSB8fCBub2RlVHlwZSA9PT0gMTEgKSB7XFxuXFx0XFx0Ly8gVXNlIHRleHRDb250ZW50IGZvciBlbGVtZW50c1xcblxcdFxcdC8vIGlubmVyVGV4dCB1c2FnZSByZW1vdmVkIGZvciBjb25zaXN0ZW5jeSBvZiBuZXcgbGluZXMgKGpRdWVyeSAjMTExNTMpXFxuXFx0XFx0aWYgKCB0eXBlb2YgZWxlbS50ZXh0Q29udGVudCA9PT0gXFxcInN0cmluZ1xcXCIgKSB7XFxuXFx0XFx0XFx0cmV0dXJuIGVsZW0udGV4dENvbnRlbnQ7XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHQvLyBUcmF2ZXJzZSBpdHMgY2hpbGRyZW5cXG5cXHRcXHRcXHRmb3IgKCBlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZyApIHtcXG5cXHRcXHRcXHRcXHRyZXQgKz0gZ2V0VGV4dCggZWxlbSApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fSBlbHNlIGlmICggbm9kZVR5cGUgPT09IDMgfHwgbm9kZVR5cGUgPT09IDQgKSB7XFxuXFx0XFx0cmV0dXJuIGVsZW0ubm9kZVZhbHVlO1xcblxcdH1cXG5cXHQvLyBEbyBub3QgaW5jbHVkZSBjb21tZW50IG9yIHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb24gbm9kZXNcXG5cXG5cXHRyZXR1cm4gcmV0O1xcbn07XFxuXFxuRXhwciA9IFNpenpsZS5zZWxlY3RvcnMgPSB7XFxuXFxuXFx0Ly8gQ2FuIGJlIGFkanVzdGVkIGJ5IHRoZSB1c2VyXFxuXFx0Y2FjaGVMZW5ndGg6IDUwLFxcblxcblxcdGNyZWF0ZVBzZXVkbzogbWFya0Z1bmN0aW9uLFxcblxcblxcdG1hdGNoOiBtYXRjaEV4cHIsXFxuXFxuXFx0YXR0ckhhbmRsZToge30sXFxuXFxuXFx0ZmluZDoge30sXFxuXFxuXFx0cmVsYXRpdmU6IHtcXG5cXHRcXHRcXFwiPlxcXCI6IHsgZGlyOiBcXFwicGFyZW50Tm9kZVxcXCIsIGZpcnN0OiB0cnVlIH0sXFxuXFx0XFx0XFxcIiBcXFwiOiB7IGRpcjogXFxcInBhcmVudE5vZGVcXFwiIH0sXFxuXFx0XFx0XFxcIitcXFwiOiB7IGRpcjogXFxcInByZXZpb3VzU2libGluZ1xcXCIsIGZpcnN0OiB0cnVlIH0sXFxuXFx0XFx0XFxcIn5cXFwiOiB7IGRpcjogXFxcInByZXZpb3VzU2libGluZ1xcXCIgfVxcblxcdH0sXFxuXFxuXFx0cHJlRmlsdGVyOiB7XFxuXFx0XFx0XFxcIkFUVFJcXFwiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XFxuXFx0XFx0XFx0bWF0Y2hbMV0gPSBtYXRjaFsxXS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xcblxcblxcdFxcdFxcdC8vIE1vdmUgdGhlIGdpdmVuIHZhbHVlIHRvIG1hdGNoWzNdIHdoZXRoZXIgcXVvdGVkIG9yIHVucXVvdGVkXFxuXFx0XFx0XFx0bWF0Y2hbM10gPSAoIG1hdGNoWzNdIHx8IG1hdGNoWzRdIHx8IG1hdGNoWzVdIHx8IFxcXCJcXFwiICkucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcXG5cXG5cXHRcXHRcXHRpZiAoIG1hdGNoWzJdID09PSBcXFwifj1cXFwiICkge1xcblxcdFxcdFxcdFxcdG1hdGNoWzNdID0gXFxcIiBcXFwiICsgbWF0Y2hbM10gKyBcXFwiIFxcXCI7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBtYXRjaC5zbGljZSggMCwgNCApO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0XFxcIkNISUxEXFxcIjogZnVuY3Rpb24oIG1hdGNoICkge1xcblxcdFxcdFxcdC8qIG1hdGNoZXMgZnJvbSBtYXRjaEV4cHJbXFxcIkNISUxEXFxcIl1cXG5cXHRcXHRcXHRcXHQxIHR5cGUgKG9ubHl8bnRofC4uLilcXG5cXHRcXHRcXHRcXHQyIHdoYXQgKGNoaWxkfG9mLXR5cGUpXFxuXFx0XFx0XFx0XFx0MyBhcmd1bWVudCAoZXZlbnxvZGR8XFxcXGQqfFxcXFxkKm4oWystXVxcXFxkKyk/fC4uLilcXG5cXHRcXHRcXHRcXHQ0IHhuLWNvbXBvbmVudCBvZiB4bit5IGFyZ3VtZW50IChbKy1dP1xcXFxkKm58KVxcblxcdFxcdFxcdFxcdDUgc2lnbiBvZiB4bi1jb21wb25lbnRcXG5cXHRcXHRcXHRcXHQ2IHggb2YgeG4tY29tcG9uZW50XFxuXFx0XFx0XFx0XFx0NyBzaWduIG9mIHktY29tcG9uZW50XFxuXFx0XFx0XFx0XFx0OCB5IG9mIHktY29tcG9uZW50XFxuXFx0XFx0XFx0Ki9cXG5cXHRcXHRcXHRtYXRjaFsxXSA9IG1hdGNoWzFdLnRvTG93ZXJDYXNlKCk7XFxuXFxuXFx0XFx0XFx0aWYgKCBtYXRjaFsxXS5zbGljZSggMCwgMyApID09PSBcXFwibnRoXFxcIiApIHtcXG5cXHRcXHRcXHRcXHQvLyBudGgtKiByZXF1aXJlcyBhcmd1bWVudFxcblxcdFxcdFxcdFxcdGlmICggIW1hdGNoWzNdICkge1xcblxcdFxcdFxcdFxcdFxcdFNpenpsZS5lcnJvciggbWF0Y2hbMF0gKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gbnVtZXJpYyB4IGFuZCB5IHBhcmFtZXRlcnMgZm9yIEV4cHIuZmlsdGVyLkNISUxEXFxuXFx0XFx0XFx0XFx0Ly8gcmVtZW1iZXIgdGhhdCBmYWxzZS90cnVlIGNhc3QgcmVzcGVjdGl2ZWx5IHRvIDAvMVxcblxcdFxcdFxcdFxcdG1hdGNoWzRdID0gKyggbWF0Y2hbNF0gPyBtYXRjaFs1XSArIChtYXRjaFs2XSB8fCAxKSA6IDIgKiAoIG1hdGNoWzNdID09PSBcXFwiZXZlblxcXCIgfHwgbWF0Y2hbM10gPT09IFxcXCJvZGRcXFwiICkgKTtcXG5cXHRcXHRcXHRcXHRtYXRjaFs1XSA9ICsoICggbWF0Y2hbN10gKyBtYXRjaFs4XSApIHx8IG1hdGNoWzNdID09PSBcXFwib2RkXFxcIiApO1xcblxcblxcdFxcdFxcdC8vIG90aGVyIHR5cGVzIHByb2hpYml0IGFyZ3VtZW50c1xcblxcdFxcdFxcdH0gZWxzZSBpZiAoIG1hdGNoWzNdICkge1xcblxcdFxcdFxcdFxcdFNpenpsZS5lcnJvciggbWF0Y2hbMF0gKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIG1hdGNoO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0XFxcIlBTRVVET1xcXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcXG5cXHRcXHRcXHR2YXIgZXhjZXNzLFxcblxcdFxcdFxcdFxcdHVucXVvdGVkID0gIW1hdGNoWzZdICYmIG1hdGNoWzJdO1xcblxcblxcdFxcdFxcdGlmICggbWF0Y2hFeHByW1xcXCJDSElMRFxcXCJdLnRlc3QoIG1hdGNoWzBdICkgKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIG51bGw7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIEFjY2VwdCBxdW90ZWQgYXJndW1lbnRzIGFzLWlzXFxuXFx0XFx0XFx0aWYgKCBtYXRjaFszXSApIHtcXG5cXHRcXHRcXHRcXHRtYXRjaFsyXSA9IG1hdGNoWzRdIHx8IG1hdGNoWzVdIHx8IFxcXCJcXFwiO1xcblxcblxcdFxcdFxcdC8vIFN0cmlwIGV4Y2VzcyBjaGFyYWN0ZXJzIGZyb20gdW5xdW90ZWQgYXJndW1lbnRzXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggdW5xdW90ZWQgJiYgcnBzZXVkby50ZXN0KCB1bnF1b3RlZCApICYmXFxuXFx0XFx0XFx0XFx0Ly8gR2V0IGV4Y2VzcyBmcm9tIHRva2VuaXplIChyZWN1cnNpdmVseSlcXG5cXHRcXHRcXHRcXHQoZXhjZXNzID0gdG9rZW5pemUoIHVucXVvdGVkLCB0cnVlICkpICYmXFxuXFx0XFx0XFx0XFx0Ly8gYWR2YW5jZSB0byB0aGUgbmV4dCBjbG9zaW5nIHBhcmVudGhlc2lzXFxuXFx0XFx0XFx0XFx0KGV4Y2VzcyA9IHVucXVvdGVkLmluZGV4T2YoIFxcXCIpXFxcIiwgdW5xdW90ZWQubGVuZ3RoIC0gZXhjZXNzICkgLSB1bnF1b3RlZC5sZW5ndGgpICkge1xcblxcblxcdFxcdFxcdFxcdC8vIGV4Y2VzcyBpcyBhIG5lZ2F0aXZlIGluZGV4XFxuXFx0XFx0XFx0XFx0bWF0Y2hbMF0gPSBtYXRjaFswXS5zbGljZSggMCwgZXhjZXNzICk7XFxuXFx0XFx0XFx0XFx0bWF0Y2hbMl0gPSB1bnF1b3RlZC5zbGljZSggMCwgZXhjZXNzICk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIFJldHVybiBvbmx5IGNhcHR1cmVzIG5lZWRlZCBieSB0aGUgcHNldWRvIGZpbHRlciBtZXRob2QgKHR5cGUgYW5kIGFyZ3VtZW50KVxcblxcdFxcdFxcdHJldHVybiBtYXRjaC5zbGljZSggMCwgMyApO1xcblxcdFxcdH1cXG5cXHR9LFxcblxcblxcdGZpbHRlcjoge1xcblxcblxcdFxcdFxcXCJUQUdcXFwiOiBmdW5jdGlvbiggbm9kZU5hbWVTZWxlY3RvciApIHtcXG5cXHRcXHRcXHR2YXIgbm9kZU5hbWUgPSBub2RlTmFtZVNlbGVjdG9yLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICkudG9Mb3dlckNhc2UoKTtcXG5cXHRcXHRcXHRyZXR1cm4gbm9kZU5hbWVTZWxlY3RvciA9PT0gXFxcIipcXFwiID9cXG5cXHRcXHRcXHRcXHRmdW5jdGlvbigpIHsgcmV0dXJuIHRydWU7IH0gOlxcblxcdFxcdFxcdFxcdGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbm9kZU5hbWU7XFxuXFx0XFx0XFx0XFx0fTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdFxcXCJDTEFTU1xcXCI6IGZ1bmN0aW9uKCBjbGFzc05hbWUgKSB7XFxuXFx0XFx0XFx0dmFyIHBhdHRlcm4gPSBjbGFzc0NhY2hlWyBjbGFzc05hbWUgKyBcXFwiIFxcXCIgXTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gcGF0dGVybiB8fFxcblxcdFxcdFxcdFxcdChwYXR0ZXJuID0gbmV3IFJlZ0V4cCggXFxcIihefFxcXCIgKyB3aGl0ZXNwYWNlICsgXFxcIilcXFwiICsgY2xhc3NOYW1lICsgXFxcIihcXFwiICsgd2hpdGVzcGFjZSArIFxcXCJ8JClcXFwiICkpICYmXFxuXFx0XFx0XFx0XFx0Y2xhc3NDYWNoZSggY2xhc3NOYW1lLCBmdW5jdGlvbiggZWxlbSApIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gcGF0dGVybi50ZXN0KCB0eXBlb2YgZWxlbS5jbGFzc05hbWUgPT09IFxcXCJzdHJpbmdcXFwiICYmIGVsZW0uY2xhc3NOYW1lIHx8IHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZSAhPT0gXFxcInVuZGVmaW5lZFxcXCIgJiYgZWxlbS5nZXRBdHRyaWJ1dGUoXFxcImNsYXNzXFxcIikgfHwgXFxcIlxcXCIgKTtcXG5cXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdFxcXCJBVFRSXFxcIjogZnVuY3Rpb24oIG5hbWUsIG9wZXJhdG9yLCBjaGVjayApIHtcXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0XFx0XFx0XFx0dmFyIHJlc3VsdCA9IFNpenpsZS5hdHRyKCBlbGVtLCBuYW1lICk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCByZXN1bHQgPT0gbnVsbCApIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gb3BlcmF0b3IgPT09IFxcXCIhPVxcXCI7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGlmICggIW9wZXJhdG9yICkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRyZXN1bHQgKz0gXFxcIlxcXCI7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIG9wZXJhdG9yID09PSBcXFwiPVxcXCIgPyByZXN1bHQgPT09IGNoZWNrIDpcXG5cXHRcXHRcXHRcXHRcXHRvcGVyYXRvciA9PT0gXFxcIiE9XFxcIiA/IHJlc3VsdCAhPT0gY2hlY2sgOlxcblxcdFxcdFxcdFxcdFxcdG9wZXJhdG9yID09PSBcXFwiXj1cXFwiID8gY2hlY2sgJiYgcmVzdWx0LmluZGV4T2YoIGNoZWNrICkgPT09IDAgOlxcblxcdFxcdFxcdFxcdFxcdG9wZXJhdG9yID09PSBcXFwiKj1cXFwiID8gY2hlY2sgJiYgcmVzdWx0LmluZGV4T2YoIGNoZWNrICkgPiAtMSA6XFxuXFx0XFx0XFx0XFx0XFx0b3BlcmF0b3IgPT09IFxcXCIkPVxcXCIgPyBjaGVjayAmJiByZXN1bHQuc2xpY2UoIC1jaGVjay5sZW5ndGggKSA9PT0gY2hlY2sgOlxcblxcdFxcdFxcdFxcdFxcdG9wZXJhdG9yID09PSBcXFwifj1cXFwiID8gKCBcXFwiIFxcXCIgKyByZXN1bHQucmVwbGFjZSggcndoaXRlc3BhY2UsIFxcXCIgXFxcIiApICsgXFxcIiBcXFwiICkuaW5kZXhPZiggY2hlY2sgKSA+IC0xIDpcXG5cXHRcXHRcXHRcXHRcXHRvcGVyYXRvciA9PT0gXFxcInw9XFxcIiA/IHJlc3VsdCA9PT0gY2hlY2sgfHwgcmVzdWx0LnNsaWNlKCAwLCBjaGVjay5sZW5ndGggKyAxICkgPT09IGNoZWNrICsgXFxcIi1cXFwiIDpcXG5cXHRcXHRcXHRcXHRcXHRmYWxzZTtcXG5cXHRcXHRcXHR9O1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0XFxcIkNISUxEXFxcIjogZnVuY3Rpb24oIHR5cGUsIHdoYXQsIGFyZ3VtZW50LCBmaXJzdCwgbGFzdCApIHtcXG5cXHRcXHRcXHR2YXIgc2ltcGxlID0gdHlwZS5zbGljZSggMCwgMyApICE9PSBcXFwibnRoXFxcIixcXG5cXHRcXHRcXHRcXHRmb3J3YXJkID0gdHlwZS5zbGljZSggLTQgKSAhPT0gXFxcImxhc3RcXFwiLFxcblxcdFxcdFxcdFxcdG9mVHlwZSA9IHdoYXQgPT09IFxcXCJvZi10eXBlXFxcIjtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gZmlyc3QgPT09IDEgJiYgbGFzdCA9PT0gMCA/XFxuXFxuXFx0XFx0XFx0XFx0Ly8gU2hvcnRjdXQgZm9yIDpudGgtKihuKVxcblxcdFxcdFxcdFxcdGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiAhIWVsZW0ucGFyZW50Tm9kZTtcXG5cXHRcXHRcXHRcXHR9IDpcXG5cXG5cXHRcXHRcXHRcXHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xcblxcdFxcdFxcdFxcdFxcdHZhciBjYWNoZSwgdW5pcXVlQ2FjaGUsIG91dGVyQ2FjaGUsIG5vZGUsIG5vZGVJbmRleCwgc3RhcnQsXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZGlyID0gc2ltcGxlICE9PSBmb3J3YXJkID8gXFxcIm5leHRTaWJsaW5nXFxcIiA6IFxcXCJwcmV2aW91c1NpYmxpbmdcXFwiLFxcblxcdFxcdFxcdFxcdFxcdFxcdHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRuYW1lID0gb2ZUeXBlICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSxcXG5cXHRcXHRcXHRcXHRcXHRcXHR1c2VDYWNoZSA9ICF4bWwgJiYgIW9mVHlwZSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRkaWZmID0gZmFsc2U7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBwYXJlbnQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gOihmaXJzdHxsYXN0fG9ubHkpLShjaGlsZHxvZi10eXBlKVxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggc2ltcGxlICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHdoaWxlICggZGlyICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG5vZGUgPSBlbGVtO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHdoaWxlICggKG5vZGUgPSBub2RlWyBkaXIgXSkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBvZlR5cGUgP1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSA6XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bm9kZS5ub2RlVHlwZSA9PT0gMSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBSZXZlcnNlIGRpcmVjdGlvbiBmb3IgOm9ubHktKiAoaWYgd2UgaGF2ZW4ndCB5ZXQgZG9uZSBzbylcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRzdGFydCA9IGRpciA9IHR5cGUgPT09IFxcXCJvbmx5XFxcIiAmJiAhc3RhcnQgJiYgXFxcIm5leHRTaWJsaW5nXFxcIjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRydWU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdHN0YXJ0ID0gWyBmb3J3YXJkID8gcGFyZW50LmZpcnN0Q2hpbGQgOiBwYXJlbnQubGFzdENoaWxkIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gbm9uLXhtbCA6bnRoLWNoaWxkKC4uLikgc3RvcmVzIGNhY2hlIGRhdGEgb24gYHBhcmVudGBcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGZvcndhcmQgJiYgdXNlQ2FjaGUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gU2VlayBgZWxlbWAgZnJvbSBhIHByZXZpb3VzbHktY2FjaGVkIGluZGV4XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gLi4uaW4gYSBnemlwLWZyaWVuZGx5IHdheVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdG5vZGUgPSBwYXJlbnQ7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0b3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fCAobm9kZVsgZXhwYW5kbyBdID0ge30pO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSB8fFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdChvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gPSB7fSk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Y2FjaGUgPSB1bmlxdWVDYWNoZVsgdHlwZSBdIHx8IFtdO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdG5vZGVJbmRleCA9IGNhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgY2FjaGVbIDEgXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRkaWZmID0gbm9kZUluZGV4ICYmIGNhY2hlWyAyIF07XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0bm9kZSA9IG5vZGVJbmRleCAmJiBwYXJlbnQuY2hpbGROb2Rlc1sgbm9kZUluZGV4IF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0d2hpbGUgKCAobm9kZSA9ICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVsgZGlyIF0gfHxcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBGYWxsYmFjayB0byBzZWVraW5nIGBlbGVtYCBmcm9tIHRoZSBzdGFydFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdChkaWZmID0gbm9kZUluZGV4ID0gMCkgfHwgc3RhcnQucG9wKCkpICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIFdoZW4gZm91bmQsIGNhY2hlIGluZGV4ZXMgb24gYHBhcmVudGAgYW5kIGJyZWFrXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBub2RlLm5vZGVUeXBlID09PSAxICYmICsrZGlmZiAmJiBub2RlID09PSBlbGVtICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHVuaXF1ZUNhY2hlWyB0eXBlIF0gPSBbIGRpcnJ1bnMsIG5vZGVJbmRleCwgZGlmZiBdO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBVc2UgcHJldmlvdXNseS1jYWNoZWQgZWxlbWVudCBpbmRleCBpZiBhdmFpbGFibGVcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIHVzZUNhY2hlICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIC4uLmluIGEgZ3ppcC1mcmllbmRseSB3YXlcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRub2RlID0gZWxlbTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8IChub2RlWyBleHBhbmRvIF0gPSB7fSk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdIHx8XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0KG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSA9IHt9KTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRjYWNoZSA9IHVuaXF1ZUNhY2hlWyB0eXBlIF0gfHwgW107XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bm9kZUluZGV4ID0gY2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBjYWNoZVsgMSBdO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRpZmYgPSBub2RlSW5kZXg7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIHhtbCA6bnRoLWNoaWxkKC4uLilcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBvciA6bnRoLWxhc3QtY2hpbGQoLi4uKSBvciA6bnRoKC1sYXN0KT8tb2YtdHlwZSguLi4pXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBkaWZmID09PSBmYWxzZSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBVc2UgdGhlIHNhbWUgbG9vcCBhcyBhYm92ZSB0byBzZWVrIGBlbGVtYCBmcm9tIHRoZSBzdGFydFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHdoaWxlICggKG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbIGRpciBdIHx8XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0KGRpZmYgPSBub2RlSW5kZXggPSAwKSB8fCBzdGFydC5wb3AoKSkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCAoIG9mVHlwZSA/XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lIDpcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRub2RlLm5vZGVUeXBlID09PSAxICkgJiZcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQrK2RpZmYgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gQ2FjaGUgdGhlIGluZGV4IG9mIGVhY2ggZW5jb3VudGVyZWQgZWxlbWVudFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggdXNlQ2FjaGUgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0b3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fCAobm9kZVsgZXhwYW5kbyBdID0ge30pO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSB8fFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdChvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gPSB7fSk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dW5pcXVlQ2FjaGVbIHR5cGUgXSA9IFsgZGlycnVucywgZGlmZiBdO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIG5vZGUgPT09IGVsZW0gKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBJbmNvcnBvcmF0ZSB0aGUgb2Zmc2V0LCB0aGVuIGNoZWNrIGFnYWluc3QgY3ljbGUgc2l6ZVxcblxcdFxcdFxcdFxcdFxcdFxcdGRpZmYgLT0gbGFzdDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gZGlmZiA9PT0gZmlyc3QgfHwgKCBkaWZmICUgZmlyc3QgPT09IDAgJiYgZGlmZiAvIGZpcnN0ID49IDAgKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdFxcXCJQU0VVRE9cXFwiOiBmdW5jdGlvbiggcHNldWRvLCBhcmd1bWVudCApIHtcXG5cXHRcXHRcXHQvLyBwc2V1ZG8tY2xhc3MgbmFtZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmVcXG5cXHRcXHRcXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI3BzZXVkby1jbGFzc2VzXFxuXFx0XFx0XFx0Ly8gUHJpb3JpdGl6ZSBieSBjYXNlIHNlbnNpdGl2aXR5IGluIGNhc2UgY3VzdG9tIHBzZXVkb3MgYXJlIGFkZGVkIHdpdGggdXBwZXJjYXNlIGxldHRlcnNcXG5cXHRcXHRcXHQvLyBSZW1lbWJlciB0aGF0IHNldEZpbHRlcnMgaW5oZXJpdHMgZnJvbSBwc2V1ZG9zXFxuXFx0XFx0XFx0dmFyIGFyZ3MsXFxuXFx0XFx0XFx0XFx0Zm4gPSBFeHByLnBzZXVkb3NbIHBzZXVkbyBdIHx8IEV4cHIuc2V0RmlsdGVyc1sgcHNldWRvLnRvTG93ZXJDYXNlKCkgXSB8fFxcblxcdFxcdFxcdFxcdFxcdFNpenpsZS5lcnJvciggXFxcInVuc3VwcG9ydGVkIHBzZXVkbzogXFxcIiArIHBzZXVkbyApO1xcblxcblxcdFxcdFxcdC8vIFRoZSB1c2VyIG1heSB1c2UgY3JlYXRlUHNldWRvIHRvIGluZGljYXRlIHRoYXRcXG5cXHRcXHRcXHQvLyBhcmd1bWVudHMgYXJlIG5lZWRlZCB0byBjcmVhdGUgdGhlIGZpbHRlciBmdW5jdGlvblxcblxcdFxcdFxcdC8vIGp1c3QgYXMgU2l6emxlIGRvZXNcXG5cXHRcXHRcXHRpZiAoIGZuWyBleHBhbmRvIF0gKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZuKCBhcmd1bWVudCApO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBCdXQgbWFpbnRhaW4gc3VwcG9ydCBmb3Igb2xkIHNpZ25hdHVyZXNcXG5cXHRcXHRcXHRpZiAoIGZuLmxlbmd0aCA+IDEgKSB7XFxuXFx0XFx0XFx0XFx0YXJncyA9IFsgcHNldWRvLCBwc2V1ZG8sIFxcXCJcXFwiLCBhcmd1bWVudCBdO1xcblxcdFxcdFxcdFxcdHJldHVybiBFeHByLnNldEZpbHRlcnMuaGFzT3duUHJvcGVydHkoIHBzZXVkby50b0xvd2VyQ2FzZSgpICkgP1xcblxcdFxcdFxcdFxcdFxcdG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcyApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgaWR4LFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdG1hdGNoZWQgPSBmbiggc2VlZCwgYXJndW1lbnQgKSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpID0gbWF0Y2hlZC5sZW5ndGg7XFxuXFx0XFx0XFx0XFx0XFx0XFx0d2hpbGUgKCBpLS0gKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWR4ID0gaW5kZXhPZiggc2VlZCwgbWF0Y2hlZFtpXSApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHNlZWRbIGlkeCBdID0gISggbWF0Y2hlc1sgaWR4IF0gPSBtYXRjaGVkW2ldICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH0pIDpcXG5cXHRcXHRcXHRcXHRcXHRmdW5jdGlvbiggZWxlbSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gZm4oIGVsZW0sIDAsIGFyZ3MgKTtcXG5cXHRcXHRcXHRcXHRcXHR9O1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gZm47XFxuXFx0XFx0fVxcblxcdH0sXFxuXFxuXFx0cHNldWRvczoge1xcblxcdFxcdC8vIFBvdGVudGlhbGx5IGNvbXBsZXggcHNldWRvc1xcblxcdFxcdFxcXCJub3RcXFwiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlbGVjdG9yICkge1xcblxcdFxcdFxcdC8vIFRyaW0gdGhlIHNlbGVjdG9yIHBhc3NlZCB0byBjb21waWxlXFxuXFx0XFx0XFx0Ly8gdG8gYXZvaWQgdHJlYXRpbmcgbGVhZGluZyBhbmQgdHJhaWxpbmdcXG5cXHRcXHRcXHQvLyBzcGFjZXMgYXMgY29tYmluYXRvcnNcXG5cXHRcXHRcXHR2YXIgaW5wdXQgPSBbXSxcXG5cXHRcXHRcXHRcXHRyZXN1bHRzID0gW10sXFxuXFx0XFx0XFx0XFx0bWF0Y2hlciA9IGNvbXBpbGUoIHNlbGVjdG9yLnJlcGxhY2UoIHJ0cmltLCBcXFwiJDFcXFwiICkgKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gbWF0Y2hlclsgZXhwYW5kbyBdID9cXG5cXHRcXHRcXHRcXHRtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMsIGNvbnRleHQsIHhtbCApIHtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgZWxlbSxcXG5cXHRcXHRcXHRcXHRcXHRcXHR1bm1hdGNoZWQgPSBtYXRjaGVyKCBzZWVkLCBudWxsLCB4bWwsIFtdICksXFxuXFx0XFx0XFx0XFx0XFx0XFx0aSA9IHNlZWQubGVuZ3RoO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIE1hdGNoIGVsZW1lbnRzIHVubWF0Y2hlZCBieSBgbWF0Y2hlcmBcXG5cXHRcXHRcXHRcXHRcXHR3aGlsZSAoIGktLSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIChlbGVtID0gdW5tYXRjaGVkW2ldKSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzZWVkW2ldID0gIShtYXRjaGVzW2ldID0gZWxlbSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9KSA6XFxuXFx0XFx0XFx0XFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcXG5cXHRcXHRcXHRcXHRcXHRpbnB1dFswXSA9IGVsZW07XFxuXFx0XFx0XFx0XFx0XFx0bWF0Y2hlciggaW5wdXQsIG51bGwsIHhtbCwgcmVzdWx0cyApO1xcblxcdFxcdFxcdFxcdFxcdC8vIERvbid0IGtlZXAgdGhlIGVsZW1lbnQgKGlzc3VlICMyOTkpXFxuXFx0XFx0XFx0XFx0XFx0aW5wdXRbMF0gPSBudWxsO1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiAhcmVzdWx0cy5wb3AoKTtcXG5cXHRcXHRcXHRcXHR9O1xcblxcdFxcdH0pLFxcblxcblxcdFxcdFxcXCJoYXNcXFwiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlbGVjdG9yICkge1xcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gU2l6emxlKCBzZWxlY3RvciwgZWxlbSApLmxlbmd0aCA+IDA7XFxuXFx0XFx0XFx0fTtcXG5cXHRcXHR9KSxcXG5cXG5cXHRcXHRcXFwiY29udGFpbnNcXFwiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHRleHQgKSB7XFxuXFx0XFx0XFx0dGV4dCA9IHRleHQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuICggZWxlbS50ZXh0Q29udGVudCB8fCBlbGVtLmlubmVyVGV4dCB8fCBnZXRUZXh0KCBlbGVtICkgKS5pbmRleE9mKCB0ZXh0ICkgPiAtMTtcXG5cXHRcXHRcXHR9O1xcblxcdFxcdH0pLFxcblxcblxcdFxcdC8vIFxcXCJXaGV0aGVyIGFuIGVsZW1lbnQgaXMgcmVwcmVzZW50ZWQgYnkgYSA6bGFuZygpIHNlbGVjdG9yXFxuXFx0XFx0Ly8gaXMgYmFzZWQgc29sZWx5IG9uIHRoZSBlbGVtZW50J3MgbGFuZ3VhZ2UgdmFsdWVcXG5cXHRcXHQvLyBiZWluZyBlcXVhbCB0byB0aGUgaWRlbnRpZmllciBDLFxcblxcdFxcdC8vIG9yIGJlZ2lubmluZyB3aXRoIHRoZSBpZGVudGlmaWVyIEMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgXFxcIi1cXFwiLlxcblxcdFxcdC8vIFRoZSBtYXRjaGluZyBvZiBDIGFnYWluc3QgdGhlIGVsZW1lbnQncyBsYW5ndWFnZSB2YWx1ZSBpcyBwZXJmb3JtZWQgY2FzZS1pbnNlbnNpdGl2ZWx5LlxcblxcdFxcdC8vIFRoZSBpZGVudGlmaWVyIEMgZG9lcyBub3QgaGF2ZSB0byBiZSBhIHZhbGlkIGxhbmd1YWdlIG5hbWUuXFxcIlxcblxcdFxcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jbGFuZy1wc2V1ZG9cXG5cXHRcXHRcXFwibGFuZ1xcXCI6IG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIGxhbmcgKSB7XFxuXFx0XFx0XFx0Ly8gbGFuZyB2YWx1ZSBtdXN0IGJlIGEgdmFsaWQgaWRlbnRpZmllclxcblxcdFxcdFxcdGlmICggIXJpZGVudGlmaWVyLnRlc3QobGFuZyB8fCBcXFwiXFxcIikgKSB7XFxuXFx0XFx0XFx0XFx0U2l6emxlLmVycm9yKCBcXFwidW5zdXBwb3J0ZWQgbGFuZzogXFxcIiArIGxhbmcgKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0bGFuZyA9IGxhbmcucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKS50b0xvd2VyQ2FzZSgpO1xcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcXG5cXHRcXHRcXHRcXHR2YXIgZWxlbUxhbmc7XFxuXFx0XFx0XFx0XFx0ZG8ge1xcblxcdFxcdFxcdFxcdFxcdGlmICggKGVsZW1MYW5nID0gZG9jdW1lbnRJc0hUTUwgP1xcblxcdFxcdFxcdFxcdFxcdFxcdGVsZW0ubGFuZyA6XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZWxlbS5nZXRBdHRyaWJ1dGUoXFxcInhtbDpsYW5nXFxcIikgfHwgZWxlbS5nZXRBdHRyaWJ1dGUoXFxcImxhbmdcXFwiKSkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZWxlbUxhbmcgPSBlbGVtTGFuZy50b0xvd2VyQ2FzZSgpO1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBlbGVtTGFuZyA9PT0gbGFuZyB8fCBlbGVtTGFuZy5pbmRleE9mKCBsYW5nICsgXFxcIi1cXFwiICkgPT09IDA7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH0gd2hpbGUgKCAoZWxlbSA9IGVsZW0ucGFyZW50Tm9kZSkgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApO1xcblxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHR9O1xcblxcdFxcdH0pLFxcblxcblxcdFxcdC8vIE1pc2NlbGxhbmVvdXNcXG5cXHRcXHRcXFwidGFyZ2V0XFxcIjogZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0XFx0XFx0dmFyIGhhc2ggPSB3aW5kb3cubG9jYXRpb24gJiYgd2luZG93LmxvY2F0aW9uLmhhc2g7XFxuXFx0XFx0XFx0cmV0dXJuIGhhc2ggJiYgaGFzaC5zbGljZSggMSApID09PSBlbGVtLmlkO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0XFxcInJvb3RcXFwiOiBmdW5jdGlvbiggZWxlbSApIHtcXG5cXHRcXHRcXHRyZXR1cm4gZWxlbSA9PT0gZG9jRWxlbTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdFxcXCJmb2N1c1xcXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdFxcdHJldHVybiBlbGVtID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmICghZG9jdW1lbnQuaGFzRm9jdXMgfHwgZG9jdW1lbnQuaGFzRm9jdXMoKSkgJiYgISEoZWxlbS50eXBlIHx8IGVsZW0uaHJlZiB8fCB+ZWxlbS50YWJJbmRleCk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvLyBCb29sZWFuIHByb3BlcnRpZXNcXG5cXHRcXHRcXFwiZW5hYmxlZFxcXCI6IGNyZWF0ZURpc2FibGVkUHNldWRvKCBmYWxzZSApLFxcblxcdFxcdFxcXCJkaXNhYmxlZFxcXCI6IGNyZWF0ZURpc2FibGVkUHNldWRvKCB0cnVlICksXFxuXFxuXFx0XFx0XFxcImNoZWNrZWRcXFwiOiBmdW5jdGlvbiggZWxlbSApIHtcXG5cXHRcXHRcXHQvLyBJbiBDU1MzLCA6Y2hlY2tlZCBzaG91bGQgcmV0dXJuIGJvdGggY2hlY2tlZCBhbmQgc2VsZWN0ZWQgZWxlbWVudHNcXG5cXHRcXHRcXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDExL1JFQy1jc3MzLXNlbGVjdG9ycy0yMDExMDkyOS8jY2hlY2tlZFxcblxcdFxcdFxcdHZhciBub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcXG5cXHRcXHRcXHRyZXR1cm4gKG5vZGVOYW1lID09PSBcXFwiaW5wdXRcXFwiICYmICEhZWxlbS5jaGVja2VkKSB8fCAobm9kZU5hbWUgPT09IFxcXCJvcHRpb25cXFwiICYmICEhZWxlbS5zZWxlY3RlZCk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRcXFwic2VsZWN0ZWRcXFwiOiBmdW5jdGlvbiggZWxlbSApIHtcXG5cXHRcXHRcXHQvLyBBY2Nlc3NpbmcgdGhpcyBwcm9wZXJ0eSBtYWtlcyBzZWxlY3RlZC1ieS1kZWZhdWx0XFxuXFx0XFx0XFx0Ly8gb3B0aW9ucyBpbiBTYWZhcmkgd29yayBwcm9wZXJseVxcblxcdFxcdFxcdGlmICggZWxlbS5wYXJlbnROb2RlICkge1xcblxcdFxcdFxcdFxcdGVsZW0ucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gZWxlbS5zZWxlY3RlZCA9PT0gdHJ1ZTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdC8vIENvbnRlbnRzXFxuXFx0XFx0XFxcImVtcHR5XFxcIjogZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0XFx0XFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNlbXB0eS1wc2V1ZG9cXG5cXHRcXHRcXHQvLyA6ZW1wdHkgaXMgbmVnYXRlZCBieSBlbGVtZW50ICgxKSBvciBjb250ZW50IG5vZGVzICh0ZXh0OiAzOyBjZGF0YTogNDsgZW50aXR5IHJlZjogNSksXFxuXFx0XFx0XFx0Ly8gICBidXQgbm90IGJ5IG90aGVycyAoY29tbWVudDogODsgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbjogNzsgZXRjLilcXG5cXHRcXHRcXHQvLyBub2RlVHlwZSA8IDYgd29ya3MgYmVjYXVzZSBhdHRyaWJ1dGVzICgyKSBkbyBub3QgYXBwZWFyIGFzIGNoaWxkcmVuXFxuXFx0XFx0XFx0Zm9yICggZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDsgZWxlbTsgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcgKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCBlbGVtLm5vZGVUeXBlIDwgNiApIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdFxcXCJwYXJlbnRcXFwiOiBmdW5jdGlvbiggZWxlbSApIHtcXG5cXHRcXHRcXHRyZXR1cm4gIUV4cHIucHNldWRvc1tcXFwiZW1wdHlcXFwiXSggZWxlbSApO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0Ly8gRWxlbWVudC9pbnB1dCB0eXBlc1xcblxcdFxcdFxcXCJoZWFkZXJcXFwiOiBmdW5jdGlvbiggZWxlbSApIHtcXG5cXHRcXHRcXHRyZXR1cm4gcmhlYWRlci50ZXN0KCBlbGVtLm5vZGVOYW1lICk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRcXFwiaW5wdXRcXFwiOiBmdW5jdGlvbiggZWxlbSApIHtcXG5cXHRcXHRcXHRyZXR1cm4gcmlucHV0cy50ZXN0KCBlbGVtLm5vZGVOYW1lICk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRcXFwiYnV0dG9uXFxcIjogZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0XFx0XFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XFxuXFx0XFx0XFx0cmV0dXJuIG5hbWUgPT09IFxcXCJpbnB1dFxcXCIgJiYgZWxlbS50eXBlID09PSBcXFwiYnV0dG9uXFxcIiB8fCBuYW1lID09PSBcXFwiYnV0dG9uXFxcIjtcXG5cXHRcXHR9LFxcblxcblxcdFxcdFxcXCJ0ZXh0XFxcIjogZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0XFx0XFx0dmFyIGF0dHI7XFxuXFx0XFx0XFx0cmV0dXJuIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXFxcImlucHV0XFxcIiAmJlxcblxcdFxcdFxcdFxcdGVsZW0udHlwZSA9PT0gXFxcInRleHRcXFwiICYmXFxuXFxuXFx0XFx0XFx0XFx0Ly8gU3VwcG9ydDogSUU8OFxcblxcdFxcdFxcdFxcdC8vIE5ldyBIVE1MNSBhdHRyaWJ1dGUgdmFsdWVzIChlLmcuLCBcXFwic2VhcmNoXFxcIikgYXBwZWFyIHdpdGggZWxlbS50eXBlID09PSBcXFwidGV4dFxcXCJcXG5cXHRcXHRcXHRcXHQoIChhdHRyID0gZWxlbS5nZXRBdHRyaWJ1dGUoXFxcInR5cGVcXFwiKSkgPT0gbnVsbCB8fCBhdHRyLnRvTG93ZXJDYXNlKCkgPT09IFxcXCJ0ZXh0XFxcIiApO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0Ly8gUG9zaXRpb24taW4tY29sbGVjdGlvblxcblxcdFxcdFxcXCJmaXJzdFxcXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0cmV0dXJuIFsgMCBdO1xcblxcdFxcdH0pLFxcblxcblxcdFxcdFxcXCJsYXN0XFxcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XFxuXFx0XFx0XFx0cmV0dXJuIFsgbGVuZ3RoIC0gMSBdO1xcblxcdFxcdH0pLFxcblxcblxcdFxcdFxcXCJlcVxcXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcXG5cXHRcXHRcXHRyZXR1cm4gWyBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50IF07XFxuXFx0XFx0fSksXFxuXFxuXFx0XFx0XFxcImV2ZW5cXFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcXG5cXHRcXHRcXHR2YXIgaSA9IDA7XFxuXFx0XFx0XFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpICs9IDIgKSB7XFxuXFx0XFx0XFx0XFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcXG5cXHRcXHR9KSxcXG5cXG5cXHRcXHRcXFwib2RkXFxcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XFxuXFx0XFx0XFx0dmFyIGkgPSAxO1xcblxcdFxcdFxcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSArPSAyICkge1xcblxcdFxcdFxcdFxcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiBtYXRjaEluZGV4ZXM7XFxuXFx0XFx0fSksXFxuXFxuXFx0XFx0XFxcImx0XFxcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xcblxcdFxcdFxcdHZhciBpID0gYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudDtcXG5cXHRcXHRcXHRmb3IgKCA7IC0taSA+PSAwOyApIHtcXG5cXHRcXHRcXHRcXHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xcblxcdFxcdH0pLFxcblxcblxcdFxcdFxcXCJndFxcXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcXG5cXHRcXHRcXHR2YXIgaSA9IGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQ7XFxuXFx0XFx0XFx0Zm9yICggOyArK2kgPCBsZW5ndGg7ICkge1xcblxcdFxcdFxcdFxcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiBtYXRjaEluZGV4ZXM7XFxuXFx0XFx0fSlcXG5cXHR9XFxufTtcXG5cXG5FeHByLnBzZXVkb3NbXFxcIm50aFxcXCJdID0gRXhwci5wc2V1ZG9zW1xcXCJlcVxcXCJdO1xcblxcbi8vIEFkZCBidXR0b24vaW5wdXQgdHlwZSBwc2V1ZG9zXFxuZm9yICggaSBpbiB7IHJhZGlvOiB0cnVlLCBjaGVja2JveDogdHJ1ZSwgZmlsZTogdHJ1ZSwgcGFzc3dvcmQ6IHRydWUsIGltYWdlOiB0cnVlIH0gKSB7XFxuXFx0RXhwci5wc2V1ZG9zWyBpIF0gPSBjcmVhdGVJbnB1dFBzZXVkbyggaSApO1xcbn1cXG5mb3IgKCBpIGluIHsgc3VibWl0OiB0cnVlLCByZXNldDogdHJ1ZSB9ICkge1xcblxcdEV4cHIucHNldWRvc1sgaSBdID0gY3JlYXRlQnV0dG9uUHNldWRvKCBpICk7XFxufVxcblxcbi8vIEVhc3kgQVBJIGZvciBjcmVhdGluZyBuZXcgc2V0RmlsdGVyc1xcbmZ1bmN0aW9uIHNldEZpbHRlcnMoKSB7fVxcbnNldEZpbHRlcnMucHJvdG90eXBlID0gRXhwci5maWx0ZXJzID0gRXhwci5wc2V1ZG9zO1xcbkV4cHIuc2V0RmlsdGVycyA9IG5ldyBzZXRGaWx0ZXJzKCk7XFxuXFxudG9rZW5pemUgPSBTaXp6bGUudG9rZW5pemUgPSBmdW5jdGlvbiggc2VsZWN0b3IsIHBhcnNlT25seSApIHtcXG5cXHR2YXIgbWF0Y2hlZCwgbWF0Y2gsIHRva2VucywgdHlwZSxcXG5cXHRcXHRzb0ZhciwgZ3JvdXBzLCBwcmVGaWx0ZXJzLFxcblxcdFxcdGNhY2hlZCA9IHRva2VuQ2FjaGVbIHNlbGVjdG9yICsgXFxcIiBcXFwiIF07XFxuXFxuXFx0aWYgKCBjYWNoZWQgKSB7XFxuXFx0XFx0cmV0dXJuIHBhcnNlT25seSA/IDAgOiBjYWNoZWQuc2xpY2UoIDAgKTtcXG5cXHR9XFxuXFxuXFx0c29GYXIgPSBzZWxlY3RvcjtcXG5cXHRncm91cHMgPSBbXTtcXG5cXHRwcmVGaWx0ZXJzID0gRXhwci5wcmVGaWx0ZXI7XFxuXFxuXFx0d2hpbGUgKCBzb0ZhciApIHtcXG5cXG5cXHRcXHQvLyBDb21tYSBhbmQgZmlyc3QgcnVuXFxuXFx0XFx0aWYgKCAhbWF0Y2hlZCB8fCAobWF0Y2ggPSByY29tbWEuZXhlYyggc29GYXIgKSkgKSB7XFxuXFx0XFx0XFx0aWYgKCBtYXRjaCApIHtcXG5cXHRcXHRcXHRcXHQvLyBEb24ndCBjb25zdW1lIHRyYWlsaW5nIGNvbW1hcyBhcyB2YWxpZFxcblxcdFxcdFxcdFxcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoWzBdLmxlbmd0aCApIHx8IHNvRmFyO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRncm91cHMucHVzaCggKHRva2VucyA9IFtdKSApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRtYXRjaGVkID0gZmFsc2U7XFxuXFxuXFx0XFx0Ly8gQ29tYmluYXRvcnNcXG5cXHRcXHRpZiAoIChtYXRjaCA9IHJjb21iaW5hdG9ycy5leGVjKCBzb0ZhciApKSApIHtcXG5cXHRcXHRcXHRtYXRjaGVkID0gbWF0Y2guc2hpZnQoKTtcXG5cXHRcXHRcXHR0b2tlbnMucHVzaCh7XFxuXFx0XFx0XFx0XFx0dmFsdWU6IG1hdGNoZWQsXFxuXFx0XFx0XFx0XFx0Ly8gQ2FzdCBkZXNjZW5kYW50IGNvbWJpbmF0b3JzIHRvIHNwYWNlXFxuXFx0XFx0XFx0XFx0dHlwZTogbWF0Y2hbMF0ucmVwbGFjZSggcnRyaW0sIFxcXCIgXFxcIiApXFxuXFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hlZC5sZW5ndGggKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gRmlsdGVyc1xcblxcdFxcdGZvciAoIHR5cGUgaW4gRXhwci5maWx0ZXIgKSB7XFxuXFx0XFx0XFx0aWYgKCAobWF0Y2ggPSBtYXRjaEV4cHJbIHR5cGUgXS5leGVjKCBzb0ZhciApKSAmJiAoIXByZUZpbHRlcnNbIHR5cGUgXSB8fFxcblxcdFxcdFxcdFxcdChtYXRjaCA9IHByZUZpbHRlcnNbIHR5cGUgXSggbWF0Y2ggKSkpICkge1xcblxcdFxcdFxcdFxcdG1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpO1xcblxcdFxcdFxcdFxcdHRva2Vucy5wdXNoKHtcXG5cXHRcXHRcXHRcXHRcXHR2YWx1ZTogbWF0Y2hlZCxcXG5cXHRcXHRcXHRcXHRcXHR0eXBlOiB0eXBlLFxcblxcdFxcdFxcdFxcdFxcdG1hdGNoZXM6IG1hdGNoXFxuXFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0XFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hlZC5sZW5ndGggKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICggIW1hdGNoZWQgKSB7XFxuXFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0fVxcblxcdH1cXG5cXG5cXHQvLyBSZXR1cm4gdGhlIGxlbmd0aCBvZiB0aGUgaW52YWxpZCBleGNlc3NcXG5cXHQvLyBpZiB3ZSdyZSBqdXN0IHBhcnNpbmdcXG5cXHQvLyBPdGhlcndpc2UsIHRocm93IGFuIGVycm9yIG9yIHJldHVybiB0b2tlbnNcXG5cXHRyZXR1cm4gcGFyc2VPbmx5ID9cXG5cXHRcXHRzb0Zhci5sZW5ndGggOlxcblxcdFxcdHNvRmFyID9cXG5cXHRcXHRcXHRTaXp6bGUuZXJyb3IoIHNlbGVjdG9yICkgOlxcblxcdFxcdFxcdC8vIENhY2hlIHRoZSB0b2tlbnNcXG5cXHRcXHRcXHR0b2tlbkNhY2hlKCBzZWxlY3RvciwgZ3JvdXBzICkuc2xpY2UoIDAgKTtcXG59O1xcblxcbmZ1bmN0aW9uIHRvU2VsZWN0b3IoIHRva2VucyApIHtcXG5cXHR2YXIgaSA9IDAsXFxuXFx0XFx0bGVuID0gdG9rZW5zLmxlbmd0aCxcXG5cXHRcXHRzZWxlY3RvciA9IFxcXCJcXFwiO1xcblxcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xcblxcdFxcdHNlbGVjdG9yICs9IHRva2Vuc1tpXS52YWx1ZTtcXG5cXHR9XFxuXFx0cmV0dXJuIHNlbGVjdG9yO1xcbn1cXG5cXG5mdW5jdGlvbiBhZGRDb21iaW5hdG9yKCBtYXRjaGVyLCBjb21iaW5hdG9yLCBiYXNlICkge1xcblxcdHZhciBkaXIgPSBjb21iaW5hdG9yLmRpcixcXG5cXHRcXHRza2lwID0gY29tYmluYXRvci5uZXh0LFxcblxcdFxcdGtleSA9IHNraXAgfHwgZGlyLFxcblxcdFxcdGNoZWNrTm9uRWxlbWVudHMgPSBiYXNlICYmIGtleSA9PT0gXFxcInBhcmVudE5vZGVcXFwiLFxcblxcdFxcdGRvbmVOYW1lID0gZG9uZSsrO1xcblxcblxcdHJldHVybiBjb21iaW5hdG9yLmZpcnN0ID9cXG5cXHRcXHQvLyBDaGVjayBhZ2FpbnN0IGNsb3Nlc3QgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRcXG5cXHRcXHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xcblxcdFxcdFxcdHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdH0gOlxcblxcblxcdFxcdC8vIENoZWNrIGFnYWluc3QgYWxsIGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50c1xcblxcdFxcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XFxuXFx0XFx0XFx0dmFyIG9sZENhY2hlLCB1bmlxdWVDYWNoZSwgb3V0ZXJDYWNoZSxcXG5cXHRcXHRcXHRcXHRuZXdDYWNoZSA9IFsgZGlycnVucywgZG9uZU5hbWUgXTtcXG5cXG5cXHRcXHRcXHQvLyBXZSBjYW4ndCBzZXQgYXJiaXRyYXJ5IGRhdGEgb24gWE1MIG5vZGVzLCBzbyB0aGV5IGRvbid0IGJlbmVmaXQgZnJvbSBjb21iaW5hdG9yIGNhY2hpbmdcXG5cXHRcXHRcXHRpZiAoIHhtbCApIHtcXG5cXHRcXHRcXHRcXHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xcblxcdFxcdFxcdFxcdFxcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRydWU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xcblxcdFxcdFxcdFxcdFxcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdG91dGVyQ2FjaGUgPSBlbGVtWyBleHBhbmRvIF0gfHwgKGVsZW1bIGV4cGFuZG8gXSA9IHt9KTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXFxuXFx0XFx0XFx0XFx0XFx0XFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBlbGVtLnVuaXF1ZUlEIF0gfHwgKG91dGVyQ2FjaGVbIGVsZW0udW5pcXVlSUQgXSA9IHt9KTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIHNraXAgJiYgc2tpcCA9PT0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGVsZW0gPSBlbGVtWyBkaXIgXSB8fCBlbGVtO1xcblxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoIChvbGRDYWNoZSA9IHVuaXF1ZUNhY2hlWyBrZXkgXSkgJiZcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRvbGRDYWNoZVsgMCBdID09PSBkaXJydW5zICYmIG9sZENhY2hlWyAxIF0gPT09IGRvbmVOYW1lICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIEFzc2lnbiB0byBuZXdDYWNoZSBzbyByZXN1bHRzIGJhY2stcHJvcGFnYXRlIHRvIHByZXZpb3VzIGVsZW1lbnRzXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIChuZXdDYWNoZVsgMiBdID0gb2xkQ2FjaGVbIDIgXSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBSZXVzZSBuZXdjYWNoZSBzbyByZXN1bHRzIGJhY2stcHJvcGFnYXRlIHRvIHByZXZpb3VzIGVsZW1lbnRzXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dW5pcXVlQ2FjaGVbIGtleSBdID0gbmV3Q2FjaGU7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gQSBtYXRjaCBtZWFucyB3ZSdyZSBkb25lOyBhIGZhaWwgbWVhbnMgd2UgaGF2ZSB0byBrZWVwIGNoZWNraW5nXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCAobmV3Q2FjaGVbIDIgXSA9IG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApKSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHR9O1xcbn1cXG5cXG5mdW5jdGlvbiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSB7XFxuXFx0cmV0dXJuIG1hdGNoZXJzLmxlbmd0aCA+IDEgP1xcblxcdFxcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XFxuXFx0XFx0XFx0dmFyIGkgPSBtYXRjaGVycy5sZW5ndGg7XFxuXFx0XFx0XFx0d2hpbGUgKCBpLS0gKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCAhbWF0Y2hlcnNbaV0oIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcdFxcdH0gOlxcblxcdFxcdG1hdGNoZXJzWzBdO1xcbn1cXG5cXG5mdW5jdGlvbiBtdWx0aXBsZUNvbnRleHRzKCBzZWxlY3RvciwgY29udGV4dHMsIHJlc3VsdHMgKSB7XFxuXFx0dmFyIGkgPSAwLFxcblxcdFxcdGxlbiA9IGNvbnRleHRzLmxlbmd0aDtcXG5cXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcXG5cXHRcXHRTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0c1tpXSwgcmVzdWx0cyApO1xcblxcdH1cXG5cXHRyZXR1cm4gcmVzdWx0cztcXG59XFxuXFxuZnVuY3Rpb24gY29uZGVuc2UoIHVubWF0Y2hlZCwgbWFwLCBmaWx0ZXIsIGNvbnRleHQsIHhtbCApIHtcXG5cXHR2YXIgZWxlbSxcXG5cXHRcXHRuZXdVbm1hdGNoZWQgPSBbXSxcXG5cXHRcXHRpID0gMCxcXG5cXHRcXHRsZW4gPSB1bm1hdGNoZWQubGVuZ3RoLFxcblxcdFxcdG1hcHBlZCA9IG1hcCAhPSBudWxsO1xcblxcblxcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xcblxcdFxcdGlmICggKGVsZW0gPSB1bm1hdGNoZWRbaV0pICkge1xcblxcdFxcdFxcdGlmICggIWZpbHRlciB8fCBmaWx0ZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xcblxcdFxcdFxcdFxcdG5ld1VubWF0Y2hlZC5wdXNoKCBlbGVtICk7XFxuXFx0XFx0XFx0XFx0aWYgKCBtYXBwZWQgKSB7XFxuXFx0XFx0XFx0XFx0XFx0bWFwLnB1c2goIGkgKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9XFxuXFxuXFx0cmV0dXJuIG5ld1VubWF0Y2hlZDtcXG59XFxuXFxuZnVuY3Rpb24gc2V0TWF0Y2hlciggcHJlRmlsdGVyLCBzZWxlY3RvciwgbWF0Y2hlciwgcG9zdEZpbHRlciwgcG9zdEZpbmRlciwgcG9zdFNlbGVjdG9yICkge1xcblxcdGlmICggcG9zdEZpbHRlciAmJiAhcG9zdEZpbHRlclsgZXhwYW5kbyBdICkge1xcblxcdFxcdHBvc3RGaWx0ZXIgPSBzZXRNYXRjaGVyKCBwb3N0RmlsdGVyICk7XFxuXFx0fVxcblxcdGlmICggcG9zdEZpbmRlciAmJiAhcG9zdEZpbmRlclsgZXhwYW5kbyBdICkge1xcblxcdFxcdHBvc3RGaW5kZXIgPSBzZXRNYXRjaGVyKCBwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IgKTtcXG5cXHR9XFxuXFx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgcmVzdWx0cywgY29udGV4dCwgeG1sICkge1xcblxcdFxcdHZhciB0ZW1wLCBpLCBlbGVtLFxcblxcdFxcdFxcdHByZU1hcCA9IFtdLFxcblxcdFxcdFxcdHBvc3RNYXAgPSBbXSxcXG5cXHRcXHRcXHRwcmVleGlzdGluZyA9IHJlc3VsdHMubGVuZ3RoLFxcblxcblxcdFxcdFxcdC8vIEdldCBpbml0aWFsIGVsZW1lbnRzIGZyb20gc2VlZCBvciBjb250ZXh0XFxuXFx0XFx0XFx0ZWxlbXMgPSBzZWVkIHx8IG11bHRpcGxlQ29udGV4dHMoIHNlbGVjdG9yIHx8IFxcXCIqXFxcIiwgY29udGV4dC5ub2RlVHlwZSA/IFsgY29udGV4dCBdIDogY29udGV4dCwgW10gKSxcXG5cXG5cXHRcXHRcXHQvLyBQcmVmaWx0ZXIgdG8gZ2V0IG1hdGNoZXIgaW5wdXQsIHByZXNlcnZpbmcgYSBtYXAgZm9yIHNlZWQtcmVzdWx0cyBzeW5jaHJvbml6YXRpb25cXG5cXHRcXHRcXHRtYXRjaGVySW4gPSBwcmVGaWx0ZXIgJiYgKCBzZWVkIHx8ICFzZWxlY3RvciApID9cXG5cXHRcXHRcXHRcXHRjb25kZW5zZSggZWxlbXMsIHByZU1hcCwgcHJlRmlsdGVyLCBjb250ZXh0LCB4bWwgKSA6XFxuXFx0XFx0XFx0XFx0ZWxlbXMsXFxuXFxuXFx0XFx0XFx0bWF0Y2hlck91dCA9IG1hdGNoZXIgP1xcblxcdFxcdFxcdFxcdC8vIElmIHdlIGhhdmUgYSBwb3N0RmluZGVyLCBvciBmaWx0ZXJlZCBzZWVkLCBvciBub24tc2VlZCBwb3N0RmlsdGVyIG9yIHByZWV4aXN0aW5nIHJlc3VsdHMsXFxuXFx0XFx0XFx0XFx0cG9zdEZpbmRlciB8fCAoIHNlZWQgPyBwcmVGaWx0ZXIgOiBwcmVleGlzdGluZyB8fCBwb3N0RmlsdGVyICkgP1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIC4uLmludGVybWVkaWF0ZSBwcm9jZXNzaW5nIGlzIG5lY2Vzc2FyeVxcblxcdFxcdFxcdFxcdFxcdFtdIDpcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyAuLi5vdGhlcndpc2UgdXNlIHJlc3VsdHMgZGlyZWN0bHlcXG5cXHRcXHRcXHRcXHRcXHRyZXN1bHRzIDpcXG5cXHRcXHRcXHRcXHRtYXRjaGVySW47XFxuXFxuXFx0XFx0Ly8gRmluZCBwcmltYXJ5IG1hdGNoZXNcXG5cXHRcXHRpZiAoIG1hdGNoZXIgKSB7XFxuXFx0XFx0XFx0bWF0Y2hlciggbWF0Y2hlckluLCBtYXRjaGVyT3V0LCBjb250ZXh0LCB4bWwgKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gQXBwbHkgcG9zdEZpbHRlclxcblxcdFxcdGlmICggcG9zdEZpbHRlciApIHtcXG5cXHRcXHRcXHR0ZW1wID0gY29uZGVuc2UoIG1hdGNoZXJPdXQsIHBvc3RNYXAgKTtcXG5cXHRcXHRcXHRwb3N0RmlsdGVyKCB0ZW1wLCBbXSwgY29udGV4dCwgeG1sICk7XFxuXFxuXFx0XFx0XFx0Ly8gVW4tbWF0Y2ggZmFpbGluZyBlbGVtZW50cyBieSBtb3ZpbmcgdGhlbSBiYWNrIHRvIG1hdGNoZXJJblxcblxcdFxcdFxcdGkgPSB0ZW1wLmxlbmd0aDtcXG5cXHRcXHRcXHR3aGlsZSAoIGktLSApIHtcXG5cXHRcXHRcXHRcXHRpZiAoIChlbGVtID0gdGVtcFtpXSkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0bWF0Y2hlck91dFsgcG9zdE1hcFtpXSBdID0gIShtYXRjaGVySW5bIHBvc3RNYXBbaV0gXSA9IGVsZW0pO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICggc2VlZCApIHtcXG5cXHRcXHRcXHRpZiAoIHBvc3RGaW5kZXIgfHwgcHJlRmlsdGVyICkge1xcblxcdFxcdFxcdFxcdGlmICggcG9zdEZpbmRlciApIHtcXG5cXHRcXHRcXHRcXHRcXHQvLyBHZXQgdGhlIGZpbmFsIG1hdGNoZXJPdXQgYnkgY29uZGVuc2luZyB0aGlzIGludGVybWVkaWF0ZSBpbnRvIHBvc3RGaW5kZXIgY29udGV4dHNcXG5cXHRcXHRcXHRcXHRcXHR0ZW1wID0gW107XFxuXFx0XFx0XFx0XFx0XFx0aSA9IG1hdGNoZXJPdXQubGVuZ3RoO1xcblxcdFxcdFxcdFxcdFxcdHdoaWxlICggaS0tICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggKGVsZW0gPSBtYXRjaGVyT3V0W2ldKSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBSZXN0b3JlIG1hdGNoZXJJbiBzaW5jZSBlbGVtIGlzIG5vdCB5ZXQgYSBmaW5hbCBtYXRjaFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHRlbXAucHVzaCggKG1hdGNoZXJJbltpXSA9IGVsZW0pICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRwb3N0RmluZGVyKCBudWxsLCAobWF0Y2hlck91dCA9IFtdKSwgdGVtcCwgeG1sICk7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIE1vdmUgbWF0Y2hlZCBlbGVtZW50cyBmcm9tIHNlZWQgdG8gcmVzdWx0cyB0byBrZWVwIHRoZW0gc3luY2hyb25pemVkXFxuXFx0XFx0XFx0XFx0aSA9IG1hdGNoZXJPdXQubGVuZ3RoO1xcblxcdFxcdFxcdFxcdHdoaWxlICggaS0tICkge1xcblxcdFxcdFxcdFxcdFxcdGlmICggKGVsZW0gPSBtYXRjaGVyT3V0W2ldKSAmJlxcblxcdFxcdFxcdFxcdFxcdFxcdCh0ZW1wID0gcG9zdEZpbmRlciA/IGluZGV4T2YoIHNlZWQsIGVsZW0gKSA6IHByZU1hcFtpXSkgPiAtMSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRzZWVkW3RlbXBdID0gIShyZXN1bHRzW3RlbXBdID0gZWxlbSk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0Ly8gQWRkIGVsZW1lbnRzIHRvIHJlc3VsdHMsIHRocm91Z2ggcG9zdEZpbmRlciBpZiBkZWZpbmVkXFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRtYXRjaGVyT3V0ID0gY29uZGVuc2UoXFxuXFx0XFx0XFx0XFx0bWF0Y2hlck91dCA9PT0gcmVzdWx0cyA/XFxuXFx0XFx0XFx0XFx0XFx0bWF0Y2hlck91dC5zcGxpY2UoIHByZWV4aXN0aW5nLCBtYXRjaGVyT3V0Lmxlbmd0aCApIDpcXG5cXHRcXHRcXHRcXHRcXHRtYXRjaGVyT3V0XFxuXFx0XFx0XFx0KTtcXG5cXHRcXHRcXHRpZiAoIHBvc3RGaW5kZXIgKSB7XFxuXFx0XFx0XFx0XFx0cG9zdEZpbmRlciggbnVsbCwgcmVzdWx0cywgbWF0Y2hlck91dCwgeG1sICk7XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRwdXNoLmFwcGx5KCByZXN1bHRzLCBtYXRjaGVyT3V0ICk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9KTtcXG59XFxuXFxuZnVuY3Rpb24gbWF0Y2hlckZyb21Ub2tlbnMoIHRva2VucyApIHtcXG5cXHR2YXIgY2hlY2tDb250ZXh0LCBtYXRjaGVyLCBqLFxcblxcdFxcdGxlbiA9IHRva2Vucy5sZW5ndGgsXFxuXFx0XFx0bGVhZGluZ1JlbGF0aXZlID0gRXhwci5yZWxhdGl2ZVsgdG9rZW5zWzBdLnR5cGUgXSxcXG5cXHRcXHRpbXBsaWNpdFJlbGF0aXZlID0gbGVhZGluZ1JlbGF0aXZlIHx8IEV4cHIucmVsYXRpdmVbXFxcIiBcXFwiXSxcXG5cXHRcXHRpID0gbGVhZGluZ1JlbGF0aXZlID8gMSA6IDAsXFxuXFxuXFx0XFx0Ly8gVGhlIGZvdW5kYXRpb25hbCBtYXRjaGVyIGVuc3VyZXMgdGhhdCBlbGVtZW50cyBhcmUgcmVhY2hhYmxlIGZyb20gdG9wLWxldmVsIGNvbnRleHQocylcXG5cXHRcXHRtYXRjaENvbnRleHQgPSBhZGRDb21iaW5hdG9yKCBmdW5jdGlvbiggZWxlbSApIHtcXG5cXHRcXHRcXHRyZXR1cm4gZWxlbSA9PT0gY2hlY2tDb250ZXh0O1xcblxcdFxcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcXG5cXHRcXHRtYXRjaEFueUNvbnRleHQgPSBhZGRDb21iaW5hdG9yKCBmdW5jdGlvbiggZWxlbSApIHtcXG5cXHRcXHRcXHRyZXR1cm4gaW5kZXhPZiggY2hlY2tDb250ZXh0LCBlbGVtICkgPiAtMTtcXG5cXHRcXHR9LCBpbXBsaWNpdFJlbGF0aXZlLCB0cnVlICksXFxuXFx0XFx0bWF0Y2hlcnMgPSBbIGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XFxuXFx0XFx0XFx0dmFyIHJldCA9ICggIWxlYWRpbmdSZWxhdGl2ZSAmJiAoIHhtbCB8fCBjb250ZXh0ICE9PSBvdXRlcm1vc3RDb250ZXh0ICkgKSB8fCAoXFxuXFx0XFx0XFx0XFx0KGNoZWNrQ29udGV4dCA9IGNvbnRleHQpLm5vZGVUeXBlID9cXG5cXHRcXHRcXHRcXHRcXHRtYXRjaENvbnRleHQoIGVsZW0sIGNvbnRleHQsIHhtbCApIDpcXG5cXHRcXHRcXHRcXHRcXHRtYXRjaEFueUNvbnRleHQoIGVsZW0sIGNvbnRleHQsIHhtbCApICk7XFxuXFx0XFx0XFx0Ly8gQXZvaWQgaGFuZ2luZyBvbnRvIGVsZW1lbnQgKGlzc3VlICMyOTkpXFxuXFx0XFx0XFx0Y2hlY2tDb250ZXh0ID0gbnVsbDtcXG5cXHRcXHRcXHRyZXR1cm4gcmV0O1xcblxcdFxcdH0gXTtcXG5cXG5cXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcXG5cXHRcXHRpZiAoIChtYXRjaGVyID0gRXhwci5yZWxhdGl2ZVsgdG9rZW5zW2ldLnR5cGUgXSkgKSB7XFxuXFx0XFx0XFx0bWF0Y2hlcnMgPSBbIGFkZENvbWJpbmF0b3IoZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICksIG1hdGNoZXIpIF07XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRtYXRjaGVyID0gRXhwci5maWx0ZXJbIHRva2Vuc1tpXS50eXBlIF0uYXBwbHkoIG51bGwsIHRva2Vuc1tpXS5tYXRjaGVzICk7XFxuXFxuXFx0XFx0XFx0Ly8gUmV0dXJuIHNwZWNpYWwgdXBvbiBzZWVpbmcgYSBwb3NpdGlvbmFsIG1hdGNoZXJcXG5cXHRcXHRcXHRpZiAoIG1hdGNoZXJbIGV4cGFuZG8gXSApIHtcXG5cXHRcXHRcXHRcXHQvLyBGaW5kIHRoZSBuZXh0IHJlbGF0aXZlIG9wZXJhdG9yIChpZiBhbnkpIGZvciBwcm9wZXIgaGFuZGxpbmdcXG5cXHRcXHRcXHRcXHRqID0gKytpO1xcblxcdFxcdFxcdFxcdGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xcblxcdFxcdFxcdFxcdFxcdGlmICggRXhwci5yZWxhdGl2ZVsgdG9rZW5zW2pdLnR5cGUgXSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHJldHVybiBzZXRNYXRjaGVyKFxcblxcdFxcdFxcdFxcdFxcdGkgPiAxICYmIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApLFxcblxcdFxcdFxcdFxcdFxcdGkgPiAxICYmIHRvU2VsZWN0b3IoXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gSWYgdGhlIHByZWNlZGluZyB0b2tlbiB3YXMgYSBkZXNjZW5kYW50IGNvbWJpbmF0b3IsIGluc2VydCBhbiBpbXBsaWNpdCBhbnktZWxlbWVudCBgKmBcXG5cXHRcXHRcXHRcXHRcXHRcXHR0b2tlbnMuc2xpY2UoIDAsIGkgLSAxICkuY29uY2F0KHsgdmFsdWU6IHRva2Vuc1sgaSAtIDIgXS50eXBlID09PSBcXFwiIFxcXCIgPyBcXFwiKlxcXCIgOiBcXFwiXFxcIiB9KVxcblxcdFxcdFxcdFxcdFxcdCkucmVwbGFjZSggcnRyaW0sIFxcXCIkMVxcXCIgKSxcXG5cXHRcXHRcXHRcXHRcXHRtYXRjaGVyLFxcblxcdFxcdFxcdFxcdFxcdGkgPCBqICYmIG1hdGNoZXJGcm9tVG9rZW5zKCB0b2tlbnMuc2xpY2UoIGksIGogKSApLFxcblxcdFxcdFxcdFxcdFxcdGogPCBsZW4gJiYgbWF0Y2hlckZyb21Ub2tlbnMoICh0b2tlbnMgPSB0b2tlbnMuc2xpY2UoIGogKSkgKSxcXG5cXHRcXHRcXHRcXHRcXHRqIDwgbGVuICYmIHRvU2VsZWN0b3IoIHRva2VucyApXFxuXFx0XFx0XFx0XFx0KTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0bWF0Y2hlcnMucHVzaCggbWF0Y2hlciApO1xcblxcdFxcdH1cXG5cXHR9XFxuXFxuXFx0cmV0dXJuIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApO1xcbn1cXG5cXG5mdW5jdGlvbiBtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMoIGVsZW1lbnRNYXRjaGVycywgc2V0TWF0Y2hlcnMgKSB7XFxuXFx0dmFyIGJ5U2V0ID0gc2V0TWF0Y2hlcnMubGVuZ3RoID4gMCxcXG5cXHRcXHRieUVsZW1lbnQgPSBlbGVtZW50TWF0Y2hlcnMubGVuZ3RoID4gMCxcXG5cXHRcXHRzdXBlck1hdGNoZXIgPSBmdW5jdGlvbiggc2VlZCwgY29udGV4dCwgeG1sLCByZXN1bHRzLCBvdXRlcm1vc3QgKSB7XFxuXFx0XFx0XFx0dmFyIGVsZW0sIGosIG1hdGNoZXIsXFxuXFx0XFx0XFx0XFx0bWF0Y2hlZENvdW50ID0gMCxcXG5cXHRcXHRcXHRcXHRpID0gXFxcIjBcXFwiLFxcblxcdFxcdFxcdFxcdHVubWF0Y2hlZCA9IHNlZWQgJiYgW10sXFxuXFx0XFx0XFx0XFx0c2V0TWF0Y2hlZCA9IFtdLFxcblxcdFxcdFxcdFxcdGNvbnRleHRCYWNrdXAgPSBvdXRlcm1vc3RDb250ZXh0LFxcblxcdFxcdFxcdFxcdC8vIFdlIG11c3QgYWx3YXlzIGhhdmUgZWl0aGVyIHNlZWQgZWxlbWVudHMgb3Igb3V0ZXJtb3N0IGNvbnRleHRcXG5cXHRcXHRcXHRcXHRlbGVtcyA9IHNlZWQgfHwgYnlFbGVtZW50ICYmIEV4cHIuZmluZFtcXFwiVEFHXFxcIl0oIFxcXCIqXFxcIiwgb3V0ZXJtb3N0ICksXFxuXFx0XFx0XFx0XFx0Ly8gVXNlIGludGVnZXIgZGlycnVucyBpZmYgdGhpcyBpcyB0aGUgb3V0ZXJtb3N0IG1hdGNoZXJcXG5cXHRcXHRcXHRcXHRkaXJydW5zVW5pcXVlID0gKGRpcnJ1bnMgKz0gY29udGV4dEJhY2t1cCA9PSBudWxsID8gMSA6IE1hdGgucmFuZG9tKCkgfHwgMC4xKSxcXG5cXHRcXHRcXHRcXHRsZW4gPSBlbGVtcy5sZW5ndGg7XFxuXFxuXFx0XFx0XFx0aWYgKCBvdXRlcm1vc3QgKSB7XFxuXFx0XFx0XFx0XFx0b3V0ZXJtb3N0Q29udGV4dCA9IGNvbnRleHQgPT09IGRvY3VtZW50IHx8IGNvbnRleHQgfHwgb3V0ZXJtb3N0O1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBBZGQgZWxlbWVudHMgcGFzc2luZyBlbGVtZW50TWF0Y2hlcnMgZGlyZWN0bHkgdG8gcmVzdWx0c1xcblxcdFxcdFxcdC8vIFN1cHBvcnQ6IElFPDksIFNhZmFyaVxcblxcdFxcdFxcdC8vIFRvbGVyYXRlIE5vZGVMaXN0IHByb3BlcnRpZXMgKElFOiBcXFwibGVuZ3RoXFxcIjsgU2FmYXJpOiA8bnVtYmVyPikgbWF0Y2hpbmcgZWxlbWVudHMgYnkgaWRcXG5cXHRcXHRcXHRmb3IgKCA7IGkgIT09IGxlbiAmJiAoZWxlbSA9IGVsZW1zW2ldKSAhPSBudWxsOyBpKysgKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCBieUVsZW1lbnQgJiYgZWxlbSApIHtcXG5cXHRcXHRcXHRcXHRcXHRqID0gMDtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoICFjb250ZXh0ICYmIGVsZW0ub3duZXJEb2N1bWVudCAhPT0gZG9jdW1lbnQgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR4bWwgPSAhZG9jdW1lbnRJc0hUTUw7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdHdoaWxlICggKG1hdGNoZXIgPSBlbGVtZW50TWF0Y2hlcnNbaisrXSkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBtYXRjaGVyKCBlbGVtLCBjb250ZXh0IHx8IGRvY3VtZW50LCB4bWwpICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJlc3VsdHMucHVzaCggZWxlbSApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBvdXRlcm1vc3QgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBUcmFjayB1bm1hdGNoZWQgZWxlbWVudHMgZm9yIHNldCBmaWx0ZXJzXFxuXFx0XFx0XFx0XFx0aWYgKCBieVNldCApIHtcXG5cXHRcXHRcXHRcXHRcXHQvLyBUaGV5IHdpbGwgaGF2ZSBnb25lIHRocm91Z2ggYWxsIHBvc3NpYmxlIG1hdGNoZXJzXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCAoZWxlbSA9ICFtYXRjaGVyICYmIGVsZW0pICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdG1hdGNoZWRDb3VudC0tO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBMZW5ndGhlbiB0aGUgYXJyYXkgZm9yIGV2ZXJ5IGVsZW1lbnQsIG1hdGNoZWQgb3Igbm90XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBzZWVkICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHVubWF0Y2hlZC5wdXNoKCBlbGVtICk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gYGlgIGlzIG5vdyB0aGUgY291bnQgb2YgZWxlbWVudHMgdmlzaXRlZCBhYm92ZSwgYW5kIGFkZGluZyBpdCB0byBgbWF0Y2hlZENvdW50YFxcblxcdFxcdFxcdC8vIG1ha2VzIHRoZSBsYXR0ZXIgbm9ubmVnYXRpdmUuXFxuXFx0XFx0XFx0bWF0Y2hlZENvdW50ICs9IGk7XFxuXFxuXFx0XFx0XFx0Ly8gQXBwbHkgc2V0IGZpbHRlcnMgdG8gdW5tYXRjaGVkIGVsZW1lbnRzXFxuXFx0XFx0XFx0Ly8gTk9URTogVGhpcyBjYW4gYmUgc2tpcHBlZCBpZiB0aGVyZSBhcmUgbm8gdW5tYXRjaGVkIGVsZW1lbnRzIChpLmUuLCBgbWF0Y2hlZENvdW50YFxcblxcdFxcdFxcdC8vIGVxdWFscyBgaWApLCB1bmxlc3Mgd2UgZGlkbid0IHZpc2l0IF9hbnlfIGVsZW1lbnRzIGluIHRoZSBhYm92ZSBsb29wIGJlY2F1c2Ugd2UgaGF2ZVxcblxcdFxcdFxcdC8vIG5vIGVsZW1lbnQgbWF0Y2hlcnMgYW5kIG5vIHNlZWQuXFxuXFx0XFx0XFx0Ly8gSW5jcmVtZW50aW5nIGFuIGluaXRpYWxseS1zdHJpbmcgXFxcIjBcXFwiIGBpYCBhbGxvd3MgYGlgIHRvIHJlbWFpbiBhIHN0cmluZyBvbmx5IGluIHRoYXRcXG5cXHRcXHRcXHQvLyBjYXNlLCB3aGljaCB3aWxsIHJlc3VsdCBpbiBhIFxcXCIwMFxcXCIgYG1hdGNoZWRDb3VudGAgdGhhdCBkaWZmZXJzIGZyb20gYGlgIGJ1dCBpcyBhbHNvXFxuXFx0XFx0XFx0Ly8gbnVtZXJpY2FsbHkgemVyby5cXG5cXHRcXHRcXHRpZiAoIGJ5U2V0ICYmIGkgIT09IG1hdGNoZWRDb3VudCApIHtcXG5cXHRcXHRcXHRcXHRqID0gMDtcXG5cXHRcXHRcXHRcXHR3aGlsZSAoIChtYXRjaGVyID0gc2V0TWF0Y2hlcnNbaisrXSkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0bWF0Y2hlciggdW5tYXRjaGVkLCBzZXRNYXRjaGVkLCBjb250ZXh0LCB4bWwgKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBzZWVkICkge1xcblxcdFxcdFxcdFxcdFxcdC8vIFJlaW50ZWdyYXRlIGVsZW1lbnQgbWF0Y2hlcyB0byBlbGltaW5hdGUgdGhlIG5lZWQgZm9yIHNvcnRpbmdcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIG1hdGNoZWRDb3VudCA+IDAgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0d2hpbGUgKCBpLS0gKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCAhKHVubWF0Y2hlZFtpXSB8fCBzZXRNYXRjaGVkW2ldKSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRzZXRNYXRjaGVkW2ldID0gcG9wLmNhbGwoIHJlc3VsdHMgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBEaXNjYXJkIGluZGV4IHBsYWNlaG9sZGVyIHZhbHVlcyB0byBnZXQgb25seSBhY3R1YWwgbWF0Y2hlc1xcblxcdFxcdFxcdFxcdFxcdHNldE1hdGNoZWQgPSBjb25kZW5zZSggc2V0TWF0Y2hlZCApO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBBZGQgbWF0Y2hlcyB0byByZXN1bHRzXFxuXFx0XFx0XFx0XFx0cHVzaC5hcHBseSggcmVzdWx0cywgc2V0TWF0Y2hlZCApO1xcblxcblxcdFxcdFxcdFxcdC8vIFNlZWRsZXNzIHNldCBtYXRjaGVzIHN1Y2NlZWRpbmcgbXVsdGlwbGUgc3VjY2Vzc2Z1bCBtYXRjaGVycyBzdGlwdWxhdGUgc29ydGluZ1xcblxcdFxcdFxcdFxcdGlmICggb3V0ZXJtb3N0ICYmICFzZWVkICYmIHNldE1hdGNoZWQubGVuZ3RoID4gMCAmJlxcblxcdFxcdFxcdFxcdFxcdCggbWF0Y2hlZENvdW50ICsgc2V0TWF0Y2hlcnMubGVuZ3RoICkgPiAxICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFNpenpsZS51bmlxdWVTb3J0KCByZXN1bHRzICk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBPdmVycmlkZSBtYW5pcHVsYXRpb24gb2YgZ2xvYmFscyBieSBuZXN0ZWQgbWF0Y2hlcnNcXG5cXHRcXHRcXHRpZiAoIG91dGVybW9zdCApIHtcXG5cXHRcXHRcXHRcXHRkaXJydW5zID0gZGlycnVuc1VuaXF1ZTtcXG5cXHRcXHRcXHRcXHRvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dEJhY2t1cDtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHVubWF0Y2hlZDtcXG5cXHRcXHR9O1xcblxcblxcdHJldHVybiBieVNldCA/XFxuXFx0XFx0bWFya0Z1bmN0aW9uKCBzdXBlck1hdGNoZXIgKSA6XFxuXFx0XFx0c3VwZXJNYXRjaGVyO1xcbn1cXG5cXG5jb21waWxlID0gU2l6emxlLmNvbXBpbGUgPSBmdW5jdGlvbiggc2VsZWN0b3IsIG1hdGNoIC8qIEludGVybmFsIFVzZSBPbmx5ICovICkge1xcblxcdHZhciBpLFxcblxcdFxcdHNldE1hdGNoZXJzID0gW10sXFxuXFx0XFx0ZWxlbWVudE1hdGNoZXJzID0gW10sXFxuXFx0XFx0Y2FjaGVkID0gY29tcGlsZXJDYWNoZVsgc2VsZWN0b3IgKyBcXFwiIFxcXCIgXTtcXG5cXG5cXHRpZiAoICFjYWNoZWQgKSB7XFxuXFx0XFx0Ly8gR2VuZXJhdGUgYSBmdW5jdGlvbiBvZiByZWN1cnNpdmUgZnVuY3Rpb25zIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2hlY2sgZWFjaCBlbGVtZW50XFxuXFx0XFx0aWYgKCAhbWF0Y2ggKSB7XFxuXFx0XFx0XFx0bWF0Y2ggPSB0b2tlbml6ZSggc2VsZWN0b3IgKTtcXG5cXHRcXHR9XFxuXFx0XFx0aSA9IG1hdGNoLmxlbmd0aDtcXG5cXHRcXHR3aGlsZSAoIGktLSApIHtcXG5cXHRcXHRcXHRjYWNoZWQgPSBtYXRjaGVyRnJvbVRva2VucyggbWF0Y2hbaV0gKTtcXG5cXHRcXHRcXHRpZiAoIGNhY2hlZFsgZXhwYW5kbyBdICkge1xcblxcdFxcdFxcdFxcdHNldE1hdGNoZXJzLnB1c2goIGNhY2hlZCApO1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0ZWxlbWVudE1hdGNoZXJzLnB1c2goIGNhY2hlZCApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gQ2FjaGUgdGhlIGNvbXBpbGVkIGZ1bmN0aW9uXFxuXFx0XFx0Y2FjaGVkID0gY29tcGlsZXJDYWNoZSggc2VsZWN0b3IsIG1hdGNoZXJGcm9tR3JvdXBNYXRjaGVycyggZWxlbWVudE1hdGNoZXJzLCBzZXRNYXRjaGVycyApICk7XFxuXFxuXFx0XFx0Ly8gU2F2ZSBzZWxlY3RvciBhbmQgdG9rZW5pemF0aW9uXFxuXFx0XFx0Y2FjaGVkLnNlbGVjdG9yID0gc2VsZWN0b3I7XFxuXFx0fVxcblxcdHJldHVybiBjYWNoZWQ7XFxufTtcXG5cXG4vKipcXG4gKiBBIGxvdy1sZXZlbCBzZWxlY3Rpb24gZnVuY3Rpb24gdGhhdCB3b3JrcyB3aXRoIFNpenpsZSdzIGNvbXBpbGVkXFxuICogIHNlbGVjdG9yIGZ1bmN0aW9uc1xcbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBzZWxlY3RvciBBIHNlbGVjdG9yIG9yIGEgcHJlLWNvbXBpbGVkXFxuICogIHNlbGVjdG9yIGZ1bmN0aW9uIGJ1aWx0IHdpdGggU2l6emxlLmNvbXBpbGVcXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRleHRcXG4gKiBAcGFyYW0ge0FycmF5fSBbcmVzdWx0c11cXG4gKiBAcGFyYW0ge0FycmF5fSBbc2VlZF0gQSBzZXQgb2YgZWxlbWVudHMgdG8gbWF0Y2ggYWdhaW5zdFxcbiAqL1xcbnNlbGVjdCA9IFNpenpsZS5zZWxlY3QgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKSB7XFxuXFx0dmFyIGksIHRva2VucywgdG9rZW4sIHR5cGUsIGZpbmQsXFxuXFx0XFx0Y29tcGlsZWQgPSB0eXBlb2Ygc2VsZWN0b3IgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgc2VsZWN0b3IsXFxuXFx0XFx0bWF0Y2ggPSAhc2VlZCAmJiB0b2tlbml6ZSggKHNlbGVjdG9yID0gY29tcGlsZWQuc2VsZWN0b3IgfHwgc2VsZWN0b3IpICk7XFxuXFxuXFx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XFxuXFxuXFx0Ly8gVHJ5IHRvIG1pbmltaXplIG9wZXJhdGlvbnMgaWYgdGhlcmUgaXMgb25seSBvbmUgc2VsZWN0b3IgaW4gdGhlIGxpc3QgYW5kIG5vIHNlZWRcXG5cXHQvLyAodGhlIGxhdHRlciBvZiB3aGljaCBndWFyYW50ZWVzIHVzIGNvbnRleHQpXFxuXFx0aWYgKCBtYXRjaC5sZW5ndGggPT09IDEgKSB7XFxuXFxuXFx0XFx0Ly8gUmVkdWNlIGNvbnRleHQgaWYgdGhlIGxlYWRpbmcgY29tcG91bmQgc2VsZWN0b3IgaXMgYW4gSURcXG5cXHRcXHR0b2tlbnMgPSBtYXRjaFswXSA9IG1hdGNoWzBdLnNsaWNlKCAwICk7XFxuXFx0XFx0aWYgKCB0b2tlbnMubGVuZ3RoID4gMiAmJiAodG9rZW4gPSB0b2tlbnNbMF0pLnR5cGUgPT09IFxcXCJJRFxcXCIgJiZcXG5cXHRcXHRcXHRcXHRjb250ZXh0Lm5vZGVUeXBlID09PSA5ICYmIGRvY3VtZW50SXNIVE1MICYmIEV4cHIucmVsYXRpdmVbIHRva2Vuc1sxXS50eXBlIF0gKSB7XFxuXFxuXFx0XFx0XFx0Y29udGV4dCA9ICggRXhwci5maW5kW1xcXCJJRFxcXCJdKCB0b2tlbi5tYXRjaGVzWzBdLnJlcGxhY2UocnVuZXNjYXBlLCBmdW5lc2NhcGUpLCBjb250ZXh0ICkgfHwgW10gKVswXTtcXG5cXHRcXHRcXHRpZiAoICFjb250ZXh0ICkge1xcblxcdFxcdFxcdFxcdHJldHVybiByZXN1bHRzO1xcblxcblxcdFxcdFxcdC8vIFByZWNvbXBpbGVkIG1hdGNoZXJzIHdpbGwgc3RpbGwgdmVyaWZ5IGFuY2VzdHJ5LCBzbyBzdGVwIHVwIGEgbGV2ZWxcXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCBjb21waWxlZCApIHtcXG5cXHRcXHRcXHRcXHRjb250ZXh0ID0gY29udGV4dC5wYXJlbnROb2RlO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRzZWxlY3RvciA9IHNlbGVjdG9yLnNsaWNlKCB0b2tlbnMuc2hpZnQoKS52YWx1ZS5sZW5ndGggKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gRmV0Y2ggYSBzZWVkIHNldCBmb3IgcmlnaHQtdG8tbGVmdCBtYXRjaGluZ1xcblxcdFxcdGkgPSBtYXRjaEV4cHJbXFxcIm5lZWRzQ29udGV4dFxcXCJdLnRlc3QoIHNlbGVjdG9yICkgPyAwIDogdG9rZW5zLmxlbmd0aDtcXG5cXHRcXHR3aGlsZSAoIGktLSApIHtcXG5cXHRcXHRcXHR0b2tlbiA9IHRva2Vuc1tpXTtcXG5cXG5cXHRcXHRcXHQvLyBBYm9ydCBpZiB3ZSBoaXQgYSBjb21iaW5hdG9yXFxuXFx0XFx0XFx0aWYgKCBFeHByLnJlbGF0aXZlWyAodHlwZSA9IHRva2VuLnR5cGUpIF0gKSB7XFxuXFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmICggKGZpbmQgPSBFeHByLmZpbmRbIHR5cGUgXSkgKSB7XFxuXFx0XFx0XFx0XFx0Ly8gU2VhcmNoLCBleHBhbmRpbmcgY29udGV4dCBmb3IgbGVhZGluZyBzaWJsaW5nIGNvbWJpbmF0b3JzXFxuXFx0XFx0XFx0XFx0aWYgKCAoc2VlZCA9IGZpbmQoXFxuXFx0XFx0XFx0XFx0XFx0dG9rZW4ubWF0Y2hlc1swXS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLFxcblxcdFxcdFxcdFxcdFxcdHJzaWJsaW5nLnRlc3QoIHRva2Vuc1swXS50eXBlICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8IGNvbnRleHRcXG5cXHRcXHRcXHRcXHQpKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBJZiBzZWVkIGlzIGVtcHR5IG9yIG5vIHRva2VucyByZW1haW4sIHdlIGNhbiByZXR1cm4gZWFybHlcXG5cXHRcXHRcXHRcXHRcXHR0b2tlbnMuc3BsaWNlKCBpLCAxICk7XFxuXFx0XFx0XFx0XFx0XFx0c2VsZWN0b3IgPSBzZWVkLmxlbmd0aCAmJiB0b1NlbGVjdG9yKCB0b2tlbnMgKTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoICFzZWxlY3RvciApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRwdXNoLmFwcGx5KCByZXN1bHRzLCBzZWVkICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHJlc3VsdHM7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdH1cXG5cXG5cXHQvLyBDb21waWxlIGFuZCBleGVjdXRlIGEgZmlsdGVyaW5nIGZ1bmN0aW9uIGlmIG9uZSBpcyBub3QgcHJvdmlkZWRcXG5cXHQvLyBQcm92aWRlIGBtYXRjaGAgdG8gYXZvaWQgcmV0b2tlbml6YXRpb24gaWYgd2UgbW9kaWZpZWQgdGhlIHNlbGVjdG9yIGFib3ZlXFxuXFx0KCBjb21waWxlZCB8fCBjb21waWxlKCBzZWxlY3RvciwgbWF0Y2ggKSApKFxcblxcdFxcdHNlZWQsXFxuXFx0XFx0Y29udGV4dCxcXG5cXHRcXHQhZG9jdW1lbnRJc0hUTUwsXFxuXFx0XFx0cmVzdWx0cyxcXG5cXHRcXHQhY29udGV4dCB8fCByc2libGluZy50ZXN0KCBzZWxlY3RvciApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fCBjb250ZXh0XFxuXFx0KTtcXG5cXHRyZXR1cm4gcmVzdWx0cztcXG59O1xcblxcbi8vIE9uZS10aW1lIGFzc2lnbm1lbnRzXFxuXFxuLy8gU29ydCBzdGFiaWxpdHlcXG5zdXBwb3J0LnNvcnRTdGFibGUgPSBleHBhbmRvLnNwbGl0KFxcXCJcXFwiKS5zb3J0KCBzb3J0T3JkZXIgKS5qb2luKFxcXCJcXFwiKSA9PT0gZXhwYW5kbztcXG5cXG4vLyBTdXBwb3J0OiBDaHJvbWUgMTQtMzUrXFxuLy8gQWx3YXlzIGFzc3VtZSBkdXBsaWNhdGVzIGlmIHRoZXkgYXJlbid0IHBhc3NlZCB0byB0aGUgY29tcGFyaXNvbiBmdW5jdGlvblxcbnN1cHBvcnQuZGV0ZWN0RHVwbGljYXRlcyA9ICEhaGFzRHVwbGljYXRlO1xcblxcbi8vIEluaXRpYWxpemUgYWdhaW5zdCB0aGUgZGVmYXVsdCBkb2N1bWVudFxcbnNldERvY3VtZW50KCk7XFxuXFxuLy8gU3VwcG9ydDogV2Via2l0PDUzNy4zMiAtIFNhZmFyaSA2LjAuMy9DaHJvbWUgMjUgKGZpeGVkIGluIENocm9tZSAyNylcXG4vLyBEZXRhY2hlZCBub2RlcyBjb25mb3VuZGluZ2x5IGZvbGxvdyAqZWFjaCBvdGhlcipcXG5zdXBwb3J0LnNvcnREZXRhY2hlZCA9IGFzc2VydChmdW5jdGlvbiggZWwgKSB7XFxuXFx0Ly8gU2hvdWxkIHJldHVybiAxLCBidXQgcmV0dXJucyA0IChmb2xsb3dpbmcpXFxuXFx0cmV0dXJuIGVsLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFxcXCJmaWVsZHNldFxcXCIpICkgJiAxO1xcbn0pO1xcblxcbi8vIFN1cHBvcnQ6IElFPDhcXG4vLyBQcmV2ZW50IGF0dHJpYnV0ZS9wcm9wZXJ0eSBcXFwiaW50ZXJwb2xhdGlvblxcXCJcXG4vLyBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L21zNTM2NDI5JTI4VlMuODUlMjkuYXNweFxcbmlmICggIWFzc2VydChmdW5jdGlvbiggZWwgKSB7XFxuXFx0ZWwuaW5uZXJIVE1MID0gXFxcIjxhIGhyZWY9JyMnPjwvYT5cXFwiO1xcblxcdHJldHVybiBlbC5maXJzdENoaWxkLmdldEF0dHJpYnV0ZShcXFwiaHJlZlxcXCIpID09PSBcXFwiI1xcXCIgO1xcbn0pICkge1xcblxcdGFkZEhhbmRsZSggXFxcInR5cGV8aHJlZnxoZWlnaHR8d2lkdGhcXFwiLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XFxuXFx0XFx0aWYgKCAhaXNYTUwgKSB7XFxuXFx0XFx0XFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lLCBuYW1lLnRvTG93ZXJDYXNlKCkgPT09IFxcXCJ0eXBlXFxcIiA/IDEgOiAyICk7XFxuXFx0XFx0fVxcblxcdH0pO1xcbn1cXG5cXG4vLyBTdXBwb3J0OiBJRTw5XFxuLy8gVXNlIGRlZmF1bHRWYWx1ZSBpbiBwbGFjZSBvZiBnZXRBdHRyaWJ1dGUoXFxcInZhbHVlXFxcIilcXG5pZiAoICFzdXBwb3J0LmF0dHJpYnV0ZXMgfHwgIWFzc2VydChmdW5jdGlvbiggZWwgKSB7XFxuXFx0ZWwuaW5uZXJIVE1MID0gXFxcIjxpbnB1dC8+XFxcIjtcXG5cXHRlbC5maXJzdENoaWxkLnNldEF0dHJpYnV0ZSggXFxcInZhbHVlXFxcIiwgXFxcIlxcXCIgKTtcXG5cXHRyZXR1cm4gZWwuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoIFxcXCJ2YWx1ZVxcXCIgKSA9PT0gXFxcIlxcXCI7XFxufSkgKSB7XFxuXFx0YWRkSGFuZGxlKCBcXFwidmFsdWVcXFwiLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XFxuXFx0XFx0aWYgKCAhaXNYTUwgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcXFwiaW5wdXRcXFwiICkge1xcblxcdFxcdFxcdHJldHVybiBlbGVtLmRlZmF1bHRWYWx1ZTtcXG5cXHRcXHR9XFxuXFx0fSk7XFxufVxcblxcbi8vIFN1cHBvcnQ6IElFPDlcXG4vLyBVc2UgZ2V0QXR0cmlidXRlTm9kZSB0byBmZXRjaCBib29sZWFucyB3aGVuIGdldEF0dHJpYnV0ZSBsaWVzXFxuaWYgKCAhYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcXG5cXHRyZXR1cm4gZWwuZ2V0QXR0cmlidXRlKFxcXCJkaXNhYmxlZFxcXCIpID09IG51bGw7XFxufSkgKSB7XFxuXFx0YWRkSGFuZGxlKCBib29sZWFucywgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xcblxcdFxcdHZhciB2YWw7XFxuXFx0XFx0aWYgKCAhaXNYTUwgKSB7XFxuXFx0XFx0XFx0cmV0dXJuIGVsZW1bIG5hbWUgXSA9PT0gdHJ1ZSA/IG5hbWUudG9Mb3dlckNhc2UoKSA6XFxuXFx0XFx0XFx0XFx0XFx0KHZhbCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZSggbmFtZSApKSAmJiB2YWwuc3BlY2lmaWVkID9cXG5cXHRcXHRcXHRcXHRcXHR2YWwudmFsdWUgOlxcblxcdFxcdFxcdFxcdG51bGw7XFxuXFx0XFx0fVxcblxcdH0pO1xcbn1cXG5cXG5yZXR1cm4gU2l6emxlO1xcblxcbn0pKCB3aW5kb3cgKTtcXG5cXG5cXG5cXG5qUXVlcnkuZmluZCA9IFNpenpsZTtcXG5qUXVlcnkuZXhwciA9IFNpenpsZS5zZWxlY3RvcnM7XFxuXFxuLy8gRGVwcmVjYXRlZFxcbmpRdWVyeS5leHByWyBcXFwiOlxcXCIgXSA9IGpRdWVyeS5leHByLnBzZXVkb3M7XFxualF1ZXJ5LnVuaXF1ZVNvcnQgPSBqUXVlcnkudW5pcXVlID0gU2l6emxlLnVuaXF1ZVNvcnQ7XFxualF1ZXJ5LnRleHQgPSBTaXp6bGUuZ2V0VGV4dDtcXG5qUXVlcnkuaXNYTUxEb2MgPSBTaXp6bGUuaXNYTUw7XFxualF1ZXJ5LmNvbnRhaW5zID0gU2l6emxlLmNvbnRhaW5zO1xcbmpRdWVyeS5lc2NhcGVTZWxlY3RvciA9IFNpenpsZS5lc2NhcGU7XFxuXFxuXFxuXFxuXFxudmFyIGRpciA9IGZ1bmN0aW9uKCBlbGVtLCBkaXIsIHVudGlsICkge1xcblxcdHZhciBtYXRjaGVkID0gW10sXFxuXFx0XFx0dHJ1bmNhdGUgPSB1bnRpbCAhPT0gdW5kZWZpbmVkO1xcblxcblxcdHdoaWxlICggKCBlbGVtID0gZWxlbVsgZGlyIF0gKSAmJiBlbGVtLm5vZGVUeXBlICE9PSA5ICkge1xcblxcdFxcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcXG5cXHRcXHRcXHRpZiAoIHRydW5jYXRlICYmIGpRdWVyeSggZWxlbSApLmlzKCB1bnRpbCApICkge1xcblxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRtYXRjaGVkLnB1c2goIGVsZW0gKTtcXG5cXHRcXHR9XFxuXFx0fVxcblxcdHJldHVybiBtYXRjaGVkO1xcbn07XFxuXFxuXFxudmFyIHNpYmxpbmdzID0gZnVuY3Rpb24oIG4sIGVsZW0gKSB7XFxuXFx0dmFyIG1hdGNoZWQgPSBbXTtcXG5cXG5cXHRmb3IgKCA7IG47IG4gPSBuLm5leHRTaWJsaW5nICkge1xcblxcdFxcdGlmICggbi5ub2RlVHlwZSA9PT0gMSAmJiBuICE9PSBlbGVtICkge1xcblxcdFxcdFxcdG1hdGNoZWQucHVzaCggbiApO1xcblxcdFxcdH1cXG5cXHR9XFxuXFxuXFx0cmV0dXJuIG1hdGNoZWQ7XFxufTtcXG5cXG5cXG52YXIgcm5lZWRzQ29udGV4dCA9IGpRdWVyeS5leHByLm1hdGNoLm5lZWRzQ29udGV4dDtcXG5cXG5cXG5cXG5mdW5jdGlvbiBub2RlTmFtZSggZWxlbSwgbmFtZSApIHtcXG5cXG4gIHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZS50b0xvd2VyQ2FzZSgpO1xcblxcbn07XFxudmFyIHJzaW5nbGVUYWcgPSAoIC9ePChbYS16XVteXFxcXC9cXFxcMD46XFxcXHgyMFxcXFx0XFxcXHJcXFxcblxcXFxmXSopW1xcXFx4MjBcXFxcdFxcXFxyXFxcXG5cXFxcZl0qXFxcXC8/Pig/OjxcXFxcL1xcXFwxPnwpJC9pICk7XFxuXFxuXFxuXFxuLy8gSW1wbGVtZW50IHRoZSBpZGVudGljYWwgZnVuY3Rpb25hbGl0eSBmb3IgZmlsdGVyIGFuZCBub3RcXG5mdW5jdGlvbiB3aW5ub3coIGVsZW1lbnRzLCBxdWFsaWZpZXIsIG5vdCApIHtcXG5cXHRpZiAoIGlzRnVuY3Rpb24oIHF1YWxpZmllciApICkge1xcblxcdFxcdHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtLCBpICkge1xcblxcdFxcdFxcdHJldHVybiAhIXF1YWxpZmllci5jYWxsKCBlbGVtLCBpLCBlbGVtICkgIT09IG5vdDtcXG5cXHRcXHR9ICk7XFxuXFx0fVxcblxcblxcdC8vIFNpbmdsZSBlbGVtZW50XFxuXFx0aWYgKCBxdWFsaWZpZXIubm9kZVR5cGUgKSB7XFxuXFx0XFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0XFx0XFx0cmV0dXJuICggZWxlbSA9PT0gcXVhbGlmaWVyICkgIT09IG5vdDtcXG5cXHRcXHR9ICk7XFxuXFx0fVxcblxcblxcdC8vIEFycmF5bGlrZSBvZiBlbGVtZW50cyAoalF1ZXJ5LCBhcmd1bWVudHMsIEFycmF5KVxcblxcdGlmICggdHlwZW9mIHF1YWxpZmllciAhPT0gXFxcInN0cmluZ1xcXCIgKSB7XFxuXFx0XFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0XFx0XFx0cmV0dXJuICggaW5kZXhPZi5jYWxsKCBxdWFsaWZpZXIsIGVsZW0gKSA+IC0xICkgIT09IG5vdDtcXG5cXHRcXHR9ICk7XFxuXFx0fVxcblxcblxcdC8vIEZpbHRlcmVkIGRpcmVjdGx5IGZvciBib3RoIHNpbXBsZSBhbmQgY29tcGxleCBzZWxlY3RvcnNcXG5cXHRyZXR1cm4galF1ZXJ5LmZpbHRlciggcXVhbGlmaWVyLCBlbGVtZW50cywgbm90ICk7XFxufVxcblxcbmpRdWVyeS5maWx0ZXIgPSBmdW5jdGlvbiggZXhwciwgZWxlbXMsIG5vdCApIHtcXG5cXHR2YXIgZWxlbSA9IGVsZW1zWyAwIF07XFxuXFxuXFx0aWYgKCBub3QgKSB7XFxuXFx0XFx0ZXhwciA9IFxcXCI6bm90KFxcXCIgKyBleHByICsgXFxcIilcXFwiO1xcblxcdH1cXG5cXG5cXHRpZiAoIGVsZW1zLmxlbmd0aCA9PT0gMSAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xcblxcdFxcdHJldHVybiBqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGVsZW0sIGV4cHIgKSA/IFsgZWxlbSBdIDogW107XFxuXFx0fVxcblxcblxcdHJldHVybiBqUXVlcnkuZmluZC5tYXRjaGVzKCBleHByLCBqUXVlcnkuZ3JlcCggZWxlbXMsIGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdHJldHVybiBlbGVtLm5vZGVUeXBlID09PSAxO1xcblxcdH0gKSApO1xcbn07XFxuXFxualF1ZXJ5LmZuLmV4dGVuZCgge1xcblxcdGZpbmQ6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcXG5cXHRcXHR2YXIgaSwgcmV0LFxcblxcdFxcdFxcdGxlbiA9IHRoaXMubGVuZ3RoLFxcblxcdFxcdFxcdHNlbGYgPSB0aGlzO1xcblxcblxcdFxcdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcXFwic3RyaW5nXFxcIiApIHtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeSggc2VsZWN0b3IgKS5maWx0ZXIoIGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpKysgKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBqUXVlcnkuY29udGFpbnMoIHNlbGZbIGkgXSwgdGhpcyApICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSApICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldCA9IHRoaXMucHVzaFN0YWNrKCBbXSApO1xcblxcblxcdFxcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpKysgKSB7XFxuXFx0XFx0XFx0alF1ZXJ5LmZpbmQoIHNlbGVjdG9yLCBzZWxmWyBpIF0sIHJldCApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gbGVuID4gMSA/IGpRdWVyeS51bmlxdWVTb3J0KCByZXQgKSA6IHJldDtcXG5cXHR9LFxcblxcdGZpbHRlcjogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xcblxcdFxcdHJldHVybiB0aGlzLnB1c2hTdGFjayggd2lubm93KCB0aGlzLCBzZWxlY3RvciB8fCBbXSwgZmFsc2UgKSApO1xcblxcdH0sXFxuXFx0bm90OiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XFxuXFx0XFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCB3aW5ub3coIHRoaXMsIHNlbGVjdG9yIHx8IFtdLCB0cnVlICkgKTtcXG5cXHR9LFxcblxcdGlzOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XFxuXFx0XFx0cmV0dXJuICEhd2lubm93KFxcblxcdFxcdFxcdHRoaXMsXFxuXFxuXFx0XFx0XFx0Ly8gSWYgdGhpcyBpcyBhIHBvc2l0aW9uYWwvcmVsYXRpdmUgc2VsZWN0b3IsIGNoZWNrIG1lbWJlcnNoaXAgaW4gdGhlIHJldHVybmVkIHNldFxcblxcdFxcdFxcdC8vIHNvICQoXFxcInA6Zmlyc3RcXFwiKS5pcyhcXFwicDpsYXN0XFxcIikgd29uJ3QgcmV0dXJuIHRydWUgZm9yIGEgZG9jIHdpdGggdHdvIFxcXCJwXFxcIi5cXG5cXHRcXHRcXHR0eXBlb2Ygc2VsZWN0b3IgPT09IFxcXCJzdHJpbmdcXFwiICYmIHJuZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3IgKSA/XFxuXFx0XFx0XFx0XFx0alF1ZXJ5KCBzZWxlY3RvciApIDpcXG5cXHRcXHRcXHRcXHRzZWxlY3RvciB8fCBbXSxcXG5cXHRcXHRcXHRmYWxzZVxcblxcdFxcdCkubGVuZ3RoO1xcblxcdH1cXG59ICk7XFxuXFxuXFxuLy8gSW5pdGlhbGl6ZSBhIGpRdWVyeSBvYmplY3RcXG5cXG5cXG4vLyBBIGNlbnRyYWwgcmVmZXJlbmNlIHRvIHRoZSByb290IGpRdWVyeShkb2N1bWVudClcXG52YXIgcm9vdGpRdWVyeSxcXG5cXG5cXHQvLyBBIHNpbXBsZSB3YXkgdG8gY2hlY2sgZm9yIEhUTUwgc3RyaW5nc1xcblxcdC8vIFByaW9yaXRpemUgI2lkIG92ZXIgPHRhZz4gdG8gYXZvaWQgWFNTIHZpYSBsb2NhdGlvbi5oYXNoICgjOTUyMSlcXG5cXHQvLyBTdHJpY3QgSFRNTCByZWNvZ25pdGlvbiAoIzExMjkwOiBtdXN0IHN0YXJ0IHdpdGggPClcXG5cXHQvLyBTaG9ydGN1dCBzaW1wbGUgI2lkIGNhc2UgZm9yIHNwZWVkXFxuXFx0cnF1aWNrRXhwciA9IC9eKD86XFxcXHMqKDxbXFxcXHdcXFxcV10rPilbXj5dKnwjKFtcXFxcdy1dKykpJC8sXFxuXFxuXFx0aW5pdCA9IGpRdWVyeS5mbi5pbml0ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0LCByb290ICkge1xcblxcdFxcdHZhciBtYXRjaCwgZWxlbTtcXG5cXG5cXHRcXHQvLyBIQU5ETEU6ICQoXFxcIlxcXCIpLCAkKG51bGwpLCAkKHVuZGVmaW5lZCksICQoZmFsc2UpXFxuXFx0XFx0aWYgKCAhc2VsZWN0b3IgKSB7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIE1ldGhvZCBpbml0KCkgYWNjZXB0cyBhbiBhbHRlcm5hdGUgcm9vdGpRdWVyeVxcblxcdFxcdC8vIHNvIG1pZ3JhdGUgY2FuIHN1cHBvcnQgalF1ZXJ5LnN1YiAoZ2gtMjEwMSlcXG5cXHRcXHRyb290ID0gcm9vdCB8fCByb290alF1ZXJ5O1xcblxcblxcdFxcdC8vIEhhbmRsZSBIVE1MIHN0cmluZ3NcXG5cXHRcXHRpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXFxcInN0cmluZ1xcXCIgKSB7XFxuXFx0XFx0XFx0aWYgKCBzZWxlY3RvclsgMCBdID09PSBcXFwiPFxcXCIgJiZcXG5cXHRcXHRcXHRcXHRzZWxlY3Rvclsgc2VsZWN0b3IubGVuZ3RoIC0gMSBdID09PSBcXFwiPlxcXCIgJiZcXG5cXHRcXHRcXHRcXHRzZWxlY3Rvci5sZW5ndGggPj0gMyApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBBc3N1bWUgdGhhdCBzdHJpbmdzIHRoYXQgc3RhcnQgYW5kIGVuZCB3aXRoIDw+IGFyZSBIVE1MIGFuZCBza2lwIHRoZSByZWdleCBjaGVja1xcblxcdFxcdFxcdFxcdG1hdGNoID0gWyBudWxsLCBzZWxlY3RvciwgbnVsbCBdO1xcblxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0bWF0Y2ggPSBycXVpY2tFeHByLmV4ZWMoIHNlbGVjdG9yICk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIE1hdGNoIGh0bWwgb3IgbWFrZSBzdXJlIG5vIGNvbnRleHQgaXMgc3BlY2lmaWVkIGZvciAjaWRcXG5cXHRcXHRcXHRpZiAoIG1hdGNoICYmICggbWF0Y2hbIDEgXSB8fCAhY29udGV4dCApICkge1xcblxcblxcdFxcdFxcdFxcdC8vIEhBTkRMRTogJChodG1sKSAtPiAkKGFycmF5KVxcblxcdFxcdFxcdFxcdGlmICggbWF0Y2hbIDEgXSApIHtcXG5cXHRcXHRcXHRcXHRcXHRjb250ZXh0ID0gY29udGV4dCBpbnN0YW5jZW9mIGpRdWVyeSA/IGNvbnRleHRbIDAgXSA6IGNvbnRleHQ7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gT3B0aW9uIHRvIHJ1biBzY3JpcHRzIGlzIHRydWUgZm9yIGJhY2stY29tcGF0XFxuXFx0XFx0XFx0XFx0XFx0Ly8gSW50ZW50aW9uYWxseSBsZXQgdGhlIGVycm9yIGJlIHRocm93biBpZiBwYXJzZUhUTUwgaXMgbm90IHByZXNlbnRcXG5cXHRcXHRcXHRcXHRcXHRqUXVlcnkubWVyZ2UoIHRoaXMsIGpRdWVyeS5wYXJzZUhUTUwoXFxuXFx0XFx0XFx0XFx0XFx0XFx0bWF0Y2hbIDEgXSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRjb250ZXh0ICYmIGNvbnRleHQubm9kZVR5cGUgPyBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCA6IGRvY3VtZW50LFxcblxcdFxcdFxcdFxcdFxcdFxcdHRydWVcXG5cXHRcXHRcXHRcXHRcXHQpICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gSEFORExFOiAkKGh0bWwsIHByb3BzKVxcblxcdFxcdFxcdFxcdFxcdGlmICggcnNpbmdsZVRhZy50ZXN0KCBtYXRjaFsgMSBdICkgJiYgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGNvbnRleHQgKSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRmb3IgKCBtYXRjaCBpbiBjb250ZXh0ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIFByb3BlcnRpZXMgb2YgY29udGV4dCBhcmUgY2FsbGVkIGFzIG1ldGhvZHMgaWYgcG9zc2libGVcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGlzRnVuY3Rpb24oIHRoaXNbIG1hdGNoIF0gKSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGlzWyBtYXRjaCBdKCBjb250ZXh0WyBtYXRjaCBdICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gLi4uYW5kIG90aGVyd2lzZSBzZXQgYXMgYXR0cmlidXRlc1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5hdHRyKCBtYXRjaCwgY29udGV4dFsgbWF0Y2ggXSApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdFxcdFxcdC8vIEhBTkRMRTogJCgjaWQpXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRlbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoIG1hdGNoWyAyIF0gKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGVsZW0gKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gSW5qZWN0IHRoZSBlbGVtZW50IGRpcmVjdGx5IGludG8gdGhlIGpRdWVyeSBvYmplY3RcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzWyAwIF0gPSBlbGVtO1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMubGVuZ3RoID0gMTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIEhBTkRMRTogJChleHByLCAkKC4uLikpXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggIWNvbnRleHQgfHwgY29udGV4dC5qcXVlcnkgKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuICggY29udGV4dCB8fCByb290ICkuZmluZCggc2VsZWN0b3IgKTtcXG5cXG5cXHRcXHRcXHQvLyBIQU5ETEU6ICQoZXhwciwgY29udGV4dClcXG5cXHRcXHRcXHQvLyAod2hpY2ggaXMganVzdCBlcXVpdmFsZW50IHRvOiAkKGNvbnRleHQpLmZpbmQoZXhwcilcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLmNvbnN0cnVjdG9yKCBjb250ZXh0ICkuZmluZCggc2VsZWN0b3IgKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0Ly8gSEFORExFOiAkKERPTUVsZW1lbnQpXFxuXFx0XFx0fSBlbHNlIGlmICggc2VsZWN0b3Iubm9kZVR5cGUgKSB7XFxuXFx0XFx0XFx0dGhpc1sgMCBdID0gc2VsZWN0b3I7XFxuXFx0XFx0XFx0dGhpcy5sZW5ndGggPSAxO1xcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdC8vIEhBTkRMRTogJChmdW5jdGlvbilcXG5cXHRcXHQvLyBTaG9ydGN1dCBmb3IgZG9jdW1lbnQgcmVhZHlcXG5cXHRcXHR9IGVsc2UgaWYgKCBpc0Z1bmN0aW9uKCBzZWxlY3RvciApICkge1xcblxcdFxcdFxcdHJldHVybiByb290LnJlYWR5ICE9PSB1bmRlZmluZWQgP1xcblxcdFxcdFxcdFxcdHJvb3QucmVhZHkoIHNlbGVjdG9yICkgOlxcblxcblxcdFxcdFxcdFxcdC8vIEV4ZWN1dGUgaW1tZWRpYXRlbHkgaWYgcmVhZHkgaXMgbm90IHByZXNlbnRcXG5cXHRcXHRcXHRcXHRzZWxlY3RvciggalF1ZXJ5ICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiBqUXVlcnkubWFrZUFycmF5KCBzZWxlY3RvciwgdGhpcyApO1xcblxcdH07XFxuXFxuLy8gR2l2ZSB0aGUgaW5pdCBmdW5jdGlvbiB0aGUgalF1ZXJ5IHByb3RvdHlwZSBmb3IgbGF0ZXIgaW5zdGFudGlhdGlvblxcbmluaXQucHJvdG90eXBlID0galF1ZXJ5LmZuO1xcblxcbi8vIEluaXRpYWxpemUgY2VudHJhbCByZWZlcmVuY2VcXG5yb290alF1ZXJ5ID0galF1ZXJ5KCBkb2N1bWVudCApO1xcblxcblxcbnZhciBycGFyZW50c3ByZXYgPSAvXig/OnBhcmVudHN8cHJldig/OlVudGlsfEFsbCkpLyxcXG5cXG5cXHQvLyBNZXRob2RzIGd1YXJhbnRlZWQgdG8gcHJvZHVjZSBhIHVuaXF1ZSBzZXQgd2hlbiBzdGFydGluZyBmcm9tIGEgdW5pcXVlIHNldFxcblxcdGd1YXJhbnRlZWRVbmlxdWUgPSB7XFxuXFx0XFx0Y2hpbGRyZW46IHRydWUsXFxuXFx0XFx0Y29udGVudHM6IHRydWUsXFxuXFx0XFx0bmV4dDogdHJ1ZSxcXG5cXHRcXHRwcmV2OiB0cnVlXFxuXFx0fTtcXG5cXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XFxuXFx0aGFzOiBmdW5jdGlvbiggdGFyZ2V0ICkge1xcblxcdFxcdHZhciB0YXJnZXRzID0galF1ZXJ5KCB0YXJnZXQsIHRoaXMgKSxcXG5cXHRcXHRcXHRsID0gdGFyZ2V0cy5sZW5ndGg7XFxuXFxuXFx0XFx0cmV0dXJuIHRoaXMuZmlsdGVyKCBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHR2YXIgaSA9IDA7XFxuXFx0XFx0XFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xcblxcdFxcdFxcdFxcdGlmICggalF1ZXJ5LmNvbnRhaW5zKCB0aGlzLCB0YXJnZXRzWyBpIF0gKSApIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0gKTtcXG5cXHR9LFxcblxcblxcdGNsb3Nlc3Q6IGZ1bmN0aW9uKCBzZWxlY3RvcnMsIGNvbnRleHQgKSB7XFxuXFx0XFx0dmFyIGN1cixcXG5cXHRcXHRcXHRpID0gMCxcXG5cXHRcXHRcXHRsID0gdGhpcy5sZW5ndGgsXFxuXFx0XFx0XFx0bWF0Y2hlZCA9IFtdLFxcblxcdFxcdFxcdHRhcmdldHMgPSB0eXBlb2Ygc2VsZWN0b3JzICE9PSBcXFwic3RyaW5nXFxcIiAmJiBqUXVlcnkoIHNlbGVjdG9ycyApO1xcblxcblxcdFxcdC8vIFBvc2l0aW9uYWwgc2VsZWN0b3JzIG5ldmVyIG1hdGNoLCBzaW5jZSB0aGVyZSdzIG5vIF9zZWxlY3Rpb25fIGNvbnRleHRcXG5cXHRcXHRpZiAoICFybmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9ycyApICkge1xcblxcdFxcdFxcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcXG5cXHRcXHRcXHRcXHRmb3IgKCBjdXIgPSB0aGlzWyBpIF07IGN1ciAmJiBjdXIgIT09IGNvbnRleHQ7IGN1ciA9IGN1ci5wYXJlbnROb2RlICkge1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIEFsd2F5cyBza2lwIGRvY3VtZW50IGZyYWdtZW50c1xcblxcdFxcdFxcdFxcdFxcdGlmICggY3VyLm5vZGVUeXBlIDwgMTEgJiYgKCB0YXJnZXRzID9cXG5cXHRcXHRcXHRcXHRcXHRcXHR0YXJnZXRzLmluZGV4KCBjdXIgKSA+IC0xIDpcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBEb24ndCBwYXNzIG5vbi1lbGVtZW50cyB0byBTaXp6bGVcXG5cXHRcXHRcXHRcXHRcXHRcXHRjdXIubm9kZVR5cGUgPT09IDEgJiZcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGN1ciwgc2VsZWN0b3JzICkgKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRtYXRjaGVkLnB1c2goIGN1ciApO1xcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIG1hdGNoZWQubGVuZ3RoID4gMSA/IGpRdWVyeS51bmlxdWVTb3J0KCBtYXRjaGVkICkgOiBtYXRjaGVkICk7XFxuXFx0fSxcXG5cXG5cXHQvLyBEZXRlcm1pbmUgdGhlIHBvc2l0aW9uIG9mIGFuIGVsZW1lbnQgd2l0aGluIHRoZSBzZXRcXG5cXHRpbmRleDogZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFxuXFx0XFx0Ly8gTm8gYXJndW1lbnQsIHJldHVybiBpbmRleCBpbiBwYXJlbnRcXG5cXHRcXHRpZiAoICFlbGVtICkge1xcblxcdFxcdFxcdHJldHVybiAoIHRoaXNbIDAgXSAmJiB0aGlzWyAwIF0ucGFyZW50Tm9kZSApID8gdGhpcy5maXJzdCgpLnByZXZBbGwoKS5sZW5ndGggOiAtMTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gSW5kZXggaW4gc2VsZWN0b3JcXG5cXHRcXHRpZiAoIHR5cGVvZiBlbGVtID09PSBcXFwic3RyaW5nXFxcIiApIHtcXG5cXHRcXHRcXHRyZXR1cm4gaW5kZXhPZi5jYWxsKCBqUXVlcnkoIGVsZW0gKSwgdGhpc1sgMCBdICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIExvY2F0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIGRlc2lyZWQgZWxlbWVudFxcblxcdFxcdHJldHVybiBpbmRleE9mLmNhbGwoIHRoaXMsXFxuXFxuXFx0XFx0XFx0Ly8gSWYgaXQgcmVjZWl2ZXMgYSBqUXVlcnkgb2JqZWN0LCB0aGUgZmlyc3QgZWxlbWVudCBpcyB1c2VkXFxuXFx0XFx0XFx0ZWxlbS5qcXVlcnkgPyBlbGVtWyAwIF0gOiBlbGVtXFxuXFx0XFx0KTtcXG5cXHR9LFxcblxcblxcdGFkZDogZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0ICkge1xcblxcdFxcdHJldHVybiB0aGlzLnB1c2hTdGFjayhcXG5cXHRcXHRcXHRqUXVlcnkudW5pcXVlU29ydChcXG5cXHRcXHRcXHRcXHRqUXVlcnkubWVyZ2UoIHRoaXMuZ2V0KCksIGpRdWVyeSggc2VsZWN0b3IsIGNvbnRleHQgKSApXFxuXFx0XFx0XFx0KVxcblxcdFxcdCk7XFxuXFx0fSxcXG5cXG5cXHRhZGRCYWNrOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XFxuXFx0XFx0cmV0dXJuIHRoaXMuYWRkKCBzZWxlY3RvciA9PSBudWxsID9cXG5cXHRcXHRcXHR0aGlzLnByZXZPYmplY3QgOiB0aGlzLnByZXZPYmplY3QuZmlsdGVyKCBzZWxlY3RvciApXFxuXFx0XFx0KTtcXG5cXHR9XFxufSApO1xcblxcbmZ1bmN0aW9uIHNpYmxpbmcoIGN1ciwgZGlyICkge1xcblxcdHdoaWxlICggKCBjdXIgPSBjdXJbIGRpciBdICkgJiYgY3VyLm5vZGVUeXBlICE9PSAxICkge31cXG5cXHRyZXR1cm4gY3VyO1xcbn1cXG5cXG5qUXVlcnkuZWFjaCgge1xcblxcdHBhcmVudDogZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0XFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcXG5cXHRcXHRyZXR1cm4gcGFyZW50ICYmIHBhcmVudC5ub2RlVHlwZSAhPT0gMTEgPyBwYXJlbnQgOiBudWxsO1xcblxcdH0sXFxuXFx0cGFyZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0XFx0cmV0dXJuIGRpciggZWxlbSwgXFxcInBhcmVudE5vZGVcXFwiICk7XFxuXFx0fSxcXG5cXHRwYXJlbnRzVW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBpLCB1bnRpbCApIHtcXG5cXHRcXHRyZXR1cm4gZGlyKCBlbGVtLCBcXFwicGFyZW50Tm9kZVxcXCIsIHVudGlsICk7XFxuXFx0fSxcXG5cXHRuZXh0OiBmdW5jdGlvbiggZWxlbSApIHtcXG5cXHRcXHRyZXR1cm4gc2libGluZyggZWxlbSwgXFxcIm5leHRTaWJsaW5nXFxcIiApO1xcblxcdH0sXFxuXFx0cHJldjogZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0XFx0cmV0dXJuIHNpYmxpbmcoIGVsZW0sIFxcXCJwcmV2aW91c1NpYmxpbmdcXFwiICk7XFxuXFx0fSxcXG5cXHRuZXh0QWxsOiBmdW5jdGlvbiggZWxlbSApIHtcXG5cXHRcXHRyZXR1cm4gZGlyKCBlbGVtLCBcXFwibmV4dFNpYmxpbmdcXFwiICk7XFxuXFx0fSxcXG5cXHRwcmV2QWxsOiBmdW5jdGlvbiggZWxlbSApIHtcXG5cXHRcXHRyZXR1cm4gZGlyKCBlbGVtLCBcXFwicHJldmlvdXNTaWJsaW5nXFxcIiApO1xcblxcdH0sXFxuXFx0bmV4dFVudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XFxuXFx0XFx0cmV0dXJuIGRpciggZWxlbSwgXFxcIm5leHRTaWJsaW5nXFxcIiwgdW50aWwgKTtcXG5cXHR9LFxcblxcdHByZXZVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xcblxcdFxcdHJldHVybiBkaXIoIGVsZW0sIFxcXCJwcmV2aW91c1NpYmxpbmdcXFwiLCB1bnRpbCApO1xcblxcdH0sXFxuXFx0c2libGluZ3M6IGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdHJldHVybiBzaWJsaW5ncyggKCBlbGVtLnBhcmVudE5vZGUgfHwge30gKS5maXJzdENoaWxkLCBlbGVtICk7XFxuXFx0fSxcXG5cXHRjaGlsZHJlbjogZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0XFx0cmV0dXJuIHNpYmxpbmdzKCBlbGVtLmZpcnN0Q2hpbGQgKTtcXG5cXHR9LFxcblxcdGNvbnRlbnRzOiBmdW5jdGlvbiggZWxlbSApIHtcXG4gICAgICAgIGlmICggbm9kZU5hbWUoIGVsZW0sIFxcXCJpZnJhbWVcXFwiICkgKSB7XFxuICAgICAgICAgICAgcmV0dXJuIGVsZW0uY29udGVudERvY3VtZW50O1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgLy8gU3VwcG9ydDogSUUgOSAtIDExIG9ubHksIGlPUyA3IG9ubHksIEFuZHJvaWQgQnJvd3NlciA8PTQuMyBvbmx5XFxuICAgICAgICAvLyBUcmVhdCB0aGUgdGVtcGxhdGUgZWxlbWVudCBhcyBhIHJlZ3VsYXIgb25lIGluIGJyb3dzZXJzIHRoYXRcXG4gICAgICAgIC8vIGRvbid0IHN1cHBvcnQgaXQuXFxuICAgICAgICBpZiAoIG5vZGVOYW1lKCBlbGVtLCBcXFwidGVtcGxhdGVcXFwiICkgKSB7XFxuICAgICAgICAgICAgZWxlbSA9IGVsZW0uY29udGVudCB8fCBlbGVtO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIGpRdWVyeS5tZXJnZSggW10sIGVsZW0uY2hpbGROb2RlcyApO1xcblxcdH1cXG59LCBmdW5jdGlvbiggbmFtZSwgZm4gKSB7XFxuXFx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggdW50aWwsIHNlbGVjdG9yICkge1xcblxcdFxcdHZhciBtYXRjaGVkID0galF1ZXJ5Lm1hcCggdGhpcywgZm4sIHVudGlsICk7XFxuXFxuXFx0XFx0aWYgKCBuYW1lLnNsaWNlKCAtNSApICE9PSBcXFwiVW50aWxcXFwiICkge1xcblxcdFxcdFxcdHNlbGVjdG9yID0gdW50aWw7XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICggc2VsZWN0b3IgJiYgdHlwZW9mIHNlbGVjdG9yID09PSBcXFwic3RyaW5nXFxcIiApIHtcXG5cXHRcXHRcXHRtYXRjaGVkID0galF1ZXJ5LmZpbHRlciggc2VsZWN0b3IsIG1hdGNoZWQgKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKCB0aGlzLmxlbmd0aCA+IDEgKSB7XFxuXFxuXFx0XFx0XFx0Ly8gUmVtb3ZlIGR1cGxpY2F0ZXNcXG5cXHRcXHRcXHRpZiAoICFndWFyYW50ZWVkVW5pcXVlWyBuYW1lIF0gKSB7XFxuXFx0XFx0XFx0XFx0alF1ZXJ5LnVuaXF1ZVNvcnQoIG1hdGNoZWQgKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gUmV2ZXJzZSBvcmRlciBmb3IgcGFyZW50cyogYW5kIHByZXYtZGVyaXZhdGl2ZXNcXG5cXHRcXHRcXHRpZiAoIHJwYXJlbnRzcHJldi50ZXN0KCBuYW1lICkgKSB7XFxuXFx0XFx0XFx0XFx0bWF0Y2hlZC5yZXZlcnNlKCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIG1hdGNoZWQgKTtcXG5cXHR9O1xcbn0gKTtcXG52YXIgcm5vdGh0bWx3aGl0ZSA9ICggL1teXFxcXHgyMFxcXFx0XFxcXHJcXFxcblxcXFxmXSsvZyApO1xcblxcblxcblxcbi8vIENvbnZlcnQgU3RyaW5nLWZvcm1hdHRlZCBvcHRpb25zIGludG8gT2JqZWN0LWZvcm1hdHRlZCBvbmVzXFxuZnVuY3Rpb24gY3JlYXRlT3B0aW9ucyggb3B0aW9ucyApIHtcXG5cXHR2YXIgb2JqZWN0ID0ge307XFxuXFx0alF1ZXJ5LmVhY2goIG9wdGlvbnMubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXSwgZnVuY3Rpb24oIF8sIGZsYWcgKSB7XFxuXFx0XFx0b2JqZWN0WyBmbGFnIF0gPSB0cnVlO1xcblxcdH0gKTtcXG5cXHRyZXR1cm4gb2JqZWN0O1xcbn1cXG5cXG4vKlxcbiAqIENyZWF0ZSBhIGNhbGxiYWNrIGxpc3QgdXNpbmcgdGhlIGZvbGxvd2luZyBwYXJhbWV0ZXJzOlxcbiAqXFxuICpcXHRvcHRpb25zOiBhbiBvcHRpb25hbCBsaXN0IG9mIHNwYWNlLXNlcGFyYXRlZCBvcHRpb25zIHRoYXQgd2lsbCBjaGFuZ2UgaG93XFxuICpcXHRcXHRcXHR0aGUgY2FsbGJhY2sgbGlzdCBiZWhhdmVzIG9yIGEgbW9yZSB0cmFkaXRpb25hbCBvcHRpb24gb2JqZWN0XFxuICpcXG4gKiBCeSBkZWZhdWx0IGEgY2FsbGJhY2sgbGlzdCB3aWxsIGFjdCBsaWtlIGFuIGV2ZW50IGNhbGxiYWNrIGxpc3QgYW5kIGNhbiBiZVxcbiAqIFxcXCJmaXJlZFxcXCIgbXVsdGlwbGUgdGltZXMuXFxuICpcXG4gKiBQb3NzaWJsZSBvcHRpb25zOlxcbiAqXFxuICpcXHRvbmNlOlxcdFxcdFxcdHdpbGwgZW5zdXJlIHRoZSBjYWxsYmFjayBsaXN0IGNhbiBvbmx5IGJlIGZpcmVkIG9uY2UgKGxpa2UgYSBEZWZlcnJlZClcXG4gKlxcbiAqXFx0bWVtb3J5OlxcdFxcdFxcdHdpbGwga2VlcCB0cmFjayBvZiBwcmV2aW91cyB2YWx1ZXMgYW5kIHdpbGwgY2FsbCBhbnkgY2FsbGJhY2sgYWRkZWRcXG4gKlxcdFxcdFxcdFxcdFxcdGFmdGVyIHRoZSBsaXN0IGhhcyBiZWVuIGZpcmVkIHJpZ2h0IGF3YXkgd2l0aCB0aGUgbGF0ZXN0IFxcXCJtZW1vcml6ZWRcXFwiXFxuICpcXHRcXHRcXHRcXHRcXHR2YWx1ZXMgKGxpa2UgYSBEZWZlcnJlZClcXG4gKlxcbiAqXFx0dW5pcXVlOlxcdFxcdFxcdHdpbGwgZW5zdXJlIGEgY2FsbGJhY2sgY2FuIG9ubHkgYmUgYWRkZWQgb25jZSAobm8gZHVwbGljYXRlIGluIHRoZSBsaXN0KVxcbiAqXFxuICpcXHRzdG9wT25GYWxzZTpcXHRpbnRlcnJ1cHQgY2FsbGluZ3Mgd2hlbiBhIGNhbGxiYWNrIHJldHVybnMgZmFsc2VcXG4gKlxcbiAqL1xcbmpRdWVyeS5DYWxsYmFja3MgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcXG5cXG5cXHQvLyBDb252ZXJ0IG9wdGlvbnMgZnJvbSBTdHJpbmctZm9ybWF0dGVkIHRvIE9iamVjdC1mb3JtYXR0ZWQgaWYgbmVlZGVkXFxuXFx0Ly8gKHdlIGNoZWNrIGluIGNhY2hlIGZpcnN0KVxcblxcdG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gXFxcInN0cmluZ1xcXCIgP1xcblxcdFxcdGNyZWF0ZU9wdGlvbnMoIG9wdGlvbnMgKSA6XFxuXFx0XFx0alF1ZXJ5LmV4dGVuZCgge30sIG9wdGlvbnMgKTtcXG5cXG5cXHR2YXIgLy8gRmxhZyB0byBrbm93IGlmIGxpc3QgaXMgY3VycmVudGx5IGZpcmluZ1xcblxcdFxcdGZpcmluZyxcXG5cXG5cXHRcXHQvLyBMYXN0IGZpcmUgdmFsdWUgZm9yIG5vbi1mb3JnZXR0YWJsZSBsaXN0c1xcblxcdFxcdG1lbW9yeSxcXG5cXG5cXHRcXHQvLyBGbGFnIHRvIGtub3cgaWYgbGlzdCB3YXMgYWxyZWFkeSBmaXJlZFxcblxcdFxcdGZpcmVkLFxcblxcblxcdFxcdC8vIEZsYWcgdG8gcHJldmVudCBmaXJpbmdcXG5cXHRcXHRsb2NrZWQsXFxuXFxuXFx0XFx0Ly8gQWN0dWFsIGNhbGxiYWNrIGxpc3RcXG5cXHRcXHRsaXN0ID0gW10sXFxuXFxuXFx0XFx0Ly8gUXVldWUgb2YgZXhlY3V0aW9uIGRhdGEgZm9yIHJlcGVhdGFibGUgbGlzdHNcXG5cXHRcXHRxdWV1ZSA9IFtdLFxcblxcblxcdFxcdC8vIEluZGV4IG9mIGN1cnJlbnRseSBmaXJpbmcgY2FsbGJhY2sgKG1vZGlmaWVkIGJ5IGFkZC9yZW1vdmUgYXMgbmVlZGVkKVxcblxcdFxcdGZpcmluZ0luZGV4ID0gLTEsXFxuXFxuXFx0XFx0Ly8gRmlyZSBjYWxsYmFja3NcXG5cXHRcXHRmaXJlID0gZnVuY3Rpb24oKSB7XFxuXFxuXFx0XFx0XFx0Ly8gRW5mb3JjZSBzaW5nbGUtZmlyaW5nXFxuXFx0XFx0XFx0bG9ja2VkID0gbG9ja2VkIHx8IG9wdGlvbnMub25jZTtcXG5cXG5cXHRcXHRcXHQvLyBFeGVjdXRlIGNhbGxiYWNrcyBmb3IgYWxsIHBlbmRpbmcgZXhlY3V0aW9ucyxcXG5cXHRcXHRcXHQvLyByZXNwZWN0aW5nIGZpcmluZ0luZGV4IG92ZXJyaWRlcyBhbmQgcnVudGltZSBjaGFuZ2VzXFxuXFx0XFx0XFx0ZmlyZWQgPSBmaXJpbmcgPSB0cnVlO1xcblxcdFxcdFxcdGZvciAoIDsgcXVldWUubGVuZ3RoOyBmaXJpbmdJbmRleCA9IC0xICkge1xcblxcdFxcdFxcdFxcdG1lbW9yeSA9IHF1ZXVlLnNoaWZ0KCk7XFxuXFx0XFx0XFx0XFx0d2hpbGUgKCArK2ZpcmluZ0luZGV4IDwgbGlzdC5sZW5ndGggKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gUnVuIGNhbGxiYWNrIGFuZCBjaGVjayBmb3IgZWFybHkgdGVybWluYXRpb25cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGxpc3RbIGZpcmluZ0luZGV4IF0uYXBwbHkoIG1lbW9yeVsgMCBdLCBtZW1vcnlbIDEgXSApID09PSBmYWxzZSAmJlxcblxcdFxcdFxcdFxcdFxcdFxcdG9wdGlvbnMuc3RvcE9uRmFsc2UgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gSnVtcCB0byBlbmQgYW5kIGZvcmdldCB0aGUgZGF0YSBzbyAuYWRkIGRvZXNuJ3QgcmUtZmlyZVxcblxcdFxcdFxcdFxcdFxcdFxcdGZpcmluZ0luZGV4ID0gbGlzdC5sZW5ndGg7XFxuXFx0XFx0XFx0XFx0XFx0XFx0bWVtb3J5ID0gZmFsc2U7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gRm9yZ2V0IHRoZSBkYXRhIGlmIHdlJ3JlIGRvbmUgd2l0aCBpdFxcblxcdFxcdFxcdGlmICggIW9wdGlvbnMubWVtb3J5ICkge1xcblxcdFxcdFxcdFxcdG1lbW9yeSA9IGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRmaXJpbmcgPSBmYWxzZTtcXG5cXG5cXHRcXHRcXHQvLyBDbGVhbiB1cCBpZiB3ZSdyZSBkb25lIGZpcmluZyBmb3IgZ29vZFxcblxcdFxcdFxcdGlmICggbG9ja2VkICkge1xcblxcblxcdFxcdFxcdFxcdC8vIEtlZXAgYW4gZW1wdHkgbGlzdCBpZiB3ZSBoYXZlIGRhdGEgZm9yIGZ1dHVyZSBhZGQgY2FsbHNcXG5cXHRcXHRcXHRcXHRpZiAoIG1lbW9yeSApIHtcXG5cXHRcXHRcXHRcXHRcXHRsaXN0ID0gW107XFxuXFxuXFx0XFx0XFx0XFx0Ly8gT3RoZXJ3aXNlLCB0aGlzIG9iamVjdCBpcyBzcGVudFxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0bGlzdCA9IFxcXCJcXFwiO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvLyBBY3R1YWwgQ2FsbGJhY2tzIG9iamVjdFxcblxcdFxcdHNlbGYgPSB7XFxuXFxuXFx0XFx0XFx0Ly8gQWRkIGEgY2FsbGJhY2sgb3IgYSBjb2xsZWN0aW9uIG9mIGNhbGxiYWNrcyB0byB0aGUgbGlzdFxcblxcdFxcdFxcdGFkZDogZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCBsaXN0ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIElmIHdlIGhhdmUgbWVtb3J5IGZyb20gYSBwYXN0IHJ1biwgd2Ugc2hvdWxkIGZpcmUgYWZ0ZXIgYWRkaW5nXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBtZW1vcnkgJiYgIWZpcmluZyApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRmaXJpbmdJbmRleCA9IGxpc3QubGVuZ3RoIC0gMTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRxdWV1ZS5wdXNoKCBtZW1vcnkgKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0KCBmdW5jdGlvbiBhZGQoIGFyZ3MgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0alF1ZXJ5LmVhY2goIGFyZ3MsIGZ1bmN0aW9uKCBfLCBhcmcgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBpc0Z1bmN0aW9uKCBhcmcgKSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoICFvcHRpb25zLnVuaXF1ZSB8fCAhc2VsZi5oYXMoIGFyZyApICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGxpc3QucHVzaCggYXJnICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoIGFyZyAmJiBhcmcubGVuZ3RoICYmIHRvVHlwZSggYXJnICkgIT09IFxcXCJzdHJpbmdcXFwiICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIEluc3BlY3QgcmVjdXJzaXZlbHlcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRhZGQoIGFyZyApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR9ICk7XFxuXFx0XFx0XFx0XFx0XFx0fSApKCBhcmd1bWVudHMgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIG1lbW9yeSAmJiAhZmlyaW5nICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGZpcmUoKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0Ly8gUmVtb3ZlIGEgY2FsbGJhY2sgZnJvbSB0aGUgbGlzdFxcblxcdFxcdFxcdHJlbW92ZTogZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0alF1ZXJ5LmVhY2goIGFyZ3VtZW50cywgZnVuY3Rpb24oIF8sIGFyZyApIHtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgaW5kZXg7XFxuXFx0XFx0XFx0XFx0XFx0d2hpbGUgKCAoIGluZGV4ID0galF1ZXJ5LmluQXJyYXkoIGFyZywgbGlzdCwgaW5kZXggKSApID4gLTEgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0bGlzdC5zcGxpY2UoIGluZGV4LCAxICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gSGFuZGxlIGZpcmluZyBpbmRleGVzXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBpbmRleCA8PSBmaXJpbmdJbmRleCApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRmaXJpbmdJbmRleC0tO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fSApO1xcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0Ly8gQ2hlY2sgaWYgYSBnaXZlbiBjYWxsYmFjayBpcyBpbiB0aGUgbGlzdC5cXG5cXHRcXHRcXHQvLyBJZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgcmV0dXJuIHdoZXRoZXIgb3Igbm90IGxpc3QgaGFzIGNhbGxiYWNrcyBhdHRhY2hlZC5cXG5cXHRcXHRcXHRoYXM6IGZ1bmN0aW9uKCBmbiApIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZm4gP1xcblxcdFxcdFxcdFxcdFxcdGpRdWVyeS5pbkFycmF5KCBmbiwgbGlzdCApID4gLTEgOlxcblxcdFxcdFxcdFxcdFxcdGxpc3QubGVuZ3RoID4gMDtcXG5cXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdC8vIFJlbW92ZSBhbGwgY2FsbGJhY2tzIGZyb20gdGhlIGxpc3RcXG5cXHRcXHRcXHRlbXB0eTogZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCBsaXN0ICkge1xcblxcdFxcdFxcdFxcdFxcdGxpc3QgPSBbXTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHQvLyBEaXNhYmxlIC5maXJlIGFuZCAuYWRkXFxuXFx0XFx0XFx0Ly8gQWJvcnQgYW55IGN1cnJlbnQvcGVuZGluZyBleGVjdXRpb25zXFxuXFx0XFx0XFx0Ly8gQ2xlYXIgYWxsIGNhbGxiYWNrcyBhbmQgdmFsdWVzXFxuXFx0XFx0XFx0ZGlzYWJsZTogZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0bG9ja2VkID0gcXVldWUgPSBbXTtcXG5cXHRcXHRcXHRcXHRsaXN0ID0gbWVtb3J5ID0gXFxcIlxcXCI7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRkaXNhYmxlZDogZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuICFsaXN0O1xcblxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0Ly8gRGlzYWJsZSAuZmlyZVxcblxcdFxcdFxcdC8vIEFsc28gZGlzYWJsZSAuYWRkIHVubGVzcyB3ZSBoYXZlIG1lbW9yeSAoc2luY2UgaXQgd291bGQgaGF2ZSBubyBlZmZlY3QpXFxuXFx0XFx0XFx0Ly8gQWJvcnQgYW55IHBlbmRpbmcgZXhlY3V0aW9uc1xcblxcdFxcdFxcdGxvY2s6IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdGxvY2tlZCA9IHF1ZXVlID0gW107XFxuXFx0XFx0XFx0XFx0aWYgKCAhbWVtb3J5ICYmICFmaXJpbmcgKSB7XFxuXFx0XFx0XFx0XFx0XFx0bGlzdCA9IG1lbW9yeSA9IFxcXCJcXFwiO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXHRcXHRcXHR9LFxcblxcdFxcdFxcdGxvY2tlZDogZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuICEhbG9ja2VkO1xcblxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0Ly8gQ2FsbCBhbGwgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGNvbnRleHQgYW5kIGFyZ3VtZW50c1xcblxcdFxcdFxcdGZpcmVXaXRoOiBmdW5jdGlvbiggY29udGV4dCwgYXJncyApIHtcXG5cXHRcXHRcXHRcXHRpZiAoICFsb2NrZWQgKSB7XFxuXFx0XFx0XFx0XFx0XFx0YXJncyA9IGFyZ3MgfHwgW107XFxuXFx0XFx0XFx0XFx0XFx0YXJncyA9IFsgY29udGV4dCwgYXJncy5zbGljZSA/IGFyZ3Muc2xpY2UoKSA6IGFyZ3MgXTtcXG5cXHRcXHRcXHRcXHRcXHRxdWV1ZS5wdXNoKCBhcmdzICk7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCAhZmlyaW5nICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGZpcmUoKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0Ly8gQ2FsbCBhbGwgdGhlIGNhbGxiYWNrcyB3aXRoIHRoZSBnaXZlbiBhcmd1bWVudHNcXG5cXHRcXHRcXHRmaXJlOiBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRzZWxmLmZpcmVXaXRoKCB0aGlzLCBhcmd1bWVudHMgKTtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdC8vIFRvIGtub3cgaWYgdGhlIGNhbGxiYWNrcyBoYXZlIGFscmVhZHkgYmVlbiBjYWxsZWQgYXQgbGVhc3Qgb25jZVxcblxcdFxcdFxcdGZpcmVkOiBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gISFmaXJlZDtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fTtcXG5cXG5cXHRyZXR1cm4gc2VsZjtcXG59O1xcblxcblxcbmZ1bmN0aW9uIElkZW50aXR5KCB2ICkge1xcblxcdHJldHVybiB2O1xcbn1cXG5mdW5jdGlvbiBUaHJvd2VyKCBleCApIHtcXG5cXHR0aHJvdyBleDtcXG59XFxuXFxuZnVuY3Rpb24gYWRvcHRWYWx1ZSggdmFsdWUsIHJlc29sdmUsIHJlamVjdCwgbm9WYWx1ZSApIHtcXG5cXHR2YXIgbWV0aG9kO1xcblxcblxcdHRyeSB7XFxuXFxuXFx0XFx0Ly8gQ2hlY2sgZm9yIHByb21pc2UgYXNwZWN0IGZpcnN0IHRvIHByaXZpbGVnZSBzeW5jaHJvbm91cyBiZWhhdmlvclxcblxcdFxcdGlmICggdmFsdWUgJiYgaXNGdW5jdGlvbiggKCBtZXRob2QgPSB2YWx1ZS5wcm9taXNlICkgKSApIHtcXG5cXHRcXHRcXHRtZXRob2QuY2FsbCggdmFsdWUgKS5kb25lKCByZXNvbHZlICkuZmFpbCggcmVqZWN0ICk7XFxuXFxuXFx0XFx0Ly8gT3RoZXIgdGhlbmFibGVzXFxuXFx0XFx0fSBlbHNlIGlmICggdmFsdWUgJiYgaXNGdW5jdGlvbiggKCBtZXRob2QgPSB2YWx1ZS50aGVuICkgKSApIHtcXG5cXHRcXHRcXHRtZXRob2QuY2FsbCggdmFsdWUsIHJlc29sdmUsIHJlamVjdCApO1xcblxcblxcdFxcdC8vIE90aGVyIG5vbi10aGVuYWJsZXNcXG5cXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdC8vIENvbnRyb2wgYHJlc29sdmVgIGFyZ3VtZW50cyBieSBsZXR0aW5nIEFycmF5I3NsaWNlIGNhc3QgYm9vbGVhbiBgbm9WYWx1ZWAgdG8gaW50ZWdlcjpcXG5cXHRcXHRcXHQvLyAqIGZhbHNlOiBbIHZhbHVlIF0uc2xpY2UoIDAgKSA9PiByZXNvbHZlKCB2YWx1ZSApXFxuXFx0XFx0XFx0Ly8gKiB0cnVlOiBbIHZhbHVlIF0uc2xpY2UoIDEgKSA9PiByZXNvbHZlKClcXG5cXHRcXHRcXHRyZXNvbHZlLmFwcGx5KCB1bmRlZmluZWQsIFsgdmFsdWUgXS5zbGljZSggbm9WYWx1ZSApICk7XFxuXFx0XFx0fVxcblxcblxcdC8vIEZvciBQcm9taXNlcy9BKywgY29udmVydCBleGNlcHRpb25zIGludG8gcmVqZWN0aW9uc1xcblxcdC8vIFNpbmNlIGpRdWVyeS53aGVuIGRvZXNuJ3QgdW53cmFwIHRoZW5hYmxlcywgd2UgY2FuIHNraXAgdGhlIGV4dHJhIGNoZWNrcyBhcHBlYXJpbmcgaW5cXG5cXHQvLyBEZWZlcnJlZCN0aGVuIHRvIGNvbmRpdGlvbmFsbHkgc3VwcHJlc3MgcmVqZWN0aW9uLlxcblxcdH0gY2F0Y2ggKCB2YWx1ZSApIHtcXG5cXG5cXHRcXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCBvbmx5XFxuXFx0XFx0Ly8gU3RyaWN0IG1vZGUgZnVuY3Rpb25zIGludm9rZWQgd2l0aG91dCAuY2FsbC8uYXBwbHkgZ2V0IGdsb2JhbC1vYmplY3QgY29udGV4dFxcblxcdFxcdHJlamVjdC5hcHBseSggdW5kZWZpbmVkLCBbIHZhbHVlIF0gKTtcXG5cXHR9XFxufVxcblxcbmpRdWVyeS5leHRlbmQoIHtcXG5cXG5cXHREZWZlcnJlZDogZnVuY3Rpb24oIGZ1bmMgKSB7XFxuXFx0XFx0dmFyIHR1cGxlcyA9IFtcXG5cXG5cXHRcXHRcXHRcXHQvLyBhY3Rpb24sIGFkZCBsaXN0ZW5lciwgY2FsbGJhY2tzLFxcblxcdFxcdFxcdFxcdC8vIC4uLiAudGhlbiBoYW5kbGVycywgYXJndW1lbnQgaW5kZXgsIFtmaW5hbCBzdGF0ZV1cXG5cXHRcXHRcXHRcXHRbIFxcXCJub3RpZnlcXFwiLCBcXFwicHJvZ3Jlc3NcXFwiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcXFwibWVtb3J5XFxcIiApLFxcblxcdFxcdFxcdFxcdFxcdGpRdWVyeS5DYWxsYmFja3MoIFxcXCJtZW1vcnlcXFwiICksIDIgXSxcXG5cXHRcXHRcXHRcXHRbIFxcXCJyZXNvbHZlXFxcIiwgXFxcImRvbmVcXFwiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcXFwib25jZSBtZW1vcnlcXFwiICksXFxuXFx0XFx0XFx0XFx0XFx0alF1ZXJ5LkNhbGxiYWNrcyggXFxcIm9uY2UgbWVtb3J5XFxcIiApLCAwLCBcXFwicmVzb2x2ZWRcXFwiIF0sXFxuXFx0XFx0XFx0XFx0WyBcXFwicmVqZWN0XFxcIiwgXFxcImZhaWxcXFwiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcXFwib25jZSBtZW1vcnlcXFwiICksXFxuXFx0XFx0XFx0XFx0XFx0alF1ZXJ5LkNhbGxiYWNrcyggXFxcIm9uY2UgbWVtb3J5XFxcIiApLCAxLCBcXFwicmVqZWN0ZWRcXFwiIF1cXG5cXHRcXHRcXHRdLFxcblxcdFxcdFxcdHN0YXRlID0gXFxcInBlbmRpbmdcXFwiLFxcblxcdFxcdFxcdHByb21pc2UgPSB7XFxuXFx0XFx0XFx0XFx0c3RhdGU6IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBzdGF0ZTtcXG5cXHRcXHRcXHRcXHR9LFxcblxcdFxcdFxcdFxcdGFsd2F5czogZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZGVmZXJyZWQuZG9uZSggYXJndW1lbnRzICkuZmFpbCggYXJndW1lbnRzICk7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFx0XFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRcXHRcXFwiY2F0Y2hcXFwiOiBmdW5jdGlvbiggZm4gKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHByb21pc2UudGhlbiggbnVsbCwgZm4gKTtcXG5cXHRcXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdFxcdC8vIEtlZXAgcGlwZSBmb3IgYmFjay1jb21wYXRcXG5cXHRcXHRcXHRcXHRwaXBlOiBmdW5jdGlvbiggLyogZm5Eb25lLCBmbkZhaWwsIGZuUHJvZ3Jlc3MgKi8gKSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIGZucyA9IGFyZ3VtZW50cztcXG5cXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4galF1ZXJ5LkRlZmVycmVkKCBmdW5jdGlvbiggbmV3RGVmZXIgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0alF1ZXJ5LmVhY2goIHR1cGxlcywgZnVuY3Rpb24oIGksIHR1cGxlICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIE1hcCB0dXBsZXMgKHByb2dyZXNzLCBkb25lLCBmYWlsKSB0byBhcmd1bWVudHMgKGRvbmUsIGZhaWwsIHByb2dyZXNzKVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZhciBmbiA9IGlzRnVuY3Rpb24oIGZuc1sgdHVwbGVbIDQgXSBdICkgJiYgZm5zWyB0dXBsZVsgNCBdIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gZGVmZXJyZWQucHJvZ3Jlc3MoZnVuY3Rpb24oKSB7IGJpbmQgdG8gbmV3RGVmZXIgb3IgbmV3RGVmZXIubm90aWZ5IH0pXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gZGVmZXJyZWQuZG9uZShmdW5jdGlvbigpIHsgYmluZCB0byBuZXdEZWZlciBvciBuZXdEZWZlci5yZXNvbHZlIH0pXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gZGVmZXJyZWQuZmFpbChmdW5jdGlvbigpIHsgYmluZCB0byBuZXdEZWZlciBvciBuZXdEZWZlci5yZWplY3QgfSlcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRkZWZlcnJlZFsgdHVwbGVbIDEgXSBdKCBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR2YXIgcmV0dXJuZWQgPSBmbiAmJiBmbi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCByZXR1cm5lZCAmJiBpc0Z1bmN0aW9uKCByZXR1cm5lZC5wcm9taXNlICkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuZWQucHJvbWlzZSgpXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0LnByb2dyZXNzKCBuZXdEZWZlci5ub3RpZnkgKVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC5kb25lKCBuZXdEZWZlci5yZXNvbHZlIClcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQuZmFpbCggbmV3RGVmZXIucmVqZWN0ICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRuZXdEZWZlclsgdHVwbGVbIDAgXSArIFxcXCJXaXRoXFxcIiBdKFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoaXMsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Zm4gPyBbIHJldHVybmVkIF0gOiBhcmd1bWVudHNcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9ICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fSApO1xcblxcdFxcdFxcdFxcdFxcdFxcdGZucyA9IG51bGw7XFxuXFx0XFx0XFx0XFx0XFx0fSApLnByb21pc2UoKTtcXG5cXHRcXHRcXHRcXHR9LFxcblxcdFxcdFxcdFxcdHRoZW46IGZ1bmN0aW9uKCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgb25Qcm9ncmVzcyApIHtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgbWF4RGVwdGggPSAwO1xcblxcdFxcdFxcdFxcdFxcdGZ1bmN0aW9uIHJlc29sdmUoIGRlcHRoLCBkZWZlcnJlZCwgaGFuZGxlciwgc3BlY2lhbCApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dmFyIHRoYXQgPSB0aGlzLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGFyZ3MgPSBhcmd1bWVudHMsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bWlnaHRUaHJvdyA9IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHZhciByZXR1cm5lZCwgdGhlbjtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuM1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTU5XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gSWdub3JlIGRvdWJsZS1yZXNvbHV0aW9uIGF0dGVtcHRzXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBkZXB0aCA8IG1heERlcHRoICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuZWQgPSBoYW5kbGVyLmFwcGx5KCB0aGF0LCBhcmdzICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTQ4XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCByZXR1cm5lZCA9PT0gZGVmZXJyZWQucHJvbWlzZSgpICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHRocm93IG5ldyBUeXBlRXJyb3IoIFxcXCJUaGVuYWJsZSBzZWxmLXJlc29sdXRpb25cXFwiICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb25zIDIuMy4zLjEsIDMuNVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTU0XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNzVcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBSZXRyaWV2ZSBgdGhlbmAgb25seSBvbmNlXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhlbiA9IHJldHVybmVkICYmXFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuNFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTY0XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gT25seSBjaGVjayBvYmplY3RzIGFuZCBmdW5jdGlvbnMgZm9yIHRoZW5hYmlsaXR5XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0KCB0eXBlb2YgcmV0dXJuZWQgPT09IFxcXCJvYmplY3RcXFwiIHx8XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dHlwZW9mIHJldHVybmVkID09PSBcXFwiZnVuY3Rpb25cXFwiICkgJiZcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm5lZC50aGVuO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIEhhbmRsZSBhIHJldHVybmVkIHRoZW5hYmxlXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBpc0Z1bmN0aW9uKCB0aGVuICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gU3BlY2lhbCBwcm9jZXNzb3JzIChub3RpZnkpIGp1c3Qgd2FpdCBmb3IgcmVzb2x1dGlvblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggc3BlY2lhbCApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGVuLmNhbGwoXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuZWQsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSwgc3BlY2lhbCApLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgVGhyb3dlciwgc3BlY2lhbCApXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0KTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBOb3JtYWwgcHJvY2Vzc29ycyAocmVzb2x2ZSkgYWxzbyBob29rIGludG8gcHJvZ3Jlc3NcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIC4uLmFuZCBkaXNyZWdhcmQgb2xkZXIgcmVzb2x1dGlvbiB2YWx1ZXNcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRtYXhEZXB0aCsrO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoZW4uY2FsbChcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm5lZCxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIElkZW50aXR5LCBzcGVjaWFsICksXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBUaHJvd2VyLCBzcGVjaWFsICksXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkZWZlcnJlZC5ub3RpZnlXaXRoIClcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBIYW5kbGUgYWxsIG90aGVyIHJldHVybmVkIHZhbHVlc1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gT25seSBzdWJzdGl0dXRlIGhhbmRsZXJzIHBhc3Mgb24gY29udGV4dFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIGFuZCBtdWx0aXBsZSB2YWx1ZXMgKG5vbi1zcGVjIGJlaGF2aW9yKVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggaGFuZGxlciAhPT0gSWRlbnRpdHkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhhdCA9IHVuZGVmaW5lZDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRhcmdzID0gWyByZXR1cm5lZCBdO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBQcm9jZXNzIHRoZSB2YWx1ZShzKVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIERlZmF1bHQgcHJvY2VzcyBpcyByZXNvbHZlXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0KCBzcGVjaWFsIHx8IGRlZmVycmVkLnJlc29sdmVXaXRoICkoIHRoYXQsIGFyZ3MgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBPbmx5IG5vcm1hbCBwcm9jZXNzb3JzIChyZXNvbHZlKSBjYXRjaCBhbmQgcmVqZWN0IGV4Y2VwdGlvbnNcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRwcm9jZXNzID0gc3BlY2lhbCA/XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bWlnaHRUaHJvdyA6XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dHJ5IHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRtaWdodFRocm93KCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fSBjYXRjaCAoIGUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBqUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRqUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayggZSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRwcm9jZXNzLnN0YWNrVHJhY2UgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMy4zLjQuMVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTYxXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gSWdub3JlIHBvc3QtcmVzb2x1dGlvbiBleGNlcHRpb25zXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBkZXB0aCArIDEgPj0gbWF4RGVwdGggKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gT25seSBzdWJzdGl0dXRlIGhhbmRsZXJzIHBhc3Mgb24gY29udGV4dFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIGFuZCBtdWx0aXBsZSB2YWx1ZXMgKG5vbi1zcGVjIGJlaGF2aW9yKVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggaGFuZGxlciAhPT0gVGhyb3dlciApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGF0ID0gdW5kZWZpbmVkO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGFyZ3MgPSBbIGUgXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggdGhhdCwgYXJncyApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuMVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTU3XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gUmUtcmVzb2x2ZSBwcm9taXNlcyBpbW1lZGlhdGVseSB0byBkb2RnZSBmYWxzZSByZWplY3Rpb24gZnJvbVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIHN1YnNlcXVlbnQgZXJyb3JzXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBkZXB0aCApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRwcm9jZXNzKCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBDYWxsIGFuIG9wdGlvbmFsIGhvb2sgdG8gcmVjb3JkIHRoZSBzdGFjaywgaW4gY2FzZSBvZiBleGNlcHRpb25cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBzaW5jZSBpdCdzIG90aGVyd2lzZSBsb3N0IHdoZW4gZXhlY3V0aW9uIGdvZXMgYXN5bmNcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGpRdWVyeS5EZWZlcnJlZC5nZXRTdGFja0hvb2sgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cHJvY2Vzcy5zdGFja1RyYWNlID0galF1ZXJ5LkRlZmVycmVkLmdldFN0YWNrSG9vaygpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR3aW5kb3cuc2V0VGltZW91dCggcHJvY2VzcyApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR9O1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4galF1ZXJ5LkRlZmVycmVkKCBmdW5jdGlvbiggbmV3RGVmZXIgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gcHJvZ3Jlc3NfaGFuZGxlcnMuYWRkKCAuLi4gKVxcblxcdFxcdFxcdFxcdFxcdFxcdHR1cGxlc1sgMCBdWyAzIF0uYWRkKFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJlc29sdmUoXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0MCxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRuZXdEZWZlcixcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpc0Z1bmN0aW9uKCBvblByb2dyZXNzICkgP1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG9uUHJvZ3Jlc3MgOlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdElkZW50aXR5LFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG5ld0RlZmVyLm5vdGlmeVdpdGhcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQpXFxuXFx0XFx0XFx0XFx0XFx0XFx0KTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBmdWxmaWxsZWRfaGFuZGxlcnMuYWRkKCAuLi4gKVxcblxcdFxcdFxcdFxcdFxcdFxcdHR1cGxlc1sgMSBdWyAzIF0uYWRkKFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJlc29sdmUoXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0MCxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRuZXdEZWZlcixcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpc0Z1bmN0aW9uKCBvbkZ1bGZpbGxlZCApID9cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRvbkZ1bGZpbGxlZCA6XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0SWRlbnRpdHlcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQpXFxuXFx0XFx0XFx0XFx0XFx0XFx0KTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyByZWplY3RlZF9oYW5kbGVycy5hZGQoIC4uLiApXFxuXFx0XFx0XFx0XFx0XFx0XFx0dHVwbGVzWyAyIF1bIDMgXS5hZGQoXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmVzb2x2ZShcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQwLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG5ld0RlZmVyLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlzRnVuY3Rpb24oIG9uUmVqZWN0ZWQgKSA/XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0b25SZWplY3RlZCA6XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0VGhyb3dlclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdClcXG5cXHRcXHRcXHRcXHRcXHRcXHQpO1xcblxcdFxcdFxcdFxcdFxcdH0gKS5wcm9taXNlKCk7XFxuXFx0XFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHRcXHQvLyBHZXQgYSBwcm9taXNlIGZvciB0aGlzIGRlZmVycmVkXFxuXFx0XFx0XFx0XFx0Ly8gSWYgb2JqIGlzIHByb3ZpZGVkLCB0aGUgcHJvbWlzZSBhc3BlY3QgaXMgYWRkZWQgdG8gdGhlIG9iamVjdFxcblxcdFxcdFxcdFxcdHByb21pc2U6IGZ1bmN0aW9uKCBvYmogKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIG9iaiAhPSBudWxsID8galF1ZXJ5LmV4dGVuZCggb2JqLCBwcm9taXNlICkgOiBwcm9taXNlO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LFxcblxcdFxcdFxcdGRlZmVycmVkID0ge307XFxuXFxuXFx0XFx0Ly8gQWRkIGxpc3Qtc3BlY2lmaWMgbWV0aG9kc1xcblxcdFxcdGpRdWVyeS5lYWNoKCB0dXBsZXMsIGZ1bmN0aW9uKCBpLCB0dXBsZSApIHtcXG5cXHRcXHRcXHR2YXIgbGlzdCA9IHR1cGxlWyAyIF0sXFxuXFx0XFx0XFx0XFx0c3RhdGVTdHJpbmcgPSB0dXBsZVsgNSBdO1xcblxcblxcdFxcdFxcdC8vIHByb21pc2UucHJvZ3Jlc3MgPSBsaXN0LmFkZFxcblxcdFxcdFxcdC8vIHByb21pc2UuZG9uZSA9IGxpc3QuYWRkXFxuXFx0XFx0XFx0Ly8gcHJvbWlzZS5mYWlsID0gbGlzdC5hZGRcXG5cXHRcXHRcXHRwcm9taXNlWyB0dXBsZVsgMSBdIF0gPSBsaXN0LmFkZDtcXG5cXG5cXHRcXHRcXHQvLyBIYW5kbGUgc3RhdGVcXG5cXHRcXHRcXHRpZiAoIHN0YXRlU3RyaW5nICkge1xcblxcdFxcdFxcdFxcdGxpc3QuYWRkKFxcblxcdFxcdFxcdFxcdFxcdGZ1bmN0aW9uKCkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIHN0YXRlID0gXFxcInJlc29sdmVkXFxcIiAoaS5lLiwgZnVsZmlsbGVkKVxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIHN0YXRlID0gXFxcInJlamVjdGVkXFxcIlxcblxcdFxcdFxcdFxcdFxcdFxcdHN0YXRlID0gc3RhdGVTdHJpbmc7XFxuXFx0XFx0XFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyByZWplY3RlZF9jYWxsYmFja3MuZGlzYWJsZVxcblxcdFxcdFxcdFxcdFxcdC8vIGZ1bGZpbGxlZF9jYWxsYmFja3MuZGlzYWJsZVxcblxcdFxcdFxcdFxcdFxcdHR1cGxlc1sgMyAtIGkgXVsgMiBdLmRpc2FibGUsXFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gcmVqZWN0ZWRfaGFuZGxlcnMuZGlzYWJsZVxcblxcdFxcdFxcdFxcdFxcdC8vIGZ1bGZpbGxlZF9oYW5kbGVycy5kaXNhYmxlXFxuXFx0XFx0XFx0XFx0XFx0dHVwbGVzWyAzIC0gaSBdWyAzIF0uZGlzYWJsZSxcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBwcm9ncmVzc19jYWxsYmFja3MubG9ja1xcblxcdFxcdFxcdFxcdFxcdHR1cGxlc1sgMCBdWyAyIF0ubG9jayxcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBwcm9ncmVzc19oYW5kbGVycy5sb2NrXFxuXFx0XFx0XFx0XFx0XFx0dHVwbGVzWyAwIF1bIDMgXS5sb2NrXFxuXFx0XFx0XFx0XFx0KTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gcHJvZ3Jlc3NfaGFuZGxlcnMuZmlyZVxcblxcdFxcdFxcdC8vIGZ1bGZpbGxlZF9oYW5kbGVycy5maXJlXFxuXFx0XFx0XFx0Ly8gcmVqZWN0ZWRfaGFuZGxlcnMuZmlyZVxcblxcdFxcdFxcdGxpc3QuYWRkKCB0dXBsZVsgMyBdLmZpcmUgKTtcXG5cXG5cXHRcXHRcXHQvLyBkZWZlcnJlZC5ub3RpZnkgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQubm90aWZ5V2l0aCguLi4pIH1cXG5cXHRcXHRcXHQvLyBkZWZlcnJlZC5yZXNvbHZlID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLnJlc29sdmVXaXRoKC4uLikgfVxcblxcdFxcdFxcdC8vIGRlZmVycmVkLnJlamVjdCA9IGZ1bmN0aW9uKCkgeyBkZWZlcnJlZC5yZWplY3RXaXRoKC4uLikgfVxcblxcdFxcdFxcdGRlZmVycmVkWyB0dXBsZVsgMCBdIF0gPSBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRkZWZlcnJlZFsgdHVwbGVbIDAgXSArIFxcXCJXaXRoXFxcIiBdKCB0aGlzID09PSBkZWZlcnJlZCA/IHVuZGVmaW5lZCA6IHRoaXMsIGFyZ3VtZW50cyApO1xcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0XFx0Ly8gZGVmZXJyZWQubm90aWZ5V2l0aCA9IGxpc3QuZmlyZVdpdGhcXG5cXHRcXHRcXHQvLyBkZWZlcnJlZC5yZXNvbHZlV2l0aCA9IGxpc3QuZmlyZVdpdGhcXG5cXHRcXHRcXHQvLyBkZWZlcnJlZC5yZWplY3RXaXRoID0gbGlzdC5maXJlV2l0aFxcblxcdFxcdFxcdGRlZmVycmVkWyB0dXBsZVsgMCBdICsgXFxcIldpdGhcXFwiIF0gPSBsaXN0LmZpcmVXaXRoO1xcblxcdFxcdH0gKTtcXG5cXG5cXHRcXHQvLyBNYWtlIHRoZSBkZWZlcnJlZCBhIHByb21pc2VcXG5cXHRcXHRwcm9taXNlLnByb21pc2UoIGRlZmVycmVkICk7XFxuXFxuXFx0XFx0Ly8gQ2FsbCBnaXZlbiBmdW5jIGlmIGFueVxcblxcdFxcdGlmICggZnVuYyApIHtcXG5cXHRcXHRcXHRmdW5jLmNhbGwoIGRlZmVycmVkLCBkZWZlcnJlZCApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBBbGwgZG9uZSFcXG5cXHRcXHRyZXR1cm4gZGVmZXJyZWQ7XFxuXFx0fSxcXG5cXG5cXHQvLyBEZWZlcnJlZCBoZWxwZXJcXG5cXHR3aGVuOiBmdW5jdGlvbiggc2luZ2xlVmFsdWUgKSB7XFxuXFx0XFx0dmFyXFxuXFxuXFx0XFx0XFx0Ly8gY291bnQgb2YgdW5jb21wbGV0ZWQgc3Vib3JkaW5hdGVzXFxuXFx0XFx0XFx0cmVtYWluaW5nID0gYXJndW1lbnRzLmxlbmd0aCxcXG5cXG5cXHRcXHRcXHQvLyBjb3VudCBvZiB1bnByb2Nlc3NlZCBhcmd1bWVudHNcXG5cXHRcXHRcXHRpID0gcmVtYWluaW5nLFxcblxcblxcdFxcdFxcdC8vIHN1Ym9yZGluYXRlIGZ1bGZpbGxtZW50IGRhdGFcXG5cXHRcXHRcXHRyZXNvbHZlQ29udGV4dHMgPSBBcnJheSggaSApLFxcblxcdFxcdFxcdHJlc29sdmVWYWx1ZXMgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSxcXG5cXG5cXHRcXHRcXHQvLyB0aGUgbWFzdGVyIERlZmVycmVkXFxuXFx0XFx0XFx0bWFzdGVyID0galF1ZXJ5LkRlZmVycmVkKCksXFxuXFxuXFx0XFx0XFx0Ly8gc3Vib3JkaW5hdGUgY2FsbGJhY2sgZmFjdG9yeVxcblxcdFxcdFxcdHVwZGF0ZUZ1bmMgPSBmdW5jdGlvbiggaSApIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24oIHZhbHVlICkge1xcblxcdFxcdFxcdFxcdFxcdHJlc29sdmVDb250ZXh0c1sgaSBdID0gdGhpcztcXG5cXHRcXHRcXHRcXHRcXHRyZXNvbHZlVmFsdWVzWyBpIF0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApIDogdmFsdWU7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCAhKCAtLXJlbWFpbmluZyApICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdG1hc3Rlci5yZXNvbHZlV2l0aCggcmVzb2x2ZUNvbnRleHRzLCByZXNvbHZlVmFsdWVzICk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH07XFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHQvLyBTaW5nbGUtIGFuZCBlbXB0eSBhcmd1bWVudHMgYXJlIGFkb3B0ZWQgbGlrZSBQcm9taXNlLnJlc29sdmVcXG5cXHRcXHRpZiAoIHJlbWFpbmluZyA8PSAxICkge1xcblxcdFxcdFxcdGFkb3B0VmFsdWUoIHNpbmdsZVZhbHVlLCBtYXN0ZXIuZG9uZSggdXBkYXRlRnVuYyggaSApICkucmVzb2x2ZSwgbWFzdGVyLnJlamVjdCxcXG5cXHRcXHRcXHRcXHQhcmVtYWluaW5nICk7XFxuXFxuXFx0XFx0XFx0Ly8gVXNlIC50aGVuKCkgdG8gdW53cmFwIHNlY29uZGFyeSB0aGVuYWJsZXMgKGNmLiBnaC0zMDAwKVxcblxcdFxcdFxcdGlmICggbWFzdGVyLnN0YXRlKCkgPT09IFxcXCJwZW5kaW5nXFxcIiB8fFxcblxcdFxcdFxcdFxcdGlzRnVuY3Rpb24oIHJlc29sdmVWYWx1ZXNbIGkgXSAmJiByZXNvbHZlVmFsdWVzWyBpIF0udGhlbiApICkge1xcblxcblxcdFxcdFxcdFxcdHJldHVybiBtYXN0ZXIudGhlbigpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gTXVsdGlwbGUgYXJndW1lbnRzIGFyZSBhZ2dyZWdhdGVkIGxpa2UgUHJvbWlzZS5hbGwgYXJyYXkgZWxlbWVudHNcXG5cXHRcXHR3aGlsZSAoIGktLSApIHtcXG5cXHRcXHRcXHRhZG9wdFZhbHVlKCByZXNvbHZlVmFsdWVzWyBpIF0sIHVwZGF0ZUZ1bmMoIGkgKSwgbWFzdGVyLnJlamVjdCApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gbWFzdGVyLnByb21pc2UoKTtcXG5cXHR9XFxufSApO1xcblxcblxcbi8vIFRoZXNlIHVzdWFsbHkgaW5kaWNhdGUgYSBwcm9ncmFtbWVyIG1pc3Rha2UgZHVyaW5nIGRldmVsb3BtZW50LFxcbi8vIHdhcm4gYWJvdXQgdGhlbSBBU0FQIHJhdGhlciB0aGFuIHN3YWxsb3dpbmcgdGhlbSBieSBkZWZhdWx0LlxcbnZhciByZXJyb3JOYW1lcyA9IC9eKEV2YWx8SW50ZXJuYWx8UmFuZ2V8UmVmZXJlbmNlfFN5bnRheHxUeXBlfFVSSSlFcnJvciQvO1xcblxcbmpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rID0gZnVuY3Rpb24oIGVycm9yLCBzdGFjayApIHtcXG5cXG5cXHQvLyBTdXBwb3J0OiBJRSA4IC0gOSBvbmx5XFxuXFx0Ly8gQ29uc29sZSBleGlzdHMgd2hlbiBkZXYgdG9vbHMgYXJlIG9wZW4sIHdoaWNoIGNhbiBoYXBwZW4gYXQgYW55IHRpbWVcXG5cXHRpZiAoIHdpbmRvdy5jb25zb2xlICYmIHdpbmRvdy5jb25zb2xlLndhcm4gJiYgZXJyb3IgJiYgcmVycm9yTmFtZXMudGVzdCggZXJyb3IubmFtZSApICkge1xcblxcdFxcdHdpbmRvdy5jb25zb2xlLndhcm4oIFxcXCJqUXVlcnkuRGVmZXJyZWQgZXhjZXB0aW9uOiBcXFwiICsgZXJyb3IubWVzc2FnZSwgZXJyb3Iuc3RhY2ssIHN0YWNrICk7XFxuXFx0fVxcbn07XFxuXFxuXFxuXFxuXFxualF1ZXJ5LnJlYWR5RXhjZXB0aW9uID0gZnVuY3Rpb24oIGVycm9yICkge1xcblxcdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcXG5cXHRcXHR0aHJvdyBlcnJvcjtcXG5cXHR9ICk7XFxufTtcXG5cXG5cXG5cXG5cXG4vLyBUaGUgZGVmZXJyZWQgdXNlZCBvbiBET00gcmVhZHlcXG52YXIgcmVhZHlMaXN0ID0galF1ZXJ5LkRlZmVycmVkKCk7XFxuXFxualF1ZXJ5LmZuLnJlYWR5ID0gZnVuY3Rpb24oIGZuICkge1xcblxcblxcdHJlYWR5TGlzdFxcblxcdFxcdC50aGVuKCBmbiApXFxuXFxuXFx0XFx0Ly8gV3JhcCBqUXVlcnkucmVhZHlFeGNlcHRpb24gaW4gYSBmdW5jdGlvbiBzbyB0aGF0IHRoZSBsb29rdXBcXG5cXHRcXHQvLyBoYXBwZW5zIGF0IHRoZSB0aW1lIG9mIGVycm9yIGhhbmRsaW5nIGluc3RlYWQgb2YgY2FsbGJhY2tcXG5cXHRcXHQvLyByZWdpc3RyYXRpb24uXFxuXFx0XFx0LmNhdGNoKCBmdW5jdGlvbiggZXJyb3IgKSB7XFxuXFx0XFx0XFx0alF1ZXJ5LnJlYWR5RXhjZXB0aW9uKCBlcnJvciApO1xcblxcdFxcdH0gKTtcXG5cXG5cXHRyZXR1cm4gdGhpcztcXG59O1xcblxcbmpRdWVyeS5leHRlbmQoIHtcXG5cXG5cXHQvLyBJcyB0aGUgRE9NIHJlYWR5IHRvIGJlIHVzZWQ/IFNldCB0byB0cnVlIG9uY2UgaXQgb2NjdXJzLlxcblxcdGlzUmVhZHk6IGZhbHNlLFxcblxcblxcdC8vIEEgY291bnRlciB0byB0cmFjayBob3cgbWFueSBpdGVtcyB0byB3YWl0IGZvciBiZWZvcmVcXG5cXHQvLyB0aGUgcmVhZHkgZXZlbnQgZmlyZXMuIFNlZSAjNjc4MVxcblxcdHJlYWR5V2FpdDogMSxcXG5cXG5cXHQvLyBIYW5kbGUgd2hlbiB0aGUgRE9NIGlzIHJlYWR5XFxuXFx0cmVhZHk6IGZ1bmN0aW9uKCB3YWl0ICkge1xcblxcblxcdFxcdC8vIEFib3J0IGlmIHRoZXJlIGFyZSBwZW5kaW5nIGhvbGRzIG9yIHdlJ3JlIGFscmVhZHkgcmVhZHlcXG5cXHRcXHRpZiAoIHdhaXQgPT09IHRydWUgPyAtLWpRdWVyeS5yZWFkeVdhaXQgOiBqUXVlcnkuaXNSZWFkeSApIHtcXG5cXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIFJlbWVtYmVyIHRoYXQgdGhlIERPTSBpcyByZWFkeVxcblxcdFxcdGpRdWVyeS5pc1JlYWR5ID0gdHJ1ZTtcXG5cXG5cXHRcXHQvLyBJZiBhIG5vcm1hbCBET00gUmVhZHkgZXZlbnQgZmlyZWQsIGRlY3JlbWVudCwgYW5kIHdhaXQgaWYgbmVlZCBiZVxcblxcdFxcdGlmICggd2FpdCAhPT0gdHJ1ZSAmJiAtLWpRdWVyeS5yZWFkeVdhaXQgPiAwICkge1xcblxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gSWYgdGhlcmUgYXJlIGZ1bmN0aW9ucyBib3VuZCwgdG8gZXhlY3V0ZVxcblxcdFxcdHJlYWR5TGlzdC5yZXNvbHZlV2l0aCggZG9jdW1lbnQsIFsgalF1ZXJ5IF0gKTtcXG5cXHR9XFxufSApO1xcblxcbmpRdWVyeS5yZWFkeS50aGVuID0gcmVhZHlMaXN0LnRoZW47XFxuXFxuLy8gVGhlIHJlYWR5IGV2ZW50IGhhbmRsZXIgYW5kIHNlbGYgY2xlYW51cCBtZXRob2RcXG5mdW5jdGlvbiBjb21wbGV0ZWQoKSB7XFxuXFx0ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggXFxcIkRPTUNvbnRlbnRMb2FkZWRcXFwiLCBjb21wbGV0ZWQgKTtcXG5cXHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciggXFxcImxvYWRcXFwiLCBjb21wbGV0ZWQgKTtcXG5cXHRqUXVlcnkucmVhZHkoKTtcXG59XFxuXFxuLy8gQ2F0Y2ggY2FzZXMgd2hlcmUgJChkb2N1bWVudCkucmVhZHkoKSBpcyBjYWxsZWRcXG4vLyBhZnRlciB0aGUgYnJvd3NlciBldmVudCBoYXMgYWxyZWFkeSBvY2N1cnJlZC5cXG4vLyBTdXBwb3J0OiBJRSA8PTkgLSAxMCBvbmx5XFxuLy8gT2xkZXIgSUUgc29tZXRpbWVzIHNpZ25hbHMgXFxcImludGVyYWN0aXZlXFxcIiB0b28gc29vblxcbmlmICggZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXFxcImNvbXBsZXRlXFxcIiB8fFxcblxcdCggZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gXFxcImxvYWRpbmdcXFwiICYmICFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZG9TY3JvbGwgKSApIHtcXG5cXG5cXHQvLyBIYW5kbGUgaXQgYXN5bmNocm9ub3VzbHkgdG8gYWxsb3cgc2NyaXB0cyB0aGUgb3Bwb3J0dW5pdHkgdG8gZGVsYXkgcmVhZHlcXG5cXHR3aW5kb3cuc2V0VGltZW91dCggalF1ZXJ5LnJlYWR5ICk7XFxuXFxufSBlbHNlIHtcXG5cXG5cXHQvLyBVc2UgdGhlIGhhbmR5IGV2ZW50IGNhbGxiYWNrXFxuXFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggXFxcIkRPTUNvbnRlbnRMb2FkZWRcXFwiLCBjb21wbGV0ZWQgKTtcXG5cXG5cXHQvLyBBIGZhbGxiYWNrIHRvIHdpbmRvdy5vbmxvYWQsIHRoYXQgd2lsbCBhbHdheXMgd29ya1xcblxcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBcXFwibG9hZFxcXCIsIGNvbXBsZXRlZCApO1xcbn1cXG5cXG5cXG5cXG5cXG4vLyBNdWx0aWZ1bmN0aW9uYWwgbWV0aG9kIHRvIGdldCBhbmQgc2V0IHZhbHVlcyBvZiBhIGNvbGxlY3Rpb25cXG4vLyBUaGUgdmFsdWUvcyBjYW4gb3B0aW9uYWxseSBiZSBleGVjdXRlZCBpZiBpdCdzIGEgZnVuY3Rpb25cXG52YXIgYWNjZXNzID0gZnVuY3Rpb24oIGVsZW1zLCBmbiwga2V5LCB2YWx1ZSwgY2hhaW5hYmxlLCBlbXB0eUdldCwgcmF3ICkge1xcblxcdHZhciBpID0gMCxcXG5cXHRcXHRsZW4gPSBlbGVtcy5sZW5ndGgsXFxuXFx0XFx0YnVsayA9IGtleSA9PSBudWxsO1xcblxcblxcdC8vIFNldHMgbWFueSB2YWx1ZXNcXG5cXHRpZiAoIHRvVHlwZSgga2V5ICkgPT09IFxcXCJvYmplY3RcXFwiICkge1xcblxcdFxcdGNoYWluYWJsZSA9IHRydWU7XFxuXFx0XFx0Zm9yICggaSBpbiBrZXkgKSB7XFxuXFx0XFx0XFx0YWNjZXNzKCBlbGVtcywgZm4sIGksIGtleVsgaSBdLCB0cnVlLCBlbXB0eUdldCwgcmF3ICk7XFxuXFx0XFx0fVxcblxcblxcdC8vIFNldHMgb25lIHZhbHVlXFxuXFx0fSBlbHNlIGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcXG5cXHRcXHRjaGFpbmFibGUgPSB0cnVlO1xcblxcblxcdFxcdGlmICggIWlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XFxuXFx0XFx0XFx0cmF3ID0gdHJ1ZTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKCBidWxrICkge1xcblxcblxcdFxcdFxcdC8vIEJ1bGsgb3BlcmF0aW9ucyBydW4gYWdhaW5zdCB0aGUgZW50aXJlIHNldFxcblxcdFxcdFxcdGlmICggcmF3ICkge1xcblxcdFxcdFxcdFxcdGZuLmNhbGwoIGVsZW1zLCB2YWx1ZSApO1xcblxcdFxcdFxcdFxcdGZuID0gbnVsbDtcXG5cXG5cXHRcXHRcXHQvLyAuLi5leGNlcHQgd2hlbiBleGVjdXRpbmcgZnVuY3Rpb24gdmFsdWVzXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRidWxrID0gZm47XFxuXFx0XFx0XFx0XFx0Zm4gPSBmdW5jdGlvbiggZWxlbSwga2V5LCB2YWx1ZSApIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gYnVsay5jYWxsKCBqUXVlcnkoIGVsZW0gKSwgdmFsdWUgKTtcXG5cXHRcXHRcXHRcXHR9O1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKCBmbiApIHtcXG5cXHRcXHRcXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcXG5cXHRcXHRcXHRcXHRmbihcXG5cXHRcXHRcXHRcXHRcXHRlbGVtc1sgaSBdLCBrZXksIHJhdyA/XFxuXFx0XFx0XFx0XFx0XFx0dmFsdWUgOlxcblxcdFxcdFxcdFxcdFxcdHZhbHVlLmNhbGwoIGVsZW1zWyBpIF0sIGksIGZuKCBlbGVtc1sgaSBdLCBrZXkgKSApXFxuXFx0XFx0XFx0XFx0KTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdH1cXG5cXG5cXHRpZiAoIGNoYWluYWJsZSApIHtcXG5cXHRcXHRyZXR1cm4gZWxlbXM7XFxuXFx0fVxcblxcblxcdC8vIEdldHNcXG5cXHRpZiAoIGJ1bGsgKSB7XFxuXFx0XFx0cmV0dXJuIGZuLmNhbGwoIGVsZW1zICk7XFxuXFx0fVxcblxcblxcdHJldHVybiBsZW4gPyBmbiggZWxlbXNbIDAgXSwga2V5ICkgOiBlbXB0eUdldDtcXG59O1xcblxcblxcbi8vIE1hdGNoZXMgZGFzaGVkIHN0cmluZyBmb3IgY2FtZWxpemluZ1xcbnZhciBybXNQcmVmaXggPSAvXi1tcy0vLFxcblxcdHJkYXNoQWxwaGEgPSAvLShbYS16XSkvZztcXG5cXG4vLyBVc2VkIGJ5IGNhbWVsQ2FzZSBhcyBjYWxsYmFjayB0byByZXBsYWNlKClcXG5mdW5jdGlvbiBmY2FtZWxDYXNlKCBhbGwsIGxldHRlciApIHtcXG5cXHRyZXR1cm4gbGV0dGVyLnRvVXBwZXJDYXNlKCk7XFxufVxcblxcbi8vIENvbnZlcnQgZGFzaGVkIHRvIGNhbWVsQ2FzZTsgdXNlZCBieSB0aGUgY3NzIGFuZCBkYXRhIG1vZHVsZXNcXG4vLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSwgRWRnZSAxMiAtIDE1XFxuLy8gTWljcm9zb2Z0IGZvcmdvdCB0byBodW1wIHRoZWlyIHZlbmRvciBwcmVmaXggKCM5NTcyKVxcbmZ1bmN0aW9uIGNhbWVsQ2FzZSggc3RyaW5nICkge1xcblxcdHJldHVybiBzdHJpbmcucmVwbGFjZSggcm1zUHJlZml4LCBcXFwibXMtXFxcIiApLnJlcGxhY2UoIHJkYXNoQWxwaGEsIGZjYW1lbENhc2UgKTtcXG59XFxudmFyIGFjY2VwdERhdGEgPSBmdW5jdGlvbiggb3duZXIgKSB7XFxuXFxuXFx0Ly8gQWNjZXB0cyBvbmx5OlxcblxcdC8vICAtIE5vZGVcXG5cXHQvLyAgICAtIE5vZGUuRUxFTUVOVF9OT0RFXFxuXFx0Ly8gICAgLSBOb2RlLkRPQ1VNRU5UX05PREVcXG5cXHQvLyAgLSBPYmplY3RcXG5cXHQvLyAgICAtIEFueVxcblxcdHJldHVybiBvd25lci5ub2RlVHlwZSA9PT0gMSB8fCBvd25lci5ub2RlVHlwZSA9PT0gOSB8fCAhKCArb3duZXIubm9kZVR5cGUgKTtcXG59O1xcblxcblxcblxcblxcbmZ1bmN0aW9uIERhdGEoKSB7XFxuXFx0dGhpcy5leHBhbmRvID0galF1ZXJ5LmV4cGFuZG8gKyBEYXRhLnVpZCsrO1xcbn1cXG5cXG5EYXRhLnVpZCA9IDE7XFxuXFxuRGF0YS5wcm90b3R5cGUgPSB7XFxuXFxuXFx0Y2FjaGU6IGZ1bmN0aW9uKCBvd25lciApIHtcXG5cXG5cXHRcXHQvLyBDaGVjayBpZiB0aGUgb3duZXIgb2JqZWN0IGFscmVhZHkgaGFzIGEgY2FjaGVcXG5cXHRcXHR2YXIgdmFsdWUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XFxuXFxuXFx0XFx0Ly8gSWYgbm90LCBjcmVhdGUgb25lXFxuXFx0XFx0aWYgKCAhdmFsdWUgKSB7XFxuXFx0XFx0XFx0dmFsdWUgPSB7fTtcXG5cXG5cXHRcXHRcXHQvLyBXZSBjYW4gYWNjZXB0IGRhdGEgZm9yIG5vbi1lbGVtZW50IG5vZGVzIGluIG1vZGVybiBicm93c2VycyxcXG5cXHRcXHRcXHQvLyBidXQgd2Ugc2hvdWxkIG5vdCwgc2VlICM4MzM1LlxcblxcdFxcdFxcdC8vIEFsd2F5cyByZXR1cm4gYW4gZW1wdHkgb2JqZWN0LlxcblxcdFxcdFxcdGlmICggYWNjZXB0RGF0YSggb3duZXIgKSApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBJZiBpdCBpcyBhIG5vZGUgdW5saWtlbHkgdG8gYmUgc3RyaW5naWZ5LWVkIG9yIGxvb3BlZCBvdmVyXFxuXFx0XFx0XFx0XFx0Ly8gdXNlIHBsYWluIGFzc2lnbm1lbnRcXG5cXHRcXHRcXHRcXHRpZiAoIG93bmVyLm5vZGVUeXBlICkge1xcblxcdFxcdFxcdFxcdFxcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSA9IHZhbHVlO1xcblxcblxcdFxcdFxcdFxcdC8vIE90aGVyd2lzZSBzZWN1cmUgaXQgaW4gYSBub24tZW51bWVyYWJsZSBwcm9wZXJ0eVxcblxcdFxcdFxcdFxcdC8vIGNvbmZpZ3VyYWJsZSBtdXN0IGJlIHRydWUgdG8gYWxsb3cgdGhlIHByb3BlcnR5IHRvIGJlXFxuXFx0XFx0XFx0XFx0Ly8gZGVsZXRlZCB3aGVuIGRhdGEgaXMgcmVtb3ZlZFxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCBvd25lciwgdGhpcy5leHBhbmRvLCB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFsdWU6IHZhbHVlLFxcblxcdFxcdFxcdFxcdFxcdFxcdGNvbmZpZ3VyYWJsZTogdHJ1ZVxcblxcdFxcdFxcdFxcdFxcdH0gKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gdmFsdWU7XFxuXFx0fSxcXG5cXHRzZXQ6IGZ1bmN0aW9uKCBvd25lciwgZGF0YSwgdmFsdWUgKSB7XFxuXFx0XFx0dmFyIHByb3AsXFxuXFx0XFx0XFx0Y2FjaGUgPSB0aGlzLmNhY2hlKCBvd25lciApO1xcblxcblxcdFxcdC8vIEhhbmRsZTogWyBvd25lciwga2V5LCB2YWx1ZSBdIGFyZ3NcXG5cXHRcXHQvLyBBbHdheXMgdXNlIGNhbWVsQ2FzZSBrZXkgKGdoLTIyNTcpXFxuXFx0XFx0aWYgKCB0eXBlb2YgZGF0YSA9PT0gXFxcInN0cmluZ1xcXCIgKSB7XFxuXFx0XFx0XFx0Y2FjaGVbIGNhbWVsQ2FzZSggZGF0YSApIF0gPSB2YWx1ZTtcXG5cXG5cXHRcXHQvLyBIYW5kbGU6IFsgb3duZXIsIHsgcHJvcGVydGllcyB9IF0gYXJnc1xcblxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0Ly8gQ29weSB0aGUgcHJvcGVydGllcyBvbmUtYnktb25lIHRvIHRoZSBjYWNoZSBvYmplY3RcXG5cXHRcXHRcXHRmb3IgKCBwcm9wIGluIGRhdGEgKSB7XFxuXFx0XFx0XFx0XFx0Y2FjaGVbIGNhbWVsQ2FzZSggcHJvcCApIF0gPSBkYXRhWyBwcm9wIF07XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHRcXHRyZXR1cm4gY2FjaGU7XFxuXFx0fSxcXG5cXHRnZXQ6IGZ1bmN0aW9uKCBvd25lciwga2V5ICkge1xcblxcdFxcdHJldHVybiBrZXkgPT09IHVuZGVmaW5lZCA/XFxuXFx0XFx0XFx0dGhpcy5jYWNoZSggb3duZXIgKSA6XFxuXFxuXFx0XFx0XFx0Ly8gQWx3YXlzIHVzZSBjYW1lbENhc2Uga2V5IChnaC0yMjU3KVxcblxcdFxcdFxcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSAmJiBvd25lclsgdGhpcy5leHBhbmRvIF1bIGNhbWVsQ2FzZSgga2V5ICkgXTtcXG5cXHR9LFxcblxcdGFjY2VzczogZnVuY3Rpb24oIG93bmVyLCBrZXksIHZhbHVlICkge1xcblxcblxcdFxcdC8vIEluIGNhc2VzIHdoZXJlIGVpdGhlcjpcXG5cXHRcXHQvL1xcblxcdFxcdC8vICAgMS4gTm8ga2V5IHdhcyBzcGVjaWZpZWRcXG5cXHRcXHQvLyAgIDIuIEEgc3RyaW5nIGtleSB3YXMgc3BlY2lmaWVkLCBidXQgbm8gdmFsdWUgcHJvdmlkZWRcXG5cXHRcXHQvL1xcblxcdFxcdC8vIFRha2UgdGhlIFxcXCJyZWFkXFxcIiBwYXRoIGFuZCBhbGxvdyB0aGUgZ2V0IG1ldGhvZCB0byBkZXRlcm1pbmVcXG5cXHRcXHQvLyB3aGljaCB2YWx1ZSB0byByZXR1cm4sIHJlc3BlY3RpdmVseSBlaXRoZXI6XFxuXFx0XFx0Ly9cXG5cXHRcXHQvLyAgIDEuIFRoZSBlbnRpcmUgY2FjaGUgb2JqZWN0XFxuXFx0XFx0Ly8gICAyLiBUaGUgZGF0YSBzdG9yZWQgYXQgdGhlIGtleVxcblxcdFxcdC8vXFxuXFx0XFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCB8fFxcblxcdFxcdFxcdFxcdCggKCBrZXkgJiYgdHlwZW9mIGtleSA9PT0gXFxcInN0cmluZ1xcXCIgKSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkICkgKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuZ2V0KCBvd25lciwga2V5ICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIFdoZW4gdGhlIGtleSBpcyBub3QgYSBzdHJpbmcsIG9yIGJvdGggYSBrZXkgYW5kIHZhbHVlXFxuXFx0XFx0Ly8gYXJlIHNwZWNpZmllZCwgc2V0IG9yIGV4dGVuZCAoZXhpc3Rpbmcgb2JqZWN0cykgd2l0aCBlaXRoZXI6XFxuXFx0XFx0Ly9cXG5cXHRcXHQvLyAgIDEuIEFuIG9iamVjdCBvZiBwcm9wZXJ0aWVzXFxuXFx0XFx0Ly8gICAyLiBBIGtleSBhbmQgdmFsdWVcXG5cXHRcXHQvL1xcblxcdFxcdHRoaXMuc2V0KCBvd25lciwga2V5LCB2YWx1ZSApO1xcblxcblxcdFxcdC8vIFNpbmNlIHRoZSBcXFwic2V0XFxcIiBwYXRoIGNhbiBoYXZlIHR3byBwb3NzaWJsZSBlbnRyeSBwb2ludHNcXG5cXHRcXHQvLyByZXR1cm4gdGhlIGV4cGVjdGVkIGRhdGEgYmFzZWQgb24gd2hpY2ggcGF0aCB3YXMgdGFrZW5bKl1cXG5cXHRcXHRyZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDoga2V5O1xcblxcdH0sXFxuXFx0cmVtb3ZlOiBmdW5jdGlvbiggb3duZXIsIGtleSApIHtcXG5cXHRcXHR2YXIgaSxcXG5cXHRcXHRcXHRjYWNoZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcXG5cXG5cXHRcXHRpZiAoIGNhY2hlID09PSB1bmRlZmluZWQgKSB7XFxuXFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAoIGtleSAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdC8vIFN1cHBvcnQgYXJyYXkgb3Igc3BhY2Ugc2VwYXJhdGVkIHN0cmluZyBvZiBrZXlzXFxuXFx0XFx0XFx0aWYgKCBBcnJheS5pc0FycmF5KCBrZXkgKSApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBJZiBrZXkgaXMgYW4gYXJyYXkgb2Yga2V5cy4uLlxcblxcdFxcdFxcdFxcdC8vIFdlIGFsd2F5cyBzZXQgY2FtZWxDYXNlIGtleXMsIHNvIHJlbW92ZSB0aGF0LlxcblxcdFxcdFxcdFxcdGtleSA9IGtleS5tYXAoIGNhbWVsQ2FzZSApO1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0a2V5ID0gY2FtZWxDYXNlKCBrZXkgKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBJZiBhIGtleSB3aXRoIHRoZSBzcGFjZXMgZXhpc3RzLCB1c2UgaXQuXFxuXFx0XFx0XFx0XFx0Ly8gT3RoZXJ3aXNlLCBjcmVhdGUgYW4gYXJyYXkgYnkgbWF0Y2hpbmcgbm9uLXdoaXRlc3BhY2VcXG5cXHRcXHRcXHRcXHRrZXkgPSBrZXkgaW4gY2FjaGUgP1xcblxcdFxcdFxcdFxcdFxcdFsga2V5IF0gOlxcblxcdFxcdFxcdFxcdFxcdCgga2V5Lm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW10gKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aSA9IGtleS5sZW5ndGg7XFxuXFxuXFx0XFx0XFx0d2hpbGUgKCBpLS0gKSB7XFxuXFx0XFx0XFx0XFx0ZGVsZXRlIGNhY2hlWyBrZXlbIGkgXSBdO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gUmVtb3ZlIHRoZSBleHBhbmRvIGlmIHRoZXJlJ3Mgbm8gbW9yZSBkYXRhXFxuXFx0XFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCB8fCBqUXVlcnkuaXNFbXB0eU9iamVjdCggY2FjaGUgKSApIHtcXG5cXG5cXHRcXHRcXHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0zNSAtIDQ1XFxuXFx0XFx0XFx0Ly8gV2Via2l0ICYgQmxpbmsgcGVyZm9ybWFuY2Ugc3VmZmVycyB3aGVuIGRlbGV0aW5nIHByb3BlcnRpZXNcXG5cXHRcXHRcXHQvLyBmcm9tIERPTSBub2Rlcywgc28gc2V0IHRvIHVuZGVmaW5lZCBpbnN0ZWFkXFxuXFx0XFx0XFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9Mzc4NjA3IChidWcgcmVzdHJpY3RlZClcXG5cXHRcXHRcXHRpZiAoIG93bmVyLm5vZGVUeXBlICkge1xcblxcdFxcdFxcdFxcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdGRlbGV0ZSBvd25lclsgdGhpcy5leHBhbmRvIF07XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9LFxcblxcdGhhc0RhdGE6IGZ1bmN0aW9uKCBvd25lciApIHtcXG5cXHRcXHR2YXIgY2FjaGUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XFxuXFx0XFx0cmV0dXJuIGNhY2hlICE9PSB1bmRlZmluZWQgJiYgIWpRdWVyeS5pc0VtcHR5T2JqZWN0KCBjYWNoZSApO1xcblxcdH1cXG59O1xcbnZhciBkYXRhUHJpdiA9IG5ldyBEYXRhKCk7XFxuXFxudmFyIGRhdGFVc2VyID0gbmV3IERhdGEoKTtcXG5cXG5cXG5cXG4vL1xcdEltcGxlbWVudGF0aW9uIFN1bW1hcnlcXG4vL1xcbi8vXFx0MS4gRW5mb3JjZSBBUEkgc3VyZmFjZSBhbmQgc2VtYW50aWMgY29tcGF0aWJpbGl0eSB3aXRoIDEuOS54IGJyYW5jaFxcbi8vXFx0Mi4gSW1wcm92ZSB0aGUgbW9kdWxlJ3MgbWFpbnRhaW5hYmlsaXR5IGJ5IHJlZHVjaW5nIHRoZSBzdG9yYWdlXFxuLy9cXHRcXHRwYXRocyB0byBhIHNpbmdsZSBtZWNoYW5pc20uXFxuLy9cXHQzLiBVc2UgdGhlIHNhbWUgc2luZ2xlIG1lY2hhbmlzbSB0byBzdXBwb3J0IFxcXCJwcml2YXRlXFxcIiBhbmQgXFxcInVzZXJcXFwiIGRhdGEuXFxuLy9cXHQ0LiBfTmV2ZXJfIGV4cG9zZSBcXFwicHJpdmF0ZVxcXCIgZGF0YSB0byB1c2VyIGNvZGUgKFRPRE86IERyb3AgX2RhdGEsIF9yZW1vdmVEYXRhKVxcbi8vXFx0NS4gQXZvaWQgZXhwb3NpbmcgaW1wbGVtZW50YXRpb24gZGV0YWlscyBvbiB1c2VyIG9iamVjdHMgKGVnLiBleHBhbmRvIHByb3BlcnRpZXMpXFxuLy9cXHQ2LiBQcm92aWRlIGEgY2xlYXIgcGF0aCBmb3IgaW1wbGVtZW50YXRpb24gdXBncmFkZSB0byBXZWFrTWFwIGluIDIwMTRcXG5cXG52YXIgcmJyYWNlID0gL14oPzpcXFxce1tcXFxcd1xcXFxXXSpcXFxcfXxcXFxcW1tcXFxcd1xcXFxXXSpcXFxcXSkkLyxcXG5cXHRybXVsdGlEYXNoID0gL1tBLVpdL2c7XFxuXFxuZnVuY3Rpb24gZ2V0RGF0YSggZGF0YSApIHtcXG5cXHRpZiAoIGRhdGEgPT09IFxcXCJ0cnVlXFxcIiApIHtcXG5cXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXHR9XFxuXFxuXFx0aWYgKCBkYXRhID09PSBcXFwiZmFsc2VcXFwiICkge1xcblxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHR9XFxuXFxuXFx0aWYgKCBkYXRhID09PSBcXFwibnVsbFxcXCIgKSB7XFxuXFx0XFx0cmV0dXJuIG51bGw7XFxuXFx0fVxcblxcblxcdC8vIE9ubHkgY29udmVydCB0byBhIG51bWJlciBpZiBpdCBkb2Vzbid0IGNoYW5nZSB0aGUgc3RyaW5nXFxuXFx0aWYgKCBkYXRhID09PSArZGF0YSArIFxcXCJcXFwiICkge1xcblxcdFxcdHJldHVybiArZGF0YTtcXG5cXHR9XFxuXFxuXFx0aWYgKCByYnJhY2UudGVzdCggZGF0YSApICkge1xcblxcdFxcdHJldHVybiBKU09OLnBhcnNlKCBkYXRhICk7XFxuXFx0fVxcblxcblxcdHJldHVybiBkYXRhO1xcbn1cXG5cXG5mdW5jdGlvbiBkYXRhQXR0ciggZWxlbSwga2V5LCBkYXRhICkge1xcblxcdHZhciBuYW1lO1xcblxcblxcdC8vIElmIG5vdGhpbmcgd2FzIGZvdW5kIGludGVybmFsbHksIHRyeSB0byBmZXRjaCBhbnlcXG5cXHQvLyBkYXRhIGZyb20gdGhlIEhUTUw1IGRhdGEtKiBhdHRyaWJ1dGVcXG5cXHRpZiAoIGRhdGEgPT09IHVuZGVmaW5lZCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xcblxcdFxcdG5hbWUgPSBcXFwiZGF0YS1cXFwiICsga2V5LnJlcGxhY2UoIHJtdWx0aURhc2gsIFxcXCItJCZcXFwiICkudG9Mb3dlckNhc2UoKTtcXG5cXHRcXHRkYXRhID0gZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUgKTtcXG5cXG5cXHRcXHRpZiAoIHR5cGVvZiBkYXRhID09PSBcXFwic3RyaW5nXFxcIiApIHtcXG5cXHRcXHRcXHR0cnkge1xcblxcdFxcdFxcdFxcdGRhdGEgPSBnZXREYXRhKCBkYXRhICk7XFxuXFx0XFx0XFx0fSBjYXRjaCAoIGUgKSB7fVxcblxcblxcdFxcdFxcdC8vIE1ha2Ugc3VyZSB3ZSBzZXQgdGhlIGRhdGEgc28gaXQgaXNuJ3QgY2hhbmdlZCBsYXRlclxcblxcdFxcdFxcdGRhdGFVc2VyLnNldCggZWxlbSwga2V5LCBkYXRhICk7XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRkYXRhID0gdW5kZWZpbmVkO1xcblxcdFxcdH1cXG5cXHR9XFxuXFx0cmV0dXJuIGRhdGE7XFxufVxcblxcbmpRdWVyeS5leHRlbmQoIHtcXG5cXHRoYXNEYXRhOiBmdW5jdGlvbiggZWxlbSApIHtcXG5cXHRcXHRyZXR1cm4gZGF0YVVzZXIuaGFzRGF0YSggZWxlbSApIHx8IGRhdGFQcml2Lmhhc0RhdGEoIGVsZW0gKTtcXG5cXHR9LFxcblxcblxcdGRhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBkYXRhICkge1xcblxcdFxcdHJldHVybiBkYXRhVXNlci5hY2Nlc3MoIGVsZW0sIG5hbWUsIGRhdGEgKTtcXG5cXHR9LFxcblxcblxcdHJlbW92ZURhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xcblxcdFxcdGRhdGFVc2VyLnJlbW92ZSggZWxlbSwgbmFtZSApO1xcblxcdH0sXFxuXFxuXFx0Ly8gVE9ETzogTm93IHRoYXQgYWxsIGNhbGxzIHRvIF9kYXRhIGFuZCBfcmVtb3ZlRGF0YSBoYXZlIGJlZW4gcmVwbGFjZWRcXG5cXHQvLyB3aXRoIGRpcmVjdCBjYWxscyB0byBkYXRhUHJpdiBtZXRob2RzLCB0aGVzZSBjYW4gYmUgZGVwcmVjYXRlZC5cXG5cXHRfZGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGRhdGEgKSB7XFxuXFx0XFx0cmV0dXJuIGRhdGFQcml2LmFjY2VzcyggZWxlbSwgbmFtZSwgZGF0YSApO1xcblxcdH0sXFxuXFxuXFx0X3JlbW92ZURhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xcblxcdFxcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgbmFtZSApO1xcblxcdH1cXG59ICk7XFxuXFxualF1ZXJ5LmZuLmV4dGVuZCgge1xcblxcdGRhdGE6IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xcblxcdFxcdHZhciBpLCBuYW1lLCBkYXRhLFxcblxcdFxcdFxcdGVsZW0gPSB0aGlzWyAwIF0sXFxuXFx0XFx0XFx0YXR0cnMgPSBlbGVtICYmIGVsZW0uYXR0cmlidXRlcztcXG5cXG5cXHRcXHQvLyBHZXRzIGFsbCB2YWx1ZXNcXG5cXHRcXHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkICkge1xcblxcdFxcdFxcdGlmICggdGhpcy5sZW5ndGggKSB7XFxuXFx0XFx0XFx0XFx0ZGF0YSA9IGRhdGFVc2VyLmdldCggZWxlbSApO1xcblxcblxcdFxcdFxcdFxcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAhZGF0YVByaXYuZ2V0KCBlbGVtLCBcXFwiaGFzRGF0YUF0dHJzXFxcIiApICkge1xcblxcdFxcdFxcdFxcdFxcdGkgPSBhdHRycy5sZW5ndGg7XFxuXFx0XFx0XFx0XFx0XFx0d2hpbGUgKCBpLS0gKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gU3VwcG9ydDogSUUgMTEgb25seVxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIFRoZSBhdHRycyBlbGVtZW50cyBjYW4gYmUgbnVsbCAoIzE0ODk0KVxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggYXR0cnNbIGkgXSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRuYW1lID0gYXR0cnNbIGkgXS5uYW1lO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggbmFtZS5pbmRleE9mKCBcXFwiZGF0YS1cXFwiICkgPT09IDAgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bmFtZSA9IGNhbWVsQ2FzZSggbmFtZS5zbGljZSggNSApICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGF0YUF0dHIoIGVsZW0sIG5hbWUsIGRhdGFbIG5hbWUgXSApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGRhdGFQcml2LnNldCggZWxlbSwgXFxcImhhc0RhdGFBdHRyc1xcXCIsIHRydWUgKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBkYXRhO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBTZXRzIG11bHRpcGxlIHZhbHVlc1xcblxcdFxcdGlmICggdHlwZW9mIGtleSA9PT0gXFxcIm9iamVjdFxcXCIgKSB7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0ZGF0YVVzZXIuc2V0KCB0aGlzLCBrZXkgKTtcXG5cXHRcXHRcXHR9ICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcXG5cXHRcXHRcXHR2YXIgZGF0YTtcXG5cXG5cXHRcXHRcXHQvLyBUaGUgY2FsbGluZyBqUXVlcnkgb2JqZWN0IChlbGVtZW50IG1hdGNoZXMpIGlzIG5vdCBlbXB0eVxcblxcdFxcdFxcdC8vIChhbmQgdGhlcmVmb3JlIGhhcyBhbiBlbGVtZW50IGFwcGVhcnMgYXQgdGhpc1sgMCBdKSBhbmQgdGhlXFxuXFx0XFx0XFx0Ly8gYHZhbHVlYCBwYXJhbWV0ZXIgd2FzIG5vdCB1bmRlZmluZWQuIEFuIGVtcHR5IGpRdWVyeSBvYmplY3RcXG5cXHRcXHRcXHQvLyB3aWxsIHJlc3VsdCBpbiBgdW5kZWZpbmVkYCBmb3IgZWxlbSA9IHRoaXNbIDAgXSB3aGljaCB3aWxsXFxuXFx0XFx0XFx0Ly8gdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFuIGF0dGVtcHQgdG8gcmVhZCBhIGRhdGEgY2FjaGUgaXMgbWFkZS5cXG5cXHRcXHRcXHRpZiAoIGVsZW0gJiYgdmFsdWUgPT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBBdHRlbXB0IHRvIGdldCBkYXRhIGZyb20gdGhlIGNhY2hlXFxuXFx0XFx0XFx0XFx0Ly8gVGhlIGtleSB3aWxsIGFsd2F5cyBiZSBjYW1lbENhc2VkIGluIERhdGFcXG5cXHRcXHRcXHRcXHRkYXRhID0gZGF0YVVzZXIuZ2V0KCBlbGVtLCBrZXkgKTtcXG5cXHRcXHRcXHRcXHRpZiAoIGRhdGEgIT09IHVuZGVmaW5lZCApIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gZGF0YTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gQXR0ZW1wdCB0byBcXFwiZGlzY292ZXJcXFwiIHRoZSBkYXRhIGluXFxuXFx0XFx0XFx0XFx0Ly8gSFRNTDUgY3VzdG9tIGRhdGEtKiBhdHRyc1xcblxcdFxcdFxcdFxcdGRhdGEgPSBkYXRhQXR0ciggZWxlbSwga2V5ICk7XFxuXFx0XFx0XFx0XFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIGRhdGE7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIFdlIHRyaWVkIHJlYWxseSBoYXJkLCBidXQgdGhlIGRhdGEgZG9lc24ndCBleGlzdC5cXG5cXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIFNldCB0aGUgZGF0YS4uLlxcblxcdFxcdFxcdHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gV2UgYWx3YXlzIHN0b3JlIHRoZSBjYW1lbENhc2VkIGtleVxcblxcdFxcdFxcdFxcdGRhdGFVc2VyLnNldCggdGhpcywga2V5LCB2YWx1ZSApO1xcblxcdFxcdFxcdH0gKTtcXG5cXHRcXHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEsIG51bGwsIHRydWUgKTtcXG5cXHR9LFxcblxcblxcdHJlbW92ZURhdGE6IGZ1bmN0aW9uKCBrZXkgKSB7XFxuXFx0XFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0ZGF0YVVzZXIucmVtb3ZlKCB0aGlzLCBrZXkgKTtcXG5cXHRcXHR9ICk7XFxuXFx0fVxcbn0gKTtcXG5cXG5cXG5qUXVlcnkuZXh0ZW5kKCB7XFxuXFx0cXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBkYXRhICkge1xcblxcdFxcdHZhciBxdWV1ZTtcXG5cXG5cXHRcXHRpZiAoIGVsZW0gKSB7XFxuXFx0XFx0XFx0dHlwZSA9ICggdHlwZSB8fCBcXFwiZnhcXFwiICkgKyBcXFwicXVldWVcXFwiO1xcblxcdFxcdFxcdHF1ZXVlID0gZGF0YVByaXYuZ2V0KCBlbGVtLCB0eXBlICk7XFxuXFxuXFx0XFx0XFx0Ly8gU3BlZWQgdXAgZGVxdWV1ZSBieSBnZXR0aW5nIG91dCBxdWlja2x5IGlmIHRoaXMgaXMganVzdCBhIGxvb2t1cFxcblxcdFxcdFxcdGlmICggZGF0YSApIHtcXG5cXHRcXHRcXHRcXHRpZiAoICFxdWV1ZSB8fCBBcnJheS5pc0FycmF5KCBkYXRhICkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0cXVldWUgPSBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIHR5cGUsIGpRdWVyeS5tYWtlQXJyYXkoIGRhdGEgKSApO1xcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0cXVldWUucHVzaCggZGF0YSApO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cmV0dXJuIHF1ZXVlIHx8IFtdO1xcblxcdFxcdH1cXG5cXHR9LFxcblxcblxcdGRlcXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xcblxcdFxcdHR5cGUgPSB0eXBlIHx8IFxcXCJmeFxcXCI7XFxuXFxuXFx0XFx0dmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKCBlbGVtLCB0eXBlICksXFxuXFx0XFx0XFx0c3RhcnRMZW5ndGggPSBxdWV1ZS5sZW5ndGgsXFxuXFx0XFx0XFx0Zm4gPSBxdWV1ZS5zaGlmdCgpLFxcblxcdFxcdFxcdGhvb2tzID0galF1ZXJ5Ll9xdWV1ZUhvb2tzKCBlbGVtLCB0eXBlICksXFxuXFx0XFx0XFx0bmV4dCA9IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdGpRdWVyeS5kZXF1ZXVlKCBlbGVtLCB0eXBlICk7XFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHQvLyBJZiB0aGUgZnggcXVldWUgaXMgZGVxdWV1ZWQsIGFsd2F5cyByZW1vdmUgdGhlIHByb2dyZXNzIHNlbnRpbmVsXFxuXFx0XFx0aWYgKCBmbiA9PT0gXFxcImlucHJvZ3Jlc3NcXFwiICkge1xcblxcdFxcdFxcdGZuID0gcXVldWUuc2hpZnQoKTtcXG5cXHRcXHRcXHRzdGFydExlbmd0aC0tO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAoIGZuICkge1xcblxcblxcdFxcdFxcdC8vIEFkZCBhIHByb2dyZXNzIHNlbnRpbmVsIHRvIHByZXZlbnQgdGhlIGZ4IHF1ZXVlIGZyb20gYmVpbmdcXG5cXHRcXHRcXHQvLyBhdXRvbWF0aWNhbGx5IGRlcXVldWVkXFxuXFx0XFx0XFx0aWYgKCB0eXBlID09PSBcXFwiZnhcXFwiICkge1xcblxcdFxcdFxcdFxcdHF1ZXVlLnVuc2hpZnQoIFxcXCJpbnByb2dyZXNzXFxcIiApO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBDbGVhciB1cCB0aGUgbGFzdCBxdWV1ZSBzdG9wIGZ1bmN0aW9uXFxuXFx0XFx0XFx0ZGVsZXRlIGhvb2tzLnN0b3A7XFxuXFx0XFx0XFx0Zm4uY2FsbCggZWxlbSwgbmV4dCwgaG9va3MgKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKCAhc3RhcnRMZW5ndGggJiYgaG9va3MgKSB7XFxuXFx0XFx0XFx0aG9va3MuZW1wdHkuZmlyZSgpO1xcblxcdFxcdH1cXG5cXHR9LFxcblxcblxcdC8vIE5vdCBwdWJsaWMgLSBnZW5lcmF0ZSBhIHF1ZXVlSG9va3Mgb2JqZWN0LCBvciByZXR1cm4gdGhlIGN1cnJlbnQgb25lXFxuXFx0X3F1ZXVlSG9va3M6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xcblxcdFxcdHZhciBrZXkgPSB0eXBlICsgXFxcInF1ZXVlSG9va3NcXFwiO1xcblxcdFxcdHJldHVybiBkYXRhUHJpdi5nZXQoIGVsZW0sIGtleSApIHx8IGRhdGFQcml2LmFjY2VzcyggZWxlbSwga2V5LCB7XFxuXFx0XFx0XFx0ZW1wdHk6IGpRdWVyeS5DYWxsYmFja3MoIFxcXCJvbmNlIG1lbW9yeVxcXCIgKS5hZGQoIGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgWyB0eXBlICsgXFxcInF1ZXVlXFxcIiwga2V5IF0gKTtcXG5cXHRcXHRcXHR9IClcXG5cXHRcXHR9ICk7XFxuXFx0fVxcbn0gKTtcXG5cXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XFxuXFx0cXVldWU6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xcblxcdFxcdHZhciBzZXR0ZXIgPSAyO1xcblxcblxcdFxcdGlmICggdHlwZW9mIHR5cGUgIT09IFxcXCJzdHJpbmdcXFwiICkge1xcblxcdFxcdFxcdGRhdGEgPSB0eXBlO1xcblxcdFxcdFxcdHR5cGUgPSBcXFwiZnhcXFwiO1xcblxcdFxcdFxcdHNldHRlci0tO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPCBzZXR0ZXIgKSB7XFxuXFx0XFx0XFx0cmV0dXJuIGpRdWVyeS5xdWV1ZSggdGhpc1sgMCBdLCB0eXBlICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiBkYXRhID09PSB1bmRlZmluZWQgP1xcblxcdFxcdFxcdHRoaXMgOlxcblxcdFxcdFxcdHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0dmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKCB0aGlzLCB0eXBlLCBkYXRhICk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gRW5zdXJlIGEgaG9va3MgZm9yIHRoaXMgcXVldWVcXG5cXHRcXHRcXHRcXHRqUXVlcnkuX3F1ZXVlSG9va3MoIHRoaXMsIHR5cGUgKTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIHR5cGUgPT09IFxcXCJmeFxcXCIgJiYgcXVldWVbIDAgXSAhPT0gXFxcImlucHJvZ3Jlc3NcXFwiICkge1xcblxcdFxcdFxcdFxcdFxcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0gKTtcXG5cXHR9LFxcblxcdGRlcXVldWU6IGZ1bmN0aW9uKCB0eXBlICkge1xcblxcdFxcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XFxuXFx0XFx0fSApO1xcblxcdH0sXFxuXFx0Y2xlYXJRdWV1ZTogZnVuY3Rpb24oIHR5cGUgKSB7XFxuXFx0XFx0cmV0dXJuIHRoaXMucXVldWUoIHR5cGUgfHwgXFxcImZ4XFxcIiwgW10gKTtcXG5cXHR9LFxcblxcblxcdC8vIEdldCBhIHByb21pc2UgcmVzb2x2ZWQgd2hlbiBxdWV1ZXMgb2YgYSBjZXJ0YWluIHR5cGVcXG5cXHQvLyBhcmUgZW1wdGllZCAoZnggaXMgdGhlIHR5cGUgYnkgZGVmYXVsdClcXG5cXHRwcm9taXNlOiBmdW5jdGlvbiggdHlwZSwgb2JqICkge1xcblxcdFxcdHZhciB0bXAsXFxuXFx0XFx0XFx0Y291bnQgPSAxLFxcblxcdFxcdFxcdGRlZmVyID0galF1ZXJ5LkRlZmVycmVkKCksXFxuXFx0XFx0XFx0ZWxlbWVudHMgPSB0aGlzLFxcblxcdFxcdFxcdGkgPSB0aGlzLmxlbmd0aCxcXG5cXHRcXHRcXHRyZXNvbHZlID0gZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCAhKCAtLWNvdW50ICkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZGVmZXIucmVzb2x2ZVdpdGgoIGVsZW1lbnRzLCBbIGVsZW1lbnRzIF0gKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcXFwic3RyaW5nXFxcIiApIHtcXG5cXHRcXHRcXHRvYmogPSB0eXBlO1xcblxcdFxcdFxcdHR5cGUgPSB1bmRlZmluZWQ7XFxuXFx0XFx0fVxcblxcdFxcdHR5cGUgPSB0eXBlIHx8IFxcXCJmeFxcXCI7XFxuXFxuXFx0XFx0d2hpbGUgKCBpLS0gKSB7XFxuXFx0XFx0XFx0dG1wID0gZGF0YVByaXYuZ2V0KCBlbGVtZW50c1sgaSBdLCB0eXBlICsgXFxcInF1ZXVlSG9va3NcXFwiICk7XFxuXFx0XFx0XFx0aWYgKCB0bXAgJiYgdG1wLmVtcHR5ICkge1xcblxcdFxcdFxcdFxcdGNvdW50Kys7XFxuXFx0XFx0XFx0XFx0dG1wLmVtcHR5LmFkZCggcmVzb2x2ZSApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0XFx0cmVzb2x2ZSgpO1xcblxcdFxcdHJldHVybiBkZWZlci5wcm9taXNlKCBvYmogKTtcXG5cXHR9XFxufSApO1xcbnZhciBwbnVtID0gKCAvWystXT8oPzpcXFxcZCpcXFxcLnwpXFxcXGQrKD86W2VFXVsrLV0/XFxcXGQrfCkvICkuc291cmNlO1xcblxcbnZhciByY3NzTnVtID0gbmV3IFJlZ0V4cCggXFxcIl4oPzooWystXSk9fCkoXFxcIiArIHBudW0gKyBcXFwiKShbYS16JV0qKSRcXFwiLCBcXFwiaVxcXCIgKTtcXG5cXG5cXG52YXIgY3NzRXhwYW5kID0gWyBcXFwiVG9wXFxcIiwgXFxcIlJpZ2h0XFxcIiwgXFxcIkJvdHRvbVxcXCIsIFxcXCJMZWZ0XFxcIiBdO1xcblxcbnZhciBpc0hpZGRlbldpdGhpblRyZWUgPSBmdW5jdGlvbiggZWxlbSwgZWwgKSB7XFxuXFxuXFx0XFx0Ly8gaXNIaWRkZW5XaXRoaW5UcmVlIG1pZ2h0IGJlIGNhbGxlZCBmcm9tIGpRdWVyeSNmaWx0ZXIgZnVuY3Rpb247XFxuXFx0XFx0Ly8gaW4gdGhhdCBjYXNlLCBlbGVtZW50IHdpbGwgYmUgc2Vjb25kIGFyZ3VtZW50XFxuXFx0XFx0ZWxlbSA9IGVsIHx8IGVsZW07XFxuXFxuXFx0XFx0Ly8gSW5saW5lIHN0eWxlIHRydW1wcyBhbGxcXG5cXHRcXHRyZXR1cm4gZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcXFwibm9uZVxcXCIgfHxcXG5cXHRcXHRcXHRlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFxcXCJcXFwiICYmXFxuXFxuXFx0XFx0XFx0Ly8gT3RoZXJ3aXNlLCBjaGVjayBjb21wdXRlZCBzdHlsZVxcblxcdFxcdFxcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00MyAtIDQ1XFxuXFx0XFx0XFx0Ly8gRGlzY29ubmVjdGVkIGVsZW1lbnRzIGNhbiBoYXZlIGNvbXB1dGVkIGRpc3BsYXk6IG5vbmUsIHNvIGZpcnN0IGNvbmZpcm0gdGhhdCBlbGVtIGlzXFxuXFx0XFx0XFx0Ly8gaW4gdGhlIGRvY3VtZW50LlxcblxcdFxcdFxcdGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICkgJiZcXG5cXG5cXHRcXHRcXHRqUXVlcnkuY3NzKCBlbGVtLCBcXFwiZGlzcGxheVxcXCIgKSA9PT0gXFxcIm5vbmVcXFwiO1xcblxcdH07XFxuXFxudmFyIHN3YXAgPSBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgY2FsbGJhY2ssIGFyZ3MgKSB7XFxuXFx0dmFyIHJldCwgbmFtZSxcXG5cXHRcXHRvbGQgPSB7fTtcXG5cXG5cXHQvLyBSZW1lbWJlciB0aGUgb2xkIHZhbHVlcywgYW5kIGluc2VydCB0aGUgbmV3IG9uZXNcXG5cXHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XFxuXFx0XFx0b2xkWyBuYW1lIF0gPSBlbGVtLnN0eWxlWyBuYW1lIF07XFxuXFx0XFx0ZWxlbS5zdHlsZVsgbmFtZSBdID0gb3B0aW9uc1sgbmFtZSBdO1xcblxcdH1cXG5cXG5cXHRyZXQgPSBjYWxsYmFjay5hcHBseSggZWxlbSwgYXJncyB8fCBbXSApO1xcblxcblxcdC8vIFJldmVydCB0aGUgb2xkIHZhbHVlc1xcblxcdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcXG5cXHRcXHRlbGVtLnN0eWxlWyBuYW1lIF0gPSBvbGRbIG5hbWUgXTtcXG5cXHR9XFxuXFxuXFx0cmV0dXJuIHJldDtcXG59O1xcblxcblxcblxcblxcbmZ1bmN0aW9uIGFkanVzdENTUyggZWxlbSwgcHJvcCwgdmFsdWVQYXJ0cywgdHdlZW4gKSB7XFxuXFx0dmFyIGFkanVzdGVkLCBzY2FsZSxcXG5cXHRcXHRtYXhJdGVyYXRpb25zID0gMjAsXFxuXFx0XFx0Y3VycmVudFZhbHVlID0gdHdlZW4gP1xcblxcdFxcdFxcdGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdHJldHVybiB0d2Vlbi5jdXIoKTtcXG5cXHRcXHRcXHR9IDpcXG5cXHRcXHRcXHRmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4galF1ZXJ5LmNzcyggZWxlbSwgcHJvcCwgXFxcIlxcXCIgKTtcXG5cXHRcXHRcXHR9LFxcblxcdFxcdGluaXRpYWwgPSBjdXJyZW50VmFsdWUoKSxcXG5cXHRcXHR1bml0ID0gdmFsdWVQYXJ0cyAmJiB2YWx1ZVBhcnRzWyAzIF0gfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gPyBcXFwiXFxcIiA6IFxcXCJweFxcXCIgKSxcXG5cXG5cXHRcXHQvLyBTdGFydGluZyB2YWx1ZSBjb21wdXRhdGlvbiBpcyByZXF1aXJlZCBmb3IgcG90ZW50aWFsIHVuaXQgbWlzbWF0Y2hlc1xcblxcdFxcdGluaXRpYWxJblVuaXQgPSAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSB8fCB1bml0ICE9PSBcXFwicHhcXFwiICYmICtpbml0aWFsICkgJiZcXG5cXHRcXHRcXHRyY3NzTnVtLmV4ZWMoIGpRdWVyeS5jc3MoIGVsZW0sIHByb3AgKSApO1xcblxcblxcdGlmICggaW5pdGlhbEluVW5pdCAmJiBpbml0aWFsSW5Vbml0WyAzIF0gIT09IHVuaXQgKSB7XFxuXFxuXFx0XFx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTU0XFxuXFx0XFx0Ly8gSGFsdmUgdGhlIGl0ZXJhdGlvbiB0YXJnZXQgdmFsdWUgdG8gcHJldmVudCBpbnRlcmZlcmVuY2UgZnJvbSBDU1MgdXBwZXIgYm91bmRzIChnaC0yMTQ0KVxcblxcdFxcdGluaXRpYWwgPSBpbml0aWFsIC8gMjtcXG5cXG5cXHRcXHQvLyBUcnVzdCB1bml0cyByZXBvcnRlZCBieSBqUXVlcnkuY3NzXFxuXFx0XFx0dW5pdCA9IHVuaXQgfHwgaW5pdGlhbEluVW5pdFsgMyBdO1xcblxcblxcdFxcdC8vIEl0ZXJhdGl2ZWx5IGFwcHJveGltYXRlIGZyb20gYSBub256ZXJvIHN0YXJ0aW5nIHBvaW50XFxuXFx0XFx0aW5pdGlhbEluVW5pdCA9ICtpbml0aWFsIHx8IDE7XFxuXFxuXFx0XFx0d2hpbGUgKCBtYXhJdGVyYXRpb25zLS0gKSB7XFxuXFxuXFx0XFx0XFx0Ly8gRXZhbHVhdGUgYW5kIHVwZGF0ZSBvdXIgYmVzdCBndWVzcyAoZG91YmxpbmcgZ3Vlc3NlcyB0aGF0IHplcm8gb3V0KS5cXG5cXHRcXHRcXHQvLyBGaW5pc2ggaWYgdGhlIHNjYWxlIGVxdWFscyBvciBjcm9zc2VzIDEgKG1ha2luZyB0aGUgb2xkKm5ldyBwcm9kdWN0IG5vbi1wb3NpdGl2ZSkuXFxuXFx0XFx0XFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wLCBpbml0aWFsSW5Vbml0ICsgdW5pdCApO1xcblxcdFxcdFxcdGlmICggKCAxIC0gc2NhbGUgKSAqICggMSAtICggc2NhbGUgPSBjdXJyZW50VmFsdWUoKSAvIGluaXRpYWwgfHwgMC41ICkgKSA8PSAwICkge1xcblxcdFxcdFxcdFxcdG1heEl0ZXJhdGlvbnMgPSAwO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpbml0aWFsSW5Vbml0ID0gaW5pdGlhbEluVW5pdCAvIHNjYWxlO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRpbml0aWFsSW5Vbml0ID0gaW5pdGlhbEluVW5pdCAqIDI7XFxuXFx0XFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wLCBpbml0aWFsSW5Vbml0ICsgdW5pdCApO1xcblxcblxcdFxcdC8vIE1ha2Ugc3VyZSB3ZSB1cGRhdGUgdGhlIHR3ZWVuIHByb3BlcnRpZXMgbGF0ZXIgb25cXG5cXHRcXHR2YWx1ZVBhcnRzID0gdmFsdWVQYXJ0cyB8fCBbXTtcXG5cXHR9XFxuXFxuXFx0aWYgKCB2YWx1ZVBhcnRzICkge1xcblxcdFxcdGluaXRpYWxJblVuaXQgPSAraW5pdGlhbEluVW5pdCB8fCAraW5pdGlhbCB8fCAwO1xcblxcblxcdFxcdC8vIEFwcGx5IHJlbGF0aXZlIG9mZnNldCAoKz0vLT0pIGlmIHNwZWNpZmllZFxcblxcdFxcdGFkanVzdGVkID0gdmFsdWVQYXJ0c1sgMSBdID9cXG5cXHRcXHRcXHRpbml0aWFsSW5Vbml0ICsgKCB2YWx1ZVBhcnRzWyAxIF0gKyAxICkgKiB2YWx1ZVBhcnRzWyAyIF0gOlxcblxcdFxcdFxcdCt2YWx1ZVBhcnRzWyAyIF07XFxuXFx0XFx0aWYgKCB0d2VlbiApIHtcXG5cXHRcXHRcXHR0d2Vlbi51bml0ID0gdW5pdDtcXG5cXHRcXHRcXHR0d2Vlbi5zdGFydCA9IGluaXRpYWxJblVuaXQ7XFxuXFx0XFx0XFx0dHdlZW4uZW5kID0gYWRqdXN0ZWQ7XFxuXFx0XFx0fVxcblxcdH1cXG5cXHRyZXR1cm4gYWRqdXN0ZWQ7XFxufVxcblxcblxcbnZhciBkZWZhdWx0RGlzcGxheU1hcCA9IHt9O1xcblxcbmZ1bmN0aW9uIGdldERlZmF1bHREaXNwbGF5KCBlbGVtICkge1xcblxcdHZhciB0ZW1wLFxcblxcdFxcdGRvYyA9IGVsZW0ub3duZXJEb2N1bWVudCxcXG5cXHRcXHRub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWUsXFxuXFx0XFx0ZGlzcGxheSA9IGRlZmF1bHREaXNwbGF5TWFwWyBub2RlTmFtZSBdO1xcblxcblxcdGlmICggZGlzcGxheSApIHtcXG5cXHRcXHRyZXR1cm4gZGlzcGxheTtcXG5cXHR9XFxuXFxuXFx0dGVtcCA9IGRvYy5ib2R5LmFwcGVuZENoaWxkKCBkb2MuY3JlYXRlRWxlbWVudCggbm9kZU5hbWUgKSApO1xcblxcdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCB0ZW1wLCBcXFwiZGlzcGxheVxcXCIgKTtcXG5cXG5cXHR0ZW1wLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIHRlbXAgKTtcXG5cXG5cXHRpZiAoIGRpc3BsYXkgPT09IFxcXCJub25lXFxcIiApIHtcXG5cXHRcXHRkaXNwbGF5ID0gXFxcImJsb2NrXFxcIjtcXG5cXHR9XFxuXFx0ZGVmYXVsdERpc3BsYXlNYXBbIG5vZGVOYW1lIF0gPSBkaXNwbGF5O1xcblxcblxcdHJldHVybiBkaXNwbGF5O1xcbn1cXG5cXG5mdW5jdGlvbiBzaG93SGlkZSggZWxlbWVudHMsIHNob3cgKSB7XFxuXFx0dmFyIGRpc3BsYXksIGVsZW0sXFxuXFx0XFx0dmFsdWVzID0gW10sXFxuXFx0XFx0aW5kZXggPSAwLFxcblxcdFxcdGxlbmd0aCA9IGVsZW1lbnRzLmxlbmd0aDtcXG5cXG5cXHQvLyBEZXRlcm1pbmUgbmV3IGRpc3BsYXkgdmFsdWUgZm9yIGVsZW1lbnRzIHRoYXQgbmVlZCB0byBjaGFuZ2VcXG5cXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xcblxcdFxcdGVsZW0gPSBlbGVtZW50c1sgaW5kZXggXTtcXG5cXHRcXHRpZiAoICFlbGVtLnN0eWxlICkge1xcblxcdFxcdFxcdGNvbnRpbnVlO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRkaXNwbGF5ID0gZWxlbS5zdHlsZS5kaXNwbGF5O1xcblxcdFxcdGlmICggc2hvdyApIHtcXG5cXG5cXHRcXHRcXHQvLyBTaW5jZSB3ZSBmb3JjZSB2aXNpYmlsaXR5IHVwb24gY2FzY2FkZS1oaWRkZW4gZWxlbWVudHMsIGFuIGltbWVkaWF0ZSAoYW5kIHNsb3cpXFxuXFx0XFx0XFx0Ly8gY2hlY2sgaXMgcmVxdWlyZWQgaW4gdGhpcyBmaXJzdCBsb29wIHVubGVzcyB3ZSBoYXZlIGEgbm9uZW1wdHkgZGlzcGxheSB2YWx1ZSAoZWl0aGVyXFxuXFx0XFx0XFx0Ly8gaW5saW5lIG9yIGFib3V0LXRvLWJlLXJlc3RvcmVkKVxcblxcdFxcdFxcdGlmICggZGlzcGxheSA9PT0gXFxcIm5vbmVcXFwiICkge1xcblxcdFxcdFxcdFxcdHZhbHVlc1sgaW5kZXggXSA9IGRhdGFQcml2LmdldCggZWxlbSwgXFxcImRpc3BsYXlcXFwiICkgfHwgbnVsbDtcXG5cXHRcXHRcXHRcXHRpZiAoICF2YWx1ZXNbIGluZGV4IF0gKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZWxlbS5zdHlsZS5kaXNwbGF5ID0gXFxcIlxcXCI7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoIGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXFxcIlxcXCIgJiYgaXNIaWRkZW5XaXRoaW5UcmVlKCBlbGVtICkgKSB7XFxuXFx0XFx0XFx0XFx0dmFsdWVzWyBpbmRleCBdID0gZ2V0RGVmYXVsdERpc3BsYXkoIGVsZW0gKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRpZiAoIGRpc3BsYXkgIT09IFxcXCJub25lXFxcIiApIHtcXG5cXHRcXHRcXHRcXHR2YWx1ZXNbIGluZGV4IF0gPSBcXFwibm9uZVxcXCI7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gUmVtZW1iZXIgd2hhdCB3ZSdyZSBvdmVyd3JpdGluZ1xcblxcdFxcdFxcdFxcdGRhdGFQcml2LnNldCggZWxlbSwgXFxcImRpc3BsYXlcXFwiLCBkaXNwbGF5ICk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9XFxuXFxuXFx0Ly8gU2V0IHRoZSBkaXNwbGF5IG9mIHRoZSBlbGVtZW50cyBpbiBhIHNlY29uZCBsb29wIHRvIGF2b2lkIGNvbnN0YW50IHJlZmxvd1xcblxcdGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XFxuXFx0XFx0aWYgKCB2YWx1ZXNbIGluZGV4IF0gIT0gbnVsbCApIHtcXG5cXHRcXHRcXHRlbGVtZW50c1sgaW5kZXggXS5zdHlsZS5kaXNwbGF5ID0gdmFsdWVzWyBpbmRleCBdO1xcblxcdFxcdH1cXG5cXHR9XFxuXFxuXFx0cmV0dXJuIGVsZW1lbnRzO1xcbn1cXG5cXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XFxuXFx0c2hvdzogZnVuY3Rpb24oKSB7XFxuXFx0XFx0cmV0dXJuIHNob3dIaWRlKCB0aGlzLCB0cnVlICk7XFxuXFx0fSxcXG5cXHRoaWRlOiBmdW5jdGlvbigpIHtcXG5cXHRcXHRyZXR1cm4gc2hvd0hpZGUoIHRoaXMgKTtcXG5cXHR9LFxcblxcdHRvZ2dsZTogZnVuY3Rpb24oIHN0YXRlICkge1xcblxcdFxcdGlmICggdHlwZW9mIHN0YXRlID09PSBcXFwiYm9vbGVhblxcXCIgKSB7XFxuXFx0XFx0XFx0cmV0dXJuIHN0YXRlID8gdGhpcy5zaG93KCkgOiB0aGlzLmhpZGUoKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0aWYgKCBpc0hpZGRlbldpdGhpblRyZWUoIHRoaXMgKSApIHtcXG5cXHRcXHRcXHRcXHRqUXVlcnkoIHRoaXMgKS5zaG93KCk7XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRqUXVlcnkoIHRoaXMgKS5oaWRlKCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0gKTtcXG5cXHR9XFxufSApO1xcbnZhciByY2hlY2thYmxlVHlwZSA9ICggL14oPzpjaGVja2JveHxyYWRpbykkL2kgKTtcXG5cXG52YXIgcnRhZ05hbWUgPSAoIC88KFthLXpdW15cXFxcL1xcXFwwPlxcXFx4MjBcXFxcdFxcXFxyXFxcXG5cXFxcZl0rKS9pICk7XFxuXFxudmFyIHJzY3JpcHRUeXBlID0gKCAvXiR8Xm1vZHVsZSR8XFxcXC8oPzpqYXZhfGVjbWEpc2NyaXB0L2kgKTtcXG5cXG5cXG5cXG4vLyBXZSBoYXZlIHRvIGNsb3NlIHRoZXNlIHRhZ3MgdG8gc3VwcG9ydCBYSFRNTCAoIzEzMjAwKVxcbnZhciB3cmFwTWFwID0ge1xcblxcblxcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XFxuXFx0b3B0aW9uOiBbIDEsIFxcXCI8c2VsZWN0IG11bHRpcGxlPSdtdWx0aXBsZSc+XFxcIiwgXFxcIjwvc2VsZWN0PlxcXCIgXSxcXG5cXG5cXHQvLyBYSFRNTCBwYXJzZXJzIGRvIG5vdCBtYWdpY2FsbHkgaW5zZXJ0IGVsZW1lbnRzIGluIHRoZVxcblxcdC8vIHNhbWUgd2F5IHRoYXQgdGFnIHNvdXAgcGFyc2VycyBkby4gU28gd2UgY2Fubm90IHNob3J0ZW5cXG5cXHQvLyB0aGlzIGJ5IG9taXR0aW5nIDx0Ym9keT4gb3Igb3RoZXIgcmVxdWlyZWQgZWxlbWVudHMuXFxuXFx0dGhlYWQ6IFsgMSwgXFxcIjx0YWJsZT5cXFwiLCBcXFwiPC90YWJsZT5cXFwiIF0sXFxuXFx0Y29sOiBbIDIsIFxcXCI8dGFibGU+PGNvbGdyb3VwPlxcXCIsIFxcXCI8L2NvbGdyb3VwPjwvdGFibGU+XFxcIiBdLFxcblxcdHRyOiBbIDIsIFxcXCI8dGFibGU+PHRib2R5PlxcXCIsIFxcXCI8L3Rib2R5PjwvdGFibGU+XFxcIiBdLFxcblxcdHRkOiBbIDMsIFxcXCI8dGFibGU+PHRib2R5Pjx0cj5cXFwiLCBcXFwiPC90cj48L3Rib2R5PjwvdGFibGU+XFxcIiBdLFxcblxcblxcdF9kZWZhdWx0OiBbIDAsIFxcXCJcXFwiLCBcXFwiXFxcIiBdXFxufTtcXG5cXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxcbndyYXBNYXAub3B0Z3JvdXAgPSB3cmFwTWFwLm9wdGlvbjtcXG5cXG53cmFwTWFwLnRib2R5ID0gd3JhcE1hcC50Zm9vdCA9IHdyYXBNYXAuY29sZ3JvdXAgPSB3cmFwTWFwLmNhcHRpb24gPSB3cmFwTWFwLnRoZWFkO1xcbndyYXBNYXAudGggPSB3cmFwTWFwLnRkO1xcblxcblxcbmZ1bmN0aW9uIGdldEFsbCggY29udGV4dCwgdGFnICkge1xcblxcblxcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcXG5cXHQvLyBVc2UgdHlwZW9mIHRvIGF2b2lkIHplcm8tYXJndW1lbnQgbWV0aG9kIGludm9jYXRpb24gb24gaG9zdCBvYmplY3RzICgjMTUxNTEpXFxuXFx0dmFyIHJldDtcXG5cXG5cXHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcXFwidW5kZWZpbmVkXFxcIiApIHtcXG5cXHRcXHRyZXQgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgfHwgXFxcIipcXFwiICk7XFxuXFxuXFx0fSBlbHNlIGlmICggdHlwZW9mIGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCAhPT0gXFxcInVuZGVmaW5lZFxcXCIgKSB7XFxuXFx0XFx0cmV0ID0gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCB0YWcgfHwgXFxcIipcXFwiICk7XFxuXFxuXFx0fSBlbHNlIHtcXG5cXHRcXHRyZXQgPSBbXTtcXG5cXHR9XFxuXFxuXFx0aWYgKCB0YWcgPT09IHVuZGVmaW5lZCB8fCB0YWcgJiYgbm9kZU5hbWUoIGNvbnRleHQsIHRhZyApICkge1xcblxcdFxcdHJldHVybiBqUXVlcnkubWVyZ2UoIFsgY29udGV4dCBdLCByZXQgKTtcXG5cXHR9XFxuXFxuXFx0cmV0dXJuIHJldDtcXG59XFxuXFxuXFxuLy8gTWFyayBzY3JpcHRzIGFzIGhhdmluZyBhbHJlYWR5IGJlZW4gZXZhbHVhdGVkXFxuZnVuY3Rpb24gc2V0R2xvYmFsRXZhbCggZWxlbXMsIHJlZkVsZW1lbnRzICkge1xcblxcdHZhciBpID0gMCxcXG5cXHRcXHRsID0gZWxlbXMubGVuZ3RoO1xcblxcblxcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcXG5cXHRcXHRkYXRhUHJpdi5zZXQoXFxuXFx0XFx0XFx0ZWxlbXNbIGkgXSxcXG5cXHRcXHRcXHRcXFwiZ2xvYmFsRXZhbFxcXCIsXFxuXFx0XFx0XFx0IXJlZkVsZW1lbnRzIHx8IGRhdGFQcml2LmdldCggcmVmRWxlbWVudHNbIGkgXSwgXFxcImdsb2JhbEV2YWxcXFwiIClcXG5cXHRcXHQpO1xcblxcdH1cXG59XFxuXFxuXFxudmFyIHJodG1sID0gLzx8JiM/XFxcXHcrOy87XFxuXFxuZnVuY3Rpb24gYnVpbGRGcmFnbWVudCggZWxlbXMsIGNvbnRleHQsIHNjcmlwdHMsIHNlbGVjdGlvbiwgaWdub3JlZCApIHtcXG5cXHR2YXIgZWxlbSwgdG1wLCB0YWcsIHdyYXAsIGNvbnRhaW5zLCBqLFxcblxcdFxcdGZyYWdtZW50ID0gY29udGV4dC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXFxuXFx0XFx0bm9kZXMgPSBbXSxcXG5cXHRcXHRpID0gMCxcXG5cXHRcXHRsID0gZWxlbXMubGVuZ3RoO1xcblxcblxcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcXG5cXHRcXHRlbGVtID0gZWxlbXNbIGkgXTtcXG5cXG5cXHRcXHRpZiAoIGVsZW0gfHwgZWxlbSA9PT0gMCApIHtcXG5cXG5cXHRcXHRcXHQvLyBBZGQgbm9kZXMgZGlyZWN0bHlcXG5cXHRcXHRcXHRpZiAoIHRvVHlwZSggZWxlbSApID09PSBcXFwib2JqZWN0XFxcIiApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcXG5cXHRcXHRcXHRcXHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XFxuXFx0XFx0XFx0XFx0alF1ZXJ5Lm1lcmdlKCBub2RlcywgZWxlbS5ub2RlVHlwZSA/IFsgZWxlbSBdIDogZWxlbSApO1xcblxcblxcdFxcdFxcdC8vIENvbnZlcnQgbm9uLWh0bWwgaW50byBhIHRleHQgbm9kZVxcblxcdFxcdFxcdH0gZWxzZSBpZiAoICFyaHRtbC50ZXN0KCBlbGVtICkgKSB7XFxuXFx0XFx0XFx0XFx0bm9kZXMucHVzaCggY29udGV4dC5jcmVhdGVUZXh0Tm9kZSggZWxlbSApICk7XFxuXFxuXFx0XFx0XFx0Ly8gQ29udmVydCBodG1sIGludG8gRE9NIG5vZGVzXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHR0bXAgPSB0bXAgfHwgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGNvbnRleHQuY3JlYXRlRWxlbWVudCggXFxcImRpdlxcXCIgKSApO1xcblxcblxcdFxcdFxcdFxcdC8vIERlc2VyaWFsaXplIGEgc3RhbmRhcmQgcmVwcmVzZW50YXRpb25cXG5cXHRcXHRcXHRcXHR0YWcgPSAoIHJ0YWdOYW1lLmV4ZWMoIGVsZW0gKSB8fCBbIFxcXCJcXFwiLCBcXFwiXFxcIiBdIClbIDEgXS50b0xvd2VyQ2FzZSgpO1xcblxcdFxcdFxcdFxcdHdyYXAgPSB3cmFwTWFwWyB0YWcgXSB8fCB3cmFwTWFwLl9kZWZhdWx0O1xcblxcdFxcdFxcdFxcdHRtcC5pbm5lckhUTUwgPSB3cmFwWyAxIF0gKyBqUXVlcnkuaHRtbFByZWZpbHRlciggZWxlbSApICsgd3JhcFsgMiBdO1xcblxcblxcdFxcdFxcdFxcdC8vIERlc2NlbmQgdGhyb3VnaCB3cmFwcGVycyB0byB0aGUgcmlnaHQgY29udGVudFxcblxcdFxcdFxcdFxcdGogPSB3cmFwWyAwIF07XFxuXFx0XFx0XFx0XFx0d2hpbGUgKCBqLS0gKSB7XFxuXFx0XFx0XFx0XFx0XFx0dG1wID0gdG1wLmxhc3RDaGlsZDtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XFxuXFx0XFx0XFx0XFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxcblxcdFxcdFxcdFxcdGpRdWVyeS5tZXJnZSggbm9kZXMsIHRtcC5jaGlsZE5vZGVzICk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gUmVtZW1iZXIgdGhlIHRvcC1sZXZlbCBjb250YWluZXJcXG5cXHRcXHRcXHRcXHR0bXAgPSBmcmFnbWVudC5maXJzdENoaWxkO1xcblxcblxcdFxcdFxcdFxcdC8vIEVuc3VyZSB0aGUgY3JlYXRlZCBub2RlcyBhcmUgb3JwaGFuZWQgKCMxMjM5MilcXG5cXHRcXHRcXHRcXHR0bXAudGV4dENvbnRlbnQgPSBcXFwiXFxcIjtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdH1cXG5cXG5cXHQvLyBSZW1vdmUgd3JhcHBlciBmcm9tIGZyYWdtZW50XFxuXFx0ZnJhZ21lbnQudGV4dENvbnRlbnQgPSBcXFwiXFxcIjtcXG5cXG5cXHRpID0gMDtcXG5cXHR3aGlsZSAoICggZWxlbSA9IG5vZGVzWyBpKysgXSApICkge1xcblxcblxcdFxcdC8vIFNraXAgZWxlbWVudHMgYWxyZWFkeSBpbiB0aGUgY29udGV4dCBjb2xsZWN0aW9uICh0cmFjLTQwODcpXFxuXFx0XFx0aWYgKCBzZWxlY3Rpb24gJiYgalF1ZXJ5LmluQXJyYXkoIGVsZW0sIHNlbGVjdGlvbiApID4gLTEgKSB7XFxuXFx0XFx0XFx0aWYgKCBpZ25vcmVkICkge1xcblxcdFxcdFxcdFxcdGlnbm9yZWQucHVzaCggZWxlbSApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRjb250aW51ZTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Y29udGFpbnMgPSBqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApO1xcblxcblxcdFxcdC8vIEFwcGVuZCB0byBmcmFnbWVudFxcblxcdFxcdHRtcCA9IGdldEFsbCggZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGVsZW0gKSwgXFxcInNjcmlwdFxcXCIgKTtcXG5cXG5cXHRcXHQvLyBQcmVzZXJ2ZSBzY3JpcHQgZXZhbHVhdGlvbiBoaXN0b3J5XFxuXFx0XFx0aWYgKCBjb250YWlucyApIHtcXG5cXHRcXHRcXHRzZXRHbG9iYWxFdmFsKCB0bXAgKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gQ2FwdHVyZSBleGVjdXRhYmxlc1xcblxcdFxcdGlmICggc2NyaXB0cyApIHtcXG5cXHRcXHRcXHRqID0gMDtcXG5cXHRcXHRcXHR3aGlsZSAoICggZWxlbSA9IHRtcFsgaisrIF0gKSApIHtcXG5cXHRcXHRcXHRcXHRpZiAoIHJzY3JpcHRUeXBlLnRlc3QoIGVsZW0udHlwZSB8fCBcXFwiXFxcIiApICkge1xcblxcdFxcdFxcdFxcdFxcdHNjcmlwdHMucHVzaCggZWxlbSApO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdH1cXG5cXG5cXHRyZXR1cm4gZnJhZ21lbnQ7XFxufVxcblxcblxcbiggZnVuY3Rpb24oKSB7XFxuXFx0dmFyIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxcblxcdFxcdGRpdiA9IGZyYWdtZW50LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcXFwiZGl2XFxcIiApICksXFxuXFx0XFx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcXFwiaW5wdXRcXFwiICk7XFxuXFxuXFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seVxcblxcdC8vIENoZWNrIHN0YXRlIGxvc3QgaWYgdGhlIG5hbWUgaXMgc2V0ICgjMTEyMTcpXFxuXFx0Ly8gU3VwcG9ydDogV2luZG93cyBXZWIgQXBwcyAoV1dBKVxcblxcdC8vIGBuYW1lYCBhbmQgYHR5cGVgIG11c3QgdXNlIC5zZXRBdHRyaWJ1dGUgZm9yIFdXQSAoIzE0OTAxKVxcblxcdGlucHV0LnNldEF0dHJpYnV0ZSggXFxcInR5cGVcXFwiLCBcXFwicmFkaW9cXFwiICk7XFxuXFx0aW5wdXQuc2V0QXR0cmlidXRlKCBcXFwiY2hlY2tlZFxcXCIsIFxcXCJjaGVja2VkXFxcIiApO1xcblxcdGlucHV0LnNldEF0dHJpYnV0ZSggXFxcIm5hbWVcXFwiLCBcXFwidFxcXCIgKTtcXG5cXG5cXHRkaXYuYXBwZW5kQ2hpbGQoIGlucHV0ICk7XFxuXFxuXFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMSBvbmx5XFxuXFx0Ly8gT2xkZXIgV2ViS2l0IGRvZXNuJ3QgY2xvbmUgY2hlY2tlZCBzdGF0ZSBjb3JyZWN0bHkgaW4gZnJhZ21lbnRzXFxuXFx0c3VwcG9ydC5jaGVja0Nsb25lID0gZGl2LmNsb25lTm9kZSggdHJ1ZSApLmNsb25lTm9kZSggdHJ1ZSApLmxhc3RDaGlsZC5jaGVja2VkO1xcblxcblxcdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxcblxcdC8vIE1ha2Ugc3VyZSB0ZXh0YXJlYSAoYW5kIGNoZWNrYm94KSBkZWZhdWx0VmFsdWUgaXMgcHJvcGVybHkgY2xvbmVkXFxuXFx0ZGl2LmlubmVySFRNTCA9IFxcXCI8dGV4dGFyZWE+eDwvdGV4dGFyZWE+XFxcIjtcXG5cXHRzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkID0gISFkaXYuY2xvbmVOb2RlKCB0cnVlICkubGFzdENoaWxkLmRlZmF1bHRWYWx1ZTtcXG59ICkoKTtcXG52YXIgZG9jdW1lbnRFbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xcblxcblxcblxcbnZhclxcblxcdHJrZXlFdmVudCA9IC9ea2V5LyxcXG5cXHRybW91c2VFdmVudCA9IC9eKD86bW91c2V8cG9pbnRlcnxjb250ZXh0bWVudXxkcmFnfGRyb3ApfGNsaWNrLyxcXG5cXHRydHlwZW5hbWVzcGFjZSA9IC9eKFteLl0qKSg/OlxcXFwuKC4rKXwpLztcXG5cXG5mdW5jdGlvbiByZXR1cm5UcnVlKCkge1xcblxcdHJldHVybiB0cnVlO1xcbn1cXG5cXG5mdW5jdGlvbiByZXR1cm5GYWxzZSgpIHtcXG5cXHRyZXR1cm4gZmFsc2U7XFxufVxcblxcbi8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XFxuLy8gU2VlICMxMzM5MyBmb3IgbW9yZSBpbmZvXFxuZnVuY3Rpb24gc2FmZUFjdGl2ZUVsZW1lbnQoKSB7XFxuXFx0dHJ5IHtcXG5cXHRcXHRyZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcXG5cXHR9IGNhdGNoICggZXJyICkgeyB9XFxufVxcblxcbmZ1bmN0aW9uIG9uKCBlbGVtLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuLCBvbmUgKSB7XFxuXFx0dmFyIG9yaWdGbiwgdHlwZTtcXG5cXG5cXHQvLyBUeXBlcyBjYW4gYmUgYSBtYXAgb2YgdHlwZXMvaGFuZGxlcnNcXG5cXHRpZiAoIHR5cGVvZiB0eXBlcyA9PT0gXFxcIm9iamVjdFxcXCIgKSB7XFxuXFxuXFx0XFx0Ly8gKCB0eXBlcy1PYmplY3QsIHNlbGVjdG9yLCBkYXRhIClcXG5cXHRcXHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXFxcInN0cmluZ1xcXCIgKSB7XFxuXFxuXFx0XFx0XFx0Ly8gKCB0eXBlcy1PYmplY3QsIGRhdGEgKVxcblxcdFxcdFxcdGRhdGEgPSBkYXRhIHx8IHNlbGVjdG9yO1xcblxcdFxcdFxcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xcblxcdFxcdH1cXG5cXHRcXHRmb3IgKCB0eXBlIGluIHR5cGVzICkge1xcblxcdFxcdFxcdG9uKCBlbGVtLCB0eXBlLCBzZWxlY3RvciwgZGF0YSwgdHlwZXNbIHR5cGUgXSwgb25lICk7XFxuXFx0XFx0fVxcblxcdFxcdHJldHVybiBlbGVtO1xcblxcdH1cXG5cXG5cXHRpZiAoIGRhdGEgPT0gbnVsbCAmJiBmbiA9PSBudWxsICkge1xcblxcblxcdFxcdC8vICggdHlwZXMsIGZuIClcXG5cXHRcXHRmbiA9IHNlbGVjdG9yO1xcblxcdFxcdGRhdGEgPSBzZWxlY3RvciA9IHVuZGVmaW5lZDtcXG5cXHR9IGVsc2UgaWYgKCBmbiA9PSBudWxsICkge1xcblxcdFxcdGlmICggdHlwZW9mIHNlbGVjdG9yID09PSBcXFwic3RyaW5nXFxcIiApIHtcXG5cXG5cXHRcXHRcXHQvLyAoIHR5cGVzLCBzZWxlY3RvciwgZm4gKVxcblxcdFxcdFxcdGZuID0gZGF0YTtcXG5cXHRcXHRcXHRkYXRhID0gdW5kZWZpbmVkO1xcblxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0Ly8gKCB0eXBlcywgZGF0YSwgZm4gKVxcblxcdFxcdFxcdGZuID0gZGF0YTtcXG5cXHRcXHRcXHRkYXRhID0gc2VsZWN0b3I7XFxuXFx0XFx0XFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XFxuXFx0XFx0fVxcblxcdH1cXG5cXHRpZiAoIGZuID09PSBmYWxzZSApIHtcXG5cXHRcXHRmbiA9IHJldHVybkZhbHNlO1xcblxcdH0gZWxzZSBpZiAoICFmbiApIHtcXG5cXHRcXHRyZXR1cm4gZWxlbTtcXG5cXHR9XFxuXFxuXFx0aWYgKCBvbmUgPT09IDEgKSB7XFxuXFx0XFx0b3JpZ0ZuID0gZm47XFxuXFx0XFx0Zm4gPSBmdW5jdGlvbiggZXZlbnQgKSB7XFxuXFxuXFx0XFx0XFx0Ly8gQ2FuIHVzZSBhbiBlbXB0eSBzZXQsIHNpbmNlIGV2ZW50IGNvbnRhaW5zIHRoZSBpbmZvXFxuXFx0XFx0XFx0alF1ZXJ5KCkub2ZmKCBldmVudCApO1xcblxcdFxcdFxcdHJldHVybiBvcmlnRm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xcblxcdFxcdH07XFxuXFxuXFx0XFx0Ly8gVXNlIHNhbWUgZ3VpZCBzbyBjYWxsZXIgY2FuIHJlbW92ZSB1c2luZyBvcmlnRm5cXG5cXHRcXHRmbi5ndWlkID0gb3JpZ0ZuLmd1aWQgfHwgKCBvcmlnRm4uZ3VpZCA9IGpRdWVyeS5ndWlkKysgKTtcXG5cXHR9XFxuXFx0cmV0dXJuIGVsZW0uZWFjaCggZnVuY3Rpb24oKSB7XFxuXFx0XFx0alF1ZXJ5LmV2ZW50LmFkZCggdGhpcywgdHlwZXMsIGZuLCBkYXRhLCBzZWxlY3RvciApO1xcblxcdH0gKTtcXG59XFxuXFxuLypcXG4gKiBIZWxwZXIgZnVuY3Rpb25zIGZvciBtYW5hZ2luZyBldmVudHMgLS0gbm90IHBhcnQgb2YgdGhlIHB1YmxpYyBpbnRlcmZhY2UuXFxuICogUHJvcHMgdG8gRGVhbiBFZHdhcmRzJyBhZGRFdmVudCBsaWJyYXJ5IGZvciBtYW55IG9mIHRoZSBpZGVhcy5cXG4gKi9cXG5qUXVlcnkuZXZlbnQgPSB7XFxuXFxuXFx0Z2xvYmFsOiB7fSxcXG5cXG5cXHRhZGQ6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlcywgaGFuZGxlciwgZGF0YSwgc2VsZWN0b3IgKSB7XFxuXFxuXFx0XFx0dmFyIGhhbmRsZU9iakluLCBldmVudEhhbmRsZSwgdG1wLFxcblxcdFxcdFxcdGV2ZW50cywgdCwgaGFuZGxlT2JqLFxcblxcdFxcdFxcdHNwZWNpYWwsIGhhbmRsZXJzLCB0eXBlLCBuYW1lc3BhY2VzLCBvcmlnVHlwZSxcXG5cXHRcXHRcXHRlbGVtRGF0YSA9IGRhdGFQcml2LmdldCggZWxlbSApO1xcblxcblxcdFxcdC8vIERvbid0IGF0dGFjaCBldmVudHMgdG8gbm9EYXRhIG9yIHRleHQvY29tbWVudCBub2RlcyAoYnV0IGFsbG93IHBsYWluIG9iamVjdHMpXFxuXFx0XFx0aWYgKCAhZWxlbURhdGEgKSB7XFxuXFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBDYWxsZXIgY2FuIHBhc3MgaW4gYW4gb2JqZWN0IG9mIGN1c3RvbSBkYXRhIGluIGxpZXUgb2YgdGhlIGhhbmRsZXJcXG5cXHRcXHRpZiAoIGhhbmRsZXIuaGFuZGxlciApIHtcXG5cXHRcXHRcXHRoYW5kbGVPYmpJbiA9IGhhbmRsZXI7XFxuXFx0XFx0XFx0aGFuZGxlciA9IGhhbmRsZU9iakluLmhhbmRsZXI7XFxuXFx0XFx0XFx0c2VsZWN0b3IgPSBoYW5kbGVPYmpJbi5zZWxlY3RvcjtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gRW5zdXJlIHRoYXQgaW52YWxpZCBzZWxlY3RvcnMgdGhyb3cgZXhjZXB0aW9ucyBhdCBhdHRhY2ggdGltZVxcblxcdFxcdC8vIEV2YWx1YXRlIGFnYWluc3QgZG9jdW1lbnRFbGVtZW50IGluIGNhc2UgZWxlbSBpcyBhIG5vbi1lbGVtZW50IG5vZGUgKGUuZy4sIGRvY3VtZW50KVxcblxcdFxcdGlmICggc2VsZWN0b3IgKSB7XFxuXFx0XFx0XFx0alF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKCBkb2N1bWVudEVsZW1lbnQsIHNlbGVjdG9yICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBoYW5kbGVyIGhhcyBhIHVuaXF1ZSBJRCwgdXNlZCB0byBmaW5kL3JlbW92ZSBpdCBsYXRlclxcblxcdFxcdGlmICggIWhhbmRsZXIuZ3VpZCApIHtcXG5cXHRcXHRcXHRoYW5kbGVyLmd1aWQgPSBqUXVlcnkuZ3VpZCsrO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBJbml0IHRoZSBlbGVtZW50J3MgZXZlbnQgc3RydWN0dXJlIGFuZCBtYWluIGhhbmRsZXIsIGlmIHRoaXMgaXMgdGhlIGZpcnN0XFxuXFx0XFx0aWYgKCAhKCBldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgKSApIHtcXG5cXHRcXHRcXHRldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgPSB7fTtcXG5cXHRcXHR9XFxuXFx0XFx0aWYgKCAhKCBldmVudEhhbmRsZSA9IGVsZW1EYXRhLmhhbmRsZSApICkge1xcblxcdFxcdFxcdGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlID0gZnVuY3Rpb24oIGUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gRGlzY2FyZCB0aGUgc2Vjb25kIGV2ZW50IG9mIGEgalF1ZXJ5LmV2ZW50LnRyaWdnZXIoKSBhbmRcXG5cXHRcXHRcXHRcXHQvLyB3aGVuIGFuIGV2ZW50IGlzIGNhbGxlZCBhZnRlciBhIHBhZ2UgaGFzIHVubG9hZGVkXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHR5cGVvZiBqUXVlcnkgIT09IFxcXCJ1bmRlZmluZWRcXFwiICYmIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgIT09IGUudHlwZSA/XFxuXFx0XFx0XFx0XFx0XFx0alF1ZXJ5LmV2ZW50LmRpc3BhdGNoLmFwcGx5KCBlbGVtLCBhcmd1bWVudHMgKSA6IHVuZGVmaW5lZDtcXG5cXHRcXHRcXHR9O1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBIYW5kbGUgbXVsdGlwbGUgZXZlbnRzIHNlcGFyYXRlZCBieSBhIHNwYWNlXFxuXFx0XFx0dHlwZXMgPSAoIHR5cGVzIHx8IFxcXCJcXFwiICkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbIFxcXCJcXFwiIF07XFxuXFx0XFx0dCA9IHR5cGVzLmxlbmd0aDtcXG5cXHRcXHR3aGlsZSAoIHQtLSApIHtcXG5cXHRcXHRcXHR0bXAgPSBydHlwZW5hbWVzcGFjZS5leGVjKCB0eXBlc1sgdCBdICkgfHwgW107XFxuXFx0XFx0XFx0dHlwZSA9IG9yaWdUeXBlID0gdG1wWyAxIF07XFxuXFx0XFx0XFx0bmFtZXNwYWNlcyA9ICggdG1wWyAyIF0gfHwgXFxcIlxcXCIgKS5zcGxpdCggXFxcIi5cXFwiICkuc29ydCgpO1xcblxcblxcdFxcdFxcdC8vIFRoZXJlICptdXN0KiBiZSBhIHR5cGUsIG5vIGF0dGFjaGluZyBuYW1lc3BhY2Utb25seSBoYW5kbGVyc1xcblxcdFxcdFxcdGlmICggIXR5cGUgKSB7XFxuXFx0XFx0XFx0XFx0Y29udGludWU7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIElmIGV2ZW50IGNoYW5nZXMgaXRzIHR5cGUsIHVzZSB0aGUgc3BlY2lhbCBldmVudCBoYW5kbGVycyBmb3IgdGhlIGNoYW5nZWQgdHlwZVxcblxcdFxcdFxcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xcblxcblxcdFxcdFxcdC8vIElmIHNlbGVjdG9yIGRlZmluZWQsIGRldGVybWluZSBzcGVjaWFsIGV2ZW50IGFwaSB0eXBlLCBvdGhlcndpc2UgZ2l2ZW4gdHlwZVxcblxcdFxcdFxcdHR5cGUgPSAoIHNlbGVjdG9yID8gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlICkgfHwgdHlwZTtcXG5cXG5cXHRcXHRcXHQvLyBVcGRhdGUgc3BlY2lhbCBiYXNlZCBvbiBuZXdseSByZXNldCB0eXBlXFxuXFx0XFx0XFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XFxuXFxuXFx0XFx0XFx0Ly8gaGFuZGxlT2JqIGlzIHBhc3NlZCB0byBhbGwgZXZlbnQgaGFuZGxlcnNcXG5cXHRcXHRcXHRoYW5kbGVPYmogPSBqUXVlcnkuZXh0ZW5kKCB7XFxuXFx0XFx0XFx0XFx0dHlwZTogdHlwZSxcXG5cXHRcXHRcXHRcXHRvcmlnVHlwZTogb3JpZ1R5cGUsXFxuXFx0XFx0XFx0XFx0ZGF0YTogZGF0YSxcXG5cXHRcXHRcXHRcXHRoYW5kbGVyOiBoYW5kbGVyLFxcblxcdFxcdFxcdFxcdGd1aWQ6IGhhbmRsZXIuZ3VpZCxcXG5cXHRcXHRcXHRcXHRzZWxlY3Rvcjogc2VsZWN0b3IsXFxuXFx0XFx0XFx0XFx0bmVlZHNDb250ZXh0OiBzZWxlY3RvciAmJiBqUXVlcnkuZXhwci5tYXRjaC5uZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3IgKSxcXG5cXHRcXHRcXHRcXHRuYW1lc3BhY2U6IG5hbWVzcGFjZXMuam9pbiggXFxcIi5cXFwiIClcXG5cXHRcXHRcXHR9LCBoYW5kbGVPYmpJbiApO1xcblxcblxcdFxcdFxcdC8vIEluaXQgdGhlIGV2ZW50IGhhbmRsZXIgcXVldWUgaWYgd2UncmUgdGhlIGZpcnN0XFxuXFx0XFx0XFx0aWYgKCAhKCBoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdICkgKSB7XFxuXFx0XFx0XFx0XFx0aGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSA9IFtdO1xcblxcdFxcdFxcdFxcdGhhbmRsZXJzLmRlbGVnYXRlQ291bnQgPSAwO1xcblxcblxcdFxcdFxcdFxcdC8vIE9ubHkgdXNlIGFkZEV2ZW50TGlzdGVuZXIgaWYgdGhlIHNwZWNpYWwgZXZlbnRzIGhhbmRsZXIgcmV0dXJucyBmYWxzZVxcblxcdFxcdFxcdFxcdGlmICggIXNwZWNpYWwuc2V0dXAgfHxcXG5cXHRcXHRcXHRcXHRcXHRzcGVjaWFsLnNldHVwLmNhbGwoIGVsZW0sIGRhdGEsIG5hbWVzcGFjZXMsIGV2ZW50SGFuZGxlICkgPT09IGZhbHNlICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggZWxlbS5hZGRFdmVudExpc3RlbmVyICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGVsZW0uYWRkRXZlbnRMaXN0ZW5lciggdHlwZSwgZXZlbnRIYW5kbGUgKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIHNwZWNpYWwuYWRkICkge1xcblxcdFxcdFxcdFxcdHNwZWNpYWwuYWRkLmNhbGwoIGVsZW0sIGhhbmRsZU9iaiApO1xcblxcblxcdFxcdFxcdFxcdGlmICggIWhhbmRsZU9iai5oYW5kbGVyLmd1aWQgKSB7XFxuXFx0XFx0XFx0XFx0XFx0aGFuZGxlT2JqLmhhbmRsZXIuZ3VpZCA9IGhhbmRsZXIuZ3VpZDtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIEFkZCB0byB0aGUgZWxlbWVudCdzIGhhbmRsZXIgbGlzdCwgZGVsZWdhdGVzIGluIGZyb250XFxuXFx0XFx0XFx0aWYgKCBzZWxlY3RvciApIHtcXG5cXHRcXHRcXHRcXHRoYW5kbGVycy5zcGxpY2UoIGhhbmRsZXJzLmRlbGVnYXRlQ291bnQrKywgMCwgaGFuZGxlT2JqICk7XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRoYW5kbGVycy5wdXNoKCBoYW5kbGVPYmogKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gS2VlcCB0cmFjayBvZiB3aGljaCBldmVudHMgaGF2ZSBldmVyIGJlZW4gdXNlZCwgZm9yIGV2ZW50IG9wdGltaXphdGlvblxcblxcdFxcdFxcdGpRdWVyeS5ldmVudC5nbG9iYWxbIHR5cGUgXSA9IHRydWU7XFxuXFx0XFx0fVxcblxcblxcdH0sXFxuXFxuXFx0Ly8gRGV0YWNoIGFuIGV2ZW50IG9yIHNldCBvZiBldmVudHMgZnJvbSBhbiBlbGVtZW50XFxuXFx0cmVtb3ZlOiBmdW5jdGlvbiggZWxlbSwgdHlwZXMsIGhhbmRsZXIsIHNlbGVjdG9yLCBtYXBwZWRUeXBlcyApIHtcXG5cXG5cXHRcXHR2YXIgaiwgb3JpZ0NvdW50LCB0bXAsXFxuXFx0XFx0XFx0ZXZlbnRzLCB0LCBoYW5kbGVPYmosXFxuXFx0XFx0XFx0c3BlY2lhbCwgaGFuZGxlcnMsIHR5cGUsIG5hbWVzcGFjZXMsIG9yaWdUeXBlLFxcblxcdFxcdFxcdGVsZW1EYXRhID0gZGF0YVByaXYuaGFzRGF0YSggZWxlbSApICYmIGRhdGFQcml2LmdldCggZWxlbSApO1xcblxcblxcdFxcdGlmICggIWVsZW1EYXRhIHx8ICEoIGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyApICkge1xcblxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gT25jZSBmb3IgZWFjaCB0eXBlLm5hbWVzcGFjZSBpbiB0eXBlczsgdHlwZSBtYXkgYmUgb21pdHRlZFxcblxcdFxcdHR5cGVzID0gKCB0eXBlcyB8fCBcXFwiXFxcIiApLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcXFwiXFxcIiBdO1xcblxcdFxcdHQgPSB0eXBlcy5sZW5ndGg7XFxuXFx0XFx0d2hpbGUgKCB0LS0gKSB7XFxuXFx0XFx0XFx0dG1wID0gcnR5cGVuYW1lc3BhY2UuZXhlYyggdHlwZXNbIHQgXSApIHx8IFtdO1xcblxcdFxcdFxcdHR5cGUgPSBvcmlnVHlwZSA9IHRtcFsgMSBdO1xcblxcdFxcdFxcdG5hbWVzcGFjZXMgPSAoIHRtcFsgMiBdIHx8IFxcXCJcXFwiICkuc3BsaXQoIFxcXCIuXFxcIiApLnNvcnQoKTtcXG5cXG5cXHRcXHRcXHQvLyBVbmJpbmQgYWxsIGV2ZW50cyAob24gdGhpcyBuYW1lc3BhY2UsIGlmIHByb3ZpZGVkKSBmb3IgdGhlIGVsZW1lbnRcXG5cXHRcXHRcXHRpZiAoICF0eXBlICkge1xcblxcdFxcdFxcdFxcdGZvciAoIHR5cGUgaW4gZXZlbnRzICkge1xcblxcdFxcdFxcdFxcdFxcdGpRdWVyeS5ldmVudC5yZW1vdmUoIGVsZW0sIHR5cGUgKyB0eXBlc1sgdCBdLCBoYW5kbGVyLCBzZWxlY3RvciwgdHJ1ZSApO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRjb250aW51ZTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XFxuXFx0XFx0XFx0dHlwZSA9ICggc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUgKSB8fCB0eXBlO1xcblxcdFxcdFxcdGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gfHwgW107XFxuXFx0XFx0XFx0dG1wID0gdG1wWyAyIF0gJiZcXG5cXHRcXHRcXHRcXHRuZXcgUmVnRXhwKCBcXFwiKF58XFxcXFxcXFwuKVxcXCIgKyBuYW1lc3BhY2VzLmpvaW4oIFxcXCJcXFxcXFxcXC4oPzouKlxcXFxcXFxcLnwpXFxcIiApICsgXFxcIihcXFxcXFxcXC58JClcXFwiICk7XFxuXFxuXFx0XFx0XFx0Ly8gUmVtb3ZlIG1hdGNoaW5nIGV2ZW50c1xcblxcdFxcdFxcdG9yaWdDb3VudCA9IGogPSBoYW5kbGVycy5sZW5ndGg7XFxuXFx0XFx0XFx0d2hpbGUgKCBqLS0gKSB7XFxuXFx0XFx0XFx0XFx0aGFuZGxlT2JqID0gaGFuZGxlcnNbIGogXTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoICggbWFwcGVkVHlwZXMgfHwgb3JpZ1R5cGUgPT09IGhhbmRsZU9iai5vcmlnVHlwZSApICYmXFxuXFx0XFx0XFx0XFx0XFx0KCAhaGFuZGxlciB8fCBoYW5kbGVyLmd1aWQgPT09IGhhbmRsZU9iai5ndWlkICkgJiZcXG5cXHRcXHRcXHRcXHRcXHQoICF0bXAgfHwgdG1wLnRlc3QoIGhhbmRsZU9iai5uYW1lc3BhY2UgKSApICYmXFxuXFx0XFx0XFx0XFx0XFx0KCAhc2VsZWN0b3IgfHwgc2VsZWN0b3IgPT09IGhhbmRsZU9iai5zZWxlY3RvciB8fFxcblxcdFxcdFxcdFxcdFxcdFxcdHNlbGVjdG9yID09PSBcXFwiKipcXFwiICYmIGhhbmRsZU9iai5zZWxlY3RvciApICkge1xcblxcdFxcdFxcdFxcdFxcdGhhbmRsZXJzLnNwbGljZSggaiwgMSApO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggaGFuZGxlT2JqLnNlbGVjdG9yICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGhhbmRsZXJzLmRlbGVnYXRlQ291bnQtLTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBzcGVjaWFsLnJlbW92ZSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRzcGVjaWFsLnJlbW92ZS5jYWxsKCBlbGVtLCBoYW5kbGVPYmogKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBSZW1vdmUgZ2VuZXJpYyBldmVudCBoYW5kbGVyIGlmIHdlIHJlbW92ZWQgc29tZXRoaW5nIGFuZCBubyBtb3JlIGhhbmRsZXJzIGV4aXN0XFxuXFx0XFx0XFx0Ly8gKGF2b2lkcyBwb3RlbnRpYWwgZm9yIGVuZGxlc3MgcmVjdXJzaW9uIGR1cmluZyByZW1vdmFsIG9mIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMpXFxuXFx0XFx0XFx0aWYgKCBvcmlnQ291bnQgJiYgIWhhbmRsZXJzLmxlbmd0aCApIHtcXG5cXHRcXHRcXHRcXHRpZiAoICFzcGVjaWFsLnRlYXJkb3duIHx8XFxuXFx0XFx0XFx0XFx0XFx0c3BlY2lhbC50ZWFyZG93bi5jYWxsKCBlbGVtLCBuYW1lc3BhY2VzLCBlbGVtRGF0YS5oYW5kbGUgKSA9PT0gZmFsc2UgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0alF1ZXJ5LnJlbW92ZUV2ZW50KCBlbGVtLCB0eXBlLCBlbGVtRGF0YS5oYW5kbGUgKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0ZGVsZXRlIGV2ZW50c1sgdHlwZSBdO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gUmVtb3ZlIGRhdGEgYW5kIHRoZSBleHBhbmRvIGlmIGl0J3Mgbm8gbG9uZ2VyIHVzZWRcXG5cXHRcXHRpZiAoIGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBldmVudHMgKSApIHtcXG5cXHRcXHRcXHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFxcXCJoYW5kbGUgZXZlbnRzXFxcIiApO1xcblxcdFxcdH1cXG5cXHR9LFxcblxcblxcdGRpc3BhdGNoOiBmdW5jdGlvbiggbmF0aXZlRXZlbnQgKSB7XFxuXFxuXFx0XFx0Ly8gTWFrZSBhIHdyaXRhYmxlIGpRdWVyeS5FdmVudCBmcm9tIHRoZSBuYXRpdmUgZXZlbnQgb2JqZWN0XFxuXFx0XFx0dmFyIGV2ZW50ID0galF1ZXJ5LmV2ZW50LmZpeCggbmF0aXZlRXZlbnQgKTtcXG5cXG5cXHRcXHR2YXIgaSwgaiwgcmV0LCBtYXRjaGVkLCBoYW5kbGVPYmosIGhhbmRsZXJRdWV1ZSxcXG5cXHRcXHRcXHRhcmdzID0gbmV3IEFycmF5KCBhcmd1bWVudHMubGVuZ3RoICksXFxuXFx0XFx0XFx0aGFuZGxlcnMgPSAoIGRhdGFQcml2LmdldCggdGhpcywgXFxcImV2ZW50c1xcXCIgKSB8fCB7fSApWyBldmVudC50eXBlIF0gfHwgW10sXFxuXFx0XFx0XFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyBldmVudC50eXBlIF0gfHwge307XFxuXFxuXFx0XFx0Ly8gVXNlIHRoZSBmaXgtZWQgalF1ZXJ5LkV2ZW50IHJhdGhlciB0aGFuIHRoZSAocmVhZC1vbmx5KSBuYXRpdmUgZXZlbnRcXG5cXHRcXHRhcmdzWyAwIF0gPSBldmVudDtcXG5cXG5cXHRcXHRmb3IgKCBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyApIHtcXG5cXHRcXHRcXHRhcmdzWyBpIF0gPSBhcmd1bWVudHNbIGkgXTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZXZlbnQuZGVsZWdhdGVUYXJnZXQgPSB0aGlzO1xcblxcblxcdFxcdC8vIENhbGwgdGhlIHByZURpc3BhdGNoIGhvb2sgZm9yIHRoZSBtYXBwZWQgdHlwZSwgYW5kIGxldCBpdCBiYWlsIGlmIGRlc2lyZWRcXG5cXHRcXHRpZiAoIHNwZWNpYWwucHJlRGlzcGF0Y2ggJiYgc3BlY2lhbC5wcmVEaXNwYXRjaC5jYWxsKCB0aGlzLCBldmVudCApID09PSBmYWxzZSApIHtcXG5cXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIERldGVybWluZSBoYW5kbGVyc1xcblxcdFxcdGhhbmRsZXJRdWV1ZSA9IGpRdWVyeS5ldmVudC5oYW5kbGVycy5jYWxsKCB0aGlzLCBldmVudCwgaGFuZGxlcnMgKTtcXG5cXG5cXHRcXHQvLyBSdW4gZGVsZWdhdGVzIGZpcnN0OyB0aGV5IG1heSB3YW50IHRvIHN0b3AgcHJvcGFnYXRpb24gYmVuZWF0aCB1c1xcblxcdFxcdGkgPSAwO1xcblxcdFxcdHdoaWxlICggKCBtYXRjaGVkID0gaGFuZGxlclF1ZXVlWyBpKysgXSApICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xcblxcdFxcdFxcdGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBtYXRjaGVkLmVsZW07XFxuXFxuXFx0XFx0XFx0aiA9IDA7XFxuXFx0XFx0XFx0d2hpbGUgKCAoIGhhbmRsZU9iaiA9IG1hdGNoZWQuaGFuZGxlcnNbIGorKyBdICkgJiZcXG5cXHRcXHRcXHRcXHQhZXZlbnQuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBUcmlnZ2VyZWQgZXZlbnQgbXVzdCBlaXRoZXIgMSkgaGF2ZSBubyBuYW1lc3BhY2UsIG9yIDIpIGhhdmUgbmFtZXNwYWNlKHMpXFxuXFx0XFx0XFx0XFx0Ly8gYSBzdWJzZXQgb3IgZXF1YWwgdG8gdGhvc2UgaW4gdGhlIGJvdW5kIGV2ZW50IChib3RoIGNhbiBoYXZlIG5vIG5hbWVzcGFjZSkuXFxuXFx0XFx0XFx0XFx0aWYgKCAhZXZlbnQucm5hbWVzcGFjZSB8fCBldmVudC5ybmFtZXNwYWNlLnRlc3QoIGhhbmRsZU9iai5uYW1lc3BhY2UgKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRldmVudC5oYW5kbGVPYmogPSBoYW5kbGVPYmo7XFxuXFx0XFx0XFx0XFx0XFx0ZXZlbnQuZGF0YSA9IGhhbmRsZU9iai5kYXRhO1xcblxcblxcdFxcdFxcdFxcdFxcdHJldCA9ICggKCBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgaGFuZGxlT2JqLm9yaWdUeXBlIF0gfHwge30gKS5oYW5kbGUgfHxcXG5cXHRcXHRcXHRcXHRcXHRcXHRoYW5kbGVPYmouaGFuZGxlciApLmFwcGx5KCBtYXRjaGVkLmVsZW0sIGFyZ3MgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHJldCAhPT0gdW5kZWZpbmVkICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggKCBldmVudC5yZXN1bHQgPSByZXQgKSA9PT0gZmFsc2UgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIENhbGwgdGhlIHBvc3REaXNwYXRjaCBob29rIGZvciB0aGUgbWFwcGVkIHR5cGVcXG5cXHRcXHRpZiAoIHNwZWNpYWwucG9zdERpc3BhdGNoICkge1xcblxcdFxcdFxcdHNwZWNpYWwucG9zdERpc3BhdGNoLmNhbGwoIHRoaXMsIGV2ZW50ICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiBldmVudC5yZXN1bHQ7XFxuXFx0fSxcXG5cXG5cXHRoYW5kbGVyczogZnVuY3Rpb24oIGV2ZW50LCBoYW5kbGVycyApIHtcXG5cXHRcXHR2YXIgaSwgaGFuZGxlT2JqLCBzZWwsIG1hdGNoZWRIYW5kbGVycywgbWF0Y2hlZFNlbGVjdG9ycyxcXG5cXHRcXHRcXHRoYW5kbGVyUXVldWUgPSBbXSxcXG5cXHRcXHRcXHRkZWxlZ2F0ZUNvdW50ID0gaGFuZGxlcnMuZGVsZWdhdGVDb3VudCxcXG5cXHRcXHRcXHRjdXIgPSBldmVudC50YXJnZXQ7XFxuXFxuXFx0XFx0Ly8gRmluZCBkZWxlZ2F0ZSBoYW5kbGVyc1xcblxcdFxcdGlmICggZGVsZWdhdGVDb3VudCAmJlxcblxcblxcdFxcdFxcdC8vIFN1cHBvcnQ6IElFIDw9OVxcblxcdFxcdFxcdC8vIEJsYWNrLWhvbGUgU1ZHIDx1c2U+IGluc3RhbmNlIHRyZWVzICh0cmFjLTEzMTgwKVxcblxcdFxcdFxcdGN1ci5ub2RlVHlwZSAmJlxcblxcblxcdFxcdFxcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00MlxcblxcdFxcdFxcdC8vIFN1cHByZXNzIHNwZWMtdmlvbGF0aW5nIGNsaWNrcyBpbmRpY2F0aW5nIGEgbm9uLXByaW1hcnkgcG9pbnRlciBidXR0b24gKHRyYWMtMzg2MSlcXG5cXHRcXHRcXHQvLyBodHRwczovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudC10eXBlLWNsaWNrXFxuXFx0XFx0XFx0Ly8gU3VwcG9ydDogSUUgMTEgb25seVxcblxcdFxcdFxcdC8vIC4uLmJ1dCBub3QgYXJyb3cga2V5IFxcXCJjbGlja3NcXFwiIG9mIHJhZGlvIGlucHV0cywgd2hpY2ggY2FuIGhhdmUgYGJ1dHRvbmAgLTEgKGdoLTIzNDMpXFxuXFx0XFx0XFx0ISggZXZlbnQudHlwZSA9PT0gXFxcImNsaWNrXFxcIiAmJiBldmVudC5idXR0b24gPj0gMSApICkge1xcblxcblxcdFxcdFxcdGZvciAoIDsgY3VyICE9PSB0aGlzOyBjdXIgPSBjdXIucGFyZW50Tm9kZSB8fCB0aGlzICkge1xcblxcblxcdFxcdFxcdFxcdC8vIERvbid0IGNoZWNrIG5vbi1lbGVtZW50cyAoIzEzMjA4KVxcblxcdFxcdFxcdFxcdC8vIERvbid0IHByb2Nlc3MgY2xpY2tzIG9uIGRpc2FibGVkIGVsZW1lbnRzICgjNjkxMSwgIzgxNjUsICMxMTM4MiwgIzExNzY0KVxcblxcdFxcdFxcdFxcdGlmICggY3VyLm5vZGVUeXBlID09PSAxICYmICEoIGV2ZW50LnR5cGUgPT09IFxcXCJjbGlja1xcXCIgJiYgY3VyLmRpc2FibGVkID09PSB0cnVlICkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0bWF0Y2hlZEhhbmRsZXJzID0gW107XFxuXFx0XFx0XFx0XFx0XFx0bWF0Y2hlZFNlbGVjdG9ycyA9IHt9O1xcblxcdFxcdFxcdFxcdFxcdGZvciAoIGkgPSAwOyBpIDwgZGVsZWdhdGVDb3VudDsgaSsrICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGhhbmRsZU9iaiA9IGhhbmRsZXJzWyBpIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gRG9uJ3QgY29uZmxpY3Qgd2l0aCBPYmplY3QucHJvdG90eXBlIHByb3BlcnRpZXMgKCMxMzIwMylcXG5cXHRcXHRcXHRcXHRcXHRcXHRzZWwgPSBoYW5kbGVPYmouc2VsZWN0b3IgKyBcXFwiIFxcXCI7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBtYXRjaGVkU2VsZWN0b3JzWyBzZWwgXSA9PT0gdW5kZWZpbmVkICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdG1hdGNoZWRTZWxlY3RvcnNbIHNlbCBdID0gaGFuZGxlT2JqLm5lZWRzQ29udGV4dCA/XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0alF1ZXJ5KCBzZWwsIHRoaXMgKS5pbmRleCggY3VyICkgPiAtMSA6XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0alF1ZXJ5LmZpbmQoIHNlbCwgdGhpcywgbnVsbCwgWyBjdXIgXSApLmxlbmd0aDtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBtYXRjaGVkU2VsZWN0b3JzWyBzZWwgXSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRtYXRjaGVkSGFuZGxlcnMucHVzaCggaGFuZGxlT2JqICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIG1hdGNoZWRIYW5kbGVycy5sZW5ndGggKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aGFuZGxlclF1ZXVlLnB1c2goIHsgZWxlbTogY3VyLCBoYW5kbGVyczogbWF0Y2hlZEhhbmRsZXJzIH0gKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gQWRkIHRoZSByZW1haW5pbmcgKGRpcmVjdGx5LWJvdW5kKSBoYW5kbGVyc1xcblxcdFxcdGN1ciA9IHRoaXM7XFxuXFx0XFx0aWYgKCBkZWxlZ2F0ZUNvdW50IDwgaGFuZGxlcnMubGVuZ3RoICkge1xcblxcdFxcdFxcdGhhbmRsZXJRdWV1ZS5wdXNoKCB7IGVsZW06IGN1ciwgaGFuZGxlcnM6IGhhbmRsZXJzLnNsaWNlKCBkZWxlZ2F0ZUNvdW50ICkgfSApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gaGFuZGxlclF1ZXVlO1xcblxcdH0sXFxuXFxuXFx0YWRkUHJvcDogZnVuY3Rpb24oIG5hbWUsIGhvb2sgKSB7XFxuXFx0XFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCBqUXVlcnkuRXZlbnQucHJvdG90eXBlLCBuYW1lLCB7XFxuXFx0XFx0XFx0ZW51bWVyYWJsZTogdHJ1ZSxcXG5cXHRcXHRcXHRjb25maWd1cmFibGU6IHRydWUsXFxuXFxuXFx0XFx0XFx0Z2V0OiBpc0Z1bmN0aW9uKCBob29rICkgP1xcblxcdFxcdFxcdFxcdGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdFxcdGlmICggdGhpcy5vcmlnaW5hbEV2ZW50ICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBob29rKCB0aGlzLm9yaWdpbmFsRXZlbnQgKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fSA6XFxuXFx0XFx0XFx0XFx0ZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCB0aGlzLm9yaWdpbmFsRXZlbnQgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMub3JpZ2luYWxFdmVudFsgbmFtZSBdO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdHNldDogZnVuY3Rpb24oIHZhbHVlICkge1xcblxcdFxcdFxcdFxcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgbmFtZSwge1xcblxcdFxcdFxcdFxcdFxcdGVudW1lcmFibGU6IHRydWUsXFxuXFx0XFx0XFx0XFx0XFx0Y29uZmlndXJhYmxlOiB0cnVlLFxcblxcdFxcdFxcdFxcdFxcdHdyaXRhYmxlOiB0cnVlLFxcblxcdFxcdFxcdFxcdFxcdHZhbHVlOiB2YWx1ZVxcblxcdFxcdFxcdFxcdH0gKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSApO1xcblxcdH0sXFxuXFxuXFx0Zml4OiBmdW5jdGlvbiggb3JpZ2luYWxFdmVudCApIHtcXG5cXHRcXHRyZXR1cm4gb3JpZ2luYWxFdmVudFsgalF1ZXJ5LmV4cGFuZG8gXSA/XFxuXFx0XFx0XFx0b3JpZ2luYWxFdmVudCA6XFxuXFx0XFx0XFx0bmV3IGpRdWVyeS5FdmVudCggb3JpZ2luYWxFdmVudCApO1xcblxcdH0sXFxuXFxuXFx0c3BlY2lhbDoge1xcblxcdFxcdGxvYWQ6IHtcXG5cXG5cXHRcXHRcXHQvLyBQcmV2ZW50IHRyaWdnZXJlZCBpbWFnZS5sb2FkIGV2ZW50cyBmcm9tIGJ1YmJsaW5nIHRvIHdpbmRvdy5sb2FkXFxuXFx0XFx0XFx0bm9CdWJibGU6IHRydWVcXG5cXHRcXHR9LFxcblxcdFxcdGZvY3VzOiB7XFxuXFxuXFx0XFx0XFx0Ly8gRmlyZSBuYXRpdmUgZXZlbnQgaWYgcG9zc2libGUgc28gYmx1ci9mb2N1cyBzZXF1ZW5jZSBpcyBjb3JyZWN0XFxuXFx0XFx0XFx0dHJpZ2dlcjogZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCB0aGlzICE9PSBzYWZlQWN0aXZlRWxlbWVudCgpICYmIHRoaXMuZm9jdXMgKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5mb2N1cygpO1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRkZWxlZ2F0ZVR5cGU6IFxcXCJmb2N1c2luXFxcIlxcblxcdFxcdH0sXFxuXFx0XFx0Ymx1cjoge1xcblxcdFxcdFxcdHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdGlmICggdGhpcyA9PT0gc2FmZUFjdGl2ZUVsZW1lbnQoKSAmJiB0aGlzLmJsdXIgKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5ibHVyKCk7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LFxcblxcdFxcdFxcdGRlbGVnYXRlVHlwZTogXFxcImZvY3Vzb3V0XFxcIlxcblxcdFxcdH0sXFxuXFx0XFx0Y2xpY2s6IHtcXG5cXG5cXHRcXHRcXHQvLyBGb3IgY2hlY2tib3gsIGZpcmUgbmF0aXZlIGV2ZW50IHNvIGNoZWNrZWQgc3RhdGUgd2lsbCBiZSByaWdodFxcblxcdFxcdFxcdHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdGlmICggdGhpcy50eXBlID09PSBcXFwiY2hlY2tib3hcXFwiICYmIHRoaXMuY2xpY2sgJiYgbm9kZU5hbWUoIHRoaXMsIFxcXCJpbnB1dFxcXCIgKSApIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmNsaWNrKCk7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdC8vIEZvciBjcm9zcy1icm93c2VyIGNvbnNpc3RlbmN5LCBkb24ndCBmaXJlIG5hdGl2ZSAuY2xpY2soKSBvbiBsaW5rc1xcblxcdFxcdFxcdF9kZWZhdWx0OiBmdW5jdGlvbiggZXZlbnQgKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIG5vZGVOYW1lKCBldmVudC50YXJnZXQsIFxcXCJhXFxcIiApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcblxcdFxcdGJlZm9yZXVubG9hZDoge1xcblxcdFxcdFxcdHBvc3REaXNwYXRjaDogZnVuY3Rpb24oIGV2ZW50ICkge1xcblxcblxcdFxcdFxcdFxcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggMjArXFxuXFx0XFx0XFx0XFx0Ly8gRmlyZWZveCBkb2Vzbid0IGFsZXJ0IGlmIHRoZSByZXR1cm5WYWx1ZSBmaWVsZCBpcyBub3Qgc2V0LlxcblxcdFxcdFxcdFxcdGlmICggZXZlbnQucmVzdWx0ICE9PSB1bmRlZmluZWQgJiYgZXZlbnQub3JpZ2luYWxFdmVudCApIHtcXG5cXHRcXHRcXHRcXHRcXHRldmVudC5vcmlnaW5hbEV2ZW50LnJldHVyblZhbHVlID0gZXZlbnQucmVzdWx0O1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdH1cXG59O1xcblxcbmpRdWVyeS5yZW1vdmVFdmVudCA9IGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBoYW5kbGUgKSB7XFxuXFxuXFx0Ly8gVGhpcyBcXFwiaWZcXFwiIGlzIG5lZWRlZCBmb3IgcGxhaW4gb2JqZWN0c1xcblxcdGlmICggZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyICkge1xcblxcdFxcdGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lciggdHlwZSwgaGFuZGxlICk7XFxuXFx0fVxcbn07XFxuXFxualF1ZXJ5LkV2ZW50ID0gZnVuY3Rpb24oIHNyYywgcHJvcHMgKSB7XFxuXFxuXFx0Ly8gQWxsb3cgaW5zdGFudGlhdGlvbiB3aXRob3V0IHRoZSAnbmV3JyBrZXl3b3JkXFxuXFx0aWYgKCAhKCB0aGlzIGluc3RhbmNlb2YgalF1ZXJ5LkV2ZW50ICkgKSB7XFxuXFx0XFx0cmV0dXJuIG5ldyBqUXVlcnkuRXZlbnQoIHNyYywgcHJvcHMgKTtcXG5cXHR9XFxuXFxuXFx0Ly8gRXZlbnQgb2JqZWN0XFxuXFx0aWYgKCBzcmMgJiYgc3JjLnR5cGUgKSB7XFxuXFx0XFx0dGhpcy5vcmlnaW5hbEV2ZW50ID0gc3JjO1xcblxcdFxcdHRoaXMudHlwZSA9IHNyYy50eXBlO1xcblxcblxcdFxcdC8vIEV2ZW50cyBidWJibGluZyB1cCB0aGUgZG9jdW1lbnQgbWF5IGhhdmUgYmVlbiBtYXJrZWQgYXMgcHJldmVudGVkXFxuXFx0XFx0Ly8gYnkgYSBoYW5kbGVyIGxvd2VyIGRvd24gdGhlIHRyZWU7IHJlZmxlY3QgdGhlIGNvcnJlY3QgdmFsdWUuXFxuXFx0XFx0dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBzcmMuZGVmYXVsdFByZXZlbnRlZCB8fFxcblxcdFxcdFxcdFxcdHNyYy5kZWZhdWx0UHJldmVudGVkID09PSB1bmRlZmluZWQgJiZcXG5cXG5cXHRcXHRcXHRcXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9Mi4zIG9ubHlcXG5cXHRcXHRcXHRcXHRzcmMucmV0dXJuVmFsdWUgPT09IGZhbHNlID9cXG5cXHRcXHRcXHRyZXR1cm5UcnVlIDpcXG5cXHRcXHRcXHRyZXR1cm5GYWxzZTtcXG5cXG5cXHRcXHQvLyBDcmVhdGUgdGFyZ2V0IHByb3BlcnRpZXNcXG5cXHRcXHQvLyBTdXBwb3J0OiBTYWZhcmkgPD02IC0gNyBvbmx5XFxuXFx0XFx0Ly8gVGFyZ2V0IHNob3VsZCBub3QgYmUgYSB0ZXh0IG5vZGUgKCM1MDQsICMxMzE0MylcXG5cXHRcXHR0aGlzLnRhcmdldCA9ICggc3JjLnRhcmdldCAmJiBzcmMudGFyZ2V0Lm5vZGVUeXBlID09PSAzICkgP1xcblxcdFxcdFxcdHNyYy50YXJnZXQucGFyZW50Tm9kZSA6XFxuXFx0XFx0XFx0c3JjLnRhcmdldDtcXG5cXG5cXHRcXHR0aGlzLmN1cnJlbnRUYXJnZXQgPSBzcmMuY3VycmVudFRhcmdldDtcXG5cXHRcXHR0aGlzLnJlbGF0ZWRUYXJnZXQgPSBzcmMucmVsYXRlZFRhcmdldDtcXG5cXG5cXHQvLyBFdmVudCB0eXBlXFxuXFx0fSBlbHNlIHtcXG5cXHRcXHR0aGlzLnR5cGUgPSBzcmM7XFxuXFx0fVxcblxcblxcdC8vIFB1dCBleHBsaWNpdGx5IHByb3ZpZGVkIHByb3BlcnRpZXMgb250byB0aGUgZXZlbnQgb2JqZWN0XFxuXFx0aWYgKCBwcm9wcyApIHtcXG5cXHRcXHRqUXVlcnkuZXh0ZW5kKCB0aGlzLCBwcm9wcyApO1xcblxcdH1cXG5cXG5cXHQvLyBDcmVhdGUgYSB0aW1lc3RhbXAgaWYgaW5jb21pbmcgZXZlbnQgZG9lc24ndCBoYXZlIG9uZVxcblxcdHRoaXMudGltZVN0YW1wID0gc3JjICYmIHNyYy50aW1lU3RhbXAgfHwgRGF0ZS5ub3coKTtcXG5cXG5cXHQvLyBNYXJrIGl0IGFzIGZpeGVkXFxuXFx0dGhpc1sgalF1ZXJ5LmV4cGFuZG8gXSA9IHRydWU7XFxufTtcXG5cXG4vLyBqUXVlcnkuRXZlbnQgaXMgYmFzZWQgb24gRE9NMyBFdmVudHMgYXMgc3BlY2lmaWVkIGJ5IHRoZSBFQ01BU2NyaXB0IExhbmd1YWdlIEJpbmRpbmdcXG4vLyBodHRwczovL3d3dy53My5vcmcvVFIvMjAwMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAwMzAzMzEvZWNtYS1zY3JpcHQtYmluZGluZy5odG1sXFxualF1ZXJ5LkV2ZW50LnByb3RvdHlwZSA9IHtcXG5cXHRjb25zdHJ1Y3RvcjogalF1ZXJ5LkV2ZW50LFxcblxcdGlzRGVmYXVsdFByZXZlbnRlZDogcmV0dXJuRmFsc2UsXFxuXFx0aXNQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxcblxcdGlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcXG5cXHRpc1NpbXVsYXRlZDogZmFsc2UsXFxuXFxuXFx0cHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uKCkge1xcblxcdFxcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xcblxcblxcdFxcdHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gcmV0dXJuVHJ1ZTtcXG5cXG5cXHRcXHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XFxuXFx0XFx0XFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xcblxcdFxcdH1cXG5cXHR9LFxcblxcdHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XFxuXFx0XFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XFxuXFxuXFx0XFx0dGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XFxuXFxuXFx0XFx0aWYgKCBlICYmICF0aGlzLmlzU2ltdWxhdGVkICkge1xcblxcdFxcdFxcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XFxuXFx0XFx0fVxcblxcdH0sXFxuXFx0c3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcXG5cXHRcXHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcXG5cXG5cXHRcXHR0aGlzLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcXG5cXG5cXHRcXHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XFxuXFx0XFx0XFx0ZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0dGhpcy5zdG9wUHJvcGFnYXRpb24oKTtcXG5cXHR9XFxufTtcXG5cXG4vLyBJbmNsdWRlcyBhbGwgY29tbW9uIGV2ZW50IHByb3BzIGluY2x1ZGluZyBLZXlFdmVudCBhbmQgTW91c2VFdmVudCBzcGVjaWZpYyBwcm9wc1xcbmpRdWVyeS5lYWNoKCB7XFxuXFx0YWx0S2V5OiB0cnVlLFxcblxcdGJ1YmJsZXM6IHRydWUsXFxuXFx0Y2FuY2VsYWJsZTogdHJ1ZSxcXG5cXHRjaGFuZ2VkVG91Y2hlczogdHJ1ZSxcXG5cXHRjdHJsS2V5OiB0cnVlLFxcblxcdGRldGFpbDogdHJ1ZSxcXG5cXHRldmVudFBoYXNlOiB0cnVlLFxcblxcdG1ldGFLZXk6IHRydWUsXFxuXFx0cGFnZVg6IHRydWUsXFxuXFx0cGFnZVk6IHRydWUsXFxuXFx0c2hpZnRLZXk6IHRydWUsXFxuXFx0dmlldzogdHJ1ZSxcXG5cXHRcXFwiY2hhclxcXCI6IHRydWUsXFxuXFx0Y2hhckNvZGU6IHRydWUsXFxuXFx0a2V5OiB0cnVlLFxcblxcdGtleUNvZGU6IHRydWUsXFxuXFx0YnV0dG9uOiB0cnVlLFxcblxcdGJ1dHRvbnM6IHRydWUsXFxuXFx0Y2xpZW50WDogdHJ1ZSxcXG5cXHRjbGllbnRZOiB0cnVlLFxcblxcdG9mZnNldFg6IHRydWUsXFxuXFx0b2Zmc2V0WTogdHJ1ZSxcXG5cXHRwb2ludGVySWQ6IHRydWUsXFxuXFx0cG9pbnRlclR5cGU6IHRydWUsXFxuXFx0c2NyZWVuWDogdHJ1ZSxcXG5cXHRzY3JlZW5ZOiB0cnVlLFxcblxcdHRhcmdldFRvdWNoZXM6IHRydWUsXFxuXFx0dG9FbGVtZW50OiB0cnVlLFxcblxcdHRvdWNoZXM6IHRydWUsXFxuXFxuXFx0d2hpY2g6IGZ1bmN0aW9uKCBldmVudCApIHtcXG5cXHRcXHR2YXIgYnV0dG9uID0gZXZlbnQuYnV0dG9uO1xcblxcblxcdFxcdC8vIEFkZCB3aGljaCBmb3Iga2V5IGV2ZW50c1xcblxcdFxcdGlmICggZXZlbnQud2hpY2ggPT0gbnVsbCAmJiBya2V5RXZlbnQudGVzdCggZXZlbnQudHlwZSApICkge1xcblxcdFxcdFxcdHJldHVybiBldmVudC5jaGFyQ29kZSAhPSBudWxsID8gZXZlbnQuY2hhckNvZGUgOiBldmVudC5rZXlDb2RlO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBBZGQgd2hpY2ggZm9yIGNsaWNrOiAxID09PSBsZWZ0OyAyID09PSBtaWRkbGU7IDMgPT09IHJpZ2h0XFxuXFx0XFx0aWYgKCAhZXZlbnQud2hpY2ggJiYgYnV0dG9uICE9PSB1bmRlZmluZWQgJiYgcm1vdXNlRXZlbnQudGVzdCggZXZlbnQudHlwZSApICkge1xcblxcdFxcdFxcdGlmICggYnV0dG9uICYgMSApIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gMTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCBidXR0b24gJiAyICkge1xcblxcdFxcdFxcdFxcdHJldHVybiAzO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIGJ1dHRvbiAmIDQgKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIDI7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiAwO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gZXZlbnQud2hpY2g7XFxuXFx0fVxcbn0sIGpRdWVyeS5ldmVudC5hZGRQcm9wICk7XFxuXFxuLy8gQ3JlYXRlIG1vdXNlZW50ZXIvbGVhdmUgZXZlbnRzIHVzaW5nIG1vdXNlb3Zlci9vdXQgYW5kIGV2ZW50LXRpbWUgY2hlY2tzXFxuLy8gc28gdGhhdCBldmVudCBkZWxlZ2F0aW9uIHdvcmtzIGluIGpRdWVyeS5cXG4vLyBEbyB0aGUgc2FtZSBmb3IgcG9pbnRlcmVudGVyL3BvaW50ZXJsZWF2ZSBhbmQgcG9pbnRlcm92ZXIvcG9pbnRlcm91dFxcbi8vXFxuLy8gU3VwcG9ydDogU2FmYXJpIDcgb25seVxcbi8vIFNhZmFyaSBzZW5kcyBtb3VzZWVudGVyIHRvbyBvZnRlbjsgc2VlOlxcbi8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ3MDI1OFxcbi8vIGZvciB0aGUgZGVzY3JpcHRpb24gb2YgdGhlIGJ1ZyAoaXQgZXhpc3RlZCBpbiBvbGRlciBDaHJvbWUgdmVyc2lvbnMgYXMgd2VsbCkuXFxualF1ZXJ5LmVhY2goIHtcXG5cXHRtb3VzZWVudGVyOiBcXFwibW91c2VvdmVyXFxcIixcXG5cXHRtb3VzZWxlYXZlOiBcXFwibW91c2VvdXRcXFwiLFxcblxcdHBvaW50ZXJlbnRlcjogXFxcInBvaW50ZXJvdmVyXFxcIixcXG5cXHRwb2ludGVybGVhdmU6IFxcXCJwb2ludGVyb3V0XFxcIlxcbn0sIGZ1bmN0aW9uKCBvcmlnLCBmaXggKSB7XFxuXFx0alF1ZXJ5LmV2ZW50LnNwZWNpYWxbIG9yaWcgXSA9IHtcXG5cXHRcXHRkZWxlZ2F0ZVR5cGU6IGZpeCxcXG5cXHRcXHRiaW5kVHlwZTogZml4LFxcblxcblxcdFxcdGhhbmRsZTogZnVuY3Rpb24oIGV2ZW50ICkge1xcblxcdFxcdFxcdHZhciByZXQsXFxuXFx0XFx0XFx0XFx0dGFyZ2V0ID0gdGhpcyxcXG5cXHRcXHRcXHRcXHRyZWxhdGVkID0gZXZlbnQucmVsYXRlZFRhcmdldCxcXG5cXHRcXHRcXHRcXHRoYW5kbGVPYmogPSBldmVudC5oYW5kbGVPYmo7XFxuXFxuXFx0XFx0XFx0Ly8gRm9yIG1vdXNlZW50ZXIvbGVhdmUgY2FsbCB0aGUgaGFuZGxlciBpZiByZWxhdGVkIGlzIG91dHNpZGUgdGhlIHRhcmdldC5cXG5cXHRcXHRcXHQvLyBOQjogTm8gcmVsYXRlZFRhcmdldCBpZiB0aGUgbW91c2UgbGVmdC9lbnRlcmVkIHRoZSBicm93c2VyIHdpbmRvd1xcblxcdFxcdFxcdGlmICggIXJlbGF0ZWQgfHwgKCByZWxhdGVkICE9PSB0YXJnZXQgJiYgIWpRdWVyeS5jb250YWlucyggdGFyZ2V0LCByZWxhdGVkICkgKSApIHtcXG5cXHRcXHRcXHRcXHRldmVudC50eXBlID0gaGFuZGxlT2JqLm9yaWdUeXBlO1xcblxcdFxcdFxcdFxcdHJldCA9IGhhbmRsZU9iai5oYW5kbGVyLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcXG5cXHRcXHRcXHRcXHRldmVudC50eXBlID0gZml4O1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRyZXR1cm4gcmV0O1xcblxcdFxcdH1cXG5cXHR9O1xcbn0gKTtcXG5cXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XFxuXFxuXFx0b246IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICkge1xcblxcdFxcdHJldHVybiBvbiggdGhpcywgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApO1xcblxcdH0sXFxuXFx0b25lOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApIHtcXG5cXHRcXHRyZXR1cm4gb24oIHRoaXMsIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIDEgKTtcXG5cXHR9LFxcblxcdG9mZjogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZm4gKSB7XFxuXFx0XFx0dmFyIGhhbmRsZU9iaiwgdHlwZTtcXG5cXHRcXHRpZiAoIHR5cGVzICYmIHR5cGVzLnByZXZlbnREZWZhdWx0ICYmIHR5cGVzLmhhbmRsZU9iaiApIHtcXG5cXG5cXHRcXHRcXHQvLyAoIGV2ZW50ICkgIGRpc3BhdGNoZWQgalF1ZXJ5LkV2ZW50XFxuXFx0XFx0XFx0aGFuZGxlT2JqID0gdHlwZXMuaGFuZGxlT2JqO1xcblxcdFxcdFxcdGpRdWVyeSggdHlwZXMuZGVsZWdhdGVUYXJnZXQgKS5vZmYoXFxuXFx0XFx0XFx0XFx0aGFuZGxlT2JqLm5hbWVzcGFjZSA/XFxuXFx0XFx0XFx0XFx0XFx0aGFuZGxlT2JqLm9yaWdUeXBlICsgXFxcIi5cXFwiICsgaGFuZGxlT2JqLm5hbWVzcGFjZSA6XFxuXFx0XFx0XFx0XFx0XFx0aGFuZGxlT2JqLm9yaWdUeXBlLFxcblxcdFxcdFxcdFxcdGhhbmRsZU9iai5zZWxlY3RvcixcXG5cXHRcXHRcXHRcXHRoYW5kbGVPYmouaGFuZGxlclxcblxcdFxcdFxcdCk7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFx0XFx0fVxcblxcdFxcdGlmICggdHlwZW9mIHR5cGVzID09PSBcXFwib2JqZWN0XFxcIiApIHtcXG5cXG5cXHRcXHRcXHQvLyAoIHR5cGVzLW9iamVjdCBbLCBzZWxlY3Rvcl0gKVxcblxcdFxcdFxcdGZvciAoIHR5cGUgaW4gdHlwZXMgKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5vZmYoIHR5cGUsIHNlbGVjdG9yLCB0eXBlc1sgdHlwZSBdICk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcdFxcdH1cXG5cXHRcXHRpZiAoIHNlbGVjdG9yID09PSBmYWxzZSB8fCB0eXBlb2Ygc2VsZWN0b3IgPT09IFxcXCJmdW5jdGlvblxcXCIgKSB7XFxuXFxuXFx0XFx0XFx0Ly8gKCB0eXBlcyBbLCBmbl0gKVxcblxcdFxcdFxcdGZuID0gc2VsZWN0b3I7XFxuXFx0XFx0XFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XFxuXFx0XFx0fVxcblxcdFxcdGlmICggZm4gPT09IGZhbHNlICkge1xcblxcdFxcdFxcdGZuID0gcmV0dXJuRmFsc2U7XFxuXFx0XFx0fVxcblxcdFxcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdGpRdWVyeS5ldmVudC5yZW1vdmUoIHRoaXMsIHR5cGVzLCBmbiwgc2VsZWN0b3IgKTtcXG5cXHRcXHR9ICk7XFxuXFx0fVxcbn0gKTtcXG5cXG5cXG52YXJcXG5cXG5cXHQvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXFxuXFxuXFx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lc2xpbnQvZXNsaW50L2lzc3Vlcy8zMjI5XFxuXFx0cnhodG1sVGFnID0gLzwoPyFhcmVhfGJyfGNvbHxlbWJlZHxocnxpbWd8aW5wdXR8bGlua3xtZXRhfHBhcmFtKSgoW2Etel1bXlxcXFwvXFxcXDA+XFxcXHgyMFxcXFx0XFxcXHJcXFxcblxcXFxmXSopW14+XSopXFxcXC8+L2dpLFxcblxcblxcdC8qIGVzbGludC1lbmFibGUgKi9cXG5cXG5cXHQvLyBTdXBwb3J0OiBJRSA8PTEwIC0gMTEsIEVkZ2UgMTIgLSAxMyBvbmx5XFxuXFx0Ly8gSW4gSUUvRWRnZSB1c2luZyByZWdleCBncm91cHMgaGVyZSBjYXVzZXMgc2V2ZXJlIHNsb3dkb3ducy5cXG5cXHQvLyBTZWUgaHR0cHM6Ly9jb25uZWN0Lm1pY3Jvc29mdC5jb20vSUUvZmVlZGJhY2svZGV0YWlscy8xNzM2NTEyL1xcblxcdHJub0lubmVyaHRtbCA9IC88c2NyaXB0fDxzdHlsZXw8bGluay9pLFxcblxcblxcdC8vIGNoZWNrZWQ9XFxcImNoZWNrZWRcXFwiIG9yIGNoZWNrZWRcXG5cXHRyY2hlY2tlZCA9IC9jaGVja2VkXFxcXHMqKD86W149XXw9XFxcXHMqLmNoZWNrZWQuKS9pLFxcblxcdHJjbGVhblNjcmlwdCA9IC9eXFxcXHMqPCEoPzpcXFxcW0NEQVRBXFxcXFt8LS0pfCg/OlxcXFxdXFxcXF18LS0pPlxcXFxzKiQvZztcXG5cXG4vLyBQcmVmZXIgYSB0Ym9keSBvdmVyIGl0cyBwYXJlbnQgdGFibGUgZm9yIGNvbnRhaW5pbmcgbmV3IHJvd3NcXG5mdW5jdGlvbiBtYW5pcHVsYXRpb25UYXJnZXQoIGVsZW0sIGNvbnRlbnQgKSB7XFxuXFx0aWYgKCBub2RlTmFtZSggZWxlbSwgXFxcInRhYmxlXFxcIiApICYmXFxuXFx0XFx0bm9kZU5hbWUoIGNvbnRlbnQubm9kZVR5cGUgIT09IDExID8gY29udGVudCA6IGNvbnRlbnQuZmlyc3RDaGlsZCwgXFxcInRyXFxcIiApICkge1xcblxcblxcdFxcdHJldHVybiBqUXVlcnkoIGVsZW0gKS5jaGlsZHJlbiggXFxcInRib2R5XFxcIiApWyAwIF0gfHwgZWxlbTtcXG5cXHR9XFxuXFxuXFx0cmV0dXJuIGVsZW07XFxufVxcblxcbi8vIFJlcGxhY2UvcmVzdG9yZSB0aGUgdHlwZSBhdHRyaWJ1dGUgb2Ygc2NyaXB0IGVsZW1lbnRzIGZvciBzYWZlIERPTSBtYW5pcHVsYXRpb25cXG5mdW5jdGlvbiBkaXNhYmxlU2NyaXB0KCBlbGVtICkge1xcblxcdGVsZW0udHlwZSA9ICggZWxlbS5nZXRBdHRyaWJ1dGUoIFxcXCJ0eXBlXFxcIiApICE9PSBudWxsICkgKyBcXFwiL1xcXCIgKyBlbGVtLnR5cGU7XFxuXFx0cmV0dXJuIGVsZW07XFxufVxcbmZ1bmN0aW9uIHJlc3RvcmVTY3JpcHQoIGVsZW0gKSB7XFxuXFx0aWYgKCAoIGVsZW0udHlwZSB8fCBcXFwiXFxcIiApLnNsaWNlKCAwLCA1ICkgPT09IFxcXCJ0cnVlL1xcXCIgKSB7XFxuXFx0XFx0ZWxlbS50eXBlID0gZWxlbS50eXBlLnNsaWNlKCA1ICk7XFxuXFx0fSBlbHNlIHtcXG5cXHRcXHRlbGVtLnJlbW92ZUF0dHJpYnV0ZSggXFxcInR5cGVcXFwiICk7XFxuXFx0fVxcblxcblxcdHJldHVybiBlbGVtO1xcbn1cXG5cXG5mdW5jdGlvbiBjbG9uZUNvcHlFdmVudCggc3JjLCBkZXN0ICkge1xcblxcdHZhciBpLCBsLCB0eXBlLCBwZGF0YU9sZCwgcGRhdGFDdXIsIHVkYXRhT2xkLCB1ZGF0YUN1ciwgZXZlbnRzO1xcblxcblxcdGlmICggZGVzdC5ub2RlVHlwZSAhPT0gMSApIHtcXG5cXHRcXHRyZXR1cm47XFxuXFx0fVxcblxcblxcdC8vIDEuIENvcHkgcHJpdmF0ZSBkYXRhOiBldmVudHMsIGhhbmRsZXJzLCBldGMuXFxuXFx0aWYgKCBkYXRhUHJpdi5oYXNEYXRhKCBzcmMgKSApIHtcXG5cXHRcXHRwZGF0YU9sZCA9IGRhdGFQcml2LmFjY2Vzcyggc3JjICk7XFxuXFx0XFx0cGRhdGFDdXIgPSBkYXRhUHJpdi5zZXQoIGRlc3QsIHBkYXRhT2xkICk7XFxuXFx0XFx0ZXZlbnRzID0gcGRhdGFPbGQuZXZlbnRzO1xcblxcblxcdFxcdGlmICggZXZlbnRzICkge1xcblxcdFxcdFxcdGRlbGV0ZSBwZGF0YUN1ci5oYW5kbGU7XFxuXFx0XFx0XFx0cGRhdGFDdXIuZXZlbnRzID0ge307XFxuXFxuXFx0XFx0XFx0Zm9yICggdHlwZSBpbiBldmVudHMgKSB7XFxuXFx0XFx0XFx0XFx0Zm9yICggaSA9IDAsIGwgPSBldmVudHNbIHR5cGUgXS5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XFxuXFx0XFx0XFx0XFx0XFx0alF1ZXJ5LmV2ZW50LmFkZCggZGVzdCwgdHlwZSwgZXZlbnRzWyB0eXBlIF1bIGkgXSApO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdH1cXG5cXG5cXHQvLyAyLiBDb3B5IHVzZXIgZGF0YVxcblxcdGlmICggZGF0YVVzZXIuaGFzRGF0YSggc3JjICkgKSB7XFxuXFx0XFx0dWRhdGFPbGQgPSBkYXRhVXNlci5hY2Nlc3MoIHNyYyApO1xcblxcdFxcdHVkYXRhQ3VyID0galF1ZXJ5LmV4dGVuZCgge30sIHVkYXRhT2xkICk7XFxuXFxuXFx0XFx0ZGF0YVVzZXIuc2V0KCBkZXN0LCB1ZGF0YUN1ciApO1xcblxcdH1cXG59XFxuXFxuLy8gRml4IElFIGJ1Z3MsIHNlZSBzdXBwb3J0IHRlc3RzXFxuZnVuY3Rpb24gZml4SW5wdXQoIHNyYywgZGVzdCApIHtcXG5cXHR2YXIgbm9kZU5hbWUgPSBkZXN0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XFxuXFxuXFx0Ly8gRmFpbHMgdG8gcGVyc2lzdCB0aGUgY2hlY2tlZCBzdGF0ZSBvZiBhIGNsb25lZCBjaGVja2JveCBvciByYWRpbyBidXR0b24uXFxuXFx0aWYgKCBub2RlTmFtZSA9PT0gXFxcImlucHV0XFxcIiAmJiByY2hlY2thYmxlVHlwZS50ZXN0KCBzcmMudHlwZSApICkge1xcblxcdFxcdGRlc3QuY2hlY2tlZCA9IHNyYy5jaGVja2VkO1xcblxcblxcdC8vIEZhaWxzIHRvIHJldHVybiB0aGUgc2VsZWN0ZWQgb3B0aW9uIHRvIHRoZSBkZWZhdWx0IHNlbGVjdGVkIHN0YXRlIHdoZW4gY2xvbmluZyBvcHRpb25zXFxuXFx0fSBlbHNlIGlmICggbm9kZU5hbWUgPT09IFxcXCJpbnB1dFxcXCIgfHwgbm9kZU5hbWUgPT09IFxcXCJ0ZXh0YXJlYVxcXCIgKSB7XFxuXFx0XFx0ZGVzdC5kZWZhdWx0VmFsdWUgPSBzcmMuZGVmYXVsdFZhbHVlO1xcblxcdH1cXG59XFxuXFxuZnVuY3Rpb24gZG9tTWFuaXAoIGNvbGxlY3Rpb24sIGFyZ3MsIGNhbGxiYWNrLCBpZ25vcmVkICkge1xcblxcblxcdC8vIEZsYXR0ZW4gYW55IG5lc3RlZCBhcnJheXNcXG5cXHRhcmdzID0gY29uY2F0LmFwcGx5KCBbXSwgYXJncyApO1xcblxcblxcdHZhciBmcmFnbWVudCwgZmlyc3QsIHNjcmlwdHMsIGhhc1NjcmlwdHMsIG5vZGUsIGRvYyxcXG5cXHRcXHRpID0gMCxcXG5cXHRcXHRsID0gY29sbGVjdGlvbi5sZW5ndGgsXFxuXFx0XFx0aU5vQ2xvbmUgPSBsIC0gMSxcXG5cXHRcXHR2YWx1ZSA9IGFyZ3NbIDAgXSxcXG5cXHRcXHR2YWx1ZUlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uKCB2YWx1ZSApO1xcblxcblxcdC8vIFdlIGNhbid0IGNsb25lTm9kZSBmcmFnbWVudHMgdGhhdCBjb250YWluIGNoZWNrZWQsIGluIFdlYktpdFxcblxcdGlmICggdmFsdWVJc0Z1bmN0aW9uIHx8XFxuXFx0XFx0XFx0KCBsID4gMSAmJiB0eXBlb2YgdmFsdWUgPT09IFxcXCJzdHJpbmdcXFwiICYmXFxuXFx0XFx0XFx0XFx0IXN1cHBvcnQuY2hlY2tDbG9uZSAmJiByY2hlY2tlZC50ZXN0KCB2YWx1ZSApICkgKSB7XFxuXFx0XFx0cmV0dXJuIGNvbGxlY3Rpb24uZWFjaCggZnVuY3Rpb24oIGluZGV4ICkge1xcblxcdFxcdFxcdHZhciBzZWxmID0gY29sbGVjdGlvbi5lcSggaW5kZXggKTtcXG5cXHRcXHRcXHRpZiAoIHZhbHVlSXNGdW5jdGlvbiApIHtcXG5cXHRcXHRcXHRcXHRhcmdzWyAwIF0gPSB2YWx1ZS5jYWxsKCB0aGlzLCBpbmRleCwgc2VsZi5odG1sKCkgKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0ZG9tTWFuaXAoIHNlbGYsIGFyZ3MsIGNhbGxiYWNrLCBpZ25vcmVkICk7XFxuXFx0XFx0fSApO1xcblxcdH1cXG5cXG5cXHRpZiAoIGwgKSB7XFxuXFx0XFx0ZnJhZ21lbnQgPSBidWlsZEZyYWdtZW50KCBhcmdzLCBjb2xsZWN0aW9uWyAwIF0ub3duZXJEb2N1bWVudCwgZmFsc2UsIGNvbGxlY3Rpb24sIGlnbm9yZWQgKTtcXG5cXHRcXHRmaXJzdCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XFxuXFxuXFx0XFx0aWYgKCBmcmFnbWVudC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSApIHtcXG5cXHRcXHRcXHRmcmFnbWVudCA9IGZpcnN0O1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBSZXF1aXJlIGVpdGhlciBuZXcgY29udGVudCBvciBhbiBpbnRlcmVzdCBpbiBpZ25vcmVkIGVsZW1lbnRzIHRvIGludm9rZSB0aGUgY2FsbGJhY2tcXG5cXHRcXHRpZiAoIGZpcnN0IHx8IGlnbm9yZWQgKSB7XFxuXFx0XFx0XFx0c2NyaXB0cyA9IGpRdWVyeS5tYXAoIGdldEFsbCggZnJhZ21lbnQsIFxcXCJzY3JpcHRcXFwiICksIGRpc2FibGVTY3JpcHQgKTtcXG5cXHRcXHRcXHRoYXNTY3JpcHRzID0gc2NyaXB0cy5sZW5ndGg7XFxuXFxuXFx0XFx0XFx0Ly8gVXNlIHRoZSBvcmlnaW5hbCBmcmFnbWVudCBmb3IgdGhlIGxhc3QgaXRlbVxcblxcdFxcdFxcdC8vIGluc3RlYWQgb2YgdGhlIGZpcnN0IGJlY2F1c2UgaXQgY2FuIGVuZCB1cFxcblxcdFxcdFxcdC8vIGJlaW5nIGVtcHRpZWQgaW5jb3JyZWN0bHkgaW4gY2VydGFpbiBzaXR1YXRpb25zICgjODA3MCkuXFxuXFx0XFx0XFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xcblxcdFxcdFxcdFxcdG5vZGUgPSBmcmFnbWVudDtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGkgIT09IGlOb0Nsb25lICkge1xcblxcdFxcdFxcdFxcdFxcdG5vZGUgPSBqUXVlcnkuY2xvbmUoIG5vZGUsIHRydWUsIHRydWUgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBLZWVwIHJlZmVyZW5jZXMgdG8gY2xvbmVkIHNjcmlwdHMgZm9yIGxhdGVyIHJlc3RvcmF0aW9uXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBoYXNTY3JpcHRzICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcXG5cXHRcXHRcXHRcXHRcXHRcXHRqUXVlcnkubWVyZ2UoIHNjcmlwdHMsIGdldEFsbCggbm9kZSwgXFxcInNjcmlwdFxcXCIgKSApO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Y2FsbGJhY2suY2FsbCggY29sbGVjdGlvblsgaSBdLCBub2RlLCBpICk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggaGFzU2NyaXB0cyApIHtcXG5cXHRcXHRcXHRcXHRkb2MgPSBzY3JpcHRzWyBzY3JpcHRzLmxlbmd0aCAtIDEgXS5vd25lckRvY3VtZW50O1xcblxcblxcdFxcdFxcdFxcdC8vIFJlZW5hYmxlIHNjcmlwdHNcXG5cXHRcXHRcXHRcXHRqUXVlcnkubWFwKCBzY3JpcHRzLCByZXN0b3JlU2NyaXB0ICk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gRXZhbHVhdGUgZXhlY3V0YWJsZSBzY3JpcHRzIG9uIGZpcnN0IGRvY3VtZW50IGluc2VydGlvblxcblxcdFxcdFxcdFxcdGZvciAoIGkgPSAwOyBpIDwgaGFzU2NyaXB0czsgaSsrICkge1xcblxcdFxcdFxcdFxcdFxcdG5vZGUgPSBzY3JpcHRzWyBpIF07XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCByc2NyaXB0VHlwZS50ZXN0KCBub2RlLnR5cGUgfHwgXFxcIlxcXCIgKSAmJlxcblxcdFxcdFxcdFxcdFxcdFxcdCFkYXRhUHJpdi5hY2Nlc3MoIG5vZGUsIFxcXCJnbG9iYWxFdmFsXFxcIiApICYmXFxuXFx0XFx0XFx0XFx0XFx0XFx0alF1ZXJ5LmNvbnRhaW5zKCBkb2MsIG5vZGUgKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIG5vZGUuc3JjICYmICggbm9kZS50eXBlIHx8IFxcXCJcXFwiICkudG9Mb3dlckNhc2UoKSAgIT09IFxcXCJtb2R1bGVcXFwiICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIE9wdGlvbmFsIEFKQVggZGVwZW5kZW5jeSwgYnV0IHdvbid0IHJ1biBzY3JpcHRzIGlmIG5vdCBwcmVzZW50XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBqUXVlcnkuX2V2YWxVcmwgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0alF1ZXJ5Ll9ldmFsVXJsKCBub2RlLnNyYyApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdERPTUV2YWwoIG5vZGUudGV4dENvbnRlbnQucmVwbGFjZSggcmNsZWFuU2NyaXB0LCBcXFwiXFxcIiApLCBkb2MsIG5vZGUgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdH1cXG5cXG5cXHRyZXR1cm4gY29sbGVjdGlvbjtcXG59XFxuXFxuZnVuY3Rpb24gcmVtb3ZlKCBlbGVtLCBzZWxlY3Rvciwga2VlcERhdGEgKSB7XFxuXFx0dmFyIG5vZGUsXFxuXFx0XFx0bm9kZXMgPSBzZWxlY3RvciA/IGpRdWVyeS5maWx0ZXIoIHNlbGVjdG9yLCBlbGVtICkgOiBlbGVtLFxcblxcdFxcdGkgPSAwO1xcblxcblxcdGZvciAoIDsgKCBub2RlID0gbm9kZXNbIGkgXSApICE9IG51bGw7IGkrKyApIHtcXG5cXHRcXHRpZiAoICFrZWVwRGF0YSAmJiBub2RlLm5vZGVUeXBlID09PSAxICkge1xcblxcdFxcdFxcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggbm9kZSApICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICggbm9kZS5wYXJlbnROb2RlICkge1xcblxcdFxcdFxcdGlmICgga2VlcERhdGEgJiYgalF1ZXJ5LmNvbnRhaW5zKCBub2RlLm93bmVyRG9jdW1lbnQsIG5vZGUgKSApIHtcXG5cXHRcXHRcXHRcXHRzZXRHbG9iYWxFdmFsKCBnZXRBbGwoIG5vZGUsIFxcXCJzY3JpcHRcXFwiICkgKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0bm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBub2RlICk7XFxuXFx0XFx0fVxcblxcdH1cXG5cXG5cXHRyZXR1cm4gZWxlbTtcXG59XFxuXFxualF1ZXJ5LmV4dGVuZCgge1xcblxcdGh0bWxQcmVmaWx0ZXI6IGZ1bmN0aW9uKCBodG1sICkge1xcblxcdFxcdHJldHVybiBodG1sLnJlcGxhY2UoIHJ4aHRtbFRhZywgXFxcIjwkMT48LyQyPlxcXCIgKTtcXG5cXHR9LFxcblxcblxcdGNsb25lOiBmdW5jdGlvbiggZWxlbSwgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKSB7XFxuXFx0XFx0dmFyIGksIGwsIHNyY0VsZW1lbnRzLCBkZXN0RWxlbWVudHMsXFxuXFx0XFx0XFx0Y2xvbmUgPSBlbGVtLmNsb25lTm9kZSggdHJ1ZSApLFxcblxcdFxcdFxcdGluUGFnZSA9IGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICk7XFxuXFxuXFx0XFx0Ly8gRml4IElFIGNsb25pbmcgaXNzdWVzXFxuXFx0XFx0aWYgKCAhc3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCAmJiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgZWxlbS5ub2RlVHlwZSA9PT0gMTEgKSAmJlxcblxcdFxcdFxcdFxcdCFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcXG5cXG5cXHRcXHRcXHQvLyBXZSBlc2NoZXcgU2l6emxlIGhlcmUgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnM6IGh0dHBzOi8vanNwZXJmLmNvbS9nZXRhbGwtdnMtc2l6emxlLzJcXG5cXHRcXHRcXHRkZXN0RWxlbWVudHMgPSBnZXRBbGwoIGNsb25lICk7XFxuXFx0XFx0XFx0c3JjRWxlbWVudHMgPSBnZXRBbGwoIGVsZW0gKTtcXG5cXG5cXHRcXHRcXHRmb3IgKCBpID0gMCwgbCA9IHNyY0VsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcXG5cXHRcXHRcXHRcXHRmaXhJbnB1dCggc3JjRWxlbWVudHNbIGkgXSwgZGVzdEVsZW1lbnRzWyBpIF0gKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIENvcHkgdGhlIGV2ZW50cyBmcm9tIHRoZSBvcmlnaW5hbCB0byB0aGUgY2xvbmVcXG5cXHRcXHRpZiAoIGRhdGFBbmRFdmVudHMgKSB7XFxuXFx0XFx0XFx0aWYgKCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcXG5cXHRcXHRcXHRcXHRzcmNFbGVtZW50cyA9IHNyY0VsZW1lbnRzIHx8IGdldEFsbCggZWxlbSApO1xcblxcdFxcdFxcdFxcdGRlc3RFbGVtZW50cyA9IGRlc3RFbGVtZW50cyB8fCBnZXRBbGwoIGNsb25lICk7XFxuXFxuXFx0XFx0XFx0XFx0Zm9yICggaSA9IDAsIGwgPSBzcmNFbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XFxuXFx0XFx0XFx0XFx0XFx0Y2xvbmVDb3B5RXZlbnQoIHNyY0VsZW1lbnRzWyBpIF0sIGRlc3RFbGVtZW50c1sgaSBdICk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0Y2xvbmVDb3B5RXZlbnQoIGVsZW0sIGNsb25lICk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBQcmVzZXJ2ZSBzY3JpcHQgZXZhbHVhdGlvbiBoaXN0b3J5XFxuXFx0XFx0ZGVzdEVsZW1lbnRzID0gZ2V0QWxsKCBjbG9uZSwgXFxcInNjcmlwdFxcXCIgKTtcXG5cXHRcXHRpZiAoIGRlc3RFbGVtZW50cy5sZW5ndGggPiAwICkge1xcblxcdFxcdFxcdHNldEdsb2JhbEV2YWwoIGRlc3RFbGVtZW50cywgIWluUGFnZSAmJiBnZXRBbGwoIGVsZW0sIFxcXCJzY3JpcHRcXFwiICkgKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gUmV0dXJuIHRoZSBjbG9uZWQgc2V0XFxuXFx0XFx0cmV0dXJuIGNsb25lO1xcblxcdH0sXFxuXFxuXFx0Y2xlYW5EYXRhOiBmdW5jdGlvbiggZWxlbXMgKSB7XFxuXFx0XFx0dmFyIGRhdGEsIGVsZW0sIHR5cGUsXFxuXFx0XFx0XFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsLFxcblxcdFxcdFxcdGkgPSAwO1xcblxcblxcdFxcdGZvciAoIDsgKCBlbGVtID0gZWxlbXNbIGkgXSApICE9PSB1bmRlZmluZWQ7IGkrKyApIHtcXG5cXHRcXHRcXHRpZiAoIGFjY2VwdERhdGEoIGVsZW0gKSApIHtcXG5cXHRcXHRcXHRcXHRpZiAoICggZGF0YSA9IGVsZW1bIGRhdGFQcml2LmV4cGFuZG8gXSApICkge1xcblxcdFxcdFxcdFxcdFxcdGlmICggZGF0YS5ldmVudHMgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Zm9yICggdHlwZSBpbiBkYXRhLmV2ZW50cyApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIHNwZWNpYWxbIHR5cGUgXSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRqUXVlcnkuZXZlbnQucmVtb3ZlKCBlbGVtLCB0eXBlICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gVGhpcyBpcyBhIHNob3J0Y3V0IHRvIGF2b2lkIGpRdWVyeS5ldmVudC5yZW1vdmUncyBvdmVyaGVhZFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0alF1ZXJ5LnJlbW92ZUV2ZW50KCBlbGVtLCB0eXBlLCBkYXRhLmhhbmRsZSApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDUrXFxuXFx0XFx0XFx0XFx0XFx0Ly8gQXNzaWduIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIHVzaW5nIGRlbGV0ZSwgc2VlIERhdGEjcmVtb3ZlXFxuXFx0XFx0XFx0XFx0XFx0ZWxlbVsgZGF0YVByaXYuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRpZiAoIGVsZW1bIGRhdGFVc2VyLmV4cGFuZG8gXSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0zNSAtIDQ1K1xcblxcdFxcdFxcdFxcdFxcdC8vIEFzc2lnbiB1bmRlZmluZWQgaW5zdGVhZCBvZiB1c2luZyBkZWxldGUsIHNlZSBEYXRhI3JlbW92ZVxcblxcdFxcdFxcdFxcdFxcdGVsZW1bIGRhdGFVc2VyLmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9XFxufSApO1xcblxcbmpRdWVyeS5mbi5leHRlbmQoIHtcXG5cXHRkZXRhY2g6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcXG5cXHRcXHRyZXR1cm4gcmVtb3ZlKCB0aGlzLCBzZWxlY3RvciwgdHJ1ZSApO1xcblxcdH0sXFxuXFxuXFx0cmVtb3ZlOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XFxuXFx0XFx0cmV0dXJuIHJlbW92ZSggdGhpcywgc2VsZWN0b3IgKTtcXG5cXHR9LFxcblxcblxcdHRleHQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcXG5cXHRcXHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XFxuXFx0XFx0XFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgP1xcblxcdFxcdFxcdFxcdGpRdWVyeS50ZXh0KCB0aGlzICkgOlxcblxcdFxcdFxcdFxcdHRoaXMuZW1wdHkoKS5lYWNoKCBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLnRleHRDb250ZW50ID0gdmFsdWU7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH0gKTtcXG5cXHRcXHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCApO1xcblxcdH0sXFxuXFxuXFx0YXBwZW5kOiBmdW5jdGlvbigpIHtcXG5cXHRcXHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0XFx0XFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XFxuXFx0XFx0XFx0XFx0dmFyIHRhcmdldCA9IG1hbmlwdWxhdGlvblRhcmdldCggdGhpcywgZWxlbSApO1xcblxcdFxcdFxcdFxcdHRhcmdldC5hcHBlbmRDaGlsZCggZWxlbSApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9ICk7XFxuXFx0fSxcXG5cXG5cXHRwcmVwZW5kOiBmdW5jdGlvbigpIHtcXG5cXHRcXHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0XFx0XFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XFxuXFx0XFx0XFx0XFx0dmFyIHRhcmdldCA9IG1hbmlwdWxhdGlvblRhcmdldCggdGhpcywgZWxlbSApO1xcblxcdFxcdFxcdFxcdHRhcmdldC5pbnNlcnRCZWZvcmUoIGVsZW0sIHRhcmdldC5maXJzdENoaWxkICk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0gKTtcXG5cXHR9LFxcblxcblxcdGJlZm9yZTogZnVuY3Rpb24oKSB7XFxuXFx0XFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdFxcdGlmICggdGhpcy5wYXJlbnROb2RlICkge1xcblxcdFxcdFxcdFxcdHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGVsZW0sIHRoaXMgKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSApO1xcblxcdH0sXFxuXFxuXFx0YWZ0ZXI6IGZ1bmN0aW9uKCkge1xcblxcdFxcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcXG5cXHRcXHRcXHRpZiAoIHRoaXMucGFyZW50Tm9kZSApIHtcXG5cXHRcXHRcXHRcXHR0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0aGlzLm5leHRTaWJsaW5nICk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0gKTtcXG5cXHR9LFxcblxcblxcdGVtcHR5OiBmdW5jdGlvbigpIHtcXG5cXHRcXHR2YXIgZWxlbSxcXG5cXHRcXHRcXHRpID0gMDtcXG5cXG5cXHRcXHRmb3IgKCA7ICggZWxlbSA9IHRoaXNbIGkgXSApICE9IG51bGw7IGkrKyApIHtcXG5cXHRcXHRcXHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gUHJldmVudCBtZW1vcnkgbGVha3NcXG5cXHRcXHRcXHRcXHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0sIGZhbHNlICkgKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBSZW1vdmUgYW55IHJlbWFpbmluZyBub2Rlc1xcblxcdFxcdFxcdFxcdGVsZW0udGV4dENvbnRlbnQgPSBcXFwiXFxcIjtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiB0aGlzO1xcblxcdH0sXFxuXFxuXFx0Y2xvbmU6IGZ1bmN0aW9uKCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcXG5cXHRcXHRkYXRhQW5kRXZlbnRzID0gZGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZmFsc2UgOiBkYXRhQW5kRXZlbnRzO1xcblxcdFxcdGRlZXBEYXRhQW5kRXZlbnRzID0gZGVlcERhdGFBbmRFdmVudHMgPT0gbnVsbCA/IGRhdGFBbmRFdmVudHMgOiBkZWVwRGF0YUFuZEV2ZW50cztcXG5cXG5cXHRcXHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdHJldHVybiBqUXVlcnkuY2xvbmUoIHRoaXMsIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICk7XFxuXFx0XFx0fSApO1xcblxcdH0sXFxuXFxuXFx0aHRtbDogZnVuY3Rpb24oIHZhbHVlICkge1xcblxcdFxcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcXG5cXHRcXHRcXHR2YXIgZWxlbSA9IHRoaXNbIDAgXSB8fCB7fSxcXG5cXHRcXHRcXHRcXHRpID0gMCxcXG5cXHRcXHRcXHRcXHRsID0gdGhpcy5sZW5ndGg7XFxuXFxuXFx0XFx0XFx0aWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGVsZW0uaW5uZXJIVE1MO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBTZWUgaWYgd2UgY2FuIHRha2UgYSBzaG9ydGN1dCBhbmQganVzdCB1c2UgaW5uZXJIVE1MXFxuXFx0XFx0XFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFxcXCJzdHJpbmdcXFwiICYmICFybm9Jbm5lcmh0bWwudGVzdCggdmFsdWUgKSAmJlxcblxcdFxcdFxcdFxcdCF3cmFwTWFwWyAoIHJ0YWdOYW1lLmV4ZWMoIHZhbHVlICkgfHwgWyBcXFwiXFxcIiwgXFxcIlxcXCIgXSApWyAxIF0udG9Mb3dlckNhc2UoKSBdICkge1xcblxcblxcdFxcdFxcdFxcdHZhbHVlID0galF1ZXJ5Lmh0bWxQcmVmaWx0ZXIoIHZhbHVlICk7XFxuXFxuXFx0XFx0XFx0XFx0dHJ5IHtcXG5cXHRcXHRcXHRcXHRcXHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZWxlbSA9IHRoaXNbIGkgXSB8fCB7fTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBSZW1vdmUgZWxlbWVudCBub2RlcyBhbmQgcHJldmVudCBtZW1vcnkgbGVha3NcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBlbGVtLCBmYWxzZSApICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZWxlbS5pbm5lckhUTUwgPSB2YWx1ZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdGVsZW0gPSAwO1xcblxcblxcdFxcdFxcdFxcdC8vIElmIHVzaW5nIGlubmVySFRNTCB0aHJvd3MgYW4gZXhjZXB0aW9uLCB1c2UgdGhlIGZhbGxiYWNrIG1ldGhvZFxcblxcdFxcdFxcdFxcdH0gY2F0Y2ggKCBlICkge31cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCBlbGVtICkge1xcblxcdFxcdFxcdFxcdHRoaXMuZW1wdHkoKS5hcHBlbmQoIHZhbHVlICk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoICk7XFxuXFx0fSxcXG5cXG5cXHRyZXBsYWNlV2l0aDogZnVuY3Rpb24oKSB7XFxuXFx0XFx0dmFyIGlnbm9yZWQgPSBbXTtcXG5cXG5cXHRcXHQvLyBNYWtlIHRoZSBjaGFuZ2VzLCByZXBsYWNpbmcgZWFjaCBub24taWdub3JlZCBjb250ZXh0IGVsZW1lbnQgd2l0aCB0aGUgbmV3IGNvbnRlbnRcXG5cXHRcXHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0XFx0XFx0dmFyIHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcXG5cXG5cXHRcXHRcXHRpZiAoIGpRdWVyeS5pbkFycmF5KCB0aGlzLCBpZ25vcmVkICkgPCAwICkge1xcblxcdFxcdFxcdFxcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggdGhpcyApICk7XFxuXFx0XFx0XFx0XFx0aWYgKCBwYXJlbnQgKSB7XFxuXFx0XFx0XFx0XFx0XFx0cGFyZW50LnJlcGxhY2VDaGlsZCggZWxlbSwgdGhpcyApO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0Ly8gRm9yY2UgY2FsbGJhY2sgaW52b2NhdGlvblxcblxcdFxcdH0sIGlnbm9yZWQgKTtcXG5cXHR9XFxufSApO1xcblxcbmpRdWVyeS5lYWNoKCB7XFxuXFx0YXBwZW5kVG86IFxcXCJhcHBlbmRcXFwiLFxcblxcdHByZXBlbmRUbzogXFxcInByZXBlbmRcXFwiLFxcblxcdGluc2VydEJlZm9yZTogXFxcImJlZm9yZVxcXCIsXFxuXFx0aW5zZXJ0QWZ0ZXI6IFxcXCJhZnRlclxcXCIsXFxuXFx0cmVwbGFjZUFsbDogXFxcInJlcGxhY2VXaXRoXFxcIlxcbn0sIGZ1bmN0aW9uKCBuYW1lLCBvcmlnaW5hbCApIHtcXG5cXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcXG5cXHRcXHR2YXIgZWxlbXMsXFxuXFx0XFx0XFx0cmV0ID0gW10sXFxuXFx0XFx0XFx0aW5zZXJ0ID0galF1ZXJ5KCBzZWxlY3RvciApLFxcblxcdFxcdFxcdGxhc3QgPSBpbnNlcnQubGVuZ3RoIC0gMSxcXG5cXHRcXHRcXHRpID0gMDtcXG5cXG5cXHRcXHRmb3IgKCA7IGkgPD0gbGFzdDsgaSsrICkge1xcblxcdFxcdFxcdGVsZW1zID0gaSA9PT0gbGFzdCA/IHRoaXMgOiB0aGlzLmNsb25lKCB0cnVlICk7XFxuXFx0XFx0XFx0alF1ZXJ5KCBpbnNlcnRbIGkgXSApWyBvcmlnaW5hbCBdKCBlbGVtcyApO1xcblxcblxcdFxcdFxcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxcblxcdFxcdFxcdC8vIC5nZXQoKSBiZWNhdXNlIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcXG5cXHRcXHRcXHRwdXNoLmFwcGx5KCByZXQsIGVsZW1zLmdldCgpICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiB0aGlzLnB1c2hTdGFjayggcmV0ICk7XFxuXFx0fTtcXG59ICk7XFxudmFyIHJudW1ub25weCA9IG5ldyBSZWdFeHAoIFxcXCJeKFxcXCIgKyBwbnVtICsgXFxcIikoPyFweClbYS16JV0rJFxcXCIsIFxcXCJpXFxcIiApO1xcblxcbnZhciBnZXRTdHlsZXMgPSBmdW5jdGlvbiggZWxlbSApIHtcXG5cXG5cXHRcXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHksIEZpcmVmb3ggPD0zMCAoIzE1MDk4LCAjMTQxNTApXFxuXFx0XFx0Ly8gSUUgdGhyb3dzIG9uIGVsZW1lbnRzIGNyZWF0ZWQgaW4gcG9wdXBzXFxuXFx0XFx0Ly8gRkYgbWVhbndoaWxlIHRocm93cyBvbiBmcmFtZSBlbGVtZW50cyB0aHJvdWdoIFxcXCJkZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlXFxcIlxcblxcdFxcdHZhciB2aWV3ID0gZWxlbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xcblxcblxcdFxcdGlmICggIXZpZXcgfHwgIXZpZXcub3BlbmVyICkge1xcblxcdFxcdFxcdHZpZXcgPSB3aW5kb3c7XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiB2aWV3LmdldENvbXB1dGVkU3R5bGUoIGVsZW0gKTtcXG5cXHR9O1xcblxcbnZhciByYm94U3R5bGUgPSBuZXcgUmVnRXhwKCBjc3NFeHBhbmQuam9pbiggXFxcInxcXFwiICksIFxcXCJpXFxcIiApO1xcblxcblxcblxcbiggZnVuY3Rpb24oKSB7XFxuXFxuXFx0Ly8gRXhlY3V0aW5nIGJvdGggcGl4ZWxQb3NpdGlvbiAmIGJveFNpemluZ1JlbGlhYmxlIHRlc3RzIHJlcXVpcmUgb25seSBvbmUgbGF5b3V0XFxuXFx0Ly8gc28gdGhleSdyZSBleGVjdXRlZCBhdCB0aGUgc2FtZSB0aW1lIHRvIHNhdmUgdGhlIHNlY29uZCBjb21wdXRhdGlvbi5cXG5cXHRmdW5jdGlvbiBjb21wdXRlU3R5bGVUZXN0cygpIHtcXG5cXG5cXHRcXHQvLyBUaGlzIGlzIGEgc2luZ2xldG9uLCB3ZSBuZWVkIHRvIGV4ZWN1dGUgaXQgb25seSBvbmNlXFxuXFx0XFx0aWYgKCAhZGl2ICkge1xcblxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Y29udGFpbmVyLnN0eWxlLmNzc1RleHQgPSBcXFwicG9zaXRpb246YWJzb2x1dGU7bGVmdDotMTExMTFweDt3aWR0aDo2MHB4O1xcXCIgK1xcblxcdFxcdFxcdFxcXCJtYXJnaW4tdG9wOjFweDtwYWRkaW5nOjA7Ym9yZGVyOjBcXFwiO1xcblxcdFxcdGRpdi5zdHlsZS5jc3NUZXh0ID1cXG5cXHRcXHRcXHRcXFwicG9zaXRpb246cmVsYXRpdmU7ZGlzcGxheTpibG9jaztib3gtc2l6aW5nOmJvcmRlci1ib3g7b3ZlcmZsb3c6c2Nyb2xsO1xcXCIgK1xcblxcdFxcdFxcdFxcXCJtYXJnaW46YXV0bztib3JkZXI6MXB4O3BhZGRpbmc6MXB4O1xcXCIgK1xcblxcdFxcdFxcdFxcXCJ3aWR0aDo2MCU7dG9wOjElXFxcIjtcXG5cXHRcXHRkb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoIGNvbnRhaW5lciApLmFwcGVuZENoaWxkKCBkaXYgKTtcXG5cXG5cXHRcXHR2YXIgZGl2U3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSggZGl2ICk7XFxuXFx0XFx0cGl4ZWxQb3NpdGlvblZhbCA9IGRpdlN0eWxlLnRvcCAhPT0gXFxcIjElXFxcIjtcXG5cXG5cXHRcXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5LCBGaXJlZm94IDw9MyAtIDQ0XFxuXFx0XFx0cmVsaWFibGVNYXJnaW5MZWZ0VmFsID0gcm91bmRQaXhlbE1lYXN1cmVzKCBkaXZTdHlsZS5tYXJnaW5MZWZ0ICkgPT09IDEyO1xcblxcblxcdFxcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHksIFNhZmFyaSA8PTkuMSAtIDEwLjEsIGlPUyA8PTcuMCAtIDkuM1xcblxcdFxcdC8vIFNvbWUgc3R5bGVzIGNvbWUgYmFjayB3aXRoIHBlcmNlbnRhZ2UgdmFsdWVzLCBldmVuIHRob3VnaCB0aGV5IHNob3VsZG4ndFxcblxcdFxcdGRpdi5zdHlsZS5yaWdodCA9IFxcXCI2MCVcXFwiO1xcblxcdFxcdHBpeGVsQm94U3R5bGVzVmFsID0gcm91bmRQaXhlbE1lYXN1cmVzKCBkaXZTdHlsZS5yaWdodCApID09PSAzNjtcXG5cXG5cXHRcXHQvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seVxcblxcdFxcdC8vIERldGVjdCBtaXNyZXBvcnRpbmcgb2YgY29udGVudCBkaW1lbnNpb25zIGZvciBib3gtc2l6aW5nOmJvcmRlci1ib3ggZWxlbWVudHNcXG5cXHRcXHRib3hTaXppbmdSZWxpYWJsZVZhbCA9IHJvdW5kUGl4ZWxNZWFzdXJlcyggZGl2U3R5bGUud2lkdGggKSA9PT0gMzY7XFxuXFxuXFx0XFx0Ly8gU3VwcG9ydDogSUUgOSBvbmx5XFxuXFx0XFx0Ly8gRGV0ZWN0IG92ZXJmbG93OnNjcm9sbCBzY3Jld2luZXNzIChnaC0zNjk5KVxcblxcdFxcdGRpdi5zdHlsZS5wb3NpdGlvbiA9IFxcXCJhYnNvbHV0ZVxcXCI7XFxuXFx0XFx0c2Nyb2xsYm94U2l6ZVZhbCA9IGRpdi5vZmZzZXRXaWR0aCA9PT0gMzYgfHwgXFxcImFic29sdXRlXFxcIjtcXG5cXG5cXHRcXHRkb2N1bWVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoIGNvbnRhaW5lciApO1xcblxcblxcdFxcdC8vIE51bGxpZnkgdGhlIGRpdiBzbyBpdCB3b3VsZG4ndCBiZSBzdG9yZWQgaW4gdGhlIG1lbW9yeSBhbmRcXG5cXHRcXHQvLyBpdCB3aWxsIGFsc28gYmUgYSBzaWduIHRoYXQgY2hlY2tzIGFscmVhZHkgcGVyZm9ybWVkXFxuXFx0XFx0ZGl2ID0gbnVsbDtcXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gcm91bmRQaXhlbE1lYXN1cmVzKCBtZWFzdXJlICkge1xcblxcdFxcdHJldHVybiBNYXRoLnJvdW5kKCBwYXJzZUZsb2F0KCBtZWFzdXJlICkgKTtcXG5cXHR9XFxuXFxuXFx0dmFyIHBpeGVsUG9zaXRpb25WYWwsIGJveFNpemluZ1JlbGlhYmxlVmFsLCBzY3JvbGxib3hTaXplVmFsLCBwaXhlbEJveFN0eWxlc1ZhbCxcXG5cXHRcXHRyZWxpYWJsZU1hcmdpbkxlZnRWYWwsXFxuXFx0XFx0Y29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXFxcImRpdlxcXCIgKSxcXG5cXHRcXHRkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcXFwiZGl2XFxcIiApO1xcblxcblxcdC8vIEZpbmlzaCBlYXJseSBpbiBsaW1pdGVkIChub24tYnJvd3NlcikgZW52aXJvbm1lbnRzXFxuXFx0aWYgKCAhZGl2LnN0eWxlICkge1xcblxcdFxcdHJldHVybjtcXG5cXHR9XFxuXFxuXFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxcblxcdC8vIFN0eWxlIG9mIGNsb25lZCBlbGVtZW50IGFmZmVjdHMgc291cmNlIGVsZW1lbnQgY2xvbmVkICgjODkwOClcXG5cXHRkaXYuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcXFwiY29udGVudC1ib3hcXFwiO1xcblxcdGRpdi5jbG9uZU5vZGUoIHRydWUgKS5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFxcXCJcXFwiO1xcblxcdHN1cHBvcnQuY2xlYXJDbG9uZVN0eWxlID0gZGl2LnN0eWxlLmJhY2tncm91bmRDbGlwID09PSBcXFwiY29udGVudC1ib3hcXFwiO1xcblxcblxcdGpRdWVyeS5leHRlbmQoIHN1cHBvcnQsIHtcXG5cXHRcXHRib3hTaXppbmdSZWxpYWJsZTogZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcXG5cXHRcXHRcXHRyZXR1cm4gYm94U2l6aW5nUmVsaWFibGVWYWw7XFxuXFx0XFx0fSxcXG5cXHRcXHRwaXhlbEJveFN0eWxlczogZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcXG5cXHRcXHRcXHRyZXR1cm4gcGl4ZWxCb3hTdHlsZXNWYWw7XFxuXFx0XFx0fSxcXG5cXHRcXHRwaXhlbFBvc2l0aW9uOiBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRjb21wdXRlU3R5bGVUZXN0cygpO1xcblxcdFxcdFxcdHJldHVybiBwaXhlbFBvc2l0aW9uVmFsO1xcblxcdFxcdH0sXFxuXFx0XFx0cmVsaWFibGVNYXJnaW5MZWZ0OiBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRjb21wdXRlU3R5bGVUZXN0cygpO1xcblxcdFxcdFxcdHJldHVybiByZWxpYWJsZU1hcmdpbkxlZnRWYWw7XFxuXFx0XFx0fSxcXG5cXHRcXHRzY3JvbGxib3hTaXplOiBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRjb21wdXRlU3R5bGVUZXN0cygpO1xcblxcdFxcdFxcdHJldHVybiBzY3JvbGxib3hTaXplVmFsO1xcblxcdFxcdH1cXG5cXHR9ICk7XFxufSApKCk7XFxuXFxuXFxuZnVuY3Rpb24gY3VyQ1NTKCBlbGVtLCBuYW1lLCBjb21wdXRlZCApIHtcXG5cXHR2YXIgd2lkdGgsIG1pbldpZHRoLCBtYXhXaWR0aCwgcmV0LFxcblxcblxcdFxcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggNTErXFxuXFx0XFx0Ly8gUmV0cmlldmluZyBzdHlsZSBiZWZvcmUgY29tcHV0ZWQgc29tZWhvd1xcblxcdFxcdC8vIGZpeGVzIGFuIGlzc3VlIHdpdGggZ2V0dGluZyB3cm9uZyB2YWx1ZXNcXG5cXHRcXHQvLyBvbiBkZXRhY2hlZCBlbGVtZW50c1xcblxcdFxcdHN0eWxlID0gZWxlbS5zdHlsZTtcXG5cXG5cXHRjb21wdXRlZCA9IGNvbXB1dGVkIHx8IGdldFN0eWxlcyggZWxlbSApO1xcblxcblxcdC8vIGdldFByb3BlcnR5VmFsdWUgaXMgbmVlZGVkIGZvcjpcXG5cXHQvLyAgIC5jc3MoJ2ZpbHRlcicpIChJRSA5IG9ubHksICMxMjUzNylcXG5cXHQvLyAgIC5jc3MoJy0tY3VzdG9tUHJvcGVydHkpICgjMzE0NClcXG5cXHRpZiAoIGNvbXB1dGVkICkge1xcblxcdFxcdHJldCA9IGNvbXB1dGVkLmdldFByb3BlcnR5VmFsdWUoIG5hbWUgKSB8fCBjb21wdXRlZFsgbmFtZSBdO1xcblxcblxcdFxcdGlmICggcmV0ID09PSBcXFwiXFxcIiAmJiAhalF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKSApIHtcXG5cXHRcXHRcXHRyZXQgPSBqUXVlcnkuc3R5bGUoIGVsZW0sIG5hbWUgKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gQSB0cmlidXRlIHRvIHRoZSBcXFwiYXdlc29tZSBoYWNrIGJ5IERlYW4gRWR3YXJkc1xcXCJcXG5cXHRcXHQvLyBBbmRyb2lkIEJyb3dzZXIgcmV0dXJucyBwZXJjZW50YWdlIGZvciBzb21lIHZhbHVlcyxcXG5cXHRcXHQvLyBidXQgd2lkdGggc2VlbXMgdG8gYmUgcmVsaWFibHkgcGl4ZWxzLlxcblxcdFxcdC8vIFRoaXMgaXMgYWdhaW5zdCB0aGUgQ1NTT00gZHJhZnQgc3BlYzpcXG5cXHRcXHQvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3Nzb20vI3Jlc29sdmVkLXZhbHVlc1xcblxcdFxcdGlmICggIXN1cHBvcnQucGl4ZWxCb3hTdHlsZXMoKSAmJiBybnVtbm9ucHgudGVzdCggcmV0ICkgJiYgcmJveFN0eWxlLnRlc3QoIG5hbWUgKSApIHtcXG5cXG5cXHRcXHRcXHQvLyBSZW1lbWJlciB0aGUgb3JpZ2luYWwgdmFsdWVzXFxuXFx0XFx0XFx0d2lkdGggPSBzdHlsZS53aWR0aDtcXG5cXHRcXHRcXHRtaW5XaWR0aCA9IHN0eWxlLm1pbldpZHRoO1xcblxcdFxcdFxcdG1heFdpZHRoID0gc3R5bGUubWF4V2lkdGg7XFxuXFxuXFx0XFx0XFx0Ly8gUHV0IGluIHRoZSBuZXcgdmFsdWVzIHRvIGdldCBhIGNvbXB1dGVkIHZhbHVlIG91dFxcblxcdFxcdFxcdHN0eWxlLm1pbldpZHRoID0gc3R5bGUubWF4V2lkdGggPSBzdHlsZS53aWR0aCA9IHJldDtcXG5cXHRcXHRcXHRyZXQgPSBjb21wdXRlZC53aWR0aDtcXG5cXG5cXHRcXHRcXHQvLyBSZXZlcnQgdGhlIGNoYW5nZWQgdmFsdWVzXFxuXFx0XFx0XFx0c3R5bGUud2lkdGggPSB3aWR0aDtcXG5cXHRcXHRcXHRzdHlsZS5taW5XaWR0aCA9IG1pbldpZHRoO1xcblxcdFxcdFxcdHN0eWxlLm1heFdpZHRoID0gbWF4V2lkdGg7XFxuXFx0XFx0fVxcblxcdH1cXG5cXG5cXHRyZXR1cm4gcmV0ICE9PSB1bmRlZmluZWQgP1xcblxcblxcdFxcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcXG5cXHRcXHQvLyBJRSByZXR1cm5zIHpJbmRleCB2YWx1ZSBhcyBhbiBpbnRlZ2VyLlxcblxcdFxcdHJldCArIFxcXCJcXFwiIDpcXG5cXHRcXHRyZXQ7XFxufVxcblxcblxcbmZ1bmN0aW9uIGFkZEdldEhvb2tJZiggY29uZGl0aW9uRm4sIGhvb2tGbiApIHtcXG5cXG5cXHQvLyBEZWZpbmUgdGhlIGhvb2ssIHdlJ2xsIGNoZWNrIG9uIHRoZSBmaXJzdCBydW4gaWYgaXQncyByZWFsbHkgbmVlZGVkLlxcblxcdHJldHVybiB7XFxuXFx0XFx0Z2V0OiBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRpZiAoIGNvbmRpdGlvbkZuKCkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gSG9vayBub3QgbmVlZGVkIChvciBpdCdzIG5vdCBwb3NzaWJsZSB0byB1c2UgaXQgZHVlXFxuXFx0XFx0XFx0XFx0Ly8gdG8gbWlzc2luZyBkZXBlbmRlbmN5KSwgcmVtb3ZlIGl0LlxcblxcdFxcdFxcdFxcdGRlbGV0ZSB0aGlzLmdldDtcXG5cXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIEhvb2sgbmVlZGVkOyByZWRlZmluZSBpdCBzbyB0aGF0IHRoZSBzdXBwb3J0IHRlc3QgaXMgbm90IGV4ZWN1dGVkIGFnYWluLlxcblxcdFxcdFxcdHJldHVybiAoIHRoaXMuZ2V0ID0gaG9va0ZuICkuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xcblxcdFxcdH1cXG5cXHR9O1xcbn1cXG5cXG5cXG52YXJcXG5cXG5cXHQvLyBTd2FwcGFibGUgaWYgZGlzcGxheSBpcyBub25lIG9yIHN0YXJ0cyB3aXRoIHRhYmxlXFxuXFx0Ly8gZXhjZXB0IFxcXCJ0YWJsZVxcXCIsIFxcXCJ0YWJsZS1jZWxsXFxcIiwgb3IgXFxcInRhYmxlLWNhcHRpb25cXFwiXFxuXFx0Ly8gU2VlIGhlcmUgZm9yIGRpc3BsYXkgdmFsdWVzOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0NTUy9kaXNwbGF5XFxuXFx0cmRpc3BsYXlzd2FwID0gL14obm9uZXx0YWJsZSg/IS1jW2VhXSkuKykvLFxcblxcdHJjdXN0b21Qcm9wID0gL14tLS8sXFxuXFx0Y3NzU2hvdyA9IHsgcG9zaXRpb246IFxcXCJhYnNvbHV0ZVxcXCIsIHZpc2liaWxpdHk6IFxcXCJoaWRkZW5cXFwiLCBkaXNwbGF5OiBcXFwiYmxvY2tcXFwiIH0sXFxuXFx0Y3NzTm9ybWFsVHJhbnNmb3JtID0ge1xcblxcdFxcdGxldHRlclNwYWNpbmc6IFxcXCIwXFxcIixcXG5cXHRcXHRmb250V2VpZ2h0OiBcXFwiNDAwXFxcIlxcblxcdH0sXFxuXFxuXFx0Y3NzUHJlZml4ZXMgPSBbIFxcXCJXZWJraXRcXFwiLCBcXFwiTW96XFxcIiwgXFxcIm1zXFxcIiBdLFxcblxcdGVtcHR5U3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcXFwiZGl2XFxcIiApLnN0eWxlO1xcblxcbi8vIFJldHVybiBhIGNzcyBwcm9wZXJ0eSBtYXBwZWQgdG8gYSBwb3RlbnRpYWxseSB2ZW5kb3IgcHJlZml4ZWQgcHJvcGVydHlcXG5mdW5jdGlvbiB2ZW5kb3JQcm9wTmFtZSggbmFtZSApIHtcXG5cXG5cXHQvLyBTaG9ydGN1dCBmb3IgbmFtZXMgdGhhdCBhcmUgbm90IHZlbmRvciBwcmVmaXhlZFxcblxcdGlmICggbmFtZSBpbiBlbXB0eVN0eWxlICkge1xcblxcdFxcdHJldHVybiBuYW1lO1xcblxcdH1cXG5cXG5cXHQvLyBDaGVjayBmb3IgdmVuZG9yIHByZWZpeGVkIG5hbWVzXFxuXFx0dmFyIGNhcE5hbWUgPSBuYW1lWyAwIF0udG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoIDEgKSxcXG5cXHRcXHRpID0gY3NzUHJlZml4ZXMubGVuZ3RoO1xcblxcblxcdHdoaWxlICggaS0tICkge1xcblxcdFxcdG5hbWUgPSBjc3NQcmVmaXhlc1sgaSBdICsgY2FwTmFtZTtcXG5cXHRcXHRpZiAoIG5hbWUgaW4gZW1wdHlTdHlsZSApIHtcXG5cXHRcXHRcXHRyZXR1cm4gbmFtZTtcXG5cXHRcXHR9XFxuXFx0fVxcbn1cXG5cXG4vLyBSZXR1cm4gYSBwcm9wZXJ0eSBtYXBwZWQgYWxvbmcgd2hhdCBqUXVlcnkuY3NzUHJvcHMgc3VnZ2VzdHMgb3IgdG9cXG4vLyBhIHZlbmRvciBwcmVmaXhlZCBwcm9wZXJ0eS5cXG5mdW5jdGlvbiBmaW5hbFByb3BOYW1lKCBuYW1lICkge1xcblxcdHZhciByZXQgPSBqUXVlcnkuY3NzUHJvcHNbIG5hbWUgXTtcXG5cXHRpZiAoICFyZXQgKSB7XFxuXFx0XFx0cmV0ID0galF1ZXJ5LmNzc1Byb3BzWyBuYW1lIF0gPSB2ZW5kb3JQcm9wTmFtZSggbmFtZSApIHx8IG5hbWU7XFxuXFx0fVxcblxcdHJldHVybiByZXQ7XFxufVxcblxcbmZ1bmN0aW9uIHNldFBvc2l0aXZlTnVtYmVyKCBlbGVtLCB2YWx1ZSwgc3VidHJhY3QgKSB7XFxuXFxuXFx0Ly8gQW55IHJlbGF0aXZlICgrLy0pIHZhbHVlcyBoYXZlIGFscmVhZHkgYmVlblxcblxcdC8vIG5vcm1hbGl6ZWQgYXQgdGhpcyBwb2ludFxcblxcdHZhciBtYXRjaGVzID0gcmNzc051bS5leGVjKCB2YWx1ZSApO1xcblxcdHJldHVybiBtYXRjaGVzID9cXG5cXG5cXHRcXHQvLyBHdWFyZCBhZ2FpbnN0IHVuZGVmaW5lZCBcXFwic3VidHJhY3RcXFwiLCBlLmcuLCB3aGVuIHVzZWQgYXMgaW4gY3NzSG9va3NcXG5cXHRcXHRNYXRoLm1heCggMCwgbWF0Y2hlc1sgMiBdIC0gKCBzdWJ0cmFjdCB8fCAwICkgKSArICggbWF0Y2hlc1sgMyBdIHx8IFxcXCJweFxcXCIgKSA6XFxuXFx0XFx0dmFsdWU7XFxufVxcblxcbmZ1bmN0aW9uIGJveE1vZGVsQWRqdXN0bWVudCggZWxlbSwgZGltZW5zaW9uLCBib3gsIGlzQm9yZGVyQm94LCBzdHlsZXMsIGNvbXB1dGVkVmFsICkge1xcblxcdHZhciBpID0gZGltZW5zaW9uID09PSBcXFwid2lkdGhcXFwiID8gMSA6IDAsXFxuXFx0XFx0ZXh0cmEgPSAwLFxcblxcdFxcdGRlbHRhID0gMDtcXG5cXG5cXHQvLyBBZGp1c3RtZW50IG1heSBub3QgYmUgbmVjZXNzYXJ5XFxuXFx0aWYgKCBib3ggPT09ICggaXNCb3JkZXJCb3ggPyBcXFwiYm9yZGVyXFxcIiA6IFxcXCJjb250ZW50XFxcIiApICkge1xcblxcdFxcdHJldHVybiAwO1xcblxcdH1cXG5cXG5cXHRmb3IgKCA7IGkgPCA0OyBpICs9IDIgKSB7XFxuXFxuXFx0XFx0Ly8gQm90aCBib3ggbW9kZWxzIGV4Y2x1ZGUgbWFyZ2luXFxuXFx0XFx0aWYgKCBib3ggPT09IFxcXCJtYXJnaW5cXFwiICkge1xcblxcdFxcdFxcdGRlbHRhICs9IGpRdWVyeS5jc3MoIGVsZW0sIGJveCArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gSWYgd2UgZ2V0IGhlcmUgd2l0aCBhIGNvbnRlbnQtYm94LCB3ZSdyZSBzZWVraW5nIFxcXCJwYWRkaW5nXFxcIiBvciBcXFwiYm9yZGVyXFxcIiBvciBcXFwibWFyZ2luXFxcIlxcblxcdFxcdGlmICggIWlzQm9yZGVyQm94ICkge1xcblxcblxcdFxcdFxcdC8vIEFkZCBwYWRkaW5nXFxuXFx0XFx0XFx0ZGVsdGEgKz0galF1ZXJ5LmNzcyggZWxlbSwgXFxcInBhZGRpbmdcXFwiICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xcblxcblxcdFxcdFxcdC8vIEZvciBcXFwiYm9yZGVyXFxcIiBvciBcXFwibWFyZ2luXFxcIiwgYWRkIGJvcmRlclxcblxcdFxcdFxcdGlmICggYm94ICE9PSBcXFwicGFkZGluZ1xcXCIgKSB7XFxuXFx0XFx0XFx0XFx0ZGVsdGEgKz0galF1ZXJ5LmNzcyggZWxlbSwgXFxcImJvcmRlclxcXCIgKyBjc3NFeHBhbmRbIGkgXSArIFxcXCJXaWR0aFxcXCIsIHRydWUsIHN0eWxlcyApO1xcblxcblxcdFxcdFxcdC8vIEJ1dCBzdGlsbCBrZWVwIHRyYWNrIG9mIGl0IG90aGVyd2lzZVxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0ZXh0cmEgKz0galF1ZXJ5LmNzcyggZWxlbSwgXFxcImJvcmRlclxcXCIgKyBjc3NFeHBhbmRbIGkgXSArIFxcXCJXaWR0aFxcXCIsIHRydWUsIHN0eWxlcyApO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHQvLyBJZiB3ZSBnZXQgaGVyZSB3aXRoIGEgYm9yZGVyLWJveCAoY29udGVudCArIHBhZGRpbmcgKyBib3JkZXIpLCB3ZSdyZSBzZWVraW5nIFxcXCJjb250ZW50XFxcIiBvclxcblxcdFxcdC8vIFxcXCJwYWRkaW5nXFxcIiBvciBcXFwibWFyZ2luXFxcIlxcblxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0Ly8gRm9yIFxcXCJjb250ZW50XFxcIiwgc3VidHJhY3QgcGFkZGluZ1xcblxcdFxcdFxcdGlmICggYm94ID09PSBcXFwiY29udGVudFxcXCIgKSB7XFxuXFx0XFx0XFx0XFx0ZGVsdGEgLT0galF1ZXJ5LmNzcyggZWxlbSwgXFxcInBhZGRpbmdcXFwiICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBGb3IgXFxcImNvbnRlbnRcXFwiIG9yIFxcXCJwYWRkaW5nXFxcIiwgc3VidHJhY3QgYm9yZGVyXFxuXFx0XFx0XFx0aWYgKCBib3ggIT09IFxcXCJtYXJnaW5cXFwiICkge1xcblxcdFxcdFxcdFxcdGRlbHRhIC09IGpRdWVyeS5jc3MoIGVsZW0sIFxcXCJib3JkZXJcXFwiICsgY3NzRXhwYW5kWyBpIF0gKyBcXFwiV2lkdGhcXFwiLCB0cnVlLCBzdHlsZXMgKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdH1cXG5cXG5cXHQvLyBBY2NvdW50IGZvciBwb3NpdGl2ZSBjb250ZW50LWJveCBzY3JvbGwgZ3V0dGVyIHdoZW4gcmVxdWVzdGVkIGJ5IHByb3ZpZGluZyBjb21wdXRlZFZhbFxcblxcdGlmICggIWlzQm9yZGVyQm94ICYmIGNvbXB1dGVkVmFsID49IDAgKSB7XFxuXFxuXFx0XFx0Ly8gb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IGlzIGEgcm91bmRlZCBzdW0gb2YgY29udGVudCwgcGFkZGluZywgc2Nyb2xsIGd1dHRlciwgYW5kIGJvcmRlclxcblxcdFxcdC8vIEFzc3VtaW5nIGludGVnZXIgc2Nyb2xsIGd1dHRlciwgc3VidHJhY3QgdGhlIHJlc3QgYW5kIHJvdW5kIGRvd25cXG5cXHRcXHRkZWx0YSArPSBNYXRoLm1heCggMCwgTWF0aC5jZWlsKFxcblxcdFxcdFxcdGVsZW1bIFxcXCJvZmZzZXRcXFwiICsgZGltZW5zaW9uWyAwIF0udG9VcHBlckNhc2UoKSArIGRpbWVuc2lvbi5zbGljZSggMSApIF0gLVxcblxcdFxcdFxcdGNvbXB1dGVkVmFsIC1cXG5cXHRcXHRcXHRkZWx0YSAtXFxuXFx0XFx0XFx0ZXh0cmEgLVxcblxcdFxcdFxcdDAuNVxcblxcdFxcdCkgKTtcXG5cXHR9XFxuXFxuXFx0cmV0dXJuIGRlbHRhO1xcbn1cXG5cXG5mdW5jdGlvbiBnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBkaW1lbnNpb24sIGV4dHJhICkge1xcblxcblxcdC8vIFN0YXJ0IHdpdGggY29tcHV0ZWQgc3R5bGVcXG5cXHR2YXIgc3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICksXFxuXFx0XFx0dmFsID0gY3VyQ1NTKCBlbGVtLCBkaW1lbnNpb24sIHN0eWxlcyApLFxcblxcdFxcdGlzQm9yZGVyQm94ID0galF1ZXJ5LmNzcyggZWxlbSwgXFxcImJveFNpemluZ1xcXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXFxcImJvcmRlci1ib3hcXFwiLFxcblxcdFxcdHZhbHVlSXNCb3JkZXJCb3ggPSBpc0JvcmRlckJveDtcXG5cXG5cXHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9NTRcXG5cXHQvLyBSZXR1cm4gYSBjb25mb3VuZGluZyBub24tcGl4ZWwgdmFsdWUgb3IgZmVpZ24gaWdub3JhbmNlLCBhcyBhcHByb3ByaWF0ZS5cXG5cXHRpZiAoIHJudW1ub25weC50ZXN0KCB2YWwgKSApIHtcXG5cXHRcXHRpZiAoICFleHRyYSApIHtcXG5cXHRcXHRcXHRyZXR1cm4gdmFsO1xcblxcdFxcdH1cXG5cXHRcXHR2YWwgPSBcXFwiYXV0b1xcXCI7XFxuXFx0fVxcblxcblxcdC8vIENoZWNrIGZvciBzdHlsZSBpbiBjYXNlIGEgYnJvd3NlciB3aGljaCByZXR1cm5zIHVucmVsaWFibGUgdmFsdWVzXFxuXFx0Ly8gZm9yIGdldENvbXB1dGVkU3R5bGUgc2lsZW50bHkgZmFsbHMgYmFjayB0byB0aGUgcmVsaWFibGUgZWxlbS5zdHlsZVxcblxcdHZhbHVlSXNCb3JkZXJCb3ggPSB2YWx1ZUlzQm9yZGVyQm94ICYmXFxuXFx0XFx0KCBzdXBwb3J0LmJveFNpemluZ1JlbGlhYmxlKCkgfHwgdmFsID09PSBlbGVtLnN0eWxlWyBkaW1lbnNpb24gXSApO1xcblxcblxcdC8vIEZhbGwgYmFjayB0byBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgd2hlbiB2YWx1ZSBpcyBcXFwiYXV0b1xcXCJcXG5cXHQvLyBUaGlzIGhhcHBlbnMgZm9yIGlubGluZSBlbGVtZW50cyB3aXRoIG5vIGV4cGxpY2l0IHNldHRpbmcgKGdoLTM1NzEpXFxuXFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMSAtIDQuMyBvbmx5XFxuXFx0Ly8gQWxzbyB1c2Ugb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IGZvciBtaXNyZXBvcnRlZCBpbmxpbmUgZGltZW5zaW9ucyAoZ2gtMzYwMilcXG5cXHRpZiAoIHZhbCA9PT0gXFxcImF1dG9cXFwiIHx8XFxuXFx0XFx0IXBhcnNlRmxvYXQoIHZhbCApICYmIGpRdWVyeS5jc3MoIGVsZW0sIFxcXCJkaXNwbGF5XFxcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcXFwiaW5saW5lXFxcIiApIHtcXG5cXG5cXHRcXHR2YWwgPSBlbGVtWyBcXFwib2Zmc2V0XFxcIiArIGRpbWVuc2lvblsgMCBdLnRvVXBwZXJDYXNlKCkgKyBkaW1lbnNpb24uc2xpY2UoIDEgKSBdO1xcblxcblxcdFxcdC8vIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBwcm92aWRlIGJvcmRlci1ib3ggdmFsdWVzXFxuXFx0XFx0dmFsdWVJc0JvcmRlckJveCA9IHRydWU7XFxuXFx0fVxcblxcblxcdC8vIE5vcm1hbGl6ZSBcXFwiXFxcIiBhbmQgYXV0b1xcblxcdHZhbCA9IHBhcnNlRmxvYXQoIHZhbCApIHx8IDA7XFxuXFxuXFx0Ly8gQWRqdXN0IGZvciB0aGUgZWxlbWVudCdzIGJveCBtb2RlbFxcblxcdHJldHVybiAoIHZhbCArXFxuXFx0XFx0Ym94TW9kZWxBZGp1c3RtZW50KFxcblxcdFxcdFxcdGVsZW0sXFxuXFx0XFx0XFx0ZGltZW5zaW9uLFxcblxcdFxcdFxcdGV4dHJhIHx8ICggaXNCb3JkZXJCb3ggPyBcXFwiYm9yZGVyXFxcIiA6IFxcXCJjb250ZW50XFxcIiApLFxcblxcdFxcdFxcdHZhbHVlSXNCb3JkZXJCb3gsXFxuXFx0XFx0XFx0c3R5bGVzLFxcblxcblxcdFxcdFxcdC8vIFByb3ZpZGUgdGhlIGN1cnJlbnQgY29tcHV0ZWQgc2l6ZSB0byByZXF1ZXN0IHNjcm9sbCBndXR0ZXIgY2FsY3VsYXRpb24gKGdoLTM1ODkpXFxuXFx0XFx0XFx0dmFsXFxuXFx0XFx0KVxcblxcdCkgKyBcXFwicHhcXFwiO1xcbn1cXG5cXG5qUXVlcnkuZXh0ZW5kKCB7XFxuXFxuXFx0Ly8gQWRkIGluIHN0eWxlIHByb3BlcnR5IGhvb2tzIGZvciBvdmVycmlkaW5nIHRoZSBkZWZhdWx0XFxuXFx0Ly8gYmVoYXZpb3Igb2YgZ2V0dGluZyBhbmQgc2V0dGluZyBhIHN0eWxlIHByb3BlcnR5XFxuXFx0Y3NzSG9va3M6IHtcXG5cXHRcXHRvcGFjaXR5OiB7XFxuXFx0XFx0XFx0Z2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCBjb21wdXRlZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBXZSBzaG91bGQgYWx3YXlzIGdldCBhIG51bWJlciBiYWNrIGZyb20gb3BhY2l0eVxcblxcdFxcdFxcdFxcdFxcdHZhciByZXQgPSBjdXJDU1MoIGVsZW0sIFxcXCJvcGFjaXR5XFxcIiApO1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiByZXQgPT09IFxcXCJcXFwiID8gXFxcIjFcXFwiIDogcmV0O1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdH0sXFxuXFxuXFx0Ly8gRG9uJ3QgYXV0b21hdGljYWxseSBhZGQgXFxcInB4XFxcIiB0byB0aGVzZSBwb3NzaWJseS11bml0bGVzcyBwcm9wZXJ0aWVzXFxuXFx0Y3NzTnVtYmVyOiB7XFxuXFx0XFx0XFxcImFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50XFxcIjogdHJ1ZSxcXG5cXHRcXHRcXFwiY29sdW1uQ291bnRcXFwiOiB0cnVlLFxcblxcdFxcdFxcXCJmaWxsT3BhY2l0eVxcXCI6IHRydWUsXFxuXFx0XFx0XFxcImZsZXhHcm93XFxcIjogdHJ1ZSxcXG5cXHRcXHRcXFwiZmxleFNocmlua1xcXCI6IHRydWUsXFxuXFx0XFx0XFxcImZvbnRXZWlnaHRcXFwiOiB0cnVlLFxcblxcdFxcdFxcXCJsaW5lSGVpZ2h0XFxcIjogdHJ1ZSxcXG5cXHRcXHRcXFwib3BhY2l0eVxcXCI6IHRydWUsXFxuXFx0XFx0XFxcIm9yZGVyXFxcIjogdHJ1ZSxcXG5cXHRcXHRcXFwib3JwaGFuc1xcXCI6IHRydWUsXFxuXFx0XFx0XFxcIndpZG93c1xcXCI6IHRydWUsXFxuXFx0XFx0XFxcInpJbmRleFxcXCI6IHRydWUsXFxuXFx0XFx0XFxcInpvb21cXFwiOiB0cnVlXFxuXFx0fSxcXG5cXG5cXHQvLyBBZGQgaW4gcHJvcGVydGllcyB3aG9zZSBuYW1lcyB5b3Ugd2lzaCB0byBmaXggYmVmb3JlXFxuXFx0Ly8gc2V0dGluZyBvciBnZXR0aW5nIHRoZSB2YWx1ZVxcblxcdGNzc1Byb3BzOiB7fSxcXG5cXG5cXHQvLyBHZXQgYW5kIHNldCB0aGUgc3R5bGUgcHJvcGVydHkgb24gYSBET00gTm9kZVxcblxcdHN0eWxlOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUsIGV4dHJhICkge1xcblxcblxcdFxcdC8vIERvbid0IHNldCBzdHlsZXMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xcblxcdFxcdGlmICggIWVsZW0gfHwgZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4IHx8ICFlbGVtLnN0eWxlICkge1xcblxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lXFxuXFx0XFx0dmFyIHJldCwgdHlwZSwgaG9va3MsXFxuXFx0XFx0XFx0b3JpZ05hbWUgPSBjYW1lbENhc2UoIG5hbWUgKSxcXG5cXHRcXHRcXHRpc0N1c3RvbVByb3AgPSByY3VzdG9tUHJvcC50ZXN0KCBuYW1lICksXFxuXFx0XFx0XFx0c3R5bGUgPSBlbGVtLnN0eWxlO1xcblxcblxcdFxcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZS4gV2UgZG9uJ3RcXG5cXHRcXHQvLyB3YW50IHRvIHF1ZXJ5IHRoZSB2YWx1ZSBpZiBpdCBpcyBhIENTUyBjdXN0b20gcHJvcGVydHlcXG5cXHRcXHQvLyBzaW5jZSB0aGV5IGFyZSB1c2VyLWRlZmluZWQuXFxuXFx0XFx0aWYgKCAhaXNDdXN0b21Qcm9wICkge1xcblxcdFxcdFxcdG5hbWUgPSBmaW5hbFByb3BOYW1lKCBvcmlnTmFtZSApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBHZXRzIGhvb2sgZm9yIHRoZSBwcmVmaXhlZCB2ZXJzaW9uLCB0aGVuIHVucHJlZml4ZWQgdmVyc2lvblxcblxcdFxcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gfHwgalF1ZXJ5LmNzc0hvb2tzWyBvcmlnTmFtZSBdO1xcblxcblxcdFxcdC8vIENoZWNrIGlmIHdlJ3JlIHNldHRpbmcgYSB2YWx1ZVxcblxcdFxcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcXG5cXHRcXHRcXHR0eXBlID0gdHlwZW9mIHZhbHVlO1xcblxcblxcdFxcdFxcdC8vIENvbnZlcnQgXFxcIis9XFxcIiBvciBcXFwiLT1cXFwiIHRvIHJlbGF0aXZlIG51bWJlcnMgKCM3MzQ1KVxcblxcdFxcdFxcdGlmICggdHlwZSA9PT0gXFxcInN0cmluZ1xcXCIgJiYgKCByZXQgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICkgKSAmJiByZXRbIDEgXSApIHtcXG5cXHRcXHRcXHRcXHR2YWx1ZSA9IGFkanVzdENTUyggZWxlbSwgbmFtZSwgcmV0ICk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gRml4ZXMgYnVnICM5MjM3XFxuXFx0XFx0XFx0XFx0dHlwZSA9IFxcXCJudW1iZXJcXFwiO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBNYWtlIHN1cmUgdGhhdCBudWxsIGFuZCBOYU4gdmFsdWVzIGFyZW4ndCBzZXQgKCM3MTE2KVxcblxcdFxcdFxcdGlmICggdmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSAhPT0gdmFsdWUgKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBJZiBhIG51bWJlciB3YXMgcGFzc2VkIGluLCBhZGQgdGhlIHVuaXQgKGV4Y2VwdCBmb3IgY2VydGFpbiBDU1MgcHJvcGVydGllcylcXG5cXHRcXHRcXHRpZiAoIHR5cGUgPT09IFxcXCJudW1iZXJcXFwiICkge1xcblxcdFxcdFxcdFxcdHZhbHVlICs9IHJldCAmJiByZXRbIDMgXSB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIG9yaWdOYW1lIF0gPyBcXFwiXFxcIiA6IFxcXCJweFxcXCIgKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gYmFja2dyb3VuZC0qIHByb3BzIGFmZmVjdCBvcmlnaW5hbCBjbG9uZSdzIHZhbHVlc1xcblxcdFxcdFxcdGlmICggIXN1cHBvcnQuY2xlYXJDbG9uZVN0eWxlICYmIHZhbHVlID09PSBcXFwiXFxcIiAmJiBuYW1lLmluZGV4T2YoIFxcXCJiYWNrZ3JvdW5kXFxcIiApID09PSAwICkge1xcblxcdFxcdFxcdFxcdHN0eWxlWyBuYW1lIF0gPSBcXFwiaW5oZXJpdFxcXCI7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQsIHVzZSB0aGF0IHZhbHVlLCBvdGhlcndpc2UganVzdCBzZXQgdGhlIHNwZWNpZmllZCB2YWx1ZVxcblxcdFxcdFxcdGlmICggIWhvb2tzIHx8ICEoIFxcXCJzZXRcXFwiIGluIGhvb2tzICkgfHxcXG5cXHRcXHRcXHRcXHQoIHZhbHVlID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgZXh0cmEgKSApICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBpc0N1c3RvbVByb3AgKSB7XFxuXFx0XFx0XFx0XFx0XFx0c3R5bGUuc2V0UHJvcGVydHkoIG5hbWUsIHZhbHVlICk7XFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRzdHlsZVsgbmFtZSBdID0gdmFsdWU7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBub24tY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxcblxcdFxcdFxcdGlmICggaG9va3MgJiYgXFxcImdldFxcXCIgaW4gaG9va3MgJiZcXG5cXHRcXHRcXHRcXHQoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgZmFsc2UsIGV4dHJhICkgKSAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdHJldHVybiByZXQ7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIE90aGVyd2lzZSBqdXN0IGdldCB0aGUgdmFsdWUgZnJvbSB0aGUgc3R5bGUgb2JqZWN0XFxuXFx0XFx0XFx0cmV0dXJuIHN0eWxlWyBuYW1lIF07XFxuXFx0XFx0fVxcblxcdH0sXFxuXFxuXFx0Y3NzOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZXh0cmEsIHN0eWxlcyApIHtcXG5cXHRcXHR2YXIgdmFsLCBudW0sIGhvb2tzLFxcblxcdFxcdFxcdG9yaWdOYW1lID0gY2FtZWxDYXNlKCBuYW1lICksXFxuXFx0XFx0XFx0aXNDdXN0b21Qcm9wID0gcmN1c3RvbVByb3AudGVzdCggbmFtZSApO1xcblxcblxcdFxcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZS4gV2UgZG9uJ3RcXG5cXHRcXHQvLyB3YW50IHRvIG1vZGlmeSB0aGUgdmFsdWUgaWYgaXQgaXMgYSBDU1MgY3VzdG9tIHByb3BlcnR5XFxuXFx0XFx0Ly8gc2luY2UgdGhleSBhcmUgdXNlci1kZWZpbmVkLlxcblxcdFxcdGlmICggIWlzQ3VzdG9tUHJvcCApIHtcXG5cXHRcXHRcXHRuYW1lID0gZmluYWxQcm9wTmFtZSggb3JpZ05hbWUgKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gVHJ5IHByZWZpeGVkIG5hbWUgZm9sbG93ZWQgYnkgdGhlIHVucHJlZml4ZWQgbmFtZVxcblxcdFxcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gfHwgalF1ZXJ5LmNzc0hvb2tzWyBvcmlnTmFtZSBdO1xcblxcblxcdFxcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXFxuXFx0XFx0aWYgKCBob29rcyAmJiBcXFwiZ2V0XFxcIiBpbiBob29rcyApIHtcXG5cXHRcXHRcXHR2YWwgPSBob29rcy5nZXQoIGVsZW0sIHRydWUsIGV4dHJhICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIE90aGVyd2lzZSwgaWYgYSB3YXkgdG8gZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBleGlzdHMsIHVzZSB0aGF0XFxuXFx0XFx0aWYgKCB2YWwgPT09IHVuZGVmaW5lZCApIHtcXG5cXHRcXHRcXHR2YWwgPSBjdXJDU1MoIGVsZW0sIG5hbWUsIHN0eWxlcyApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBDb252ZXJ0IFxcXCJub3JtYWxcXFwiIHRvIGNvbXB1dGVkIHZhbHVlXFxuXFx0XFx0aWYgKCB2YWwgPT09IFxcXCJub3JtYWxcXFwiICYmIG5hbWUgaW4gY3NzTm9ybWFsVHJhbnNmb3JtICkge1xcblxcdFxcdFxcdHZhbCA9IGNzc05vcm1hbFRyYW5zZm9ybVsgbmFtZSBdO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBNYWtlIG51bWVyaWMgaWYgZm9yY2VkIG9yIGEgcXVhbGlmaWVyIHdhcyBwcm92aWRlZCBhbmQgdmFsIGxvb2tzIG51bWVyaWNcXG5cXHRcXHRpZiAoIGV4dHJhID09PSBcXFwiXFxcIiB8fCBleHRyYSApIHtcXG5cXHRcXHRcXHRudW0gPSBwYXJzZUZsb2F0KCB2YWwgKTtcXG5cXHRcXHRcXHRyZXR1cm4gZXh0cmEgPT09IHRydWUgfHwgaXNGaW5pdGUoIG51bSApID8gbnVtIHx8IDAgOiB2YWw7XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiB2YWw7XFxuXFx0fVxcbn0gKTtcXG5cXG5qUXVlcnkuZWFjaCggWyBcXFwiaGVpZ2h0XFxcIiwgXFxcIndpZHRoXFxcIiBdLCBmdW5jdGlvbiggaSwgZGltZW5zaW9uICkge1xcblxcdGpRdWVyeS5jc3NIb29rc1sgZGltZW5zaW9uIF0gPSB7XFxuXFx0XFx0Z2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQsIGV4dHJhICkge1xcblxcdFxcdFxcdGlmICggY29tcHV0ZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gQ2VydGFpbiBlbGVtZW50cyBjYW4gaGF2ZSBkaW1lbnNpb24gaW5mbyBpZiB3ZSBpbnZpc2libHkgc2hvdyB0aGVtXFxuXFx0XFx0XFx0XFx0Ly8gYnV0IGl0IG11c3QgaGF2ZSBhIGN1cnJlbnQgZGlzcGxheSBzdHlsZSB0aGF0IHdvdWxkIGJlbmVmaXRcXG5cXHRcXHRcXHRcXHRyZXR1cm4gcmRpc3BsYXlzd2FwLnRlc3QoIGpRdWVyeS5jc3MoIGVsZW0sIFxcXCJkaXNwbGF5XFxcIiApICkgJiZcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBTdXBwb3J0OiBTYWZhcmkgOCtcXG5cXHRcXHRcXHRcXHRcXHQvLyBUYWJsZSBjb2x1bW5zIGluIFNhZmFyaSBoYXZlIG5vbi16ZXJvIG9mZnNldFdpZHRoICYgemVyb1xcblxcdFxcdFxcdFxcdFxcdC8vIGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIHVubGVzcyBkaXNwbGF5IGlzIGNoYW5nZWQuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XFxuXFx0XFx0XFx0XFx0XFx0Ly8gUnVubmluZyBnZXRCb3VuZGluZ0NsaWVudFJlY3Qgb24gYSBkaXNjb25uZWN0ZWQgbm9kZVxcblxcdFxcdFxcdFxcdFxcdC8vIGluIElFIHRocm93cyBhbiBlcnJvci5cXG5cXHRcXHRcXHRcXHRcXHQoICFlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoIHx8ICFlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoICkgP1xcblxcdFxcdFxcdFxcdFxcdFxcdHN3YXAoIGVsZW0sIGNzc1Nob3csIGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBkaW1lbnNpb24sIGV4dHJhICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fSApIDpcXG5cXHRcXHRcXHRcXHRcXHRcXHRnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBkaW1lbnNpb24sIGV4dHJhICk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUsIGV4dHJhICkge1xcblxcdFxcdFxcdHZhciBtYXRjaGVzLFxcblxcdFxcdFxcdFxcdHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApLFxcblxcdFxcdFxcdFxcdGlzQm9yZGVyQm94ID0galF1ZXJ5LmNzcyggZWxlbSwgXFxcImJveFNpemluZ1xcXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXFxcImJvcmRlci1ib3hcXFwiLFxcblxcdFxcdFxcdFxcdHN1YnRyYWN0ID0gZXh0cmEgJiYgYm94TW9kZWxBZGp1c3RtZW50KFxcblxcdFxcdFxcdFxcdFxcdGVsZW0sXFxuXFx0XFx0XFx0XFx0XFx0ZGltZW5zaW9uLFxcblxcdFxcdFxcdFxcdFxcdGV4dHJhLFxcblxcdFxcdFxcdFxcdFxcdGlzQm9yZGVyQm94LFxcblxcdFxcdFxcdFxcdFxcdHN0eWxlc1xcblxcdFxcdFxcdFxcdCk7XFxuXFxuXFx0XFx0XFx0Ly8gQWNjb3VudCBmb3IgdW5yZWxpYWJsZSBib3JkZXItYm94IGRpbWVuc2lvbnMgYnkgY29tcGFyaW5nIG9mZnNldCogdG8gY29tcHV0ZWQgYW5kXFxuXFx0XFx0XFx0Ly8gZmFraW5nIGEgY29udGVudC1ib3ggdG8gZ2V0IGJvcmRlciBhbmQgcGFkZGluZyAoZ2gtMzY5OSlcXG5cXHRcXHRcXHRpZiAoIGlzQm9yZGVyQm94ICYmIHN1cHBvcnQuc2Nyb2xsYm94U2l6ZSgpID09PSBzdHlsZXMucG9zaXRpb24gKSB7XFxuXFx0XFx0XFx0XFx0c3VidHJhY3QgLT0gTWF0aC5jZWlsKFxcblxcdFxcdFxcdFxcdFxcdGVsZW1bIFxcXCJvZmZzZXRcXFwiICsgZGltZW5zaW9uWyAwIF0udG9VcHBlckNhc2UoKSArIGRpbWVuc2lvbi5zbGljZSggMSApIF0gLVxcblxcdFxcdFxcdFxcdFxcdHBhcnNlRmxvYXQoIHN0eWxlc1sgZGltZW5zaW9uIF0gKSAtXFxuXFx0XFx0XFx0XFx0XFx0Ym94TW9kZWxBZGp1c3RtZW50KCBlbGVtLCBkaW1lbnNpb24sIFxcXCJib3JkZXJcXFwiLCBmYWxzZSwgc3R5bGVzICkgLVxcblxcdFxcdFxcdFxcdFxcdDAuNVxcblxcdFxcdFxcdFxcdCk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIENvbnZlcnQgdG8gcGl4ZWxzIGlmIHZhbHVlIGFkanVzdG1lbnQgaXMgbmVlZGVkXFxuXFx0XFx0XFx0aWYgKCBzdWJ0cmFjdCAmJiAoIG1hdGNoZXMgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICkgKSAmJlxcblxcdFxcdFxcdFxcdCggbWF0Y2hlc1sgMyBdIHx8IFxcXCJweFxcXCIgKSAhPT0gXFxcInB4XFxcIiApIHtcXG5cXG5cXHRcXHRcXHRcXHRlbGVtLnN0eWxlWyBkaW1lbnNpb24gXSA9IHZhbHVlO1xcblxcdFxcdFxcdFxcdHZhbHVlID0galF1ZXJ5LmNzcyggZWxlbSwgZGltZW5zaW9uICk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBzZXRQb3NpdGl2ZU51bWJlciggZWxlbSwgdmFsdWUsIHN1YnRyYWN0ICk7XFxuXFx0XFx0fVxcblxcdH07XFxufSApO1xcblxcbmpRdWVyeS5jc3NIb29rcy5tYXJnaW5MZWZ0ID0gYWRkR2V0SG9va0lmKCBzdXBwb3J0LnJlbGlhYmxlTWFyZ2luTGVmdCxcXG5cXHRmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XFxuXFx0XFx0aWYgKCBjb21wdXRlZCApIHtcXG5cXHRcXHRcXHRyZXR1cm4gKCBwYXJzZUZsb2F0KCBjdXJDU1MoIGVsZW0sIFxcXCJtYXJnaW5MZWZ0XFxcIiApICkgfHxcXG5cXHRcXHRcXHRcXHRlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgLVxcblxcdFxcdFxcdFxcdFxcdHN3YXAoIGVsZW0sIHsgbWFyZ2luTGVmdDogMCB9LCBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xcblxcdFxcdFxcdFxcdFxcdH0gKVxcblxcdFxcdFxcdFxcdCkgKyBcXFwicHhcXFwiO1xcblxcdFxcdH1cXG5cXHR9XFxuKTtcXG5cXG4vLyBUaGVzZSBob29rcyBhcmUgdXNlZCBieSBhbmltYXRlIHRvIGV4cGFuZCBwcm9wZXJ0aWVzXFxualF1ZXJ5LmVhY2goIHtcXG5cXHRtYXJnaW46IFxcXCJcXFwiLFxcblxcdHBhZGRpbmc6IFxcXCJcXFwiLFxcblxcdGJvcmRlcjogXFxcIldpZHRoXFxcIlxcbn0sIGZ1bmN0aW9uKCBwcmVmaXgsIHN1ZmZpeCApIHtcXG5cXHRqUXVlcnkuY3NzSG9va3NbIHByZWZpeCArIHN1ZmZpeCBdID0ge1xcblxcdFxcdGV4cGFuZDogZnVuY3Rpb24oIHZhbHVlICkge1xcblxcdFxcdFxcdHZhciBpID0gMCxcXG5cXHRcXHRcXHRcXHRleHBhbmRlZCA9IHt9LFxcblxcblxcdFxcdFxcdFxcdC8vIEFzc3VtZXMgYSBzaW5nbGUgbnVtYmVyIGlmIG5vdCBhIHN0cmluZ1xcblxcdFxcdFxcdFxcdHBhcnRzID0gdHlwZW9mIHZhbHVlID09PSBcXFwic3RyaW5nXFxcIiA/IHZhbHVlLnNwbGl0KCBcXFwiIFxcXCIgKSA6IFsgdmFsdWUgXTtcXG5cXG5cXHRcXHRcXHRmb3IgKCA7IGkgPCA0OyBpKysgKSB7XFxuXFx0XFx0XFx0XFx0ZXhwYW5kZWRbIHByZWZpeCArIGNzc0V4cGFuZFsgaSBdICsgc3VmZml4IF0gPVxcblxcdFxcdFxcdFxcdFxcdHBhcnRzWyBpIF0gfHwgcGFydHNbIGkgLSAyIF0gfHwgcGFydHNbIDAgXTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGV4cGFuZGVkO1xcblxcdFxcdH1cXG5cXHR9O1xcblxcblxcdGlmICggcHJlZml4ICE9PSBcXFwibWFyZ2luXFxcIiApIHtcXG5cXHRcXHRqUXVlcnkuY3NzSG9va3NbIHByZWZpeCArIHN1ZmZpeCBdLnNldCA9IHNldFBvc2l0aXZlTnVtYmVyO1xcblxcdH1cXG59ICk7XFxuXFxualF1ZXJ5LmZuLmV4dGVuZCgge1xcblxcdGNzczogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xcblxcdFxcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcXG5cXHRcXHRcXHR2YXIgc3R5bGVzLCBsZW4sXFxuXFx0XFx0XFx0XFx0bWFwID0ge30sXFxuXFx0XFx0XFx0XFx0aSA9IDA7XFxuXFxuXFx0XFx0XFx0aWYgKCBBcnJheS5pc0FycmF5KCBuYW1lICkgKSB7XFxuXFx0XFx0XFx0XFx0c3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICk7XFxuXFx0XFx0XFx0XFx0bGVuID0gbmFtZS5sZW5ndGg7XFxuXFxuXFx0XFx0XFx0XFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XFxuXFx0XFx0XFx0XFx0XFx0bWFwWyBuYW1lWyBpIF0gXSA9IGpRdWVyeS5jc3MoIGVsZW0sIG5hbWVbIGkgXSwgZmFsc2UsIHN0eWxlcyApO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gbWFwO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/XFxuXFx0XFx0XFx0XFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBuYW1lLCB2YWx1ZSApIDpcXG5cXHRcXHRcXHRcXHRqUXVlcnkuY3NzKCBlbGVtLCBuYW1lICk7XFxuXFx0XFx0fSwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XFxuXFx0fVxcbn0gKTtcXG5cXG5cXG5mdW5jdGlvbiBUd2VlbiggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcgKSB7XFxuXFx0cmV0dXJuIG5ldyBUd2Vlbi5wcm90b3R5cGUuaW5pdCggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcgKTtcXG59XFxualF1ZXJ5LlR3ZWVuID0gVHdlZW47XFxuXFxuVHdlZW4ucHJvdG90eXBlID0ge1xcblxcdGNvbnN0cnVjdG9yOiBUd2VlbixcXG5cXHRpbml0OiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcsIHVuaXQgKSB7XFxuXFx0XFx0dGhpcy5lbGVtID0gZWxlbTtcXG5cXHRcXHR0aGlzLnByb3AgPSBwcm9wO1xcblxcdFxcdHRoaXMuZWFzaW5nID0gZWFzaW5nIHx8IGpRdWVyeS5lYXNpbmcuX2RlZmF1bHQ7XFxuXFx0XFx0dGhpcy5vcHRpb25zID0gb3B0aW9ucztcXG5cXHRcXHR0aGlzLnN0YXJ0ID0gdGhpcy5ub3cgPSB0aGlzLmN1cigpO1xcblxcdFxcdHRoaXMuZW5kID0gZW5kO1xcblxcdFxcdHRoaXMudW5pdCA9IHVuaXQgfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gPyBcXFwiXFxcIiA6IFxcXCJweFxcXCIgKTtcXG5cXHR9LFxcblxcdGN1cjogZnVuY3Rpb24oKSB7XFxuXFx0XFx0dmFyIGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzWyB0aGlzLnByb3AgXTtcXG5cXG5cXHRcXHRyZXR1cm4gaG9va3MgJiYgaG9va3MuZ2V0ID9cXG5cXHRcXHRcXHRob29rcy5nZXQoIHRoaXMgKSA6XFxuXFx0XFx0XFx0VHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LmdldCggdGhpcyApO1xcblxcdH0sXFxuXFx0cnVuOiBmdW5jdGlvbiggcGVyY2VudCApIHtcXG5cXHRcXHR2YXIgZWFzZWQsXFxuXFx0XFx0XFx0aG9va3MgPSBUd2Vlbi5wcm9wSG9va3NbIHRoaXMucHJvcCBdO1xcblxcblxcdFxcdGlmICggdGhpcy5vcHRpb25zLmR1cmF0aW9uICkge1xcblxcdFxcdFxcdHRoaXMucG9zID0gZWFzZWQgPSBqUXVlcnkuZWFzaW5nWyB0aGlzLmVhc2luZyBdKFxcblxcdFxcdFxcdFxcdHBlcmNlbnQsIHRoaXMub3B0aW9ucy5kdXJhdGlvbiAqIHBlcmNlbnQsIDAsIDEsIHRoaXMub3B0aW9ucy5kdXJhdGlvblxcblxcdFxcdFxcdCk7XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHR0aGlzLnBvcyA9IGVhc2VkID0gcGVyY2VudDtcXG5cXHRcXHR9XFxuXFx0XFx0dGhpcy5ub3cgPSAoIHRoaXMuZW5kIC0gdGhpcy5zdGFydCApICogZWFzZWQgKyB0aGlzLnN0YXJ0O1xcblxcblxcdFxcdGlmICggdGhpcy5vcHRpb25zLnN0ZXAgKSB7XFxuXFx0XFx0XFx0dGhpcy5vcHRpb25zLnN0ZXAuY2FsbCggdGhpcy5lbGVtLCB0aGlzLm5vdywgdGhpcyApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAoIGhvb2tzICYmIGhvb2tzLnNldCApIHtcXG5cXHRcXHRcXHRob29rcy5zZXQoIHRoaXMgKTtcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFR3ZWVuLnByb3BIb29rcy5fZGVmYXVsdC5zZXQoIHRoaXMgKTtcXG5cXHRcXHR9XFxuXFx0XFx0cmV0dXJuIHRoaXM7XFxuXFx0fVxcbn07XFxuXFxuVHdlZW4ucHJvdG90eXBlLmluaXQucHJvdG90eXBlID0gVHdlZW4ucHJvdG90eXBlO1xcblxcblR3ZWVuLnByb3BIb29rcyA9IHtcXG5cXHRfZGVmYXVsdDoge1xcblxcdFxcdGdldDogZnVuY3Rpb24oIHR3ZWVuICkge1xcblxcdFxcdFxcdHZhciByZXN1bHQ7XFxuXFxuXFx0XFx0XFx0Ly8gVXNlIGEgcHJvcGVydHkgb24gdGhlIGVsZW1lbnQgZGlyZWN0bHkgd2hlbiBpdCBpcyBub3QgYSBET00gZWxlbWVudCxcXG5cXHRcXHRcXHQvLyBvciB3aGVuIHRoZXJlIGlzIG5vIG1hdGNoaW5nIHN0eWxlIHByb3BlcnR5IHRoYXQgZXhpc3RzLlxcblxcdFxcdFxcdGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSAhPT0gMSB8fFxcblxcdFxcdFxcdFxcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSAhPSBudWxsICYmIHR3ZWVuLmVsZW0uc3R5bGVbIHR3ZWVuLnByb3AgXSA9PSBudWxsICkge1xcblxcdFxcdFxcdFxcdHJldHVybiB0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF07XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIFBhc3NpbmcgYW4gZW1wdHkgc3RyaW5nIGFzIGEgM3JkIHBhcmFtZXRlciB0byAuY3NzIHdpbGwgYXV0b21hdGljYWxseVxcblxcdFxcdFxcdC8vIGF0dGVtcHQgYSBwYXJzZUZsb2F0IGFuZCBmYWxsYmFjayB0byBhIHN0cmluZyBpZiB0aGUgcGFyc2UgZmFpbHMuXFxuXFx0XFx0XFx0Ly8gU2ltcGxlIHZhbHVlcyBzdWNoIGFzIFxcXCIxMHB4XFxcIiBhcmUgcGFyc2VkIHRvIEZsb2F0O1xcblxcdFxcdFxcdC8vIGNvbXBsZXggdmFsdWVzIHN1Y2ggYXMgXFxcInJvdGF0ZSgxcmFkKVxcXCIgYXJlIHJldHVybmVkIGFzLWlzLlxcblxcdFxcdFxcdHJlc3VsdCA9IGpRdWVyeS5jc3MoIHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIFxcXCJcXFwiICk7XFxuXFxuXFx0XFx0XFx0Ly8gRW1wdHkgc3RyaW5ncywgbnVsbCwgdW5kZWZpbmVkIGFuZCBcXFwiYXV0b1xcXCIgYXJlIGNvbnZlcnRlZCB0byAwLlxcblxcdFxcdFxcdHJldHVybiAhcmVzdWx0IHx8IHJlc3VsdCA9PT0gXFxcImF1dG9cXFwiID8gMCA6IHJlc3VsdDtcXG5cXHRcXHR9LFxcblxcdFxcdHNldDogZnVuY3Rpb24oIHR3ZWVuICkge1xcblxcblxcdFxcdFxcdC8vIFVzZSBzdGVwIGhvb2sgZm9yIGJhY2sgY29tcGF0LlxcblxcdFxcdFxcdC8vIFVzZSBjc3NIb29rIGlmIGl0cyB0aGVyZS5cXG5cXHRcXHRcXHQvLyBVc2UgLnN0eWxlIGlmIGF2YWlsYWJsZSBhbmQgdXNlIHBsYWluIHByb3BlcnRpZXMgd2hlcmUgYXZhaWxhYmxlLlxcblxcdFxcdFxcdGlmICggalF1ZXJ5LmZ4LnN0ZXBbIHR3ZWVuLnByb3AgXSApIHtcXG5cXHRcXHRcXHRcXHRqUXVlcnkuZnguc3RlcFsgdHdlZW4ucHJvcCBdKCB0d2VlbiApO1xcblxcdFxcdFxcdH0gZWxzZSBpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgPT09IDEgJiZcXG5cXHRcXHRcXHRcXHQoIHR3ZWVuLmVsZW0uc3R5bGVbIGpRdWVyeS5jc3NQcm9wc1sgdHdlZW4ucHJvcCBdIF0gIT0gbnVsbCB8fFxcblxcdFxcdFxcdFxcdFxcdGpRdWVyeS5jc3NIb29rc1sgdHdlZW4ucHJvcCBdICkgKSB7XFxuXFx0XFx0XFx0XFx0alF1ZXJ5LnN0eWxlKCB0d2Vlbi5lbGVtLCB0d2Vlbi5wcm9wLCB0d2Vlbi5ub3cgKyB0d2Vlbi51bml0ICk7XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gPSB0d2Vlbi5ub3c7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9XFxufTtcXG5cXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxcbi8vIFBhbmljIGJhc2VkIGFwcHJvYWNoIHRvIHNldHRpbmcgdGhpbmdzIG9uIGRpc2Nvbm5lY3RlZCBub2Rlc1xcblR3ZWVuLnByb3BIb29rcy5zY3JvbGxUb3AgPSBUd2Vlbi5wcm9wSG9va3Muc2Nyb2xsTGVmdCA9IHtcXG5cXHRzZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcXG5cXHRcXHRpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgJiYgdHdlZW4uZWxlbS5wYXJlbnROb2RlICkge1xcblxcdFxcdFxcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSA9IHR3ZWVuLm5vdztcXG5cXHRcXHR9XFxuXFx0fVxcbn07XFxuXFxualF1ZXJ5LmVhc2luZyA9IHtcXG5cXHRsaW5lYXI6IGZ1bmN0aW9uKCBwICkge1xcblxcdFxcdHJldHVybiBwO1xcblxcdH0sXFxuXFx0c3dpbmc6IGZ1bmN0aW9uKCBwICkge1xcblxcdFxcdHJldHVybiAwLjUgLSBNYXRoLmNvcyggcCAqIE1hdGguUEkgKSAvIDI7XFxuXFx0fSxcXG5cXHRfZGVmYXVsdDogXFxcInN3aW5nXFxcIlxcbn07XFxuXFxualF1ZXJ5LmZ4ID0gVHdlZW4ucHJvdG90eXBlLmluaXQ7XFxuXFxuLy8gQmFjayBjb21wYXQgPDEuOCBleHRlbnNpb24gcG9pbnRcXG5qUXVlcnkuZnguc3RlcCA9IHt9O1xcblxcblxcblxcblxcbnZhclxcblxcdGZ4Tm93LCBpblByb2dyZXNzLFxcblxcdHJmeHR5cGVzID0gL14oPzp0b2dnbGV8c2hvd3xoaWRlKSQvLFxcblxcdHJydW4gPSAvcXVldWVIb29rcyQvO1xcblxcbmZ1bmN0aW9uIHNjaGVkdWxlKCkge1xcblxcdGlmICggaW5Qcm9ncmVzcyApIHtcXG5cXHRcXHRpZiAoIGRvY3VtZW50LmhpZGRlbiA9PT0gZmFsc2UgJiYgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSApIHtcXG5cXHRcXHRcXHR3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCBzY2hlZHVsZSApO1xcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0d2luZG93LnNldFRpbWVvdXQoIHNjaGVkdWxlLCBqUXVlcnkuZnguaW50ZXJ2YWwgKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0alF1ZXJ5LmZ4LnRpY2soKTtcXG5cXHR9XFxufVxcblxcbi8vIEFuaW1hdGlvbnMgY3JlYXRlZCBzeW5jaHJvbm91c2x5IHdpbGwgcnVuIHN5bmNocm9ub3VzbHlcXG5mdW5jdGlvbiBjcmVhdGVGeE5vdygpIHtcXG5cXHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XFxuXFx0XFx0ZnhOb3cgPSB1bmRlZmluZWQ7XFxuXFx0fSApO1xcblxcdHJldHVybiAoIGZ4Tm93ID0gRGF0ZS5ub3coKSApO1xcbn1cXG5cXG4vLyBHZW5lcmF0ZSBwYXJhbWV0ZXJzIHRvIGNyZWF0ZSBhIHN0YW5kYXJkIGFuaW1hdGlvblxcbmZ1bmN0aW9uIGdlbkZ4KCB0eXBlLCBpbmNsdWRlV2lkdGggKSB7XFxuXFx0dmFyIHdoaWNoLFxcblxcdFxcdGkgPSAwLFxcblxcdFxcdGF0dHJzID0geyBoZWlnaHQ6IHR5cGUgfTtcXG5cXG5cXHQvLyBJZiB3ZSBpbmNsdWRlIHdpZHRoLCBzdGVwIHZhbHVlIGlzIDEgdG8gZG8gYWxsIGNzc0V4cGFuZCB2YWx1ZXMsXFxuXFx0Ly8gb3RoZXJ3aXNlIHN0ZXAgdmFsdWUgaXMgMiB0byBza2lwIG92ZXIgTGVmdCBhbmQgUmlnaHRcXG5cXHRpbmNsdWRlV2lkdGggPSBpbmNsdWRlV2lkdGggPyAxIDogMDtcXG5cXHRmb3IgKCA7IGkgPCA0OyBpICs9IDIgLSBpbmNsdWRlV2lkdGggKSB7XFxuXFx0XFx0d2hpY2ggPSBjc3NFeHBhbmRbIGkgXTtcXG5cXHRcXHRhdHRyc1sgXFxcIm1hcmdpblxcXCIgKyB3aGljaCBdID0gYXR0cnNbIFxcXCJwYWRkaW5nXFxcIiArIHdoaWNoIF0gPSB0eXBlO1xcblxcdH1cXG5cXG5cXHRpZiAoIGluY2x1ZGVXaWR0aCApIHtcXG5cXHRcXHRhdHRycy5vcGFjaXR5ID0gYXR0cnMud2lkdGggPSB0eXBlO1xcblxcdH1cXG5cXG5cXHRyZXR1cm4gYXR0cnM7XFxufVxcblxcbmZ1bmN0aW9uIGNyZWF0ZVR3ZWVuKCB2YWx1ZSwgcHJvcCwgYW5pbWF0aW9uICkge1xcblxcdHZhciB0d2VlbixcXG5cXHRcXHRjb2xsZWN0aW9uID0gKCBBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSB8fCBbXSApLmNvbmNhdCggQW5pbWF0aW9uLnR3ZWVuZXJzWyBcXFwiKlxcXCIgXSApLFxcblxcdFxcdGluZGV4ID0gMCxcXG5cXHRcXHRsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcXG5cXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xcblxcdFxcdGlmICggKCB0d2VlbiA9IGNvbGxlY3Rpb25bIGluZGV4IF0uY2FsbCggYW5pbWF0aW9uLCBwcm9wLCB2YWx1ZSApICkgKSB7XFxuXFxuXFx0XFx0XFx0Ly8gV2UncmUgZG9uZSB3aXRoIHRoaXMgcHJvcGVydHlcXG5cXHRcXHRcXHRyZXR1cm4gdHdlZW47XFxuXFx0XFx0fVxcblxcdH1cXG59XFxuXFxuZnVuY3Rpb24gZGVmYXVsdFByZWZpbHRlciggZWxlbSwgcHJvcHMsIG9wdHMgKSB7XFxuXFx0dmFyIHByb3AsIHZhbHVlLCB0b2dnbGUsIGhvb2tzLCBvbGRmaXJlLCBwcm9wVHdlZW4sIHJlc3RvcmVEaXNwbGF5LCBkaXNwbGF5LFxcblxcdFxcdGlzQm94ID0gXFxcIndpZHRoXFxcIiBpbiBwcm9wcyB8fCBcXFwiaGVpZ2h0XFxcIiBpbiBwcm9wcyxcXG5cXHRcXHRhbmltID0gdGhpcyxcXG5cXHRcXHRvcmlnID0ge30sXFxuXFx0XFx0c3R5bGUgPSBlbGVtLnN0eWxlLFxcblxcdFxcdGhpZGRlbiA9IGVsZW0ubm9kZVR5cGUgJiYgaXNIaWRkZW5XaXRoaW5UcmVlKCBlbGVtICksXFxuXFx0XFx0ZGF0YVNob3cgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFxcXCJmeHNob3dcXFwiICk7XFxuXFxuXFx0Ly8gUXVldWUtc2tpcHBpbmcgYW5pbWF0aW9ucyBoaWphY2sgdGhlIGZ4IGhvb2tzXFxuXFx0aWYgKCAhb3B0cy5xdWV1ZSApIHtcXG5cXHRcXHRob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgXFxcImZ4XFxcIiApO1xcblxcdFxcdGlmICggaG9va3MudW5xdWV1ZWQgPT0gbnVsbCApIHtcXG5cXHRcXHRcXHRob29rcy51bnF1ZXVlZCA9IDA7XFxuXFx0XFx0XFx0b2xkZmlyZSA9IGhvb2tzLmVtcHR5LmZpcmU7XFxuXFx0XFx0XFx0aG9va3MuZW1wdHkuZmlyZSA9IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdGlmICggIWhvb2tzLnVucXVldWVkICkge1xcblxcdFxcdFxcdFxcdFxcdG9sZGZpcmUoKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fTtcXG5cXHRcXHR9XFxuXFx0XFx0aG9va3MudW5xdWV1ZWQrKztcXG5cXG5cXHRcXHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XFxuXFxuXFx0XFx0XFx0Ly8gRW5zdXJlIHRoZSBjb21wbGV0ZSBoYW5kbGVyIGlzIGNhbGxlZCBiZWZvcmUgdGhpcyBjb21wbGV0ZXNcXG5cXHRcXHRcXHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0aG9va3MudW5xdWV1ZWQtLTtcXG5cXHRcXHRcXHRcXHRpZiAoICFqUXVlcnkucXVldWUoIGVsZW0sIFxcXCJmeFxcXCIgKS5sZW5ndGggKSB7XFxuXFx0XFx0XFx0XFx0XFx0aG9va3MuZW1wdHkuZmlyZSgpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9ICk7XFxuXFx0XFx0fSApO1xcblxcdH1cXG5cXG5cXHQvLyBEZXRlY3Qgc2hvdy9oaWRlIGFuaW1hdGlvbnNcXG5cXHRmb3IgKCBwcm9wIGluIHByb3BzICkge1xcblxcdFxcdHZhbHVlID0gcHJvcHNbIHByb3AgXTtcXG5cXHRcXHRpZiAoIHJmeHR5cGVzLnRlc3QoIHZhbHVlICkgKSB7XFxuXFx0XFx0XFx0ZGVsZXRlIHByb3BzWyBwcm9wIF07XFxuXFx0XFx0XFx0dG9nZ2xlID0gdG9nZ2xlIHx8IHZhbHVlID09PSBcXFwidG9nZ2xlXFxcIjtcXG5cXHRcXHRcXHRpZiAoIHZhbHVlID09PSAoIGhpZGRlbiA/IFxcXCJoaWRlXFxcIiA6IFxcXCJzaG93XFxcIiApICkge1xcblxcblxcdFxcdFxcdFxcdC8vIFByZXRlbmQgdG8gYmUgaGlkZGVuIGlmIHRoaXMgaXMgYSBcXFwic2hvd1xcXCIgYW5kXFxuXFx0XFx0XFx0XFx0Ly8gdGhlcmUgaXMgc3RpbGwgZGF0YSBmcm9tIGEgc3RvcHBlZCBzaG93L2hpZGVcXG5cXHRcXHRcXHRcXHRpZiAoIHZhbHVlID09PSBcXFwic2hvd1xcXCIgJiYgZGF0YVNob3cgJiYgZGF0YVNob3dbIHByb3AgXSAhPT0gdW5kZWZpbmVkICkge1xcblxcdFxcdFxcdFxcdFxcdGhpZGRlbiA9IHRydWU7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gSWdub3JlIGFsbCBvdGhlciBuby1vcCBzaG93L2hpZGUgZGF0YVxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0Y29udGludWU7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRvcmlnWyBwcm9wIF0gPSBkYXRhU2hvdyAmJiBkYXRhU2hvd1sgcHJvcCBdIHx8IGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCApO1xcblxcdFxcdH1cXG5cXHR9XFxuXFxuXFx0Ly8gQmFpbCBvdXQgaWYgdGhpcyBpcyBhIG5vLW9wIGxpa2UgLmhpZGUoKS5oaWRlKClcXG5cXHRwcm9wVHdlZW4gPSAhalF1ZXJ5LmlzRW1wdHlPYmplY3QoIHByb3BzICk7XFxuXFx0aWYgKCAhcHJvcFR3ZWVuICYmIGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBvcmlnICkgKSB7XFxuXFx0XFx0cmV0dXJuO1xcblxcdH1cXG5cXG5cXHQvLyBSZXN0cmljdCBcXFwib3ZlcmZsb3dcXFwiIGFuZCBcXFwiZGlzcGxheVxcXCIgc3R5bGVzIGR1cmluZyBib3ggYW5pbWF0aW9uc1xcblxcdGlmICggaXNCb3ggJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcXG5cXG5cXHRcXHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSwgRWRnZSAxMiAtIDE1XFxuXFx0XFx0Ly8gUmVjb3JkIGFsbCAzIG92ZXJmbG93IGF0dHJpYnV0ZXMgYmVjYXVzZSBJRSBkb2VzIG5vdCBpbmZlciB0aGUgc2hvcnRoYW5kXFxuXFx0XFx0Ly8gZnJvbSBpZGVudGljYWxseS12YWx1ZWQgb3ZlcmZsb3dYIGFuZCBvdmVyZmxvd1kgYW5kIEVkZ2UganVzdCBtaXJyb3JzXFxuXFx0XFx0Ly8gdGhlIG92ZXJmbG93WCB2YWx1ZSB0aGVyZS5cXG5cXHRcXHRvcHRzLm92ZXJmbG93ID0gWyBzdHlsZS5vdmVyZmxvdywgc3R5bGUub3ZlcmZsb3dYLCBzdHlsZS5vdmVyZmxvd1kgXTtcXG5cXG5cXHRcXHQvLyBJZGVudGlmeSBhIGRpc3BsYXkgdHlwZSwgcHJlZmVycmluZyBvbGQgc2hvdy9oaWRlIGRhdGEgb3ZlciB0aGUgQ1NTIGNhc2NhZGVcXG5cXHRcXHRyZXN0b3JlRGlzcGxheSA9IGRhdGFTaG93ICYmIGRhdGFTaG93LmRpc3BsYXk7XFxuXFx0XFx0aWYgKCByZXN0b3JlRGlzcGxheSA9PSBudWxsICkge1xcblxcdFxcdFxcdHJlc3RvcmVEaXNwbGF5ID0gZGF0YVByaXYuZ2V0KCBlbGVtLCBcXFwiZGlzcGxheVxcXCIgKTtcXG5cXHRcXHR9XFxuXFx0XFx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIGVsZW0sIFxcXCJkaXNwbGF5XFxcIiApO1xcblxcdFxcdGlmICggZGlzcGxheSA9PT0gXFxcIm5vbmVcXFwiICkge1xcblxcdFxcdFxcdGlmICggcmVzdG9yZURpc3BsYXkgKSB7XFxuXFx0XFx0XFx0XFx0ZGlzcGxheSA9IHJlc3RvcmVEaXNwbGF5O1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gR2V0IG5vbmVtcHR5IHZhbHVlKHMpIGJ5IHRlbXBvcmFyaWx5IGZvcmNpbmcgdmlzaWJpbGl0eVxcblxcdFxcdFxcdFxcdHNob3dIaWRlKCBbIGVsZW0gXSwgdHJ1ZSApO1xcblxcdFxcdFxcdFxcdHJlc3RvcmVEaXNwbGF5ID0gZWxlbS5zdHlsZS5kaXNwbGF5IHx8IHJlc3RvcmVEaXNwbGF5O1xcblxcdFxcdFxcdFxcdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCBlbGVtLCBcXFwiZGlzcGxheVxcXCIgKTtcXG5cXHRcXHRcXHRcXHRzaG93SGlkZSggWyBlbGVtIF0gKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIEFuaW1hdGUgaW5saW5lIGVsZW1lbnRzIGFzIGlubGluZS1ibG9ja1xcblxcdFxcdGlmICggZGlzcGxheSA9PT0gXFxcImlubGluZVxcXCIgfHwgZGlzcGxheSA9PT0gXFxcImlubGluZS1ibG9ja1xcXCIgJiYgcmVzdG9yZURpc3BsYXkgIT0gbnVsbCApIHtcXG5cXHRcXHRcXHRpZiAoIGpRdWVyeS5jc3MoIGVsZW0sIFxcXCJmbG9hdFxcXCIgKSA9PT0gXFxcIm5vbmVcXFwiICkge1xcblxcblxcdFxcdFxcdFxcdC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIGRpc3BsYXkgdmFsdWUgYXQgdGhlIGVuZCBvZiBwdXJlIHNob3cvaGlkZSBhbmltYXRpb25zXFxuXFx0XFx0XFx0XFx0aWYgKCAhcHJvcFR3ZWVuICkge1xcblxcdFxcdFxcdFxcdFxcdGFuaW0uZG9uZSggZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0c3R5bGUuZGlzcGxheSA9IHJlc3RvcmVEaXNwbGF5O1xcblxcdFxcdFxcdFxcdFxcdH0gKTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHJlc3RvcmVEaXNwbGF5ID09IG51bGwgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZGlzcGxheSA9IHN0eWxlLmRpc3BsYXk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmVzdG9yZURpc3BsYXkgPSBkaXNwbGF5ID09PSBcXFwibm9uZVxcXCIgPyBcXFwiXFxcIiA6IGRpc3BsYXk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRzdHlsZS5kaXNwbGF5ID0gXFxcImlubGluZS1ibG9ja1xcXCI7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9XFxuXFxuXFx0aWYgKCBvcHRzLm92ZXJmbG93ICkge1xcblxcdFxcdHN0eWxlLm92ZXJmbG93ID0gXFxcImhpZGRlblxcXCI7XFxuXFx0XFx0YW5pbS5hbHdheXMoIGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdHN0eWxlLm92ZXJmbG93ID0gb3B0cy5vdmVyZmxvd1sgMCBdO1xcblxcdFxcdFxcdHN0eWxlLm92ZXJmbG93WCA9IG9wdHMub3ZlcmZsb3dbIDEgXTtcXG5cXHRcXHRcXHRzdHlsZS5vdmVyZmxvd1kgPSBvcHRzLm92ZXJmbG93WyAyIF07XFxuXFx0XFx0fSApO1xcblxcdH1cXG5cXG5cXHQvLyBJbXBsZW1lbnQgc2hvdy9oaWRlIGFuaW1hdGlvbnNcXG5cXHRwcm9wVHdlZW4gPSBmYWxzZTtcXG5cXHRmb3IgKCBwcm9wIGluIG9yaWcgKSB7XFxuXFxuXFx0XFx0Ly8gR2VuZXJhbCBzaG93L2hpZGUgc2V0dXAgZm9yIHRoaXMgZWxlbWVudCBhbmltYXRpb25cXG5cXHRcXHRpZiAoICFwcm9wVHdlZW4gKSB7XFxuXFx0XFx0XFx0aWYgKCBkYXRhU2hvdyApIHtcXG5cXHRcXHRcXHRcXHRpZiAoIFxcXCJoaWRkZW5cXFwiIGluIGRhdGFTaG93ICkge1xcblxcdFxcdFxcdFxcdFxcdGhpZGRlbiA9IGRhdGFTaG93LmhpZGRlbjtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRkYXRhU2hvdyA9IGRhdGFQcml2LmFjY2VzcyggZWxlbSwgXFxcImZ4c2hvd1xcXCIsIHsgZGlzcGxheTogcmVzdG9yZURpc3BsYXkgfSApO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBTdG9yZSBoaWRkZW4vdmlzaWJsZSBmb3IgdG9nZ2xlIHNvIGAuc3RvcCgpLnRvZ2dsZSgpYCBcXFwicmV2ZXJzZXNcXFwiXFxuXFx0XFx0XFx0aWYgKCB0b2dnbGUgKSB7XFxuXFx0XFx0XFx0XFx0ZGF0YVNob3cuaGlkZGVuID0gIWhpZGRlbjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gU2hvdyBlbGVtZW50cyBiZWZvcmUgYW5pbWF0aW5nIHRoZW1cXG5cXHRcXHRcXHRpZiAoIGhpZGRlbiApIHtcXG5cXHRcXHRcXHRcXHRzaG93SGlkZSggWyBlbGVtIF0sIHRydWUgKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0LyogZXNsaW50LWRpc2FibGUgbm8tbG9vcC1mdW5jICovXFxuXFxuXFx0XFx0XFx0YW5pbS5kb25lKCBmdW5jdGlvbigpIHtcXG5cXG5cXHRcXHRcXHQvKiBlc2xpbnQtZW5hYmxlIG5vLWxvb3AtZnVuYyAqL1xcblxcblxcdFxcdFxcdFxcdC8vIFRoZSBmaW5hbCBzdGVwIG9mIGEgXFxcImhpZGVcXFwiIGFuaW1hdGlvbiBpcyBhY3R1YWxseSBoaWRpbmcgdGhlIGVsZW1lbnRcXG5cXHRcXHRcXHRcXHRpZiAoICFoaWRkZW4gKSB7XFxuXFx0XFx0XFx0XFx0XFx0c2hvd0hpZGUoIFsgZWxlbSBdICk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgXFxcImZ4c2hvd1xcXCIgKTtcXG5cXHRcXHRcXHRcXHRmb3IgKCBwcm9wIGluIG9yaWcgKSB7XFxuXFx0XFx0XFx0XFx0XFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wLCBvcmlnWyBwcm9wIF0gKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBQZXItcHJvcGVydHkgc2V0dXBcXG5cXHRcXHRwcm9wVHdlZW4gPSBjcmVhdGVUd2VlbiggaGlkZGVuID8gZGF0YVNob3dbIHByb3AgXSA6IDAsIHByb3AsIGFuaW0gKTtcXG5cXHRcXHRpZiAoICEoIHByb3AgaW4gZGF0YVNob3cgKSApIHtcXG5cXHRcXHRcXHRkYXRhU2hvd1sgcHJvcCBdID0gcHJvcFR3ZWVuLnN0YXJ0O1xcblxcdFxcdFxcdGlmICggaGlkZGVuICkge1xcblxcdFxcdFxcdFxcdHByb3BUd2Vlbi5lbmQgPSBwcm9wVHdlZW4uc3RhcnQ7XFxuXFx0XFx0XFx0XFx0cHJvcFR3ZWVuLnN0YXJ0ID0gMDtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdH1cXG59XFxuXFxuZnVuY3Rpb24gcHJvcEZpbHRlciggcHJvcHMsIHNwZWNpYWxFYXNpbmcgKSB7XFxuXFx0dmFyIGluZGV4LCBuYW1lLCBlYXNpbmcsIHZhbHVlLCBob29rcztcXG5cXG5cXHQvLyBjYW1lbENhc2UsIHNwZWNpYWxFYXNpbmcgYW5kIGV4cGFuZCBjc3NIb29rIHBhc3NcXG5cXHRmb3IgKCBpbmRleCBpbiBwcm9wcyApIHtcXG5cXHRcXHRuYW1lID0gY2FtZWxDYXNlKCBpbmRleCApO1xcblxcdFxcdGVhc2luZyA9IHNwZWNpYWxFYXNpbmdbIG5hbWUgXTtcXG5cXHRcXHR2YWx1ZSA9IHByb3BzWyBpbmRleCBdO1xcblxcdFxcdGlmICggQXJyYXkuaXNBcnJheSggdmFsdWUgKSApIHtcXG5cXHRcXHRcXHRlYXNpbmcgPSB2YWx1ZVsgMSBdO1xcblxcdFxcdFxcdHZhbHVlID0gcHJvcHNbIGluZGV4IF0gPSB2YWx1ZVsgMCBdO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAoIGluZGV4ICE9PSBuYW1lICkge1xcblxcdFxcdFxcdHByb3BzWyBuYW1lIF0gPSB2YWx1ZTtcXG5cXHRcXHRcXHRkZWxldGUgcHJvcHNbIGluZGV4IF07XFxuXFx0XFx0fVxcblxcblxcdFxcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF07XFxuXFx0XFx0aWYgKCBob29rcyAmJiBcXFwiZXhwYW5kXFxcIiBpbiBob29rcyApIHtcXG5cXHRcXHRcXHR2YWx1ZSA9IGhvb2tzLmV4cGFuZCggdmFsdWUgKTtcXG5cXHRcXHRcXHRkZWxldGUgcHJvcHNbIG5hbWUgXTtcXG5cXG5cXHRcXHRcXHQvLyBOb3QgcXVpdGUgJC5leHRlbmQsIHRoaXMgd29uJ3Qgb3ZlcndyaXRlIGV4aXN0aW5nIGtleXMuXFxuXFx0XFx0XFx0Ly8gUmV1c2luZyAnaW5kZXgnIGJlY2F1c2Ugd2UgaGF2ZSB0aGUgY29ycmVjdCBcXFwibmFtZVxcXCJcXG5cXHRcXHRcXHRmb3IgKCBpbmRleCBpbiB2YWx1ZSApIHtcXG5cXHRcXHRcXHRcXHRpZiAoICEoIGluZGV4IGluIHByb3BzICkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0cHJvcHNbIGluZGV4IF0gPSB2YWx1ZVsgaW5kZXggXTtcXG5cXHRcXHRcXHRcXHRcXHRzcGVjaWFsRWFzaW5nWyBpbmRleCBdID0gZWFzaW5nO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRzcGVjaWFsRWFzaW5nWyBuYW1lIF0gPSBlYXNpbmc7XFxuXFx0XFx0fVxcblxcdH1cXG59XFxuXFxuZnVuY3Rpb24gQW5pbWF0aW9uKCBlbGVtLCBwcm9wZXJ0aWVzLCBvcHRpb25zICkge1xcblxcdHZhciByZXN1bHQsXFxuXFx0XFx0c3RvcHBlZCxcXG5cXHRcXHRpbmRleCA9IDAsXFxuXFx0XFx0bGVuZ3RoID0gQW5pbWF0aW9uLnByZWZpbHRlcnMubGVuZ3RoLFxcblxcdFxcdGRlZmVycmVkID0galF1ZXJ5LkRlZmVycmVkKCkuYWx3YXlzKCBmdW5jdGlvbigpIHtcXG5cXG5cXHRcXHRcXHQvLyBEb24ndCBtYXRjaCBlbGVtIGluIHRoZSA6YW5pbWF0ZWQgc2VsZWN0b3JcXG5cXHRcXHRcXHRkZWxldGUgdGljay5lbGVtO1xcblxcdFxcdH0gKSxcXG5cXHRcXHR0aWNrID0gZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0aWYgKCBzdG9wcGVkICkge1xcblxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0dmFyIGN1cnJlbnRUaW1lID0gZnhOb3cgfHwgY3JlYXRlRnhOb3coKSxcXG5cXHRcXHRcXHRcXHRyZW1haW5pbmcgPSBNYXRoLm1heCggMCwgYW5pbWF0aW9uLnN0YXJ0VGltZSArIGFuaW1hdGlvbi5kdXJhdGlvbiAtIGN1cnJlbnRUaW1lICksXFxuXFxuXFx0XFx0XFx0XFx0Ly8gU3VwcG9ydDogQW5kcm9pZCAyLjMgb25seVxcblxcdFxcdFxcdFxcdC8vIEFyY2hhaWMgY3Jhc2ggYnVnIHdvbid0IGFsbG93IHVzIHRvIHVzZSBgMSAtICggMC41IHx8IDAgKWAgKCMxMjQ5NylcXG5cXHRcXHRcXHRcXHR0ZW1wID0gcmVtYWluaW5nIC8gYW5pbWF0aW9uLmR1cmF0aW9uIHx8IDAsXFxuXFx0XFx0XFx0XFx0cGVyY2VudCA9IDEgLSB0ZW1wLFxcblxcdFxcdFxcdFxcdGluZGV4ID0gMCxcXG5cXHRcXHRcXHRcXHRsZW5ndGggPSBhbmltYXRpb24udHdlZW5zLmxlbmd0aDtcXG5cXG5cXHRcXHRcXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xcblxcdFxcdFxcdFxcdGFuaW1hdGlvbi50d2VlbnNbIGluZGV4IF0ucnVuKCBwZXJjZW50ICk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBwZXJjZW50LCByZW1haW5pbmcgXSApO1xcblxcblxcdFxcdFxcdC8vIElmIHRoZXJlJ3MgbW9yZSB0byBkbywgeWllbGRcXG5cXHRcXHRcXHRpZiAoIHBlcmNlbnQgPCAxICYmIGxlbmd0aCApIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gcmVtYWluaW5nO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBJZiB0aGlzIHdhcyBhbiBlbXB0eSBhbmltYXRpb24sIHN5bnRoZXNpemUgYSBmaW5hbCBwcm9ncmVzcyBub3RpZmljYXRpb25cXG5cXHRcXHRcXHRpZiAoICFsZW5ndGggKSB7XFxuXFx0XFx0XFx0XFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIDEsIDAgXSApO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBSZXNvbHZlIHRoZSBhbmltYXRpb24gYW5kIHJlcG9ydCBpdHMgY29uY2x1c2lvblxcblxcdFxcdFxcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiBdICk7XFxuXFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdH0sXFxuXFx0XFx0YW5pbWF0aW9uID0gZGVmZXJyZWQucHJvbWlzZSgge1xcblxcdFxcdFxcdGVsZW06IGVsZW0sXFxuXFx0XFx0XFx0cHJvcHM6IGpRdWVyeS5leHRlbmQoIHt9LCBwcm9wZXJ0aWVzICksXFxuXFx0XFx0XFx0b3B0czogalF1ZXJ5LmV4dGVuZCggdHJ1ZSwge1xcblxcdFxcdFxcdFxcdHNwZWNpYWxFYXNpbmc6IHt9LFxcblxcdFxcdFxcdFxcdGVhc2luZzogalF1ZXJ5LmVhc2luZy5fZGVmYXVsdFxcblxcdFxcdFxcdH0sIG9wdGlvbnMgKSxcXG5cXHRcXHRcXHRvcmlnaW5hbFByb3BlcnRpZXM6IHByb3BlcnRpZXMsXFxuXFx0XFx0XFx0b3JpZ2luYWxPcHRpb25zOiBvcHRpb25zLFxcblxcdFxcdFxcdHN0YXJ0VGltZTogZnhOb3cgfHwgY3JlYXRlRnhOb3coKSxcXG5cXHRcXHRcXHRkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvbixcXG5cXHRcXHRcXHR0d2VlbnM6IFtdLFxcblxcdFxcdFxcdGNyZWF0ZVR3ZWVuOiBmdW5jdGlvbiggcHJvcCwgZW5kICkge1xcblxcdFxcdFxcdFxcdHZhciB0d2VlbiA9IGpRdWVyeS5Ud2VlbiggZWxlbSwgYW5pbWF0aW9uLm9wdHMsIHByb3AsIGVuZCxcXG5cXHRcXHRcXHRcXHRcXHRcXHRhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nWyBwcm9wIF0gfHwgYW5pbWF0aW9uLm9wdHMuZWFzaW5nICk7XFxuXFx0XFx0XFx0XFx0YW5pbWF0aW9uLnR3ZWVucy5wdXNoKCB0d2VlbiApO1xcblxcdFxcdFxcdFxcdHJldHVybiB0d2VlbjtcXG5cXHRcXHRcXHR9LFxcblxcdFxcdFxcdHN0b3A6IGZ1bmN0aW9uKCBnb3RvRW5kICkge1xcblxcdFxcdFxcdFxcdHZhciBpbmRleCA9IDAsXFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gSWYgd2UgYXJlIGdvaW5nIHRvIHRoZSBlbmQsIHdlIHdhbnQgdG8gcnVuIGFsbCB0aGUgdHdlZW5zXFxuXFx0XFx0XFx0XFx0XFx0Ly8gb3RoZXJ3aXNlIHdlIHNraXAgdGhpcyBwYXJ0XFxuXFx0XFx0XFx0XFx0XFx0bGVuZ3RoID0gZ290b0VuZCA/IGFuaW1hdGlvbi50d2VlbnMubGVuZ3RoIDogMDtcXG5cXHRcXHRcXHRcXHRpZiAoIHN0b3BwZWQgKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHN0b3BwZWQgPSB0cnVlO1xcblxcdFxcdFxcdFxcdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XFxuXFx0XFx0XFx0XFx0XFx0YW5pbWF0aW9uLnR3ZWVuc1sgaW5kZXggXS5ydW4oIDEgKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gUmVzb2x2ZSB3aGVuIHdlIHBsYXllZCB0aGUgbGFzdCBmcmFtZTsgb3RoZXJ3aXNlLCByZWplY3RcXG5cXHRcXHRcXHRcXHRpZiAoIGdvdG9FbmQgKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIDEsIDAgXSApO1xcblxcdFxcdFxcdFxcdFxcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgZ290b0VuZCBdICk7XFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRkZWZlcnJlZC5yZWplY3RXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgZ290b0VuZCBdICk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9ICksXFxuXFx0XFx0cHJvcHMgPSBhbmltYXRpb24ucHJvcHM7XFxuXFxuXFx0cHJvcEZpbHRlciggcHJvcHMsIGFuaW1hdGlvbi5vcHRzLnNwZWNpYWxFYXNpbmcgKTtcXG5cXG5cXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xcblxcdFxcdHJlc3VsdCA9IEFuaW1hdGlvbi5wcmVmaWx0ZXJzWyBpbmRleCBdLmNhbGwoIGFuaW1hdGlvbiwgZWxlbSwgcHJvcHMsIGFuaW1hdGlvbi5vcHRzICk7XFxuXFx0XFx0aWYgKCByZXN1bHQgKSB7XFxuXFx0XFx0XFx0aWYgKCBpc0Z1bmN0aW9uKCByZXN1bHQuc3RvcCApICkge1xcblxcdFxcdFxcdFxcdGpRdWVyeS5fcXVldWVIb29rcyggYW5pbWF0aW9uLmVsZW0sIGFuaW1hdGlvbi5vcHRzLnF1ZXVlICkuc3RvcCA9XFxuXFx0XFx0XFx0XFx0XFx0cmVzdWx0LnN0b3AuYmluZCggcmVzdWx0ICk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiByZXN1bHQ7XFxuXFx0XFx0fVxcblxcdH1cXG5cXG5cXHRqUXVlcnkubWFwKCBwcm9wcywgY3JlYXRlVHdlZW4sIGFuaW1hdGlvbiApO1xcblxcblxcdGlmICggaXNGdW5jdGlvbiggYW5pbWF0aW9uLm9wdHMuc3RhcnQgKSApIHtcXG5cXHRcXHRhbmltYXRpb24ub3B0cy5zdGFydC5jYWxsKCBlbGVtLCBhbmltYXRpb24gKTtcXG5cXHR9XFxuXFxuXFx0Ly8gQXR0YWNoIGNhbGxiYWNrcyBmcm9tIG9wdGlvbnNcXG5cXHRhbmltYXRpb25cXG5cXHRcXHQucHJvZ3Jlc3MoIGFuaW1hdGlvbi5vcHRzLnByb2dyZXNzIClcXG5cXHRcXHQuZG9uZSggYW5pbWF0aW9uLm9wdHMuZG9uZSwgYW5pbWF0aW9uLm9wdHMuY29tcGxldGUgKVxcblxcdFxcdC5mYWlsKCBhbmltYXRpb24ub3B0cy5mYWlsIClcXG5cXHRcXHQuYWx3YXlzKCBhbmltYXRpb24ub3B0cy5hbHdheXMgKTtcXG5cXG5cXHRqUXVlcnkuZngudGltZXIoXFxuXFx0XFx0alF1ZXJ5LmV4dGVuZCggdGljaywge1xcblxcdFxcdFxcdGVsZW06IGVsZW0sXFxuXFx0XFx0XFx0YW5pbTogYW5pbWF0aW9uLFxcblxcdFxcdFxcdHF1ZXVlOiBhbmltYXRpb24ub3B0cy5xdWV1ZVxcblxcdFxcdH0gKVxcblxcdCk7XFxuXFxuXFx0cmV0dXJuIGFuaW1hdGlvbjtcXG59XFxuXFxualF1ZXJ5LkFuaW1hdGlvbiA9IGpRdWVyeS5leHRlbmQoIEFuaW1hdGlvbiwge1xcblxcblxcdHR3ZWVuZXJzOiB7XFxuXFx0XFx0XFxcIipcXFwiOiBbIGZ1bmN0aW9uKCBwcm9wLCB2YWx1ZSApIHtcXG5cXHRcXHRcXHR2YXIgdHdlZW4gPSB0aGlzLmNyZWF0ZVR3ZWVuKCBwcm9wLCB2YWx1ZSApO1xcblxcdFxcdFxcdGFkanVzdENTUyggdHdlZW4uZWxlbSwgcHJvcCwgcmNzc051bS5leGVjKCB2YWx1ZSApLCB0d2VlbiApO1xcblxcdFxcdFxcdHJldHVybiB0d2VlbjtcXG5cXHRcXHR9IF1cXG5cXHR9LFxcblxcblxcdHR3ZWVuZXI6IGZ1bmN0aW9uKCBwcm9wcywgY2FsbGJhY2sgKSB7XFxuXFx0XFx0aWYgKCBpc0Z1bmN0aW9uKCBwcm9wcyApICkge1xcblxcdFxcdFxcdGNhbGxiYWNrID0gcHJvcHM7XFxuXFx0XFx0XFx0cHJvcHMgPSBbIFxcXCIqXFxcIiBdO1xcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0cHJvcHMgPSBwcm9wcy5tYXRjaCggcm5vdGh0bWx3aGl0ZSApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHR2YXIgcHJvcCxcXG5cXHRcXHRcXHRpbmRleCA9IDAsXFxuXFx0XFx0XFx0bGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xcblxcblxcdFxcdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XFxuXFx0XFx0XFx0cHJvcCA9IHByb3BzWyBpbmRleCBdO1xcblxcdFxcdFxcdEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdID0gQW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gfHwgW107XFxuXFx0XFx0XFx0QW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0udW5zaGlmdCggY2FsbGJhY2sgKTtcXG5cXHRcXHR9XFxuXFx0fSxcXG5cXG5cXHRwcmVmaWx0ZXJzOiBbIGRlZmF1bHRQcmVmaWx0ZXIgXSxcXG5cXG5cXHRwcmVmaWx0ZXI6IGZ1bmN0aW9uKCBjYWxsYmFjaywgcHJlcGVuZCApIHtcXG5cXHRcXHRpZiAoIHByZXBlbmQgKSB7XFxuXFx0XFx0XFx0QW5pbWF0aW9uLnByZWZpbHRlcnMudW5zaGlmdCggY2FsbGJhY2sgKTtcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdEFuaW1hdGlvbi5wcmVmaWx0ZXJzLnB1c2goIGNhbGxiYWNrICk7XFxuXFx0XFx0fVxcblxcdH1cXG59ICk7XFxuXFxualF1ZXJ5LnNwZWVkID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGZuICkge1xcblxcdHZhciBvcHQgPSBzcGVlZCAmJiB0eXBlb2Ygc3BlZWQgPT09IFxcXCJvYmplY3RcXFwiID8galF1ZXJ5LmV4dGVuZCgge30sIHNwZWVkICkgOiB7XFxuXFx0XFx0Y29tcGxldGU6IGZuIHx8ICFmbiAmJiBlYXNpbmcgfHxcXG5cXHRcXHRcXHRpc0Z1bmN0aW9uKCBzcGVlZCApICYmIHNwZWVkLFxcblxcdFxcdGR1cmF0aW9uOiBzcGVlZCxcXG5cXHRcXHRlYXNpbmc6IGZuICYmIGVhc2luZyB8fCBlYXNpbmcgJiYgIWlzRnVuY3Rpb24oIGVhc2luZyApICYmIGVhc2luZ1xcblxcdH07XFxuXFxuXFx0Ly8gR28gdG8gdGhlIGVuZCBzdGF0ZSBpZiBmeCBhcmUgb2ZmXFxuXFx0aWYgKCBqUXVlcnkuZngub2ZmICkge1xcblxcdFxcdG9wdC5kdXJhdGlvbiA9IDA7XFxuXFxuXFx0fSBlbHNlIHtcXG5cXHRcXHRpZiAoIHR5cGVvZiBvcHQuZHVyYXRpb24gIT09IFxcXCJudW1iZXJcXFwiICkge1xcblxcdFxcdFxcdGlmICggb3B0LmR1cmF0aW9uIGluIGpRdWVyeS5meC5zcGVlZHMgKSB7XFxuXFx0XFx0XFx0XFx0b3B0LmR1cmF0aW9uID0galF1ZXJ5LmZ4LnNwZWVkc1sgb3B0LmR1cmF0aW9uIF07XFxuXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRvcHQuZHVyYXRpb24gPSBqUXVlcnkuZnguc3BlZWRzLl9kZWZhdWx0O1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fVxcblxcblxcdC8vIE5vcm1hbGl6ZSBvcHQucXVldWUgLSB0cnVlL3VuZGVmaW5lZC9udWxsIC0+IFxcXCJmeFxcXCJcXG5cXHRpZiAoIG9wdC5xdWV1ZSA9PSBudWxsIHx8IG9wdC5xdWV1ZSA9PT0gdHJ1ZSApIHtcXG5cXHRcXHRvcHQucXVldWUgPSBcXFwiZnhcXFwiO1xcblxcdH1cXG5cXG5cXHQvLyBRdWV1ZWluZ1xcblxcdG9wdC5vbGQgPSBvcHQuY29tcGxldGU7XFxuXFxuXFx0b3B0LmNvbXBsZXRlID0gZnVuY3Rpb24oKSB7XFxuXFx0XFx0aWYgKCBpc0Z1bmN0aW9uKCBvcHQub2xkICkgKSB7XFxuXFx0XFx0XFx0b3B0Lm9sZC5jYWxsKCB0aGlzICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICggb3B0LnF1ZXVlICkge1xcblxcdFxcdFxcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCBvcHQucXVldWUgKTtcXG5cXHRcXHR9XFxuXFx0fTtcXG5cXG5cXHRyZXR1cm4gb3B0O1xcbn07XFxuXFxualF1ZXJ5LmZuLmV4dGVuZCgge1xcblxcdGZhZGVUbzogZnVuY3Rpb24oIHNwZWVkLCB0bywgZWFzaW5nLCBjYWxsYmFjayApIHtcXG5cXG5cXHRcXHQvLyBTaG93IGFueSBoaWRkZW4gZWxlbWVudHMgYWZ0ZXIgc2V0dGluZyBvcGFjaXR5IHRvIDBcXG5cXHRcXHRyZXR1cm4gdGhpcy5maWx0ZXIoIGlzSGlkZGVuV2l0aGluVHJlZSApLmNzcyggXFxcIm9wYWNpdHlcXFwiLCAwICkuc2hvdygpXFxuXFxuXFx0XFx0XFx0Ly8gQW5pbWF0ZSB0byB0aGUgdmFsdWUgc3BlY2lmaWVkXFxuXFx0XFx0XFx0LmVuZCgpLmFuaW1hdGUoIHsgb3BhY2l0eTogdG8gfSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcXG5cXHR9LFxcblxcdGFuaW1hdGU6IGZ1bmN0aW9uKCBwcm9wLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcXG5cXHRcXHR2YXIgZW1wdHkgPSBqUXVlcnkuaXNFbXB0eU9iamVjdCggcHJvcCApLFxcblxcdFxcdFxcdG9wdGFsbCA9IGpRdWVyeS5zcGVlZCggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSxcXG5cXHRcXHRcXHRkb0FuaW1hdGlvbiA9IGZ1bmN0aW9uKCkge1xcblxcblxcdFxcdFxcdFxcdC8vIE9wZXJhdGUgb24gYSBjb3B5IG9mIHByb3Agc28gcGVyLXByb3BlcnR5IGVhc2luZyB3b24ndCBiZSBsb3N0XFxuXFx0XFx0XFx0XFx0dmFyIGFuaW0gPSBBbmltYXRpb24oIHRoaXMsIGpRdWVyeS5leHRlbmQoIHt9LCBwcm9wICksIG9wdGFsbCApO1xcblxcblxcdFxcdFxcdFxcdC8vIEVtcHR5IGFuaW1hdGlvbnMsIG9yIGZpbmlzaGluZyByZXNvbHZlcyBpbW1lZGlhdGVseVxcblxcdFxcdFxcdFxcdGlmICggZW1wdHkgfHwgZGF0YVByaXYuZ2V0KCB0aGlzLCBcXFwiZmluaXNoXFxcIiApICkge1xcblxcdFxcdFxcdFxcdFxcdGFuaW0uc3RvcCggdHJ1ZSApO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9O1xcblxcdFxcdFxcdGRvQW5pbWF0aW9uLmZpbmlzaCA9IGRvQW5pbWF0aW9uO1xcblxcblxcdFxcdHJldHVybiBlbXB0eSB8fCBvcHRhbGwucXVldWUgPT09IGZhbHNlID9cXG5cXHRcXHRcXHR0aGlzLmVhY2goIGRvQW5pbWF0aW9uICkgOlxcblxcdFxcdFxcdHRoaXMucXVldWUoIG9wdGFsbC5xdWV1ZSwgZG9BbmltYXRpb24gKTtcXG5cXHR9LFxcblxcdHN0b3A6IGZ1bmN0aW9uKCB0eXBlLCBjbGVhclF1ZXVlLCBnb3RvRW5kICkge1xcblxcdFxcdHZhciBzdG9wUXVldWUgPSBmdW5jdGlvbiggaG9va3MgKSB7XFxuXFx0XFx0XFx0dmFyIHN0b3AgPSBob29rcy5zdG9wO1xcblxcdFxcdFxcdGRlbGV0ZSBob29rcy5zdG9wO1xcblxcdFxcdFxcdHN0b3AoIGdvdG9FbmQgKTtcXG5cXHRcXHR9O1xcblxcblxcdFxcdGlmICggdHlwZW9mIHR5cGUgIT09IFxcXCJzdHJpbmdcXFwiICkge1xcblxcdFxcdFxcdGdvdG9FbmQgPSBjbGVhclF1ZXVlO1xcblxcdFxcdFxcdGNsZWFyUXVldWUgPSB0eXBlO1xcblxcdFxcdFxcdHR5cGUgPSB1bmRlZmluZWQ7XFxuXFx0XFx0fVxcblxcdFxcdGlmICggY2xlYXJRdWV1ZSAmJiB0eXBlICE9PSBmYWxzZSApIHtcXG5cXHRcXHRcXHR0aGlzLnF1ZXVlKCB0eXBlIHx8IFxcXCJmeFxcXCIsIFtdICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdHZhciBkZXF1ZXVlID0gdHJ1ZSxcXG5cXHRcXHRcXHRcXHRpbmRleCA9IHR5cGUgIT0gbnVsbCAmJiB0eXBlICsgXFxcInF1ZXVlSG9va3NcXFwiLFxcblxcdFxcdFxcdFxcdHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXFxuXFx0XFx0XFx0XFx0ZGF0YSA9IGRhdGFQcml2LmdldCggdGhpcyApO1xcblxcblxcdFxcdFxcdGlmICggaW5kZXggKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCApIHtcXG5cXHRcXHRcXHRcXHRcXHRzdG9wUXVldWUoIGRhdGFbIGluZGV4IF0gKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRmb3IgKCBpbmRleCBpbiBkYXRhICkge1xcblxcdFxcdFxcdFxcdFxcdGlmICggZGF0YVsgaW5kZXggXSAmJiBkYXRhWyBpbmRleCBdLnN0b3AgJiYgcnJ1bi50ZXN0KCBpbmRleCApICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHN0b3BRdWV1ZSggZGF0YVsgaW5kZXggXSApO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGZvciAoIGluZGV4ID0gdGltZXJzLmxlbmd0aDsgaW5kZXgtLTsgKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCB0aW1lcnNbIGluZGV4IF0uZWxlbSA9PT0gdGhpcyAmJlxcblxcdFxcdFxcdFxcdFxcdCggdHlwZSA9PSBudWxsIHx8IHRpbWVyc1sgaW5kZXggXS5xdWV1ZSA9PT0gdHlwZSApICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHRpbWVyc1sgaW5kZXggXS5hbmltLnN0b3AoIGdvdG9FbmQgKTtcXG5cXHRcXHRcXHRcXHRcXHRkZXF1ZXVlID0gZmFsc2U7XFxuXFx0XFx0XFx0XFx0XFx0dGltZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIFN0YXJ0IHRoZSBuZXh0IGluIHRoZSBxdWV1ZSBpZiB0aGUgbGFzdCBzdGVwIHdhc24ndCBmb3JjZWQuXFxuXFx0XFx0XFx0Ly8gVGltZXJzIGN1cnJlbnRseSB3aWxsIGNhbGwgdGhlaXIgY29tcGxldGUgY2FsbGJhY2tzLCB3aGljaFxcblxcdFxcdFxcdC8vIHdpbGwgZGVxdWV1ZSBidXQgb25seSBpZiB0aGV5IHdlcmUgZ290b0VuZC5cXG5cXHRcXHRcXHRpZiAoIGRlcXVldWUgfHwgIWdvdG9FbmQgKSB7XFxuXFx0XFx0XFx0XFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSApO1xcblxcdH0sXFxuXFx0ZmluaXNoOiBmdW5jdGlvbiggdHlwZSApIHtcXG5cXHRcXHRpZiAoIHR5cGUgIT09IGZhbHNlICkge1xcblxcdFxcdFxcdHR5cGUgPSB0eXBlIHx8IFxcXCJmeFxcXCI7XFxuXFx0XFx0fVxcblxcdFxcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdHZhciBpbmRleCxcXG5cXHRcXHRcXHRcXHRkYXRhID0gZGF0YVByaXYuZ2V0KCB0aGlzICksXFxuXFx0XFx0XFx0XFx0cXVldWUgPSBkYXRhWyB0eXBlICsgXFxcInF1ZXVlXFxcIiBdLFxcblxcdFxcdFxcdFxcdGhvb2tzID0gZGF0YVsgdHlwZSArIFxcXCJxdWV1ZUhvb2tzXFxcIiBdLFxcblxcdFxcdFxcdFxcdHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXFxuXFx0XFx0XFx0XFx0bGVuZ3RoID0gcXVldWUgPyBxdWV1ZS5sZW5ndGggOiAwO1xcblxcblxcdFxcdFxcdC8vIEVuYWJsZSBmaW5pc2hpbmcgZmxhZyBvbiBwcml2YXRlIGRhdGFcXG5cXHRcXHRcXHRkYXRhLmZpbmlzaCA9IHRydWU7XFxuXFxuXFx0XFx0XFx0Ly8gRW1wdHkgdGhlIHF1ZXVlIGZpcnN0XFxuXFx0XFx0XFx0alF1ZXJ5LnF1ZXVlKCB0aGlzLCB0eXBlLCBbXSApO1xcblxcblxcdFxcdFxcdGlmICggaG9va3MgJiYgaG9va3Muc3RvcCApIHtcXG5cXHRcXHRcXHRcXHRob29rcy5zdG9wLmNhbGwoIHRoaXMsIHRydWUgKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gTG9vayBmb3IgYW55IGFjdGl2ZSBhbmltYXRpb25zLCBhbmQgZmluaXNoIHRoZW1cXG5cXHRcXHRcXHRmb3IgKCBpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07ICkge1xcblxcdFxcdFxcdFxcdGlmICggdGltZXJzWyBpbmRleCBdLmVsZW0gPT09IHRoaXMgJiYgdGltZXJzWyBpbmRleCBdLnF1ZXVlID09PSB0eXBlICkge1xcblxcdFxcdFxcdFxcdFxcdHRpbWVyc1sgaW5kZXggXS5hbmltLnN0b3AoIHRydWUgKTtcXG5cXHRcXHRcXHRcXHRcXHR0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gTG9vayBmb3IgYW55IGFuaW1hdGlvbnMgaW4gdGhlIG9sZCBxdWV1ZSBhbmQgZmluaXNoIHRoZW1cXG5cXHRcXHRcXHRmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xcblxcdFxcdFxcdFxcdGlmICggcXVldWVbIGluZGV4IF0gJiYgcXVldWVbIGluZGV4IF0uZmluaXNoICkge1xcblxcdFxcdFxcdFxcdFxcdHF1ZXVlWyBpbmRleCBdLmZpbmlzaC5jYWxsKCB0aGlzICk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBUdXJuIG9mZiBmaW5pc2hpbmcgZmxhZ1xcblxcdFxcdFxcdGRlbGV0ZSBkYXRhLmZpbmlzaDtcXG5cXHRcXHR9ICk7XFxuXFx0fVxcbn0gKTtcXG5cXG5qUXVlcnkuZWFjaCggWyBcXFwidG9nZ2xlXFxcIiwgXFxcInNob3dcXFwiLCBcXFwiaGlkZVxcXCIgXSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XFxuXFx0dmFyIGNzc0ZuID0galF1ZXJ5LmZuWyBuYW1lIF07XFxuXFx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XFxuXFx0XFx0cmV0dXJuIHNwZWVkID09IG51bGwgfHwgdHlwZW9mIHNwZWVkID09PSBcXFwiYm9vbGVhblxcXCIgP1xcblxcdFxcdFxcdGNzc0ZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSA6XFxuXFx0XFx0XFx0dGhpcy5hbmltYXRlKCBnZW5GeCggbmFtZSwgdHJ1ZSApLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xcblxcdH07XFxufSApO1xcblxcbi8vIEdlbmVyYXRlIHNob3J0Y3V0cyBmb3IgY3VzdG9tIGFuaW1hdGlvbnNcXG5qUXVlcnkuZWFjaCgge1xcblxcdHNsaWRlRG93bjogZ2VuRngoIFxcXCJzaG93XFxcIiApLFxcblxcdHNsaWRlVXA6IGdlbkZ4KCBcXFwiaGlkZVxcXCIgKSxcXG5cXHRzbGlkZVRvZ2dsZTogZ2VuRngoIFxcXCJ0b2dnbGVcXFwiICksXFxuXFx0ZmFkZUluOiB7IG9wYWNpdHk6IFxcXCJzaG93XFxcIiB9LFxcblxcdGZhZGVPdXQ6IHsgb3BhY2l0eTogXFxcImhpZGVcXFwiIH0sXFxuXFx0ZmFkZVRvZ2dsZTogeyBvcGFjaXR5OiBcXFwidG9nZ2xlXFxcIiB9XFxufSwgZnVuY3Rpb24oIG5hbWUsIHByb3BzICkge1xcblxcdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xcblxcdFxcdHJldHVybiB0aGlzLmFuaW1hdGUoIHByb3BzLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xcblxcdH07XFxufSApO1xcblxcbmpRdWVyeS50aW1lcnMgPSBbXTtcXG5qUXVlcnkuZngudGljayA9IGZ1bmN0aW9uKCkge1xcblxcdHZhciB0aW1lcixcXG5cXHRcXHRpID0gMCxcXG5cXHRcXHR0aW1lcnMgPSBqUXVlcnkudGltZXJzO1xcblxcblxcdGZ4Tm93ID0gRGF0ZS5ub3coKTtcXG5cXG5cXHRmb3IgKCA7IGkgPCB0aW1lcnMubGVuZ3RoOyBpKysgKSB7XFxuXFx0XFx0dGltZXIgPSB0aW1lcnNbIGkgXTtcXG5cXG5cXHRcXHQvLyBSdW4gdGhlIHRpbWVyIGFuZCBzYWZlbHkgcmVtb3ZlIGl0IHdoZW4gZG9uZSAoYWxsb3dpbmcgZm9yIGV4dGVybmFsIHJlbW92YWwpXFxuXFx0XFx0aWYgKCAhdGltZXIoKSAmJiB0aW1lcnNbIGkgXSA9PT0gdGltZXIgKSB7XFxuXFx0XFx0XFx0dGltZXJzLnNwbGljZSggaS0tLCAxICk7XFxuXFx0XFx0fVxcblxcdH1cXG5cXG5cXHRpZiAoICF0aW1lcnMubGVuZ3RoICkge1xcblxcdFxcdGpRdWVyeS5meC5zdG9wKCk7XFxuXFx0fVxcblxcdGZ4Tm93ID0gdW5kZWZpbmVkO1xcbn07XFxuXFxualF1ZXJ5LmZ4LnRpbWVyID0gZnVuY3Rpb24oIHRpbWVyICkge1xcblxcdGpRdWVyeS50aW1lcnMucHVzaCggdGltZXIgKTtcXG5cXHRqUXVlcnkuZnguc3RhcnQoKTtcXG59O1xcblxcbmpRdWVyeS5meC5pbnRlcnZhbCA9IDEzO1xcbmpRdWVyeS5meC5zdGFydCA9IGZ1bmN0aW9uKCkge1xcblxcdGlmICggaW5Qcm9ncmVzcyApIHtcXG5cXHRcXHRyZXR1cm47XFxuXFx0fVxcblxcblxcdGluUHJvZ3Jlc3MgPSB0cnVlO1xcblxcdHNjaGVkdWxlKCk7XFxufTtcXG5cXG5qUXVlcnkuZnguc3RvcCA9IGZ1bmN0aW9uKCkge1xcblxcdGluUHJvZ3Jlc3MgPSBudWxsO1xcbn07XFxuXFxualF1ZXJ5LmZ4LnNwZWVkcyA9IHtcXG5cXHRzbG93OiA2MDAsXFxuXFx0ZmFzdDogMjAwLFxcblxcblxcdC8vIERlZmF1bHQgc3BlZWRcXG5cXHRfZGVmYXVsdDogNDAwXFxufTtcXG5cXG5cXG4vLyBCYXNlZCBvZmYgb2YgdGhlIHBsdWdpbiBieSBDbGludCBIZWxmZXJzLCB3aXRoIHBlcm1pc3Npb24uXFxuLy8gaHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTAwMzI0MDE0NzQ3L2h0dHA6Ly9ibGluZHNpZ25hbHMuY29tL2luZGV4LnBocC8yMDA5LzA3L2pxdWVyeS1kZWxheS9cXG5qUXVlcnkuZm4uZGVsYXkgPSBmdW5jdGlvbiggdGltZSwgdHlwZSApIHtcXG5cXHR0aW1lID0galF1ZXJ5LmZ4ID8galF1ZXJ5LmZ4LnNwZWVkc1sgdGltZSBdIHx8IHRpbWUgOiB0aW1lO1xcblxcdHR5cGUgPSB0eXBlIHx8IFxcXCJmeFxcXCI7XFxuXFxuXFx0cmV0dXJuIHRoaXMucXVldWUoIHR5cGUsIGZ1bmN0aW9uKCBuZXh0LCBob29rcyApIHtcXG5cXHRcXHR2YXIgdGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KCBuZXh0LCB0aW1lICk7XFxuXFx0XFx0aG9va3Muc3RvcCA9IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdHdpbmRvdy5jbGVhclRpbWVvdXQoIHRpbWVvdXQgKTtcXG5cXHRcXHR9O1xcblxcdH0gKTtcXG59O1xcblxcblxcbiggZnVuY3Rpb24oKSB7XFxuXFx0dmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXFxcImlucHV0XFxcIiApLFxcblxcdFxcdHNlbGVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFxcXCJzZWxlY3RcXFwiICksXFxuXFx0XFx0b3B0ID0gc2VsZWN0LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcXFwib3B0aW9uXFxcIiApICk7XFxuXFxuXFx0aW5wdXQudHlwZSA9IFxcXCJjaGVja2JveFxcXCI7XFxuXFxuXFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMyBvbmx5XFxuXFx0Ly8gRGVmYXVsdCB2YWx1ZSBmb3IgYSBjaGVja2JveCBzaG91bGQgYmUgXFxcIm9uXFxcIlxcblxcdHN1cHBvcnQuY2hlY2tPbiA9IGlucHV0LnZhbHVlICE9PSBcXFwiXFxcIjtcXG5cXG5cXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcXG5cXHQvLyBNdXN0IGFjY2VzcyBzZWxlY3RlZEluZGV4IHRvIG1ha2UgZGVmYXVsdCBvcHRpb25zIHNlbGVjdFxcblxcdHN1cHBvcnQub3B0U2VsZWN0ZWQgPSBvcHQuc2VsZWN0ZWQ7XFxuXFxuXFx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XFxuXFx0Ly8gQW4gaW5wdXQgbG9zZXMgaXRzIHZhbHVlIGFmdGVyIGJlY29taW5nIGEgcmFkaW9cXG5cXHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFxcXCJpbnB1dFxcXCIgKTtcXG5cXHRpbnB1dC52YWx1ZSA9IFxcXCJ0XFxcIjtcXG5cXHRpbnB1dC50eXBlID0gXFxcInJhZGlvXFxcIjtcXG5cXHRzdXBwb3J0LnJhZGlvVmFsdWUgPSBpbnB1dC52YWx1ZSA9PT0gXFxcInRcXFwiO1xcbn0gKSgpO1xcblxcblxcbnZhciBib29sSG9vayxcXG5cXHRhdHRySGFuZGxlID0galF1ZXJ5LmV4cHIuYXR0ckhhbmRsZTtcXG5cXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XFxuXFx0YXR0cjogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xcblxcdFxcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGpRdWVyeS5hdHRyLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcXG5cXHR9LFxcblxcblxcdHJlbW92ZUF0dHI6IGZ1bmN0aW9uKCBuYW1lICkge1xcblxcdFxcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdGpRdWVyeS5yZW1vdmVBdHRyKCB0aGlzLCBuYW1lICk7XFxuXFx0XFx0fSApO1xcblxcdH1cXG59ICk7XFxuXFxualF1ZXJ5LmV4dGVuZCgge1xcblxcdGF0dHI6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcXG5cXHRcXHR2YXIgcmV0LCBob29rcyxcXG5cXHRcXHRcXHRuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XFxuXFxuXFx0XFx0Ly8gRG9uJ3QgZ2V0L3NldCBhdHRyaWJ1dGVzIG9uIHRleHQsIGNvbW1lbnQgYW5kIGF0dHJpYnV0ZSBub2Rlc1xcblxcdFxcdGlmICggblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIgKSB7XFxuXFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBGYWxsYmFjayB0byBwcm9wIHdoZW4gYXR0cmlidXRlcyBhcmUgbm90IHN1cHBvcnRlZFxcblxcdFxcdGlmICggdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlID09PSBcXFwidW5kZWZpbmVkXFxcIiApIHtcXG5cXHRcXHRcXHRyZXR1cm4galF1ZXJ5LnByb3AoIGVsZW0sIG5hbWUsIHZhbHVlICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIEF0dHJpYnV0ZSBob29rcyBhcmUgZGV0ZXJtaW5lZCBieSB0aGUgbG93ZXJjYXNlIHZlcnNpb25cXG5cXHRcXHQvLyBHcmFiIG5lY2Vzc2FyeSBob29rIGlmIG9uZSBpcyBkZWZpbmVkXFxuXFx0XFx0aWYgKCBuVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XFxuXFx0XFx0XFx0aG9va3MgPSBqUXVlcnkuYXR0ckhvb2tzWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSB8fFxcblxcdFxcdFxcdFxcdCggalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC50ZXN0KCBuYW1lICkgPyBib29sSG9vayA6IHVuZGVmaW5lZCApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XFxuXFx0XFx0XFx0aWYgKCB2YWx1ZSA9PT0gbnVsbCApIHtcXG5cXHRcXHRcXHRcXHRqUXVlcnkucmVtb3ZlQXR0ciggZWxlbSwgbmFtZSApO1xcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCBob29rcyAmJiBcXFwic2V0XFxcIiBpbiBob29rcyAmJlxcblxcdFxcdFxcdFxcdCggcmV0ID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApICkgIT09IHVuZGVmaW5lZCApIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gcmV0O1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgdmFsdWUgKyBcXFwiXFxcIiApO1xcblxcdFxcdFxcdHJldHVybiB2YWx1ZTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKCBob29rcyAmJiBcXFwiZ2V0XFxcIiBpbiBob29rcyAmJiAoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgbmFtZSApICkgIT09IG51bGwgKSB7XFxuXFx0XFx0XFx0cmV0dXJuIHJldDtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0ID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgbmFtZSApO1xcblxcblxcdFxcdC8vIE5vbi1leGlzdGVudCBhdHRyaWJ1dGVzIHJldHVybiBudWxsLCB3ZSBub3JtYWxpemUgdG8gdW5kZWZpbmVkXFxuXFx0XFx0cmV0dXJuIHJldCA9PSBudWxsID8gdW5kZWZpbmVkIDogcmV0O1xcblxcdH0sXFxuXFxuXFx0YXR0ckhvb2tzOiB7XFxuXFx0XFx0dHlwZToge1xcblxcdFxcdFxcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xcblxcdFxcdFxcdFxcdGlmICggIXN1cHBvcnQucmFkaW9WYWx1ZSAmJiB2YWx1ZSA9PT0gXFxcInJhZGlvXFxcIiAmJlxcblxcdFxcdFxcdFxcdFxcdG5vZGVOYW1lKCBlbGVtLCBcXFwiaW5wdXRcXFwiICkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIHZhbCA9IGVsZW0udmFsdWU7XFxuXFx0XFx0XFx0XFx0XFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIFxcXCJ0eXBlXFxcIiwgdmFsdWUgKTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHZhbCApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRlbGVtLnZhbHVlID0gdmFsO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gdmFsdWU7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fSxcXG5cXG5cXHRyZW1vdmVBdHRyOiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XFxuXFx0XFx0dmFyIG5hbWUsXFxuXFx0XFx0XFx0aSA9IDAsXFxuXFxuXFx0XFx0XFx0Ly8gQXR0cmlidXRlIG5hbWVzIGNhbiBjb250YWluIG5vbi1IVE1MIHdoaXRlc3BhY2UgY2hhcmFjdGVyc1xcblxcdFxcdFxcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2F0dHJpYnV0ZXMtMlxcblxcdFxcdFxcdGF0dHJOYW1lcyA9IHZhbHVlICYmIHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICk7XFxuXFxuXFx0XFx0aWYgKCBhdHRyTmFtZXMgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcXG5cXHRcXHRcXHR3aGlsZSAoICggbmFtZSA9IGF0dHJOYW1lc1sgaSsrIF0gKSApIHtcXG5cXHRcXHRcXHRcXHRlbGVtLnJlbW92ZUF0dHJpYnV0ZSggbmFtZSApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fVxcbn0gKTtcXG5cXG4vLyBIb29rcyBmb3IgYm9vbGVhbiBhdHRyaWJ1dGVzXFxuYm9vbEhvb2sgPSB7XFxuXFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUsIG5hbWUgKSB7XFxuXFx0XFx0aWYgKCB2YWx1ZSA9PT0gZmFsc2UgKSB7XFxuXFxuXFx0XFx0XFx0Ly8gUmVtb3ZlIGJvb2xlYW4gYXR0cmlidXRlcyB3aGVuIHNldCB0byBmYWxzZVxcblxcdFxcdFxcdGpRdWVyeS5yZW1vdmVBdHRyKCBlbGVtLCBuYW1lICk7XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgbmFtZSApO1xcblxcdFxcdH1cXG5cXHRcXHRyZXR1cm4gbmFtZTtcXG5cXHR9XFxufTtcXG5cXG5qUXVlcnkuZWFjaCggalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC5zb3VyY2UubWF0Y2goIC9cXFxcdysvZyApLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcXG5cXHR2YXIgZ2V0dGVyID0gYXR0ckhhbmRsZVsgbmFtZSBdIHx8IGpRdWVyeS5maW5kLmF0dHI7XFxuXFxuXFx0YXR0ckhhbmRsZVsgbmFtZSBdID0gZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xcblxcdFxcdHZhciByZXQsIGhhbmRsZSxcXG5cXHRcXHRcXHRsb3dlcmNhc2VOYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xcblxcblxcdFxcdGlmICggIWlzWE1MICkge1xcblxcblxcdFxcdFxcdC8vIEF2b2lkIGFuIGluZmluaXRlIGxvb3AgYnkgdGVtcG9yYXJpbHkgcmVtb3ZpbmcgdGhpcyBmdW5jdGlvbiBmcm9tIHRoZSBnZXR0ZXJcXG5cXHRcXHRcXHRoYW5kbGUgPSBhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF07XFxuXFx0XFx0XFx0YXR0ckhhbmRsZVsgbG93ZXJjYXNlTmFtZSBdID0gcmV0O1xcblxcdFxcdFxcdHJldCA9IGdldHRlciggZWxlbSwgbmFtZSwgaXNYTUwgKSAhPSBudWxsID9cXG5cXHRcXHRcXHRcXHRsb3dlcmNhc2VOYW1lIDpcXG5cXHRcXHRcXHRcXHRudWxsO1xcblxcdFxcdFxcdGF0dHJIYW5kbGVbIGxvd2VyY2FzZU5hbWUgXSA9IGhhbmRsZTtcXG5cXHRcXHR9XFxuXFx0XFx0cmV0dXJuIHJldDtcXG5cXHR9O1xcbn0gKTtcXG5cXG5cXG5cXG5cXG52YXIgcmZvY3VzYWJsZSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksXFxuXFx0cmNsaWNrYWJsZSA9IC9eKD86YXxhcmVhKSQvaTtcXG5cXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XFxuXFx0cHJvcDogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xcblxcdFxcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGpRdWVyeS5wcm9wLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcXG5cXHR9LFxcblxcblxcdHJlbW92ZVByb3A6IGZ1bmN0aW9uKCBuYW1lICkge1xcblxcdFxcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdGRlbGV0ZSB0aGlzWyBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWUgXTtcXG5cXHRcXHR9ICk7XFxuXFx0fVxcbn0gKTtcXG5cXG5qUXVlcnkuZXh0ZW5kKCB7XFxuXFx0cHJvcDogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xcblxcdFxcdHZhciByZXQsIGhvb2tzLFxcblxcdFxcdFxcdG5UeXBlID0gZWxlbS5ub2RlVHlwZTtcXG5cXG5cXHRcXHQvLyBEb24ndCBnZXQvc2V0IHByb3BlcnRpZXMgb24gdGV4dCwgY29tbWVudCBhbmQgYXR0cmlidXRlIG5vZGVzXFxuXFx0XFx0aWYgKCBuVHlwZSA9PT0gMyB8fCBuVHlwZSA9PT0gOCB8fCBuVHlwZSA9PT0gMiApIHtcXG5cXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICggblR5cGUgIT09IDEgfHwgIWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xcblxcblxcdFxcdFxcdC8vIEZpeCBuYW1lIGFuZCBhdHRhY2ggaG9va3NcXG5cXHRcXHRcXHRuYW1lID0galF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lO1xcblxcdFxcdFxcdGhvb2tzID0galF1ZXJ5LnByb3BIb29rc1sgbmFtZSBdO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XFxuXFx0XFx0XFx0aWYgKCBob29rcyAmJiBcXFwic2V0XFxcIiBpbiBob29rcyAmJlxcblxcdFxcdFxcdFxcdCggcmV0ID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApICkgIT09IHVuZGVmaW5lZCApIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gcmV0O1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gKCBlbGVtWyBuYW1lIF0gPSB2YWx1ZSApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAoIGhvb2tzICYmIFxcXCJnZXRcXFwiIGluIGhvb2tzICYmICggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBuYW1lICkgKSAhPT0gbnVsbCApIHtcXG5cXHRcXHRcXHRyZXR1cm4gcmV0O1xcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gZWxlbVsgbmFtZSBdO1xcblxcdH0sXFxuXFxuXFx0cHJvcEhvb2tzOiB7XFxuXFx0XFx0dGFiSW5kZXg6IHtcXG5cXHRcXHRcXHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xcblxcblxcdFxcdFxcdFxcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcXG5cXHRcXHRcXHRcXHQvLyBlbGVtLnRhYkluZGV4IGRvZXNuJ3QgYWx3YXlzIHJldHVybiB0aGVcXG5cXHRcXHRcXHRcXHQvLyBjb3JyZWN0IHZhbHVlIHdoZW4gaXQgaGFzbid0IGJlZW4gZXhwbGljaXRseSBzZXRcXG5cXHRcXHRcXHRcXHQvLyBodHRwczovL3dlYi5hcmNoaXZlLm9yZy93ZWIvMjAxNDExMTYyMzMzNDcvaHR0cDovL2ZsdWlkcHJvamVjdC5vcmcvYmxvZy8yMDA4LzAxLzA5L2dldHRpbmctc2V0dGluZy1hbmQtcmVtb3ZpbmctdGFiaW5kZXgtdmFsdWVzLXdpdGgtamF2YXNjcmlwdC9cXG5cXHRcXHRcXHRcXHQvLyBVc2UgcHJvcGVyIGF0dHJpYnV0ZSByZXRyaWV2YWwoIzEyMDcyKVxcblxcdFxcdFxcdFxcdHZhciB0YWJpbmRleCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIFxcXCJ0YWJpbmRleFxcXCIgKTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIHRhYmluZGV4ICkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBwYXJzZUludCggdGFiaW5kZXgsIDEwICk7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGlmIChcXG5cXHRcXHRcXHRcXHRcXHRyZm9jdXNhYmxlLnRlc3QoIGVsZW0ubm9kZU5hbWUgKSB8fFxcblxcdFxcdFxcdFxcdFxcdHJjbGlja2FibGUudGVzdCggZWxlbS5ub2RlTmFtZSApICYmXFxuXFx0XFx0XFx0XFx0XFx0ZWxlbS5ocmVmXFxuXFx0XFx0XFx0XFx0KSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIDA7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHJldHVybiAtMTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdH0sXFxuXFxuXFx0cHJvcEZpeDoge1xcblxcdFxcdFxcXCJmb3JcXFwiOiBcXFwiaHRtbEZvclxcXCIsXFxuXFx0XFx0XFxcImNsYXNzXFxcIjogXFxcImNsYXNzTmFtZVxcXCJcXG5cXHR9XFxufSApO1xcblxcbi8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxcbi8vIEFjY2Vzc2luZyB0aGUgc2VsZWN0ZWRJbmRleCBwcm9wZXJ0eVxcbi8vIGZvcmNlcyB0aGUgYnJvd3NlciB0byByZXNwZWN0IHNldHRpbmcgc2VsZWN0ZWRcXG4vLyBvbiB0aGUgb3B0aW9uXFxuLy8gVGhlIGdldHRlciBlbnN1cmVzIGEgZGVmYXVsdCBvcHRpb24gaXMgc2VsZWN0ZWRcXG4vLyB3aGVuIGluIGFuIG9wdGdyb3VwXFxuLy8gZXNsaW50IHJ1bGUgXFxcIm5vLXVudXNlZC1leHByZXNzaW9uc1xcXCIgaXMgZGlzYWJsZWQgZm9yIHRoaXMgY29kZVxcbi8vIHNpbmNlIGl0IGNvbnNpZGVycyBzdWNoIGFjY2Vzc2lvbnMgbm9vcFxcbmlmICggIXN1cHBvcnQub3B0U2VsZWN0ZWQgKSB7XFxuXFx0alF1ZXJ5LnByb3BIb29rcy5zZWxlY3RlZCA9IHtcXG5cXHRcXHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xcblxcblxcdFxcdFxcdC8qIGVzbGludCBuby11bnVzZWQtZXhwcmVzc2lvbnM6IFxcXCJvZmZcXFwiICovXFxuXFxuXFx0XFx0XFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcXG5cXHRcXHRcXHRpZiAoIHBhcmVudCAmJiBwYXJlbnQucGFyZW50Tm9kZSApIHtcXG5cXHRcXHRcXHRcXHRwYXJlbnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRyZXR1cm4gbnVsbDtcXG5cXHRcXHR9LFxcblxcdFxcdHNldDogZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFxuXFx0XFx0XFx0LyogZXNsaW50IG5vLXVudXNlZC1leHByZXNzaW9uczogXFxcIm9mZlxcXCIgKi9cXG5cXG5cXHRcXHRcXHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xcblxcdFxcdFxcdGlmICggcGFyZW50ICkge1xcblxcdFxcdFxcdFxcdHBhcmVudC5zZWxlY3RlZEluZGV4O1xcblxcblxcdFxcdFxcdFxcdGlmICggcGFyZW50LnBhcmVudE5vZGUgKSB7XFxuXFx0XFx0XFx0XFx0XFx0cGFyZW50LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9O1xcbn1cXG5cXG5qUXVlcnkuZWFjaCggW1xcblxcdFxcXCJ0YWJJbmRleFxcXCIsXFxuXFx0XFxcInJlYWRPbmx5XFxcIixcXG5cXHRcXFwibWF4TGVuZ3RoXFxcIixcXG5cXHRcXFwiY2VsbFNwYWNpbmdcXFwiLFxcblxcdFxcXCJjZWxsUGFkZGluZ1xcXCIsXFxuXFx0XFxcInJvd1NwYW5cXFwiLFxcblxcdFxcXCJjb2xTcGFuXFxcIixcXG5cXHRcXFwidXNlTWFwXFxcIixcXG5cXHRcXFwiZnJhbWVCb3JkZXJcXFwiLFxcblxcdFxcXCJjb250ZW50RWRpdGFibGVcXFwiXFxuXSwgZnVuY3Rpb24oKSB7XFxuXFx0alF1ZXJ5LnByb3BGaXhbIHRoaXMudG9Mb3dlckNhc2UoKSBdID0gdGhpcztcXG59ICk7XFxuXFxuXFxuXFxuXFxuXFx0Ly8gU3RyaXAgYW5kIGNvbGxhcHNlIHdoaXRlc3BhY2UgYWNjb3JkaW5nIHRvIEhUTUwgc3BlY1xcblxcdC8vIGh0dHBzOi8vaW5mcmEuc3BlYy53aGF0d2cub3JnLyNzdHJpcC1hbmQtY29sbGFwc2UtYXNjaWktd2hpdGVzcGFjZVxcblxcdGZ1bmN0aW9uIHN0cmlwQW5kQ29sbGFwc2UoIHZhbHVlICkge1xcblxcdFxcdHZhciB0b2tlbnMgPSB2YWx1ZS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xcblxcdFxcdHJldHVybiB0b2tlbnMuam9pbiggXFxcIiBcXFwiICk7XFxuXFx0fVxcblxcblxcbmZ1bmN0aW9uIGdldENsYXNzKCBlbGVtICkge1xcblxcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSAmJiBlbGVtLmdldEF0dHJpYnV0ZSggXFxcImNsYXNzXFxcIiApIHx8IFxcXCJcXFwiO1xcbn1cXG5cXG5mdW5jdGlvbiBjbGFzc2VzVG9BcnJheSggdmFsdWUgKSB7XFxuXFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWx1ZSApICkge1xcblxcdFxcdHJldHVybiB2YWx1ZTtcXG5cXHR9XFxuXFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFxcXCJzdHJpbmdcXFwiICkge1xcblxcdFxcdHJldHVybiB2YWx1ZS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xcblxcdH1cXG5cXHRyZXR1cm4gW107XFxufVxcblxcbmpRdWVyeS5mbi5leHRlbmQoIHtcXG5cXHRhZGRDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xcblxcdFxcdHZhciBjbGFzc2VzLCBlbGVtLCBjdXIsIGN1clZhbHVlLCBjbGF6eiwgaiwgZmluYWxWYWx1ZSxcXG5cXHRcXHRcXHRpID0gMDtcXG5cXG5cXHRcXHRpZiAoIGlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGogKSB7XFxuXFx0XFx0XFx0XFx0alF1ZXJ5KCB0aGlzICkuYWRkQ2xhc3MoIHZhbHVlLmNhbGwoIHRoaXMsIGosIGdldENsYXNzKCB0aGlzICkgKSApO1xcblxcdFxcdFxcdH0gKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Y2xhc3NlcyA9IGNsYXNzZXNUb0FycmF5KCB2YWx1ZSApO1xcblxcblxcdFxcdGlmICggY2xhc3Nlcy5sZW5ndGggKSB7XFxuXFx0XFx0XFx0d2hpbGUgKCAoIGVsZW0gPSB0aGlzWyBpKysgXSApICkge1xcblxcdFxcdFxcdFxcdGN1clZhbHVlID0gZ2V0Q2xhc3MoIGVsZW0gKTtcXG5cXHRcXHRcXHRcXHRjdXIgPSBlbGVtLm5vZGVUeXBlID09PSAxICYmICggXFxcIiBcXFwiICsgc3RyaXBBbmRDb2xsYXBzZSggY3VyVmFsdWUgKSArIFxcXCIgXFxcIiApO1xcblxcblxcdFxcdFxcdFxcdGlmICggY3VyICkge1xcblxcdFxcdFxcdFxcdFxcdGogPSAwO1xcblxcdFxcdFxcdFxcdFxcdHdoaWxlICggKCBjbGF6eiA9IGNsYXNzZXNbIGorKyBdICkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBjdXIuaW5kZXhPZiggXFxcIiBcXFwiICsgY2xhenogKyBcXFwiIFxcXCIgKSA8IDAgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Y3VyICs9IGNsYXp6ICsgXFxcIiBcXFwiO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gT25seSBhc3NpZ24gaWYgZGlmZmVyZW50IHRvIGF2b2lkIHVubmVlZGVkIHJlbmRlcmluZy5cXG5cXHRcXHRcXHRcXHRcXHRmaW5hbFZhbHVlID0gc3RyaXBBbmRDb2xsYXBzZSggY3VyICk7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBjdXJWYWx1ZSAhPT0gZmluYWxWYWx1ZSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRlbGVtLnNldEF0dHJpYnV0ZSggXFxcImNsYXNzXFxcIiwgZmluYWxWYWx1ZSApO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gdGhpcztcXG5cXHR9LFxcblxcblxcdHJlbW92ZUNsYXNzOiBmdW5jdGlvbiggdmFsdWUgKSB7XFxuXFx0XFx0dmFyIGNsYXNzZXMsIGVsZW0sIGN1ciwgY3VyVmFsdWUsIGNsYXp6LCBqLCBmaW5hbFZhbHVlLFxcblxcdFxcdFxcdGkgPSAwO1xcblxcblxcdFxcdGlmICggaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaiApIHtcXG5cXHRcXHRcXHRcXHRqUXVlcnkoIHRoaXMgKS5yZW1vdmVDbGFzcyggdmFsdWUuY2FsbCggdGhpcywgaiwgZ2V0Q2xhc3MoIHRoaXMgKSApICk7XFxuXFx0XFx0XFx0fSApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAoICFhcmd1bWVudHMubGVuZ3RoICkge1xcblxcdFxcdFxcdHJldHVybiB0aGlzLmF0dHIoIFxcXCJjbGFzc1xcXCIsIFxcXCJcXFwiICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdGNsYXNzZXMgPSBjbGFzc2VzVG9BcnJheSggdmFsdWUgKTtcXG5cXG5cXHRcXHRpZiAoIGNsYXNzZXMubGVuZ3RoICkge1xcblxcdFxcdFxcdHdoaWxlICggKCBlbGVtID0gdGhpc1sgaSsrIF0gKSApIHtcXG5cXHRcXHRcXHRcXHRjdXJWYWx1ZSA9IGdldENsYXNzKCBlbGVtICk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gVGhpcyBleHByZXNzaW9uIGlzIGhlcmUgZm9yIGJldHRlciBjb21wcmVzc2liaWxpdHkgKHNlZSBhZGRDbGFzcylcXG5cXHRcXHRcXHRcXHRjdXIgPSBlbGVtLm5vZGVUeXBlID09PSAxICYmICggXFxcIiBcXFwiICsgc3RyaXBBbmRDb2xsYXBzZSggY3VyVmFsdWUgKSArIFxcXCIgXFxcIiApO1xcblxcblxcdFxcdFxcdFxcdGlmICggY3VyICkge1xcblxcdFxcdFxcdFxcdFxcdGogPSAwO1xcblxcdFxcdFxcdFxcdFxcdHdoaWxlICggKCBjbGF6eiA9IGNsYXNzZXNbIGorKyBdICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gUmVtb3ZlICphbGwqIGluc3RhbmNlc1xcblxcdFxcdFxcdFxcdFxcdFxcdHdoaWxlICggY3VyLmluZGV4T2YoIFxcXCIgXFxcIiArIGNsYXp6ICsgXFxcIiBcXFwiICkgPiAtMSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRjdXIgPSBjdXIucmVwbGFjZSggXFxcIiBcXFwiICsgY2xhenogKyBcXFwiIFxcXCIsIFxcXCIgXFxcIiApO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gT25seSBhc3NpZ24gaWYgZGlmZmVyZW50IHRvIGF2b2lkIHVubmVlZGVkIHJlbmRlcmluZy5cXG5cXHRcXHRcXHRcXHRcXHRmaW5hbFZhbHVlID0gc3RyaXBBbmRDb2xsYXBzZSggY3VyICk7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBjdXJWYWx1ZSAhPT0gZmluYWxWYWx1ZSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRlbGVtLnNldEF0dHJpYnV0ZSggXFxcImNsYXNzXFxcIiwgZmluYWxWYWx1ZSApO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gdGhpcztcXG5cXHR9LFxcblxcblxcdHRvZ2dsZUNsYXNzOiBmdW5jdGlvbiggdmFsdWUsIHN0YXRlVmFsICkge1xcblxcdFxcdHZhciB0eXBlID0gdHlwZW9mIHZhbHVlLFxcblxcdFxcdFxcdGlzVmFsaWRWYWx1ZSA9IHR5cGUgPT09IFxcXCJzdHJpbmdcXFwiIHx8IEFycmF5LmlzQXJyYXkoIHZhbHVlICk7XFxuXFxuXFx0XFx0aWYgKCB0eXBlb2Ygc3RhdGVWYWwgPT09IFxcXCJib29sZWFuXFxcIiAmJiBpc1ZhbGlkVmFsdWUgKSB7XFxuXFx0XFx0XFx0cmV0dXJuIHN0YXRlVmFsID8gdGhpcy5hZGRDbGFzcyggdmFsdWUgKSA6IHRoaXMucmVtb3ZlQ2xhc3MoIHZhbHVlICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICggaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcXG5cXHRcXHRcXHRcXHRqUXVlcnkoIHRoaXMgKS50b2dnbGVDbGFzcyhcXG5cXHRcXHRcXHRcXHRcXHR2YWx1ZS5jYWxsKCB0aGlzLCBpLCBnZXRDbGFzcyggdGhpcyApLCBzdGF0ZVZhbCApLFxcblxcdFxcdFxcdFxcdFxcdHN0YXRlVmFsXFxuXFx0XFx0XFx0XFx0KTtcXG5cXHRcXHRcXHR9ICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdHZhciBjbGFzc05hbWUsIGksIHNlbGYsIGNsYXNzTmFtZXM7XFxuXFxuXFx0XFx0XFx0aWYgKCBpc1ZhbGlkVmFsdWUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gVG9nZ2xlIGluZGl2aWR1YWwgY2xhc3MgbmFtZXNcXG5cXHRcXHRcXHRcXHRpID0gMDtcXG5cXHRcXHRcXHRcXHRzZWxmID0galF1ZXJ5KCB0aGlzICk7XFxuXFx0XFx0XFx0XFx0Y2xhc3NOYW1lcyA9IGNsYXNzZXNUb0FycmF5KCB2YWx1ZSApO1xcblxcblxcdFxcdFxcdFxcdHdoaWxlICggKCBjbGFzc05hbWUgPSBjbGFzc05hbWVzWyBpKysgXSApICkge1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIENoZWNrIGVhY2ggY2xhc3NOYW1lIGdpdmVuLCBzcGFjZSBzZXBhcmF0ZWQgbGlzdFxcblxcdFxcdFxcdFxcdFxcdGlmICggc2VsZi5oYXNDbGFzcyggY2xhc3NOYW1lICkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0c2VsZi5yZW1vdmVDbGFzcyggY2xhc3NOYW1lICk7XFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRzZWxmLmFkZENsYXNzKCBjbGFzc05hbWUgKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIFRvZ2dsZSB3aG9sZSBjbGFzcyBuYW1lXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB0eXBlID09PSBcXFwiYm9vbGVhblxcXCIgKSB7XFxuXFx0XFx0XFx0XFx0Y2xhc3NOYW1lID0gZ2V0Q2xhc3MoIHRoaXMgKTtcXG5cXHRcXHRcXHRcXHRpZiAoIGNsYXNzTmFtZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBTdG9yZSBjbGFzc05hbWUgaWYgc2V0XFxuXFx0XFx0XFx0XFx0XFx0ZGF0YVByaXYuc2V0KCB0aGlzLCBcXFwiX19jbGFzc05hbWVfX1xcXCIsIGNsYXNzTmFtZSApO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBJZiB0aGUgZWxlbWVudCBoYXMgYSBjbGFzcyBuYW1lIG9yIGlmIHdlJ3JlIHBhc3NlZCBgZmFsc2VgLFxcblxcdFxcdFxcdFxcdC8vIHRoZW4gcmVtb3ZlIHRoZSB3aG9sZSBjbGFzc25hbWUgKGlmIHRoZXJlIHdhcyBvbmUsIHRoZSBhYm92ZSBzYXZlZCBpdCkuXFxuXFx0XFx0XFx0XFx0Ly8gT3RoZXJ3aXNlIGJyaW5nIGJhY2sgd2hhdGV2ZXIgd2FzIHByZXZpb3VzbHkgc2F2ZWQgKGlmIGFueXRoaW5nKSxcXG5cXHRcXHRcXHRcXHQvLyBmYWxsaW5nIGJhY2sgdG8gdGhlIGVtcHR5IHN0cmluZyBpZiBub3RoaW5nIHdhcyBzdG9yZWQuXFxuXFx0XFx0XFx0XFx0aWYgKCB0aGlzLnNldEF0dHJpYnV0ZSApIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnNldEF0dHJpYnV0ZSggXFxcImNsYXNzXFxcIixcXG5cXHRcXHRcXHRcXHRcXHRcXHRjbGFzc05hbWUgfHwgdmFsdWUgPT09IGZhbHNlID9cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXFwiXFxcIiA6XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZGF0YVByaXYuZ2V0KCB0aGlzLCBcXFwiX19jbGFzc05hbWVfX1xcXCIgKSB8fCBcXFwiXFxcIlxcblxcdFxcdFxcdFxcdFxcdCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9ICk7XFxuXFx0fSxcXG5cXG5cXHRoYXNDbGFzczogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xcblxcdFxcdHZhciBjbGFzc05hbWUsIGVsZW0sXFxuXFx0XFx0XFx0aSA9IDA7XFxuXFxuXFx0XFx0Y2xhc3NOYW1lID0gXFxcIiBcXFwiICsgc2VsZWN0b3IgKyBcXFwiIFxcXCI7XFxuXFx0XFx0d2hpbGUgKCAoIGVsZW0gPSB0aGlzWyBpKysgXSApICkge1xcblxcdFxcdFxcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSAmJlxcblxcdFxcdFxcdFxcdCggXFxcIiBcXFwiICsgc3RyaXBBbmRDb2xsYXBzZSggZ2V0Q2xhc3MoIGVsZW0gKSApICsgXFxcIiBcXFwiICkuaW5kZXhPZiggY2xhc3NOYW1lICkgPiAtMSApIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHR9XFxufSApO1xcblxcblxcblxcblxcbnZhciBycmV0dXJuID0gL1xcXFxyL2c7XFxuXFxualF1ZXJ5LmZuLmV4dGVuZCgge1xcblxcdHZhbDogZnVuY3Rpb24oIHZhbHVlICkge1xcblxcdFxcdHZhciBob29rcywgcmV0LCB2YWx1ZUlzRnVuY3Rpb24sXFxuXFx0XFx0XFx0ZWxlbSA9IHRoaXNbIDAgXTtcXG5cXG5cXHRcXHRpZiAoICFhcmd1bWVudHMubGVuZ3RoICkge1xcblxcdFxcdFxcdGlmICggZWxlbSApIHtcXG5cXHRcXHRcXHRcXHRob29rcyA9IGpRdWVyeS52YWxIb29rc1sgZWxlbS50eXBlIF0gfHxcXG5cXHRcXHRcXHRcXHRcXHRqUXVlcnkudmFsSG9va3NbIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xcblxcblxcdFxcdFxcdFxcdGlmICggaG9va3MgJiZcXG5cXHRcXHRcXHRcXHRcXHRcXFwiZ2V0XFxcIiBpbiBob29rcyAmJlxcblxcdFxcdFxcdFxcdFxcdCggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBcXFwidmFsdWVcXFwiICkgKSAhPT0gdW5kZWZpbmVkXFxuXFx0XFx0XFx0XFx0KSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHJldDtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0cmV0ID0gZWxlbS52YWx1ZTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBIYW5kbGUgbW9zdCBjb21tb24gc3RyaW5nIGNhc2VzXFxuXFx0XFx0XFx0XFx0aWYgKCB0eXBlb2YgcmV0ID09PSBcXFwic3RyaW5nXFxcIiApIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gcmV0LnJlcGxhY2UoIHJyZXR1cm4sIFxcXCJcXFwiICk7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIEhhbmRsZSBjYXNlcyB3aGVyZSB2YWx1ZSBpcyBudWxsL3VuZGVmIG9yIG51bWJlclxcblxcdFxcdFxcdFxcdHJldHVybiByZXQgPT0gbnVsbCA/IFxcXCJcXFwiIDogcmV0O1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0fVxcblxcblxcdFxcdHZhbHVlSXNGdW5jdGlvbiA9IGlzRnVuY3Rpb24oIHZhbHVlICk7XFxuXFxuXFx0XFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XFxuXFx0XFx0XFx0dmFyIHZhbDtcXG5cXG5cXHRcXHRcXHRpZiAoIHRoaXMubm9kZVR5cGUgIT09IDEgKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIHZhbHVlSXNGdW5jdGlvbiApIHtcXG5cXHRcXHRcXHRcXHR2YWwgPSB2YWx1ZS5jYWxsKCB0aGlzLCBpLCBqUXVlcnkoIHRoaXMgKS52YWwoKSApO1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0dmFsID0gdmFsdWU7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIFRyZWF0IG51bGwvdW5kZWZpbmVkIGFzIFxcXCJcXFwiOyBjb252ZXJ0IG51bWJlcnMgdG8gc3RyaW5nXFxuXFx0XFx0XFx0aWYgKCB2YWwgPT0gbnVsbCApIHtcXG5cXHRcXHRcXHRcXHR2YWwgPSBcXFwiXFxcIjtcXG5cXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCB0eXBlb2YgdmFsID09PSBcXFwibnVtYmVyXFxcIiApIHtcXG5cXHRcXHRcXHRcXHR2YWwgKz0gXFxcIlxcXCI7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggQXJyYXkuaXNBcnJheSggdmFsICkgKSB7XFxuXFx0XFx0XFx0XFx0dmFsID0galF1ZXJ5Lm1hcCggdmFsLCBmdW5jdGlvbiggdmFsdWUgKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHZhbHVlID09IG51bGwgPyBcXFwiXFxcIiA6IHZhbHVlICsgXFxcIlxcXCI7XFxuXFx0XFx0XFx0XFx0fSApO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRob29rcyA9IGpRdWVyeS52YWxIb29rc1sgdGhpcy50eXBlIF0gfHwgalF1ZXJ5LnZhbEhvb2tzWyB0aGlzLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgXTtcXG5cXG5cXHRcXHRcXHQvLyBJZiBzZXQgcmV0dXJucyB1bmRlZmluZWQsIGZhbGwgYmFjayB0byBub3JtYWwgc2V0dGluZ1xcblxcdFxcdFxcdGlmICggIWhvb2tzIHx8ICEoIFxcXCJzZXRcXFwiIGluIGhvb2tzICkgfHwgaG9va3Muc2V0KCB0aGlzLCB2YWwsIFxcXCJ2YWx1ZVxcXCIgKSA9PT0gdW5kZWZpbmVkICkge1xcblxcdFxcdFxcdFxcdHRoaXMudmFsdWUgPSB2YWw7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0gKTtcXG5cXHR9XFxufSApO1xcblxcbmpRdWVyeS5leHRlbmQoIHtcXG5cXHR2YWxIb29rczoge1xcblxcdFxcdG9wdGlvbjoge1xcblxcdFxcdFxcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHZhbCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIFxcXCJ2YWx1ZVxcXCIgKTtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdmFsICE9IG51bGwgP1xcblxcdFxcdFxcdFxcdFxcdHZhbCA6XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gU3VwcG9ydDogSUUgPD0xMCAtIDExIG9ubHlcXG5cXHRcXHRcXHRcXHRcXHQvLyBvcHRpb24udGV4dCB0aHJvd3MgZXhjZXB0aW9ucyAoIzE0Njg2LCAjMTQ4NTgpXFxuXFx0XFx0XFx0XFx0XFx0Ly8gU3RyaXAgYW5kIGNvbGxhcHNlIHdoaXRlc3BhY2VcXG5cXHRcXHRcXHRcXHRcXHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnLyNzdHJpcC1hbmQtY29sbGFwc2Utd2hpdGVzcGFjZVxcblxcdFxcdFxcdFxcdFxcdHN0cmlwQW5kQ29sbGFwc2UoIGpRdWVyeS50ZXh0KCBlbGVtICkgKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXHRcXHRzZWxlY3Q6IHtcXG5cXHRcXHRcXHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdFxcdFxcdHZhciB2YWx1ZSwgb3B0aW9uLCBpLFxcblxcdFxcdFxcdFxcdFxcdG9wdGlvbnMgPSBlbGVtLm9wdGlvbnMsXFxuXFx0XFx0XFx0XFx0XFx0aW5kZXggPSBlbGVtLnNlbGVjdGVkSW5kZXgsXFxuXFx0XFx0XFx0XFx0XFx0b25lID0gZWxlbS50eXBlID09PSBcXFwic2VsZWN0LW9uZVxcXCIsXFxuXFx0XFx0XFx0XFx0XFx0dmFsdWVzID0gb25lID8gbnVsbCA6IFtdLFxcblxcdFxcdFxcdFxcdFxcdG1heCA9IG9uZSA/IGluZGV4ICsgMSA6IG9wdGlvbnMubGVuZ3RoO1xcblxcblxcdFxcdFxcdFxcdGlmICggaW5kZXggPCAwICkge1xcblxcdFxcdFxcdFxcdFxcdGkgPSBtYXg7XFxuXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRpID0gb25lID8gaW5kZXggOiAwO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBMb29wIHRocm91Z2ggYWxsIHRoZSBzZWxlY3RlZCBvcHRpb25zXFxuXFx0XFx0XFx0XFx0Zm9yICggOyBpIDwgbWF4OyBpKysgKSB7XFxuXFx0XFx0XFx0XFx0XFx0b3B0aW9uID0gb3B0aW9uc1sgaSBdO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XFxuXFx0XFx0XFx0XFx0XFx0Ly8gSUU4LTkgZG9lc24ndCB1cGRhdGUgc2VsZWN0ZWQgYWZ0ZXIgZm9ybSByZXNldCAoIzI1NTEpXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCAoIG9wdGlvbi5zZWxlY3RlZCB8fCBpID09PSBpbmRleCApICYmXFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gRG9uJ3QgcmV0dXJuIG9wdGlvbnMgdGhhdCBhcmUgZGlzYWJsZWQgb3IgaW4gYSBkaXNhYmxlZCBvcHRncm91cFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdCFvcHRpb24uZGlzYWJsZWQgJiZcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQoICFvcHRpb24ucGFyZW50Tm9kZS5kaXNhYmxlZCB8fFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdCFub2RlTmFtZSggb3B0aW9uLnBhcmVudE5vZGUsIFxcXCJvcHRncm91cFxcXCIgKSApICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIEdldCB0aGUgc3BlY2lmaWMgdmFsdWUgZm9yIHRoZSBvcHRpb25cXG5cXHRcXHRcXHRcXHRcXHRcXHR2YWx1ZSA9IGpRdWVyeSggb3B0aW9uICkudmFsKCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gV2UgZG9uJ3QgbmVlZCBhbiBhcnJheSBmb3Igb25lIHNlbGVjdHNcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIG9uZSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gdmFsdWU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIE11bHRpLVNlbGVjdHMgcmV0dXJuIGFuIGFycmF5XFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFsdWVzLnB1c2goIHZhbHVlICk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdmFsdWVzO1xcblxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XFxuXFx0XFx0XFx0XFx0dmFyIG9wdGlvblNldCwgb3B0aW9uLFxcblxcdFxcdFxcdFxcdFxcdG9wdGlvbnMgPSBlbGVtLm9wdGlvbnMsXFxuXFx0XFx0XFx0XFx0XFx0dmFsdWVzID0galF1ZXJ5Lm1ha2VBcnJheSggdmFsdWUgKSxcXG5cXHRcXHRcXHRcXHRcXHRpID0gb3B0aW9ucy5sZW5ndGg7XFxuXFxuXFx0XFx0XFx0XFx0d2hpbGUgKCBpLS0gKSB7XFxuXFx0XFx0XFx0XFx0XFx0b3B0aW9uID0gb3B0aW9uc1sgaSBdO1xcblxcblxcdFxcdFxcdFxcdFxcdC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbmQtYXNzaWduICovXFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBvcHRpb24uc2VsZWN0ZWQgPVxcblxcdFxcdFxcdFxcdFxcdFxcdGpRdWVyeS5pbkFycmF5KCBqUXVlcnkudmFsSG9va3Mub3B0aW9uLmdldCggb3B0aW9uICksIHZhbHVlcyApID4gLTFcXG5cXHRcXHRcXHRcXHRcXHQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRvcHRpb25TZXQgPSB0cnVlO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHQvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbmQtYXNzaWduICovXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIEZvcmNlIGJyb3dzZXJzIHRvIGJlaGF2ZSBjb25zaXN0ZW50bHkgd2hlbiBub24tbWF0Y2hpbmcgdmFsdWUgaXMgc2V0XFxuXFx0XFx0XFx0XFx0aWYgKCAhb3B0aW9uU2V0ICkge1xcblxcdFxcdFxcdFxcdFxcdGVsZW0uc2VsZWN0ZWRJbmRleCA9IC0xO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdmFsdWVzO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fVxcbn0gKTtcXG5cXG4vLyBSYWRpb3MgYW5kIGNoZWNrYm94ZXMgZ2V0dGVyL3NldHRlclxcbmpRdWVyeS5lYWNoKCBbIFxcXCJyYWRpb1xcXCIsIFxcXCJjaGVja2JveFxcXCIgXSwgZnVuY3Rpb24oKSB7XFxuXFx0alF1ZXJ5LnZhbEhvb2tzWyB0aGlzIF0gPSB7XFxuXFx0XFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XFxuXFx0XFx0XFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWx1ZSApICkge1xcblxcdFxcdFxcdFxcdHJldHVybiAoIGVsZW0uY2hlY2tlZCA9IGpRdWVyeS5pbkFycmF5KCBqUXVlcnkoIGVsZW0gKS52YWwoKSwgdmFsdWUgKSA+IC0xICk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9O1xcblxcdGlmICggIXN1cHBvcnQuY2hlY2tPbiApIHtcXG5cXHRcXHRqUXVlcnkudmFsSG9va3NbIHRoaXMgXS5nZXQgPSBmdW5jdGlvbiggZWxlbSApIHtcXG5cXHRcXHRcXHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoIFxcXCJ2YWx1ZVxcXCIgKSA9PT0gbnVsbCA/IFxcXCJvblxcXCIgOiBlbGVtLnZhbHVlO1xcblxcdFxcdH07XFxuXFx0fVxcbn0gKTtcXG5cXG5cXG5cXG5cXG4vLyBSZXR1cm4galF1ZXJ5IGZvciBhdHRyaWJ1dGVzLW9ubHkgaW5jbHVzaW9uXFxuXFxuXFxuc3VwcG9ydC5mb2N1c2luID0gXFxcIm9uZm9jdXNpblxcXCIgaW4gd2luZG93O1xcblxcblxcbnZhciByZm9jdXNNb3JwaCA9IC9eKD86Zm9jdXNpbmZvY3VzfGZvY3Vzb3V0Ymx1cikkLyxcXG5cXHRzdG9wUHJvcGFnYXRpb25DYWxsYmFjayA9IGZ1bmN0aW9uKCBlICkge1xcblxcdFxcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XFxuXFx0fTtcXG5cXG5qUXVlcnkuZXh0ZW5kKCBqUXVlcnkuZXZlbnQsIHtcXG5cXG5cXHR0cmlnZ2VyOiBmdW5jdGlvbiggZXZlbnQsIGRhdGEsIGVsZW0sIG9ubHlIYW5kbGVycyApIHtcXG5cXG5cXHRcXHR2YXIgaSwgY3VyLCB0bXAsIGJ1YmJsZVR5cGUsIG9udHlwZSwgaGFuZGxlLCBzcGVjaWFsLCBsYXN0RWxlbWVudCxcXG5cXHRcXHRcXHRldmVudFBhdGggPSBbIGVsZW0gfHwgZG9jdW1lbnQgXSxcXG5cXHRcXHRcXHR0eXBlID0gaGFzT3duLmNhbGwoIGV2ZW50LCBcXFwidHlwZVxcXCIgKSA/IGV2ZW50LnR5cGUgOiBldmVudCxcXG5cXHRcXHRcXHRuYW1lc3BhY2VzID0gaGFzT3duLmNhbGwoIGV2ZW50LCBcXFwibmFtZXNwYWNlXFxcIiApID8gZXZlbnQubmFtZXNwYWNlLnNwbGl0KCBcXFwiLlxcXCIgKSA6IFtdO1xcblxcblxcdFxcdGN1ciA9IGxhc3RFbGVtZW50ID0gdG1wID0gZWxlbSA9IGVsZW0gfHwgZG9jdW1lbnQ7XFxuXFxuXFx0XFx0Ly8gRG9uJ3QgZG8gZXZlbnRzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcXG5cXHRcXHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCApIHtcXG5cXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIGZvY3VzL2JsdXIgbW9ycGhzIHRvIGZvY3VzaW4vb3V0OyBlbnN1cmUgd2UncmUgbm90IGZpcmluZyB0aGVtIHJpZ2h0IG5vd1xcblxcdFxcdGlmICggcmZvY3VzTW9ycGgudGVzdCggdHlwZSArIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgKSApIHtcXG5cXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICggdHlwZS5pbmRleE9mKCBcXFwiLlxcXCIgKSA+IC0xICkge1xcblxcblxcdFxcdFxcdC8vIE5hbWVzcGFjZWQgdHJpZ2dlcjsgY3JlYXRlIGEgcmVnZXhwIHRvIG1hdGNoIGV2ZW50IHR5cGUgaW4gaGFuZGxlKClcXG5cXHRcXHRcXHRuYW1lc3BhY2VzID0gdHlwZS5zcGxpdCggXFxcIi5cXFwiICk7XFxuXFx0XFx0XFx0dHlwZSA9IG5hbWVzcGFjZXMuc2hpZnQoKTtcXG5cXHRcXHRcXHRuYW1lc3BhY2VzLnNvcnQoKTtcXG5cXHRcXHR9XFxuXFx0XFx0b250eXBlID0gdHlwZS5pbmRleE9mKCBcXFwiOlxcXCIgKSA8IDAgJiYgXFxcIm9uXFxcIiArIHR5cGU7XFxuXFxuXFx0XFx0Ly8gQ2FsbGVyIGNhbiBwYXNzIGluIGEgalF1ZXJ5LkV2ZW50IG9iamVjdCwgT2JqZWN0LCBvciBqdXN0IGFuIGV2ZW50IHR5cGUgc3RyaW5nXFxuXFx0XFx0ZXZlbnQgPSBldmVudFsgalF1ZXJ5LmV4cGFuZG8gXSA/XFxuXFx0XFx0XFx0ZXZlbnQgOlxcblxcdFxcdFxcdG5ldyBqUXVlcnkuRXZlbnQoIHR5cGUsIHR5cGVvZiBldmVudCA9PT0gXFxcIm9iamVjdFxcXCIgJiYgZXZlbnQgKTtcXG5cXG5cXHRcXHQvLyBUcmlnZ2VyIGJpdG1hc2s6ICYgMSBmb3IgbmF0aXZlIGhhbmRsZXJzOyAmIDIgZm9yIGpRdWVyeSAoYWx3YXlzIHRydWUpXFxuXFx0XFx0ZXZlbnQuaXNUcmlnZ2VyID0gb25seUhhbmRsZXJzID8gMiA6IDM7XFxuXFx0XFx0ZXZlbnQubmFtZXNwYWNlID0gbmFtZXNwYWNlcy5qb2luKCBcXFwiLlxcXCIgKTtcXG5cXHRcXHRldmVudC5ybmFtZXNwYWNlID0gZXZlbnQubmFtZXNwYWNlID9cXG5cXHRcXHRcXHRuZXcgUmVnRXhwKCBcXFwiKF58XFxcXFxcXFwuKVxcXCIgKyBuYW1lc3BhY2VzLmpvaW4oIFxcXCJcXFxcXFxcXC4oPzouKlxcXFxcXFxcLnwpXFxcIiApICsgXFxcIihcXFxcXFxcXC58JClcXFwiICkgOlxcblxcdFxcdFxcdG51bGw7XFxuXFxuXFx0XFx0Ly8gQ2xlYW4gdXAgdGhlIGV2ZW50IGluIGNhc2UgaXQgaXMgYmVpbmcgcmV1c2VkXFxuXFx0XFx0ZXZlbnQucmVzdWx0ID0gdW5kZWZpbmVkO1xcblxcdFxcdGlmICggIWV2ZW50LnRhcmdldCApIHtcXG5cXHRcXHRcXHRldmVudC50YXJnZXQgPSBlbGVtO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBDbG9uZSBhbnkgaW5jb21pbmcgZGF0YSBhbmQgcHJlcGVuZCB0aGUgZXZlbnQsIGNyZWF0aW5nIHRoZSBoYW5kbGVyIGFyZyBsaXN0XFxuXFx0XFx0ZGF0YSA9IGRhdGEgPT0gbnVsbCA/XFxuXFx0XFx0XFx0WyBldmVudCBdIDpcXG5cXHRcXHRcXHRqUXVlcnkubWFrZUFycmF5KCBkYXRhLCBbIGV2ZW50IF0gKTtcXG5cXG5cXHRcXHQvLyBBbGxvdyBzcGVjaWFsIGV2ZW50cyB0byBkcmF3IG91dHNpZGUgdGhlIGxpbmVzXFxuXFx0XFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XFxuXFx0XFx0aWYgKCAhb25seUhhbmRsZXJzICYmIHNwZWNpYWwudHJpZ2dlciAmJiBzcGVjaWFsLnRyaWdnZXIuYXBwbHkoIGVsZW0sIGRhdGEgKSA9PT0gZmFsc2UgKSB7XFxuXFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBEZXRlcm1pbmUgZXZlbnQgcHJvcGFnYXRpb24gcGF0aCBpbiBhZHZhbmNlLCBwZXIgVzNDIGV2ZW50cyBzcGVjICgjOTk1MSlcXG5cXHRcXHQvLyBCdWJibGUgdXAgdG8gZG9jdW1lbnQsIHRoZW4gdG8gd2luZG93OyB3YXRjaCBmb3IgYSBnbG9iYWwgb3duZXJEb2N1bWVudCB2YXIgKCM5NzI0KVxcblxcdFxcdGlmICggIW9ubHlIYW5kbGVycyAmJiAhc3BlY2lhbC5ub0J1YmJsZSAmJiAhaXNXaW5kb3coIGVsZW0gKSApIHtcXG5cXG5cXHRcXHRcXHRidWJibGVUeXBlID0gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgfHwgdHlwZTtcXG5cXHRcXHRcXHRpZiAoICFyZm9jdXNNb3JwaC50ZXN0KCBidWJibGVUeXBlICsgdHlwZSApICkge1xcblxcdFxcdFxcdFxcdGN1ciA9IGN1ci5wYXJlbnROb2RlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRmb3IgKCA7IGN1cjsgY3VyID0gY3VyLnBhcmVudE5vZGUgKSB7XFxuXFx0XFx0XFx0XFx0ZXZlbnRQYXRoLnB1c2goIGN1ciApO1xcblxcdFxcdFxcdFxcdHRtcCA9IGN1cjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gT25seSBhZGQgd2luZG93IGlmIHdlIGdvdCB0byBkb2N1bWVudCAoZS5nLiwgbm90IHBsYWluIG9iaiBvciBkZXRhY2hlZCBET00pXFxuXFx0XFx0XFx0aWYgKCB0bXAgPT09ICggZWxlbS5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50ICkgKSB7XFxuXFx0XFx0XFx0XFx0ZXZlbnRQYXRoLnB1c2goIHRtcC5kZWZhdWx0VmlldyB8fCB0bXAucGFyZW50V2luZG93IHx8IHdpbmRvdyApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gRmlyZSBoYW5kbGVycyBvbiB0aGUgZXZlbnQgcGF0aFxcblxcdFxcdGkgPSAwO1xcblxcdFxcdHdoaWxlICggKCBjdXIgPSBldmVudFBhdGhbIGkrKyBdICkgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XFxuXFx0XFx0XFx0bGFzdEVsZW1lbnQgPSBjdXI7XFxuXFx0XFx0XFx0ZXZlbnQudHlwZSA9IGkgPiAxID9cXG5cXHRcXHRcXHRcXHRidWJibGVUeXBlIDpcXG5cXHRcXHRcXHRcXHRzcGVjaWFsLmJpbmRUeXBlIHx8IHR5cGU7XFxuXFxuXFx0XFx0XFx0Ly8galF1ZXJ5IGhhbmRsZXJcXG5cXHRcXHRcXHRoYW5kbGUgPSAoIGRhdGFQcml2LmdldCggY3VyLCBcXFwiZXZlbnRzXFxcIiApIHx8IHt9IClbIGV2ZW50LnR5cGUgXSAmJlxcblxcdFxcdFxcdFxcdGRhdGFQcml2LmdldCggY3VyLCBcXFwiaGFuZGxlXFxcIiApO1xcblxcdFxcdFxcdGlmICggaGFuZGxlICkge1xcblxcdFxcdFxcdFxcdGhhbmRsZS5hcHBseSggY3VyLCBkYXRhICk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIE5hdGl2ZSBoYW5kbGVyXFxuXFx0XFx0XFx0aGFuZGxlID0gb250eXBlICYmIGN1clsgb250eXBlIF07XFxuXFx0XFx0XFx0aWYgKCBoYW5kbGUgJiYgaGFuZGxlLmFwcGx5ICYmIGFjY2VwdERhdGEoIGN1ciApICkge1xcblxcdFxcdFxcdFxcdGV2ZW50LnJlc3VsdCA9IGhhbmRsZS5hcHBseSggY3VyLCBkYXRhICk7XFxuXFx0XFx0XFx0XFx0aWYgKCBldmVudC5yZXN1bHQgPT09IGZhbHNlICkge1xcblxcdFxcdFxcdFxcdFxcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0XFx0ZXZlbnQudHlwZSA9IHR5cGU7XFxuXFxuXFx0XFx0Ly8gSWYgbm9ib2R5IHByZXZlbnRlZCB0aGUgZGVmYXVsdCBhY3Rpb24sIGRvIGl0IG5vd1xcblxcdFxcdGlmICggIW9ubHlIYW5kbGVycyAmJiAhZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCAoICFzcGVjaWFsLl9kZWZhdWx0IHx8XFxuXFx0XFx0XFx0XFx0c3BlY2lhbC5fZGVmYXVsdC5hcHBseSggZXZlbnRQYXRoLnBvcCgpLCBkYXRhICkgPT09IGZhbHNlICkgJiZcXG5cXHRcXHRcXHRcXHRhY2NlcHREYXRhKCBlbGVtICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gQ2FsbCBhIG5hdGl2ZSBET00gbWV0aG9kIG9uIHRoZSB0YXJnZXQgd2l0aCB0aGUgc2FtZSBuYW1lIGFzIHRoZSBldmVudC5cXG5cXHRcXHRcXHRcXHQvLyBEb24ndCBkbyBkZWZhdWx0IGFjdGlvbnMgb24gd2luZG93LCB0aGF0J3Mgd2hlcmUgZ2xvYmFsIHZhcmlhYmxlcyBiZSAoIzYxNzApXFxuXFx0XFx0XFx0XFx0aWYgKCBvbnR5cGUgJiYgaXNGdW5jdGlvbiggZWxlbVsgdHlwZSBdICkgJiYgIWlzV2luZG93KCBlbGVtICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gRG9uJ3QgcmUtdHJpZ2dlciBhbiBvbkZPTyBldmVudCB3aGVuIHdlIGNhbGwgaXRzIEZPTygpIG1ldGhvZFxcblxcdFxcdFxcdFxcdFxcdHRtcCA9IGVsZW1bIG9udHlwZSBdO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggdG1wICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGVsZW1bIG9udHlwZSBdID0gbnVsbDtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gUHJldmVudCByZS10cmlnZ2VyaW5nIG9mIHRoZSBzYW1lIGV2ZW50LCBzaW5jZSB3ZSBhbHJlYWR5IGJ1YmJsZWQgaXQgYWJvdmVcXG5cXHRcXHRcXHRcXHRcXHRqUXVlcnkuZXZlbnQudHJpZ2dlcmVkID0gdHlwZTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0bGFzdEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggdHlwZSwgc3RvcFByb3BhZ2F0aW9uQ2FsbGJhY2sgKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0ZWxlbVsgdHlwZSBdKCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGxhc3RFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoIHR5cGUsIHN0b3BQcm9wYWdhdGlvbkNhbGxiYWNrICk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB1bmRlZmluZWQ7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCB0bXAgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZWxlbVsgb250eXBlIF0gPSB0bXA7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiBldmVudC5yZXN1bHQ7XFxuXFx0fSxcXG5cXG5cXHQvLyBQaWdneWJhY2sgb24gYSBkb25vciBldmVudCB0byBzaW11bGF0ZSBhIGRpZmZlcmVudCBvbmVcXG5cXHQvLyBVc2VkIG9ubHkgZm9yIGBmb2N1cyhpbiB8IG91dClgIGV2ZW50c1xcblxcdHNpbXVsYXRlOiBmdW5jdGlvbiggdHlwZSwgZWxlbSwgZXZlbnQgKSB7XFxuXFx0XFx0dmFyIGUgPSBqUXVlcnkuZXh0ZW5kKFxcblxcdFxcdFxcdG5ldyBqUXVlcnkuRXZlbnQoKSxcXG5cXHRcXHRcXHRldmVudCxcXG5cXHRcXHRcXHR7XFxuXFx0XFx0XFx0XFx0dHlwZTogdHlwZSxcXG5cXHRcXHRcXHRcXHRpc1NpbXVsYXRlZDogdHJ1ZVxcblxcdFxcdFxcdH1cXG5cXHRcXHQpO1xcblxcblxcdFxcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBlLCBudWxsLCBlbGVtICk7XFxuXFx0fVxcblxcbn0gKTtcXG5cXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XFxuXFxuXFx0dHJpZ2dlcjogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XFxuXFx0XFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIHRoaXMgKTtcXG5cXHRcXHR9ICk7XFxuXFx0fSxcXG5cXHR0cmlnZ2VySGFuZGxlcjogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XFxuXFx0XFx0dmFyIGVsZW0gPSB0aGlzWyAwIF07XFxuXFx0XFx0aWYgKCBlbGVtICkge1xcblxcdFxcdFxcdHJldHVybiBqUXVlcnkuZXZlbnQudHJpZ2dlciggdHlwZSwgZGF0YSwgZWxlbSwgdHJ1ZSApO1xcblxcdFxcdH1cXG5cXHR9XFxufSApO1xcblxcblxcbi8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00NFxcbi8vIEZpcmVmb3ggZG9lc24ndCBoYXZlIGZvY3VzKGluIHwgb3V0KSBldmVudHNcXG4vLyBSZWxhdGVkIHRpY2tldCAtIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY4Nzc4N1xcbi8vXFxuLy8gU3VwcG9ydDogQ2hyb21lIDw9NDggLSA0OSwgU2FmYXJpIDw9OS4wIC0gOS4xXFxuLy8gZm9jdXMoaW4gfCBvdXQpIGV2ZW50cyBmaXJlIGFmdGVyIGZvY3VzICYgYmx1ciBldmVudHMsXFxuLy8gd2hpY2ggaXMgc3BlYyB2aW9sYXRpb24gLSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50cy1mb2N1c2V2ZW50LWV2ZW50LW9yZGVyXFxuLy8gUmVsYXRlZCB0aWNrZXQgLSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NDk4NTdcXG5pZiAoICFzdXBwb3J0LmZvY3VzaW4gKSB7XFxuXFx0alF1ZXJ5LmVhY2goIHsgZm9jdXM6IFxcXCJmb2N1c2luXFxcIiwgYmx1cjogXFxcImZvY3Vzb3V0XFxcIiB9LCBmdW5jdGlvbiggb3JpZywgZml4ICkge1xcblxcblxcdFxcdC8vIEF0dGFjaCBhIHNpbmdsZSBjYXB0dXJpbmcgaGFuZGxlciBvbiB0aGUgZG9jdW1lbnQgd2hpbGUgc29tZW9uZSB3YW50cyBmb2N1c2luL2ZvY3Vzb3V0XFxuXFx0XFx0dmFyIGhhbmRsZXIgPSBmdW5jdGlvbiggZXZlbnQgKSB7XFxuXFx0XFx0XFx0alF1ZXJ5LmV2ZW50LnNpbXVsYXRlKCBmaXgsIGV2ZW50LnRhcmdldCwgalF1ZXJ5LmV2ZW50LmZpeCggZXZlbnQgKSApO1xcblxcdFxcdH07XFxuXFxuXFx0XFx0alF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGZpeCBdID0ge1xcblxcdFxcdFxcdHNldHVwOiBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHR2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMsXFxuXFx0XFx0XFx0XFx0XFx0YXR0YWNoZXMgPSBkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4ICk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCAhYXR0YWNoZXMgKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZG9jLmFkZEV2ZW50TGlzdGVuZXIoIG9yaWcsIGhhbmRsZXIsIHRydWUgKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0ZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCwgKCBhdHRhY2hlcyB8fCAwICkgKyAxICk7XFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHR0ZWFyZG93bjogZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0dmFyIGRvYyA9IHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzLFxcblxcdFxcdFxcdFxcdFxcdGF0dGFjaGVzID0gZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCApIC0gMTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoICFhdHRhY2hlcyApIHtcXG5cXHRcXHRcXHRcXHRcXHRkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lciggb3JpZywgaGFuZGxlciwgdHJ1ZSApO1xcblxcdFxcdFxcdFxcdFxcdGRhdGFQcml2LnJlbW92ZSggZG9jLCBmaXggKTtcXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXgsIGF0dGFjaGVzICk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9O1xcblxcdH0gKTtcXG59XFxudmFyIGxvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uO1xcblxcbnZhciBub25jZSA9IERhdGUubm93KCk7XFxuXFxudmFyIHJxdWVyeSA9ICggL1xcXFw/LyApO1xcblxcblxcblxcbi8vIENyb3NzLWJyb3dzZXIgeG1sIHBhcnNpbmdcXG5qUXVlcnkucGFyc2VYTUwgPSBmdW5jdGlvbiggZGF0YSApIHtcXG5cXHR2YXIgeG1sO1xcblxcdGlmICggIWRhdGEgfHwgdHlwZW9mIGRhdGEgIT09IFxcXCJzdHJpbmdcXFwiICkge1xcblxcdFxcdHJldHVybiBudWxsO1xcblxcdH1cXG5cXG5cXHQvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seVxcblxcdC8vIElFIHRocm93cyBvbiBwYXJzZUZyb21TdHJpbmcgd2l0aCBpbnZhbGlkIGlucHV0LlxcblxcdHRyeSB7XFxuXFx0XFx0eG1sID0gKCBuZXcgd2luZG93LkRPTVBhcnNlcigpICkucGFyc2VGcm9tU3RyaW5nKCBkYXRhLCBcXFwidGV4dC94bWxcXFwiICk7XFxuXFx0fSBjYXRjaCAoIGUgKSB7XFxuXFx0XFx0eG1sID0gdW5kZWZpbmVkO1xcblxcdH1cXG5cXG5cXHRpZiAoICF4bWwgfHwgeG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCBcXFwicGFyc2VyZXJyb3JcXFwiICkubGVuZ3RoICkge1xcblxcdFxcdGpRdWVyeS5lcnJvciggXFxcIkludmFsaWQgWE1MOiBcXFwiICsgZGF0YSApO1xcblxcdH1cXG5cXHRyZXR1cm4geG1sO1xcbn07XFxuXFxuXFxudmFyXFxuXFx0cmJyYWNrZXQgPSAvXFxcXFtcXFxcXSQvLFxcblxcdHJDUkxGID0gL1xcXFxyP1xcXFxuL2csXFxuXFx0cnN1Ym1pdHRlclR5cGVzID0gL14oPzpzdWJtaXR8YnV0dG9ufGltYWdlfHJlc2V0fGZpbGUpJC9pLFxcblxcdHJzdWJtaXR0YWJsZSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGtleWdlbikvaTtcXG5cXG5mdW5jdGlvbiBidWlsZFBhcmFtcyggcHJlZml4LCBvYmosIHRyYWRpdGlvbmFsLCBhZGQgKSB7XFxuXFx0dmFyIG5hbWU7XFxuXFxuXFx0aWYgKCBBcnJheS5pc0FycmF5KCBvYmogKSApIHtcXG5cXG5cXHRcXHQvLyBTZXJpYWxpemUgYXJyYXkgaXRlbS5cXG5cXHRcXHRqUXVlcnkuZWFjaCggb2JqLCBmdW5jdGlvbiggaSwgdiApIHtcXG5cXHRcXHRcXHRpZiAoIHRyYWRpdGlvbmFsIHx8IHJicmFja2V0LnRlc3QoIHByZWZpeCApICkge1xcblxcblxcdFxcdFxcdFxcdC8vIFRyZWF0IGVhY2ggYXJyYXkgaXRlbSBhcyBhIHNjYWxhci5cXG5cXHRcXHRcXHRcXHRhZGQoIHByZWZpeCwgdiApO1xcblxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gSXRlbSBpcyBub24tc2NhbGFyIChhcnJheSBvciBvYmplY3QpLCBlbmNvZGUgaXRzIG51bWVyaWMgaW5kZXguXFxuXFx0XFx0XFx0XFx0YnVpbGRQYXJhbXMoXFxuXFx0XFx0XFx0XFx0XFx0cHJlZml4ICsgXFxcIltcXFwiICsgKCB0eXBlb2YgdiA9PT0gXFxcIm9iamVjdFxcXCIgJiYgdiAhPSBudWxsID8gaSA6IFxcXCJcXFwiICkgKyBcXFwiXVxcXCIsXFxuXFx0XFx0XFx0XFx0XFx0dixcXG5cXHRcXHRcXHRcXHRcXHR0cmFkaXRpb25hbCxcXG5cXHRcXHRcXHRcXHRcXHRhZGRcXG5cXHRcXHRcXHRcXHQpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9ICk7XFxuXFxuXFx0fSBlbHNlIGlmICggIXRyYWRpdGlvbmFsICYmIHRvVHlwZSggb2JqICkgPT09IFxcXCJvYmplY3RcXFwiICkge1xcblxcblxcdFxcdC8vIFNlcmlhbGl6ZSBvYmplY3QgaXRlbS5cXG5cXHRcXHRmb3IgKCBuYW1lIGluIG9iaiApIHtcXG5cXHRcXHRcXHRidWlsZFBhcmFtcyggcHJlZml4ICsgXFxcIltcXFwiICsgbmFtZSArIFxcXCJdXFxcIiwgb2JqWyBuYW1lIF0sIHRyYWRpdGlvbmFsLCBhZGQgKTtcXG5cXHRcXHR9XFxuXFxuXFx0fSBlbHNlIHtcXG5cXG5cXHRcXHQvLyBTZXJpYWxpemUgc2NhbGFyIGl0ZW0uXFxuXFx0XFx0YWRkKCBwcmVmaXgsIG9iaiApO1xcblxcdH1cXG59XFxuXFxuLy8gU2VyaWFsaXplIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMgb3IgYSBzZXQgb2ZcXG4vLyBrZXkvdmFsdWVzIGludG8gYSBxdWVyeSBzdHJpbmdcXG5qUXVlcnkucGFyYW0gPSBmdW5jdGlvbiggYSwgdHJhZGl0aW9uYWwgKSB7XFxuXFx0dmFyIHByZWZpeCxcXG5cXHRcXHRzID0gW10sXFxuXFx0XFx0YWRkID0gZnVuY3Rpb24oIGtleSwgdmFsdWVPckZ1bmN0aW9uICkge1xcblxcblxcdFxcdFxcdC8vIElmIHZhbHVlIGlzIGEgZnVuY3Rpb24sIGludm9rZSBpdCBhbmQgdXNlIGl0cyByZXR1cm4gdmFsdWVcXG5cXHRcXHRcXHR2YXIgdmFsdWUgPSBpc0Z1bmN0aW9uKCB2YWx1ZU9yRnVuY3Rpb24gKSA/XFxuXFx0XFx0XFx0XFx0dmFsdWVPckZ1bmN0aW9uKCkgOlxcblxcdFxcdFxcdFxcdHZhbHVlT3JGdW5jdGlvbjtcXG5cXG5cXHRcXHRcXHRzWyBzLmxlbmd0aCBdID0gZW5jb2RlVVJJQ29tcG9uZW50KCBrZXkgKSArIFxcXCI9XFxcIiArXFxuXFx0XFx0XFx0XFx0ZW5jb2RlVVJJQ29tcG9uZW50KCB2YWx1ZSA9PSBudWxsID8gXFxcIlxcXCIgOiB2YWx1ZSApO1xcblxcdFxcdH07XFxuXFxuXFx0Ly8gSWYgYW4gYXJyYXkgd2FzIHBhc3NlZCBpbiwgYXNzdW1lIHRoYXQgaXQgaXMgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cy5cXG5cXHRpZiAoIEFycmF5LmlzQXJyYXkoIGEgKSB8fCAoIGEuanF1ZXJ5ICYmICFqUXVlcnkuaXNQbGFpbk9iamVjdCggYSApICkgKSB7XFxuXFxuXFx0XFx0Ly8gU2VyaWFsaXplIHRoZSBmb3JtIGVsZW1lbnRzXFxuXFx0XFx0alF1ZXJ5LmVhY2goIGEsIGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdGFkZCggdGhpcy5uYW1lLCB0aGlzLnZhbHVlICk7XFxuXFx0XFx0fSApO1xcblxcblxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0Ly8gSWYgdHJhZGl0aW9uYWwsIGVuY29kZSB0aGUgXFxcIm9sZFxcXCIgd2F5ICh0aGUgd2F5IDEuMy4yIG9yIG9sZGVyXFxuXFx0XFx0Ly8gZGlkIGl0KSwgb3RoZXJ3aXNlIGVuY29kZSBwYXJhbXMgcmVjdXJzaXZlbHkuXFxuXFx0XFx0Zm9yICggcHJlZml4IGluIGEgKSB7XFxuXFx0XFx0XFx0YnVpbGRQYXJhbXMoIHByZWZpeCwgYVsgcHJlZml4IF0sIHRyYWRpdGlvbmFsLCBhZGQgKTtcXG5cXHRcXHR9XFxuXFx0fVxcblxcblxcdC8vIFJldHVybiB0aGUgcmVzdWx0aW5nIHNlcmlhbGl6YXRpb25cXG5cXHRyZXR1cm4gcy5qb2luKCBcXFwiJlxcXCIgKTtcXG59O1xcblxcbmpRdWVyeS5mbi5leHRlbmQoIHtcXG5cXHRzZXJpYWxpemU6IGZ1bmN0aW9uKCkge1xcblxcdFxcdHJldHVybiBqUXVlcnkucGFyYW0oIHRoaXMuc2VyaWFsaXplQXJyYXkoKSApO1xcblxcdH0sXFxuXFx0c2VyaWFsaXplQXJyYXk6IGZ1bmN0aW9uKCkge1xcblxcdFxcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XFxuXFxuXFx0XFx0XFx0Ly8gQ2FuIGFkZCBwcm9wSG9vayBmb3IgXFxcImVsZW1lbnRzXFxcIiB0byBmaWx0ZXIgb3IgYWRkIGZvcm0gZWxlbWVudHNcXG5cXHRcXHRcXHR2YXIgZWxlbWVudHMgPSBqUXVlcnkucHJvcCggdGhpcywgXFxcImVsZW1lbnRzXFxcIiApO1xcblxcdFxcdFxcdHJldHVybiBlbGVtZW50cyA/IGpRdWVyeS5tYWtlQXJyYXkoIGVsZW1lbnRzICkgOiB0aGlzO1xcblxcdFxcdH0gKVxcblxcdFxcdC5maWx0ZXIoIGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdHZhciB0eXBlID0gdGhpcy50eXBlO1xcblxcblxcdFxcdFxcdC8vIFVzZSAuaXMoIFxcXCI6ZGlzYWJsZWRcXFwiICkgc28gdGhhdCBmaWVsZHNldFtkaXNhYmxlZF0gd29ya3NcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5uYW1lICYmICFqUXVlcnkoIHRoaXMgKS5pcyggXFxcIjpkaXNhYmxlZFxcXCIgKSAmJlxcblxcdFxcdFxcdFxcdHJzdWJtaXR0YWJsZS50ZXN0KCB0aGlzLm5vZGVOYW1lICkgJiYgIXJzdWJtaXR0ZXJUeXBlcy50ZXN0KCB0eXBlICkgJiZcXG5cXHRcXHRcXHRcXHQoIHRoaXMuY2hlY2tlZCB8fCAhcmNoZWNrYWJsZVR5cGUudGVzdCggdHlwZSApICk7XFxuXFx0XFx0fSApXFxuXFx0XFx0Lm1hcCggZnVuY3Rpb24oIGksIGVsZW0gKSB7XFxuXFx0XFx0XFx0dmFyIHZhbCA9IGpRdWVyeSggdGhpcyApLnZhbCgpO1xcblxcblxcdFxcdFxcdGlmICggdmFsID09IG51bGwgKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIG51bGw7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggQXJyYXkuaXNBcnJheSggdmFsICkgKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGpRdWVyeS5tYXAoIHZhbCwgZnVuY3Rpb24oIHZhbCApIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4geyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZSggckNSTEYsIFxcXCJcXFxcclxcXFxuXFxcIiApIH07XFxuXFx0XFx0XFx0XFx0fSApO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4geyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZSggckNSTEYsIFxcXCJcXFxcclxcXFxuXFxcIiApIH07XFxuXFx0XFx0fSApLmdldCgpO1xcblxcdH1cXG59ICk7XFxuXFxuXFxudmFyXFxuXFx0cjIwID0gLyUyMC9nLFxcblxcdHJoYXNoID0gLyMuKiQvLFxcblxcdHJhbnRpQ2FjaGUgPSAvKFs/Jl0pXz1bXiZdKi8sXFxuXFx0cmhlYWRlcnMgPSAvXiguKj8pOlsgXFxcXHRdKihbXlxcXFxyXFxcXG5dKikkL21nLFxcblxcblxcdC8vICM3NjUzLCAjODEyNSwgIzgxNTI6IGxvY2FsIHByb3RvY29sIGRldGVjdGlvblxcblxcdHJsb2NhbFByb3RvY29sID0gL14oPzphYm91dHxhcHB8YXBwLXN0b3JhZ2V8ListZXh0ZW5zaW9ufGZpbGV8cmVzfHdpZGdldCk6JC8sXFxuXFx0cm5vQ29udGVudCA9IC9eKD86R0VUfEhFQUQpJC8sXFxuXFx0cnByb3RvY29sID0gL15cXFxcL1xcXFwvLyxcXG5cXG5cXHQvKiBQcmVmaWx0ZXJzXFxuXFx0ICogMSkgVGhleSBhcmUgdXNlZnVsIHRvIGludHJvZHVjZSBjdXN0b20gZGF0YVR5cGVzIChzZWUgYWpheC9qc29ucC5qcyBmb3IgYW4gZXhhbXBsZSlcXG5cXHQgKiAyKSBUaGVzZSBhcmUgY2FsbGVkOlxcblxcdCAqICAgIC0gQkVGT1JFIGFza2luZyBmb3IgYSB0cmFuc3BvcnRcXG5cXHQgKiAgICAtIEFGVEVSIHBhcmFtIHNlcmlhbGl6YXRpb24gKHMuZGF0YSBpcyBhIHN0cmluZyBpZiBzLnByb2Nlc3NEYXRhIGlzIHRydWUpXFxuXFx0ICogMykga2V5IGlzIHRoZSBkYXRhVHlwZVxcblxcdCAqIDQpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXFxcIipcXFwiIGNhbiBiZSB1c2VkXFxuXFx0ICogNSkgZXhlY3V0aW9uIHdpbGwgc3RhcnQgd2l0aCB0cmFuc3BvcnQgZGF0YVR5cGUgYW5kIFRIRU4gY29udGludWUgZG93biB0byBcXFwiKlxcXCIgaWYgbmVlZGVkXFxuXFx0ICovXFxuXFx0cHJlZmlsdGVycyA9IHt9LFxcblxcblxcdC8qIFRyYW5zcG9ydHMgYmluZGluZ3NcXG5cXHQgKiAxKSBrZXkgaXMgdGhlIGRhdGFUeXBlXFxuXFx0ICogMikgdGhlIGNhdGNoYWxsIHN5bWJvbCBcXFwiKlxcXCIgY2FuIGJlIHVzZWRcXG5cXHQgKiAzKSBzZWxlY3Rpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBnbyB0byBcXFwiKlxcXCIgaWYgbmVlZGVkXFxuXFx0ICovXFxuXFx0dHJhbnNwb3J0cyA9IHt9LFxcblxcblxcdC8vIEF2b2lkIGNvbW1lbnQtcHJvbG9nIGNoYXIgc2VxdWVuY2UgKCMxMDA5OCk7IG11c3QgYXBwZWFzZSBsaW50IGFuZCBldmFkZSBjb21wcmVzc2lvblxcblxcdGFsbFR5cGVzID0gXFxcIiovXFxcIi5jb25jYXQoIFxcXCIqXFxcIiApLFxcblxcblxcdC8vIEFuY2hvciB0YWcgZm9yIHBhcnNpbmcgdGhlIGRvY3VtZW50IG9yaWdpblxcblxcdG9yaWdpbkFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFxcXCJhXFxcIiApO1xcblxcdG9yaWdpbkFuY2hvci5ocmVmID0gbG9jYXRpb24uaHJlZjtcXG5cXG4vLyBCYXNlIFxcXCJjb25zdHJ1Y3RvclxcXCIgZm9yIGpRdWVyeS5hamF4UHJlZmlsdGVyIGFuZCBqUXVlcnkuYWpheFRyYW5zcG9ydFxcbmZ1bmN0aW9uIGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggc3RydWN0dXJlICkge1xcblxcblxcdC8vIGRhdGFUeXBlRXhwcmVzc2lvbiBpcyBvcHRpb25hbCBhbmQgZGVmYXVsdHMgdG8gXFxcIipcXFwiXFxuXFx0cmV0dXJuIGZ1bmN0aW9uKCBkYXRhVHlwZUV4cHJlc3Npb24sIGZ1bmMgKSB7XFxuXFxuXFx0XFx0aWYgKCB0eXBlb2YgZGF0YVR5cGVFeHByZXNzaW9uICE9PSBcXFwic3RyaW5nXFxcIiApIHtcXG5cXHRcXHRcXHRmdW5jID0gZGF0YVR5cGVFeHByZXNzaW9uO1xcblxcdFxcdFxcdGRhdGFUeXBlRXhwcmVzc2lvbiA9IFxcXCIqXFxcIjtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0dmFyIGRhdGFUeXBlLFxcblxcdFxcdFxcdGkgPSAwLFxcblxcdFxcdFxcdGRhdGFUeXBlcyA9IGRhdGFUeXBlRXhwcmVzc2lvbi50b0xvd2VyQ2FzZSgpLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW107XFxuXFxuXFx0XFx0aWYgKCBpc0Z1bmN0aW9uKCBmdW5jICkgKSB7XFxuXFxuXFx0XFx0XFx0Ly8gRm9yIGVhY2ggZGF0YVR5cGUgaW4gdGhlIGRhdGFUeXBlRXhwcmVzc2lvblxcblxcdFxcdFxcdHdoaWxlICggKCBkYXRhVHlwZSA9IGRhdGFUeXBlc1sgaSsrIF0gKSApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBQcmVwZW5kIGlmIHJlcXVlc3RlZFxcblxcdFxcdFxcdFxcdGlmICggZGF0YVR5cGVbIDAgXSA9PT0gXFxcIitcXFwiICkge1xcblxcdFxcdFxcdFxcdFxcdGRhdGFUeXBlID0gZGF0YVR5cGUuc2xpY2UoIDEgKSB8fCBcXFwiKlxcXCI7XFxuXFx0XFx0XFx0XFx0XFx0KCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gPSBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10gKS51bnNoaWZ0KCBmdW5jICk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gT3RoZXJ3aXNlIGFwcGVuZFxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0KCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gPSBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10gKS5wdXNoKCBmdW5jICk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fTtcXG59XFxuXFxuLy8gQmFzZSBpbnNwZWN0aW9uIGZ1bmN0aW9uIGZvciBwcmVmaWx0ZXJzIGFuZCB0cmFuc3BvcnRzXFxuZnVuY3Rpb24gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSwgb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUiApIHtcXG5cXG5cXHR2YXIgaW5zcGVjdGVkID0ge30sXFxuXFx0XFx0c2Vla2luZ1RyYW5zcG9ydCA9ICggc3RydWN0dXJlID09PSB0cmFuc3BvcnRzICk7XFxuXFxuXFx0ZnVuY3Rpb24gaW5zcGVjdCggZGF0YVR5cGUgKSB7XFxuXFx0XFx0dmFyIHNlbGVjdGVkO1xcblxcdFxcdGluc3BlY3RlZFsgZGF0YVR5cGUgXSA9IHRydWU7XFxuXFx0XFx0alF1ZXJ5LmVhY2goIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSwgZnVuY3Rpb24oIF8sIHByZWZpbHRlck9yRmFjdG9yeSApIHtcXG5cXHRcXHRcXHR2YXIgZGF0YVR5cGVPclRyYW5zcG9ydCA9IHByZWZpbHRlck9yRmFjdG9yeSggb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUiApO1xcblxcdFxcdFxcdGlmICggdHlwZW9mIGRhdGFUeXBlT3JUcmFuc3BvcnQgPT09IFxcXCJzdHJpbmdcXFwiICYmXFxuXFx0XFx0XFx0XFx0IXNlZWtpbmdUcmFuc3BvcnQgJiYgIWluc3BlY3RlZFsgZGF0YVR5cGVPclRyYW5zcG9ydCBdICkge1xcblxcblxcdFxcdFxcdFxcdG9wdGlvbnMuZGF0YVR5cGVzLnVuc2hpZnQoIGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcXG5cXHRcXHRcXHRcXHRpbnNwZWN0KCBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH0gZWxzZSBpZiAoIHNlZWtpbmdUcmFuc3BvcnQgKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuICEoIHNlbGVjdGVkID0gZGF0YVR5cGVPclRyYW5zcG9ydCApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9ICk7XFxuXFx0XFx0cmV0dXJuIHNlbGVjdGVkO1xcblxcdH1cXG5cXG5cXHRyZXR1cm4gaW5zcGVjdCggb3B0aW9ucy5kYXRhVHlwZXNbIDAgXSApIHx8ICFpbnNwZWN0ZWRbIFxcXCIqXFxcIiBdICYmIGluc3BlY3QoIFxcXCIqXFxcIiApO1xcbn1cXG5cXG4vLyBBIHNwZWNpYWwgZXh0ZW5kIGZvciBhamF4IG9wdGlvbnNcXG4vLyB0aGF0IHRha2VzIFxcXCJmbGF0XFxcIiBvcHRpb25zIChub3QgdG8gYmUgZGVlcCBleHRlbmRlZClcXG4vLyBGaXhlcyAjOTg4N1xcbmZ1bmN0aW9uIGFqYXhFeHRlbmQoIHRhcmdldCwgc3JjICkge1xcblxcdHZhciBrZXksIGRlZXAsXFxuXFx0XFx0ZmxhdE9wdGlvbnMgPSBqUXVlcnkuYWpheFNldHRpbmdzLmZsYXRPcHRpb25zIHx8IHt9O1xcblxcblxcdGZvciAoIGtleSBpbiBzcmMgKSB7XFxuXFx0XFx0aWYgKCBzcmNbIGtleSBdICE9PSB1bmRlZmluZWQgKSB7XFxuXFx0XFx0XFx0KCBmbGF0T3B0aW9uc1sga2V5IF0gPyB0YXJnZXQgOiAoIGRlZXAgfHwgKCBkZWVwID0ge30gKSApIClbIGtleSBdID0gc3JjWyBrZXkgXTtcXG5cXHRcXHR9XFxuXFx0fVxcblxcdGlmICggZGVlcCApIHtcXG5cXHRcXHRqUXVlcnkuZXh0ZW5kKCB0cnVlLCB0YXJnZXQsIGRlZXAgKTtcXG5cXHR9XFxuXFxuXFx0cmV0dXJuIHRhcmdldDtcXG59XFxuXFxuLyogSGFuZGxlcyByZXNwb25zZXMgdG8gYW4gYWpheCByZXF1ZXN0OlxcbiAqIC0gZmluZHMgdGhlIHJpZ2h0IGRhdGFUeXBlIChtZWRpYXRlcyBiZXR3ZWVuIGNvbnRlbnQtdHlwZSBhbmQgZXhwZWN0ZWQgZGF0YVR5cGUpXFxuICogLSByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHJlc3BvbnNlXFxuICovXFxuZnVuY3Rpb24gYWpheEhhbmRsZVJlc3BvbnNlcyggcywganFYSFIsIHJlc3BvbnNlcyApIHtcXG5cXG5cXHR2YXIgY3QsIHR5cGUsIGZpbmFsRGF0YVR5cGUsIGZpcnN0RGF0YVR5cGUsXFxuXFx0XFx0Y29udGVudHMgPSBzLmNvbnRlbnRzLFxcblxcdFxcdGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzO1xcblxcblxcdC8vIFJlbW92ZSBhdXRvIGRhdGFUeXBlIGFuZCBnZXQgY29udGVudC10eXBlIGluIHRoZSBwcm9jZXNzXFxuXFx0d2hpbGUgKCBkYXRhVHlwZXNbIDAgXSA9PT0gXFxcIipcXFwiICkge1xcblxcdFxcdGRhdGFUeXBlcy5zaGlmdCgpO1xcblxcdFxcdGlmICggY3QgPT09IHVuZGVmaW5lZCApIHtcXG5cXHRcXHRcXHRjdCA9IHMubWltZVR5cGUgfHwganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFxcXCJDb250ZW50LVR5cGVcXFwiICk7XFxuXFx0XFx0fVxcblxcdH1cXG5cXG5cXHQvLyBDaGVjayBpZiB3ZSdyZSBkZWFsaW5nIHdpdGggYSBrbm93biBjb250ZW50LXR5cGVcXG5cXHRpZiAoIGN0ICkge1xcblxcdFxcdGZvciAoIHR5cGUgaW4gY29udGVudHMgKSB7XFxuXFx0XFx0XFx0aWYgKCBjb250ZW50c1sgdHlwZSBdICYmIGNvbnRlbnRzWyB0eXBlIF0udGVzdCggY3QgKSApIHtcXG5cXHRcXHRcXHRcXHRkYXRhVHlwZXMudW5zaGlmdCggdHlwZSApO1xcblxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fVxcblxcblxcdC8vIENoZWNrIHRvIHNlZSBpZiB3ZSBoYXZlIGEgcmVzcG9uc2UgZm9yIHRoZSBleHBlY3RlZCBkYXRhVHlwZVxcblxcdGlmICggZGF0YVR5cGVzWyAwIF0gaW4gcmVzcG9uc2VzICkge1xcblxcdFxcdGZpbmFsRGF0YVR5cGUgPSBkYXRhVHlwZXNbIDAgXTtcXG5cXHR9IGVsc2Uge1xcblxcblxcdFxcdC8vIFRyeSBjb252ZXJ0aWJsZSBkYXRhVHlwZXNcXG5cXHRcXHRmb3IgKCB0eXBlIGluIHJlc3BvbnNlcyApIHtcXG5cXHRcXHRcXHRpZiAoICFkYXRhVHlwZXNbIDAgXSB8fCBzLmNvbnZlcnRlcnNbIHR5cGUgKyBcXFwiIFxcXCIgKyBkYXRhVHlwZXNbIDAgXSBdICkge1xcblxcdFxcdFxcdFxcdGZpbmFsRGF0YVR5cGUgPSB0eXBlO1xcblxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoICFmaXJzdERhdGFUeXBlICkge1xcblxcdFxcdFxcdFxcdGZpcnN0RGF0YVR5cGUgPSB0eXBlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gT3IganVzdCB1c2UgZmlyc3Qgb25lXFxuXFx0XFx0ZmluYWxEYXRhVHlwZSA9IGZpbmFsRGF0YVR5cGUgfHwgZmlyc3REYXRhVHlwZTtcXG5cXHR9XFxuXFxuXFx0Ly8gSWYgd2UgZm91bmQgYSBkYXRhVHlwZVxcblxcdC8vIFdlIGFkZCB0aGUgZGF0YVR5cGUgdG8gdGhlIGxpc3QgaWYgbmVlZGVkXFxuXFx0Ly8gYW5kIHJldHVybiB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxcblxcdGlmICggZmluYWxEYXRhVHlwZSApIHtcXG5cXHRcXHRpZiAoIGZpbmFsRGF0YVR5cGUgIT09IGRhdGFUeXBlc1sgMCBdICkge1xcblxcdFxcdFxcdGRhdGFUeXBlcy51bnNoaWZ0KCBmaW5hbERhdGFUeXBlICk7XFxuXFx0XFx0fVxcblxcdFxcdHJldHVybiByZXNwb25zZXNbIGZpbmFsRGF0YVR5cGUgXTtcXG5cXHR9XFxufVxcblxcbi8qIENoYWluIGNvbnZlcnNpb25zIGdpdmVuIHRoZSByZXF1ZXN0IGFuZCB0aGUgb3JpZ2luYWwgcmVzcG9uc2VcXG4gKiBBbHNvIHNldHMgdGhlIHJlc3BvbnNlWFhYIGZpZWxkcyBvbiB0aGUganFYSFIgaW5zdGFuY2VcXG4gKi9cXG5mdW5jdGlvbiBhamF4Q29udmVydCggcywgcmVzcG9uc2UsIGpxWEhSLCBpc1N1Y2Nlc3MgKSB7XFxuXFx0dmFyIGNvbnYyLCBjdXJyZW50LCBjb252LCB0bXAsIHByZXYsXFxuXFx0XFx0Y29udmVydGVycyA9IHt9LFxcblxcblxcdFxcdC8vIFdvcmsgd2l0aCBhIGNvcHkgb2YgZGF0YVR5cGVzIGluIGNhc2Ugd2UgbmVlZCB0byBtb2RpZnkgaXQgZm9yIGNvbnZlcnNpb25cXG5cXHRcXHRkYXRhVHlwZXMgPSBzLmRhdGFUeXBlcy5zbGljZSgpO1xcblxcblxcdC8vIENyZWF0ZSBjb252ZXJ0ZXJzIG1hcCB3aXRoIGxvd2VyY2FzZWQga2V5c1xcblxcdGlmICggZGF0YVR5cGVzWyAxIF0gKSB7XFxuXFx0XFx0Zm9yICggY29udiBpbiBzLmNvbnZlcnRlcnMgKSB7XFxuXFx0XFx0XFx0Y29udmVydGVyc1sgY29udi50b0xvd2VyQ2FzZSgpIF0gPSBzLmNvbnZlcnRlcnNbIGNvbnYgXTtcXG5cXHRcXHR9XFxuXFx0fVxcblxcblxcdGN1cnJlbnQgPSBkYXRhVHlwZXMuc2hpZnQoKTtcXG5cXG5cXHQvLyBDb252ZXJ0IHRvIGVhY2ggc2VxdWVudGlhbCBkYXRhVHlwZVxcblxcdHdoaWxlICggY3VycmVudCApIHtcXG5cXG5cXHRcXHRpZiAoIHMucmVzcG9uc2VGaWVsZHNbIGN1cnJlbnQgXSApIHtcXG5cXHRcXHRcXHRqcVhIUlsgcy5yZXNwb25zZUZpZWxkc1sgY3VycmVudCBdIF0gPSByZXNwb25zZTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gQXBwbHkgdGhlIGRhdGFGaWx0ZXIgaWYgcHJvdmlkZWRcXG5cXHRcXHRpZiAoICFwcmV2ICYmIGlzU3VjY2VzcyAmJiBzLmRhdGFGaWx0ZXIgKSB7XFxuXFx0XFx0XFx0cmVzcG9uc2UgPSBzLmRhdGFGaWx0ZXIoIHJlc3BvbnNlLCBzLmRhdGFUeXBlICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdHByZXYgPSBjdXJyZW50O1xcblxcdFxcdGN1cnJlbnQgPSBkYXRhVHlwZXMuc2hpZnQoKTtcXG5cXG5cXHRcXHRpZiAoIGN1cnJlbnQgKSB7XFxuXFxuXFx0XFx0XFx0Ly8gVGhlcmUncyBvbmx5IHdvcmsgdG8gZG8gaWYgY3VycmVudCBkYXRhVHlwZSBpcyBub24tYXV0b1xcblxcdFxcdFxcdGlmICggY3VycmVudCA9PT0gXFxcIipcXFwiICkge1xcblxcblxcdFxcdFxcdFxcdGN1cnJlbnQgPSBwcmV2O1xcblxcblxcdFxcdFxcdC8vIENvbnZlcnQgcmVzcG9uc2UgaWYgcHJldiBkYXRhVHlwZSBpcyBub24tYXV0byBhbmQgZGlmZmVycyBmcm9tIGN1cnJlbnRcXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCBwcmV2ICE9PSBcXFwiKlxcXCIgJiYgcHJldiAhPT0gY3VycmVudCApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBTZWVrIGEgZGlyZWN0IGNvbnZlcnRlclxcblxcdFxcdFxcdFxcdGNvbnYgPSBjb252ZXJ0ZXJzWyBwcmV2ICsgXFxcIiBcXFwiICsgY3VycmVudCBdIHx8IGNvbnZlcnRlcnNbIFxcXCIqIFxcXCIgKyBjdXJyZW50IF07XFxuXFxuXFx0XFx0XFx0XFx0Ly8gSWYgbm9uZSBmb3VuZCwgc2VlayBhIHBhaXJcXG5cXHRcXHRcXHRcXHRpZiAoICFjb252ICkge1xcblxcdFxcdFxcdFxcdFxcdGZvciAoIGNvbnYyIGluIGNvbnZlcnRlcnMgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gSWYgY29udjIgb3V0cHV0cyBjdXJyZW50XFxuXFx0XFx0XFx0XFx0XFx0XFx0dG1wID0gY29udjIuc3BsaXQoIFxcXCIgXFxcIiApO1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggdG1wWyAxIF0gPT09IGN1cnJlbnQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gSWYgcHJldiBjYW4gYmUgY29udmVydGVkIHRvIGFjY2VwdGVkIGlucHV0XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Y29udiA9IGNvbnZlcnRlcnNbIHByZXYgKyBcXFwiIFxcXCIgKyB0bXBbIDAgXSBdIHx8XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Y29udmVydGVyc1sgXFxcIiogXFxcIiArIHRtcFsgMCBdIF07XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBjb252ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIENvbmRlbnNlIGVxdWl2YWxlbmNlIGNvbnZlcnRlcnNcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGNvbnYgPT09IHRydWUgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Y29udiA9IGNvbnZlcnRlcnNbIGNvbnYyIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gT3RoZXJ3aXNlLCBpbnNlcnQgdGhlIGludGVybWVkaWF0ZSBkYXRhVHlwZVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoIGNvbnZlcnRlcnNbIGNvbnYyIF0gIT09IHRydWUgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Y3VycmVudCA9IHRtcFsgMCBdO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRhdGFUeXBlcy51bnNoaWZ0KCB0bXBbIDEgXSApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gQXBwbHkgY29udmVydGVyIChpZiBub3QgYW4gZXF1aXZhbGVuY2UpXFxuXFx0XFx0XFx0XFx0aWYgKCBjb252ICE9PSB0cnVlICkge1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIFVubGVzcyBlcnJvcnMgYXJlIGFsbG93ZWQgdG8gYnViYmxlLCBjYXRjaCBhbmQgcmV0dXJuIHRoZW1cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGNvbnYgJiYgcy50aHJvd3MgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmVzcG9uc2UgPSBjb252KCByZXNwb25zZSApO1xcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dHJ5IHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXNwb25zZSA9IGNvbnYoIHJlc3BvbnNlICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fSBjYXRjaCAoIGUgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRzdGF0ZTogXFxcInBhcnNlcmVycm9yXFxcIixcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRlcnJvcjogY29udiA/IGUgOiBcXFwiTm8gY29udmVyc2lvbiBmcm9tIFxcXCIgKyBwcmV2ICsgXFxcIiB0byBcXFwiICsgY3VycmVudFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH07XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9XFxuXFxuXFx0cmV0dXJuIHsgc3RhdGU6IFxcXCJzdWNjZXNzXFxcIiwgZGF0YTogcmVzcG9uc2UgfTtcXG59XFxuXFxualF1ZXJ5LmV4dGVuZCgge1xcblxcblxcdC8vIENvdW50ZXIgZm9yIGhvbGRpbmcgdGhlIG51bWJlciBvZiBhY3RpdmUgcXVlcmllc1xcblxcdGFjdGl2ZTogMCxcXG5cXG5cXHQvLyBMYXN0LU1vZGlmaWVkIGhlYWRlciBjYWNoZSBmb3IgbmV4dCByZXF1ZXN0XFxuXFx0bGFzdE1vZGlmaWVkOiB7fSxcXG5cXHRldGFnOiB7fSxcXG5cXG5cXHRhamF4U2V0dGluZ3M6IHtcXG5cXHRcXHR1cmw6IGxvY2F0aW9uLmhyZWYsXFxuXFx0XFx0dHlwZTogXFxcIkdFVFxcXCIsXFxuXFx0XFx0aXNMb2NhbDogcmxvY2FsUHJvdG9jb2wudGVzdCggbG9jYXRpb24ucHJvdG9jb2wgKSxcXG5cXHRcXHRnbG9iYWw6IHRydWUsXFxuXFx0XFx0cHJvY2Vzc0RhdGE6IHRydWUsXFxuXFx0XFx0YXN5bmM6IHRydWUsXFxuXFx0XFx0Y29udGVudFR5cGU6IFxcXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7IGNoYXJzZXQ9VVRGLThcXFwiLFxcblxcblxcdFxcdC8qXFxuXFx0XFx0dGltZW91dDogMCxcXG5cXHRcXHRkYXRhOiBudWxsLFxcblxcdFxcdGRhdGFUeXBlOiBudWxsLFxcblxcdFxcdHVzZXJuYW1lOiBudWxsLFxcblxcdFxcdHBhc3N3b3JkOiBudWxsLFxcblxcdFxcdGNhY2hlOiBudWxsLFxcblxcdFxcdHRocm93czogZmFsc2UsXFxuXFx0XFx0dHJhZGl0aW9uYWw6IGZhbHNlLFxcblxcdFxcdGhlYWRlcnM6IHt9LFxcblxcdFxcdCovXFxuXFxuXFx0XFx0YWNjZXB0czoge1xcblxcdFxcdFxcdFxcXCIqXFxcIjogYWxsVHlwZXMsXFxuXFx0XFx0XFx0dGV4dDogXFxcInRleHQvcGxhaW5cXFwiLFxcblxcdFxcdFxcdGh0bWw6IFxcXCJ0ZXh0L2h0bWxcXFwiLFxcblxcdFxcdFxcdHhtbDogXFxcImFwcGxpY2F0aW9uL3htbCwgdGV4dC94bWxcXFwiLFxcblxcdFxcdFxcdGpzb246IFxcXCJhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L2phdmFzY3JpcHRcXFwiXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjb250ZW50czoge1xcblxcdFxcdFxcdHhtbDogL1xcXFxieG1sXFxcXGIvLFxcblxcdFxcdFxcdGh0bWw6IC9cXFxcYmh0bWwvLFxcblxcdFxcdFxcdGpzb246IC9cXFxcYmpzb25cXFxcYi9cXG5cXHRcXHR9LFxcblxcblxcdFxcdHJlc3BvbnNlRmllbGRzOiB7XFxuXFx0XFx0XFx0eG1sOiBcXFwicmVzcG9uc2VYTUxcXFwiLFxcblxcdFxcdFxcdHRleHQ6IFxcXCJyZXNwb25zZVRleHRcXFwiLFxcblxcdFxcdFxcdGpzb246IFxcXCJyZXNwb25zZUpTT05cXFwiXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvLyBEYXRhIGNvbnZlcnRlcnNcXG5cXHRcXHQvLyBLZXlzIHNlcGFyYXRlIHNvdXJjZSAob3IgY2F0Y2hhbGwgXFxcIipcXFwiKSBhbmQgZGVzdGluYXRpb24gdHlwZXMgd2l0aCBhIHNpbmdsZSBzcGFjZVxcblxcdFxcdGNvbnZlcnRlcnM6IHtcXG5cXG5cXHRcXHRcXHQvLyBDb252ZXJ0IGFueXRoaW5nIHRvIHRleHRcXG5cXHRcXHRcXHRcXFwiKiB0ZXh0XFxcIjogU3RyaW5nLFxcblxcblxcdFxcdFxcdC8vIFRleHQgdG8gaHRtbCAodHJ1ZSA9IG5vIHRyYW5zZm9ybWF0aW9uKVxcblxcdFxcdFxcdFxcXCJ0ZXh0IGh0bWxcXFwiOiB0cnVlLFxcblxcblxcdFxcdFxcdC8vIEV2YWx1YXRlIHRleHQgYXMgYSBqc29uIGV4cHJlc3Npb25cXG5cXHRcXHRcXHRcXFwidGV4dCBqc29uXFxcIjogSlNPTi5wYXJzZSxcXG5cXG5cXHRcXHRcXHQvLyBQYXJzZSB0ZXh0IGFzIHhtbFxcblxcdFxcdFxcdFxcXCJ0ZXh0IHhtbFxcXCI6IGpRdWVyeS5wYXJzZVhNTFxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Ly8gRm9yIG9wdGlvbnMgdGhhdCBzaG91bGRuJ3QgYmUgZGVlcCBleHRlbmRlZDpcXG5cXHRcXHQvLyB5b3UgY2FuIGFkZCB5b3VyIG93biBjdXN0b20gb3B0aW9ucyBoZXJlIGlmXFxuXFx0XFx0Ly8gYW5kIHdoZW4geW91IGNyZWF0ZSBvbmUgdGhhdCBzaG91bGRuJ3QgYmVcXG5cXHRcXHQvLyBkZWVwIGV4dGVuZGVkIChzZWUgYWpheEV4dGVuZClcXG5cXHRcXHRmbGF0T3B0aW9uczoge1xcblxcdFxcdFxcdHVybDogdHJ1ZSxcXG5cXHRcXHRcXHRjb250ZXh0OiB0cnVlXFxuXFx0XFx0fVxcblxcdH0sXFxuXFxuXFx0Ly8gQ3JlYXRlcyBhIGZ1bGwgZmxlZGdlZCBzZXR0aW5ncyBvYmplY3QgaW50byB0YXJnZXRcXG5cXHQvLyB3aXRoIGJvdGggYWpheFNldHRpbmdzIGFuZCBzZXR0aW5ncyBmaWVsZHMuXFxuXFx0Ly8gSWYgdGFyZ2V0IGlzIG9taXR0ZWQsIHdyaXRlcyBpbnRvIGFqYXhTZXR0aW5ncy5cXG5cXHRhamF4U2V0dXA6IGZ1bmN0aW9uKCB0YXJnZXQsIHNldHRpbmdzICkge1xcblxcdFxcdHJldHVybiBzZXR0aW5ncyA/XFxuXFxuXFx0XFx0XFx0Ly8gQnVpbGRpbmcgYSBzZXR0aW5ncyBvYmplY3RcXG5cXHRcXHRcXHRhamF4RXh0ZW5kKCBhamF4RXh0ZW5kKCB0YXJnZXQsIGpRdWVyeS5hamF4U2V0dGluZ3MgKSwgc2V0dGluZ3MgKSA6XFxuXFxuXFx0XFx0XFx0Ly8gRXh0ZW5kaW5nIGFqYXhTZXR0aW5nc1xcblxcdFxcdFxcdGFqYXhFeHRlbmQoIGpRdWVyeS5hamF4U2V0dGluZ3MsIHRhcmdldCApO1xcblxcdH0sXFxuXFxuXFx0YWpheFByZWZpbHRlcjogYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBwcmVmaWx0ZXJzICksXFxuXFx0YWpheFRyYW5zcG9ydDogYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCB0cmFuc3BvcnRzICksXFxuXFxuXFx0Ly8gTWFpbiBtZXRob2RcXG5cXHRhamF4OiBmdW5jdGlvbiggdXJsLCBvcHRpb25zICkge1xcblxcblxcdFxcdC8vIElmIHVybCBpcyBhbiBvYmplY3QsIHNpbXVsYXRlIHByZS0xLjUgc2lnbmF0dXJlXFxuXFx0XFx0aWYgKCB0eXBlb2YgdXJsID09PSBcXFwib2JqZWN0XFxcIiApIHtcXG5cXHRcXHRcXHRvcHRpb25zID0gdXJsO1xcblxcdFxcdFxcdHVybCA9IHVuZGVmaW5lZDtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gRm9yY2Ugb3B0aW9ucyB0byBiZSBhbiBvYmplY3RcXG5cXHRcXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcXG5cXG5cXHRcXHR2YXIgdHJhbnNwb3J0LFxcblxcblxcdFxcdFxcdC8vIFVSTCB3aXRob3V0IGFudGktY2FjaGUgcGFyYW1cXG5cXHRcXHRcXHRjYWNoZVVSTCxcXG5cXG5cXHRcXHRcXHQvLyBSZXNwb25zZSBoZWFkZXJzXFxuXFx0XFx0XFx0cmVzcG9uc2VIZWFkZXJzU3RyaW5nLFxcblxcdFxcdFxcdHJlc3BvbnNlSGVhZGVycyxcXG5cXG5cXHRcXHRcXHQvLyB0aW1lb3V0IGhhbmRsZVxcblxcdFxcdFxcdHRpbWVvdXRUaW1lcixcXG5cXG5cXHRcXHRcXHQvLyBVcmwgY2xlYW51cCB2YXJcXG5cXHRcXHRcXHR1cmxBbmNob3IsXFxuXFxuXFx0XFx0XFx0Ly8gUmVxdWVzdCBzdGF0ZSAoYmVjb21lcyBmYWxzZSB1cG9uIHNlbmQgYW5kIHRydWUgdXBvbiBjb21wbGV0aW9uKVxcblxcdFxcdFxcdGNvbXBsZXRlZCxcXG5cXG5cXHRcXHRcXHQvLyBUbyBrbm93IGlmIGdsb2JhbCBldmVudHMgYXJlIHRvIGJlIGRpc3BhdGNoZWRcXG5cXHRcXHRcXHRmaXJlR2xvYmFscyxcXG5cXG5cXHRcXHRcXHQvLyBMb29wIHZhcmlhYmxlXFxuXFx0XFx0XFx0aSxcXG5cXG5cXHRcXHRcXHQvLyB1bmNhY2hlZCBwYXJ0IG9mIHRoZSB1cmxcXG5cXHRcXHRcXHR1bmNhY2hlZCxcXG5cXG5cXHRcXHRcXHQvLyBDcmVhdGUgdGhlIGZpbmFsIG9wdGlvbnMgb2JqZWN0XFxuXFx0XFx0XFx0cyA9IGpRdWVyeS5hamF4U2V0dXAoIHt9LCBvcHRpb25zICksXFxuXFxuXFx0XFx0XFx0Ly8gQ2FsbGJhY2tzIGNvbnRleHRcXG5cXHRcXHRcXHRjYWxsYmFja0NvbnRleHQgPSBzLmNvbnRleHQgfHwgcyxcXG5cXG5cXHRcXHRcXHQvLyBDb250ZXh0IGZvciBnbG9iYWwgZXZlbnRzIGlzIGNhbGxiYWNrQ29udGV4dCBpZiBpdCBpcyBhIERPTSBub2RlIG9yIGpRdWVyeSBjb2xsZWN0aW9uXFxuXFx0XFx0XFx0Z2xvYmFsRXZlbnRDb250ZXh0ID0gcy5jb250ZXh0ICYmXFxuXFx0XFx0XFx0XFx0KCBjYWxsYmFja0NvbnRleHQubm9kZVR5cGUgfHwgY2FsbGJhY2tDb250ZXh0LmpxdWVyeSApID9cXG5cXHRcXHRcXHRcXHRcXHRqUXVlcnkoIGNhbGxiYWNrQ29udGV4dCApIDpcXG5cXHRcXHRcXHRcXHRcXHRqUXVlcnkuZXZlbnQsXFxuXFxuXFx0XFx0XFx0Ly8gRGVmZXJyZWRzXFxuXFx0XFx0XFx0ZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKSxcXG5cXHRcXHRcXHRjb21wbGV0ZURlZmVycmVkID0galF1ZXJ5LkNhbGxiYWNrcyggXFxcIm9uY2UgbWVtb3J5XFxcIiApLFxcblxcblxcdFxcdFxcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXFxuXFx0XFx0XFx0c3RhdHVzQ29kZSA9IHMuc3RhdHVzQ29kZSB8fCB7fSxcXG5cXG5cXHRcXHRcXHQvLyBIZWFkZXJzICh0aGV5IGFyZSBzZW50IGFsbCBhdCBvbmNlKVxcblxcdFxcdFxcdHJlcXVlc3RIZWFkZXJzID0ge30sXFxuXFx0XFx0XFx0cmVxdWVzdEhlYWRlcnNOYW1lcyA9IHt9LFxcblxcblxcdFxcdFxcdC8vIERlZmF1bHQgYWJvcnQgbWVzc2FnZVxcblxcdFxcdFxcdHN0ckFib3J0ID0gXFxcImNhbmNlbGVkXFxcIixcXG5cXG5cXHRcXHRcXHQvLyBGYWtlIHhoclxcblxcdFxcdFxcdGpxWEhSID0ge1xcblxcdFxcdFxcdFxcdHJlYWR5U3RhdGU6IDAsXFxuXFxuXFx0XFx0XFx0XFx0Ly8gQnVpbGRzIGhlYWRlcnMgaGFzaHRhYmxlIGlmIG5lZWRlZFxcblxcdFxcdFxcdFxcdGdldFJlc3BvbnNlSGVhZGVyOiBmdW5jdGlvbigga2V5ICkge1xcblxcdFxcdFxcdFxcdFxcdHZhciBtYXRjaDtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGNvbXBsZXRlZCApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoICFyZXNwb25zZUhlYWRlcnMgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmVzcG9uc2VIZWFkZXJzID0ge307XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0d2hpbGUgKCAoIG1hdGNoID0gcmhlYWRlcnMuZXhlYyggcmVzcG9uc2VIZWFkZXJzU3RyaW5nICkgKSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXNwb25zZUhlYWRlcnNbIG1hdGNoWyAxIF0udG9Mb3dlckNhc2UoKSBdID0gbWF0Y2hbIDIgXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdG1hdGNoID0gcmVzcG9uc2VIZWFkZXJzWyBrZXkudG9Mb3dlckNhc2UoKSBdO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gbWF0Y2ggPT0gbnVsbCA/IG51bGwgOiBtYXRjaDtcXG5cXHRcXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdFxcdC8vIFJhdyBzdHJpbmdcXG5cXHRcXHRcXHRcXHRnZXRBbGxSZXNwb25zZUhlYWRlcnM6IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBjb21wbGV0ZWQgPyByZXNwb25zZUhlYWRlcnNTdHJpbmcgOiBudWxsO1xcblxcdFxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0XFx0Ly8gQ2FjaGVzIHRoZSBoZWFkZXJcXG5cXHRcXHRcXHRcXHRzZXRSZXF1ZXN0SGVhZGVyOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBjb21wbGV0ZWQgPT0gbnVsbCApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRuYW1lID0gcmVxdWVzdEhlYWRlcnNOYW1lc1sgbmFtZS50b0xvd2VyQ2FzZSgpIF0gPVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJlcXVlc3RIZWFkZXJzTmFtZXNbIG5hbWUudG9Mb3dlckNhc2UoKSBdIHx8IG5hbWU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmVxdWVzdEhlYWRlcnNbIG5hbWUgXSA9IHZhbHVlO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXHRcXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdFxcdC8vIE92ZXJyaWRlcyByZXNwb25zZSBjb250ZW50LXR5cGUgaGVhZGVyXFxuXFx0XFx0XFx0XFx0b3ZlcnJpZGVNaW1lVHlwZTogZnVuY3Rpb24oIHR5cGUgKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBjb21wbGV0ZWQgPT0gbnVsbCApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRzLm1pbWVUeXBlID0gdHlwZTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFx0XFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHRcXHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xcblxcdFxcdFxcdFxcdHN0YXR1c0NvZGU6IGZ1bmN0aW9uKCBtYXAgKSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIGNvZGU7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBtYXAgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBjb21wbGV0ZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gRXhlY3V0ZSB0aGUgYXBwcm9wcmlhdGUgY2FsbGJhY2tzXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0anFYSFIuYWx3YXlzKCBtYXBbIGpxWEhSLnN0YXR1cyBdICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBMYXp5LWFkZCB0aGUgbmV3IGNhbGxiYWNrcyBpbiBhIHdheSB0aGF0IHByZXNlcnZlcyBvbGQgb25lc1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGZvciAoIGNvZGUgaW4gbWFwICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHN0YXR1c0NvZGVbIGNvZGUgXSA9IFsgc3RhdHVzQ29kZVsgY29kZSBdLCBtYXBbIGNvZGUgXSBdO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcdFxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0XFx0Ly8gQ2FuY2VsIHRoZSByZXF1ZXN0XFxuXFx0XFx0XFx0XFx0YWJvcnQ6IGZ1bmN0aW9uKCBzdGF0dXNUZXh0ICkge1xcblxcdFxcdFxcdFxcdFxcdHZhciBmaW5hbFRleHQgPSBzdGF0dXNUZXh0IHx8IHN0ckFib3J0O1xcblxcdFxcdFxcdFxcdFxcdGlmICggdHJhbnNwb3J0ICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRyYW5zcG9ydC5hYm9ydCggZmluYWxUZXh0ICk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGRvbmUoIDAsIGZpbmFsVGV4dCApO1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdC8vIEF0dGFjaCBkZWZlcnJlZHNcXG5cXHRcXHRkZWZlcnJlZC5wcm9taXNlKCBqcVhIUiApO1xcblxcblxcdFxcdC8vIEFkZCBwcm90b2NvbCBpZiBub3QgcHJvdmlkZWQgKHByZWZpbHRlcnMgbWlnaHQgZXhwZWN0IGl0KVxcblxcdFxcdC8vIEhhbmRsZSBmYWxzeSB1cmwgaW4gdGhlIHNldHRpbmdzIG9iamVjdCAoIzEwMDkzOiBjb25zaXN0ZW5jeSB3aXRoIG9sZCBzaWduYXR1cmUpXFxuXFx0XFx0Ly8gV2UgYWxzbyB1c2UgdGhlIHVybCBwYXJhbWV0ZXIgaWYgYXZhaWxhYmxlXFxuXFx0XFx0cy51cmwgPSAoICggdXJsIHx8IHMudXJsIHx8IGxvY2F0aW9uLmhyZWYgKSArIFxcXCJcXFwiIClcXG5cXHRcXHRcXHQucmVwbGFjZSggcnByb3RvY29sLCBsb2NhdGlvbi5wcm90b2NvbCArIFxcXCIvL1xcXCIgKTtcXG5cXG5cXHRcXHQvLyBBbGlhcyBtZXRob2Qgb3B0aW9uIHRvIHR5cGUgYXMgcGVyIHRpY2tldCAjMTIwMDRcXG5cXHRcXHRzLnR5cGUgPSBvcHRpb25zLm1ldGhvZCB8fCBvcHRpb25zLnR5cGUgfHwgcy5tZXRob2QgfHwgcy50eXBlO1xcblxcblxcdFxcdC8vIEV4dHJhY3QgZGF0YVR5cGVzIGxpc3RcXG5cXHRcXHRzLmRhdGFUeXBlcyA9ICggcy5kYXRhVHlwZSB8fCBcXFwiKlxcXCIgKS50b0xvd2VyQ2FzZSgpLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcXFwiXFxcIiBdO1xcblxcblxcdFxcdC8vIEEgY3Jvc3MtZG9tYWluIHJlcXVlc3QgaXMgaW4gb3JkZXIgd2hlbiB0aGUgb3JpZ2luIGRvZXNuJ3QgbWF0Y2ggdGhlIGN1cnJlbnQgb3JpZ2luLlxcblxcdFxcdGlmICggcy5jcm9zc0RvbWFpbiA9PSBudWxsICkge1xcblxcdFxcdFxcdHVybEFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFxcXCJhXFxcIiApO1xcblxcblxcdFxcdFxcdC8vIFN1cHBvcnQ6IElFIDw9OCAtIDExLCBFZGdlIDEyIC0gMTVcXG5cXHRcXHRcXHQvLyBJRSB0aHJvd3MgZXhjZXB0aW9uIG9uIGFjY2Vzc2luZyB0aGUgaHJlZiBwcm9wZXJ0eSBpZiB1cmwgaXMgbWFsZm9ybWVkLFxcblxcdFxcdFxcdC8vIGUuZy4gaHR0cDovL2V4YW1wbGUuY29tOjgweC9cXG5cXHRcXHRcXHR0cnkge1xcblxcdFxcdFxcdFxcdHVybEFuY2hvci5ocmVmID0gcy51cmw7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gU3VwcG9ydDogSUUgPD04IC0gMTEgb25seVxcblxcdFxcdFxcdFxcdC8vIEFuY2hvcidzIGhvc3QgcHJvcGVydHkgaXNuJ3QgY29ycmVjdGx5IHNldCB3aGVuIHMudXJsIGlzIHJlbGF0aXZlXFxuXFx0XFx0XFx0XFx0dXJsQW5jaG9yLmhyZWYgPSB1cmxBbmNob3IuaHJlZjtcXG5cXHRcXHRcXHRcXHRzLmNyb3NzRG9tYWluID0gb3JpZ2luQW5jaG9yLnByb3RvY29sICsgXFxcIi8vXFxcIiArIG9yaWdpbkFuY2hvci5ob3N0ICE9PVxcblxcdFxcdFxcdFxcdFxcdHVybEFuY2hvci5wcm90b2NvbCArIFxcXCIvL1xcXCIgKyB1cmxBbmNob3IuaG9zdDtcXG5cXHRcXHRcXHR9IGNhdGNoICggZSApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBJZiB0aGVyZSBpcyBhbiBlcnJvciBwYXJzaW5nIHRoZSBVUkwsIGFzc3VtZSBpdCBpcyBjcm9zc0RvbWFpbixcXG5cXHRcXHRcXHRcXHQvLyBpdCBjYW4gYmUgcmVqZWN0ZWQgYnkgdGhlIHRyYW5zcG9ydCBpZiBpdCBpcyBpbnZhbGlkXFxuXFx0XFx0XFx0XFx0cy5jcm9zc0RvbWFpbiA9IHRydWU7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBDb252ZXJ0IGRhdGEgaWYgbm90IGFscmVhZHkgYSBzdHJpbmdcXG5cXHRcXHRpZiAoIHMuZGF0YSAmJiBzLnByb2Nlc3NEYXRhICYmIHR5cGVvZiBzLmRhdGEgIT09IFxcXCJzdHJpbmdcXFwiICkge1xcblxcdFxcdFxcdHMuZGF0YSA9IGpRdWVyeS5wYXJhbSggcy5kYXRhLCBzLnRyYWRpdGlvbmFsICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIEFwcGx5IHByZWZpbHRlcnNcXG5cXHRcXHRpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggcHJlZmlsdGVycywgcywgb3B0aW9ucywganFYSFIgKTtcXG5cXG5cXHRcXHQvLyBJZiByZXF1ZXN0IHdhcyBhYm9ydGVkIGluc2lkZSBhIHByZWZpbHRlciwgc3RvcCB0aGVyZVxcblxcdFxcdGlmICggY29tcGxldGVkICkge1xcblxcdFxcdFxcdHJldHVybiBqcVhIUjtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gV2UgY2FuIGZpcmUgZ2xvYmFsIGV2ZW50cyBhcyBvZiBub3cgaWYgYXNrZWQgdG9cXG5cXHRcXHQvLyBEb24ndCBmaXJlIGV2ZW50cyBpZiBqUXVlcnkuZXZlbnQgaXMgdW5kZWZpbmVkIGluIGFuIEFNRC11c2FnZSBzY2VuYXJpbyAoIzE1MTE4KVxcblxcdFxcdGZpcmVHbG9iYWxzID0galF1ZXJ5LmV2ZW50ICYmIHMuZ2xvYmFsO1xcblxcblxcdFxcdC8vIFdhdGNoIGZvciBhIG5ldyBzZXQgb2YgcmVxdWVzdHNcXG5cXHRcXHRpZiAoIGZpcmVHbG9iYWxzICYmIGpRdWVyeS5hY3RpdmUrKyA9PT0gMCApIHtcXG5cXHRcXHRcXHRqUXVlcnkuZXZlbnQudHJpZ2dlciggXFxcImFqYXhTdGFydFxcXCIgKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gVXBwZXJjYXNlIHRoZSB0eXBlXFxuXFx0XFx0cy50eXBlID0gcy50eXBlLnRvVXBwZXJDYXNlKCk7XFxuXFxuXFx0XFx0Ly8gRGV0ZXJtaW5lIGlmIHJlcXVlc3QgaGFzIGNvbnRlbnRcXG5cXHRcXHRzLmhhc0NvbnRlbnQgPSAhcm5vQ29udGVudC50ZXN0KCBzLnR5cGUgKTtcXG5cXG5cXHRcXHQvLyBTYXZlIHRoZSBVUkwgaW4gY2FzZSB3ZSdyZSB0b3lpbmcgd2l0aCB0aGUgSWYtTW9kaWZpZWQtU2luY2VcXG5cXHRcXHQvLyBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIgbGF0ZXIgb25cXG5cXHRcXHQvLyBSZW1vdmUgaGFzaCB0byBzaW1wbGlmeSB1cmwgbWFuaXB1bGF0aW9uXFxuXFx0XFx0Y2FjaGVVUkwgPSBzLnVybC5yZXBsYWNlKCByaGFzaCwgXFxcIlxcXCIgKTtcXG5cXG5cXHRcXHQvLyBNb3JlIG9wdGlvbnMgaGFuZGxpbmcgZm9yIHJlcXVlc3RzIHdpdGggbm8gY29udGVudFxcblxcdFxcdGlmICggIXMuaGFzQ29udGVudCApIHtcXG5cXG5cXHRcXHRcXHQvLyBSZW1lbWJlciB0aGUgaGFzaCBzbyB3ZSBjYW4gcHV0IGl0IGJhY2tcXG5cXHRcXHRcXHR1bmNhY2hlZCA9IHMudXJsLnNsaWNlKCBjYWNoZVVSTC5sZW5ndGggKTtcXG5cXG5cXHRcXHRcXHQvLyBJZiBkYXRhIGlzIGF2YWlsYWJsZSBhbmQgc2hvdWxkIGJlIHByb2Nlc3NlZCwgYXBwZW5kIGRhdGEgdG8gdXJsXFxuXFx0XFx0XFx0aWYgKCBzLmRhdGEgJiYgKCBzLnByb2Nlc3NEYXRhIHx8IHR5cGVvZiBzLmRhdGEgPT09IFxcXCJzdHJpbmdcXFwiICkgKSB7XFxuXFx0XFx0XFx0XFx0Y2FjaGVVUkwgKz0gKCBycXVlcnkudGVzdCggY2FjaGVVUkwgKSA/IFxcXCImXFxcIiA6IFxcXCI/XFxcIiApICsgcy5kYXRhO1xcblxcblxcdFxcdFxcdFxcdC8vICM5NjgyOiByZW1vdmUgZGF0YSBzbyB0aGF0IGl0J3Mgbm90IHVzZWQgaW4gYW4gZXZlbnR1YWwgcmV0cnlcXG5cXHRcXHRcXHRcXHRkZWxldGUgcy5kYXRhO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBBZGQgb3IgdXBkYXRlIGFudGktY2FjaGUgcGFyYW0gaWYgbmVlZGVkXFxuXFx0XFx0XFx0aWYgKCBzLmNhY2hlID09PSBmYWxzZSApIHtcXG5cXHRcXHRcXHRcXHRjYWNoZVVSTCA9IGNhY2hlVVJMLnJlcGxhY2UoIHJhbnRpQ2FjaGUsIFxcXCIkMVxcXCIgKTtcXG5cXHRcXHRcXHRcXHR1bmNhY2hlZCA9ICggcnF1ZXJ5LnRlc3QoIGNhY2hlVVJMICkgPyBcXFwiJlxcXCIgOiBcXFwiP1xcXCIgKSArIFxcXCJfPVxcXCIgKyAoIG5vbmNlKysgKSArIHVuY2FjaGVkO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBQdXQgaGFzaCBhbmQgYW50aS1jYWNoZSBvbiB0aGUgVVJMIHRoYXQgd2lsbCBiZSByZXF1ZXN0ZWQgKGdoLTE3MzIpXFxuXFx0XFx0XFx0cy51cmwgPSBjYWNoZVVSTCArIHVuY2FjaGVkO1xcblxcblxcdFxcdC8vIENoYW5nZSAnJTIwJyB0byAnKycgaWYgdGhpcyBpcyBlbmNvZGVkIGZvcm0gYm9keSBjb250ZW50IChnaC0yNjU4KVxcblxcdFxcdH0gZWxzZSBpZiAoIHMuZGF0YSAmJiBzLnByb2Nlc3NEYXRhICYmXFxuXFx0XFx0XFx0KCBzLmNvbnRlbnRUeXBlIHx8IFxcXCJcXFwiICkuaW5kZXhPZiggXFxcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFxcXCIgKSA9PT0gMCApIHtcXG5cXHRcXHRcXHRzLmRhdGEgPSBzLmRhdGEucmVwbGFjZSggcjIwLCBcXFwiK1xcXCIgKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gU2V0IHRoZSBJZi1Nb2RpZmllZC1TaW5jZSBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIsIGlmIGluIGlmTW9kaWZpZWQgbW9kZS5cXG5cXHRcXHRpZiAoIHMuaWZNb2RpZmllZCApIHtcXG5cXHRcXHRcXHRpZiAoIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gKSB7XFxuXFx0XFx0XFx0XFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXFxcIklmLU1vZGlmaWVkLVNpbmNlXFxcIiwgalF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoIGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdICkge1xcblxcdFxcdFxcdFxcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFxcXCJJZi1Ob25lLU1hdGNoXFxcIiwgalF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIFNldCB0aGUgY29ycmVjdCBoZWFkZXIsIGlmIGRhdGEgaXMgYmVpbmcgc2VudFxcblxcdFxcdGlmICggcy5kYXRhICYmIHMuaGFzQ29udGVudCAmJiBzLmNvbnRlbnRUeXBlICE9PSBmYWxzZSB8fCBvcHRpb25zLmNvbnRlbnRUeXBlICkge1xcblxcdFxcdFxcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFxcXCJDb250ZW50LVR5cGVcXFwiLCBzLmNvbnRlbnRUeXBlICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIFNldCB0aGUgQWNjZXB0cyBoZWFkZXIgZm9yIHRoZSBzZXJ2ZXIsIGRlcGVuZGluZyBvbiB0aGUgZGF0YVR5cGVcXG5cXHRcXHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKFxcblxcdFxcdFxcdFxcXCJBY2NlcHRcXFwiLFxcblxcdFxcdFxcdHMuZGF0YVR5cGVzWyAwIF0gJiYgcy5hY2NlcHRzWyBzLmRhdGFUeXBlc1sgMCBdIF0gP1xcblxcdFxcdFxcdFxcdHMuYWNjZXB0c1sgcy5kYXRhVHlwZXNbIDAgXSBdICtcXG5cXHRcXHRcXHRcXHRcXHQoIHMuZGF0YVR5cGVzWyAwIF0gIT09IFxcXCIqXFxcIiA/IFxcXCIsIFxcXCIgKyBhbGxUeXBlcyArIFxcXCI7IHE9MC4wMVxcXCIgOiBcXFwiXFxcIiApIDpcXG5cXHRcXHRcXHRcXHRzLmFjY2VwdHNbIFxcXCIqXFxcIiBdXFxuXFx0XFx0KTtcXG5cXG5cXHRcXHQvLyBDaGVjayBmb3IgaGVhZGVycyBvcHRpb25cXG5cXHRcXHRmb3IgKCBpIGluIHMuaGVhZGVycyApIHtcXG5cXHRcXHRcXHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBpLCBzLmhlYWRlcnNbIGkgXSApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBBbGxvdyBjdXN0b20gaGVhZGVycy9taW1ldHlwZXMgYW5kIGVhcmx5IGFib3J0XFxuXFx0XFx0aWYgKCBzLmJlZm9yZVNlbmQgJiZcXG5cXHRcXHRcXHQoIHMuYmVmb3JlU2VuZC5jYWxsKCBjYWxsYmFja0NvbnRleHQsIGpxWEhSLCBzICkgPT09IGZhbHNlIHx8IGNvbXBsZXRlZCApICkge1xcblxcblxcdFxcdFxcdC8vIEFib3J0IGlmIG5vdCBkb25lIGFscmVhZHkgYW5kIHJldHVyblxcblxcdFxcdFxcdHJldHVybiBqcVhIUi5hYm9ydCgpO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBBYm9ydGluZyBpcyBubyBsb25nZXIgYSBjYW5jZWxsYXRpb25cXG5cXHRcXHRzdHJBYm9ydCA9IFxcXCJhYm9ydFxcXCI7XFxuXFxuXFx0XFx0Ly8gSW5zdGFsbCBjYWxsYmFja3Mgb24gZGVmZXJyZWRzXFxuXFx0XFx0Y29tcGxldGVEZWZlcnJlZC5hZGQoIHMuY29tcGxldGUgKTtcXG5cXHRcXHRqcVhIUi5kb25lKCBzLnN1Y2Nlc3MgKTtcXG5cXHRcXHRqcVhIUi5mYWlsKCBzLmVycm9yICk7XFxuXFxuXFx0XFx0Ly8gR2V0IHRyYW5zcG9ydFxcblxcdFxcdHRyYW5zcG9ydCA9IGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCB0cmFuc3BvcnRzLCBzLCBvcHRpb25zLCBqcVhIUiApO1xcblxcblxcdFxcdC8vIElmIG5vIHRyYW5zcG9ydCwgd2UgYXV0by1hYm9ydFxcblxcdFxcdGlmICggIXRyYW5zcG9ydCApIHtcXG5cXHRcXHRcXHRkb25lKCAtMSwgXFxcIk5vIFRyYW5zcG9ydFxcXCIgKTtcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdGpxWEhSLnJlYWR5U3RhdGUgPSAxO1xcblxcblxcdFxcdFxcdC8vIFNlbmQgZ2xvYmFsIGV2ZW50XFxuXFx0XFx0XFx0aWYgKCBmaXJlR2xvYmFscyApIHtcXG5cXHRcXHRcXHRcXHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggXFxcImFqYXhTZW5kXFxcIiwgWyBqcVhIUiwgcyBdICk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIElmIHJlcXVlc3Qgd2FzIGFib3J0ZWQgaW5zaWRlIGFqYXhTZW5kLCBzdG9wIHRoZXJlXFxuXFx0XFx0XFx0aWYgKCBjb21wbGV0ZWQgKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGpxWEhSO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBUaW1lb3V0XFxuXFx0XFx0XFx0aWYgKCBzLmFzeW5jICYmIHMudGltZW91dCA+IDAgKSB7XFxuXFx0XFx0XFx0XFx0dGltZW91dFRpbWVyID0gd2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdFxcdGpxWEhSLmFib3J0KCBcXFwidGltZW91dFxcXCIgKTtcXG5cXHRcXHRcXHRcXHR9LCBzLnRpbWVvdXQgKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dHJ5IHtcXG5cXHRcXHRcXHRcXHRjb21wbGV0ZWQgPSBmYWxzZTtcXG5cXHRcXHRcXHRcXHR0cmFuc3BvcnQuc2VuZCggcmVxdWVzdEhlYWRlcnMsIGRvbmUgKTtcXG5cXHRcXHRcXHR9IGNhdGNoICggZSApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBSZXRocm93IHBvc3QtY29tcGxldGlvbiBleGNlcHRpb25zXFxuXFx0XFx0XFx0XFx0aWYgKCBjb21wbGV0ZWQgKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhyb3cgZTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gUHJvcGFnYXRlIG90aGVycyBhcyByZXN1bHRzXFxuXFx0XFx0XFx0XFx0ZG9uZSggLTEsIGUgKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIENhbGxiYWNrIGZvciB3aGVuIGV2ZXJ5dGhpbmcgaXMgZG9uZVxcblxcdFxcdGZ1bmN0aW9uIGRvbmUoIHN0YXR1cywgbmF0aXZlU3RhdHVzVGV4dCwgcmVzcG9uc2VzLCBoZWFkZXJzICkge1xcblxcdFxcdFxcdHZhciBpc1N1Y2Nlc3MsIHN1Y2Nlc3MsIGVycm9yLCByZXNwb25zZSwgbW9kaWZpZWQsXFxuXFx0XFx0XFx0XFx0c3RhdHVzVGV4dCA9IG5hdGl2ZVN0YXR1c1RleHQ7XFxuXFxuXFx0XFx0XFx0Ly8gSWdub3JlIHJlcGVhdCBpbnZvY2F0aW9uc1xcblxcdFxcdFxcdGlmICggY29tcGxldGVkICkge1xcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Y29tcGxldGVkID0gdHJ1ZTtcXG5cXG5cXHRcXHRcXHQvLyBDbGVhciB0aW1lb3V0IGlmIGl0IGV4aXN0c1xcblxcdFxcdFxcdGlmICggdGltZW91dFRpbWVyICkge1xcblxcdFxcdFxcdFxcdHdpbmRvdy5jbGVhclRpbWVvdXQoIHRpbWVvdXRUaW1lciApO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBEZXJlZmVyZW5jZSB0cmFuc3BvcnQgZm9yIGVhcmx5IGdhcmJhZ2UgY29sbGVjdGlvblxcblxcdFxcdFxcdC8vIChubyBtYXR0ZXIgaG93IGxvbmcgdGhlIGpxWEhSIG9iamVjdCB3aWxsIGJlIHVzZWQpXFxuXFx0XFx0XFx0dHJhbnNwb3J0ID0gdW5kZWZpbmVkO1xcblxcblxcdFxcdFxcdC8vIENhY2hlIHJlc3BvbnNlIGhlYWRlcnNcXG5cXHRcXHRcXHRyZXNwb25zZUhlYWRlcnNTdHJpbmcgPSBoZWFkZXJzIHx8IFxcXCJcXFwiO1xcblxcblxcdFxcdFxcdC8vIFNldCByZWFkeVN0YXRlXFxuXFx0XFx0XFx0anFYSFIucmVhZHlTdGF0ZSA9IHN0YXR1cyA+IDAgPyA0IDogMDtcXG5cXG5cXHRcXHRcXHQvLyBEZXRlcm1pbmUgaWYgc3VjY2Vzc2Z1bFxcblxcdFxcdFxcdGlzU3VjY2VzcyA9IHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwIHx8IHN0YXR1cyA9PT0gMzA0O1xcblxcblxcdFxcdFxcdC8vIEdldCByZXNwb25zZSBkYXRhXFxuXFx0XFx0XFx0aWYgKCByZXNwb25zZXMgKSB7XFxuXFx0XFx0XFx0XFx0cmVzcG9uc2UgPSBhamF4SGFuZGxlUmVzcG9uc2VzKCBzLCBqcVhIUiwgcmVzcG9uc2VzICk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIENvbnZlcnQgbm8gbWF0dGVyIHdoYXQgKHRoYXQgd2F5IHJlc3BvbnNlWFhYIGZpZWxkcyBhcmUgYWx3YXlzIHNldClcXG5cXHRcXHRcXHRyZXNwb25zZSA9IGFqYXhDb252ZXJ0KCBzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2VzcyApO1xcblxcblxcdFxcdFxcdC8vIElmIHN1Y2Nlc3NmdWwsIGhhbmRsZSB0eXBlIGNoYWluaW5nXFxuXFx0XFx0XFx0aWYgKCBpc1N1Y2Nlc3MgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gU2V0IHRoZSBJZi1Nb2RpZmllZC1TaW5jZSBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIsIGlmIGluIGlmTW9kaWZpZWQgbW9kZS5cXG5cXHRcXHRcXHRcXHRpZiAoIHMuaWZNb2RpZmllZCApIHtcXG5cXHRcXHRcXHRcXHRcXHRtb2RpZmllZCA9IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcXFwiTGFzdC1Nb2RpZmllZFxcXCIgKTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIG1vZGlmaWVkICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0bW9kaWZpZWQgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXFxcImV0YWdcXFwiICk7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBtb2RpZmllZCApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSA9IG1vZGlmaWVkO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gaWYgbm8gY29udGVudFxcblxcdFxcdFxcdFxcdGlmICggc3RhdHVzID09PSAyMDQgfHwgcy50eXBlID09PSBcXFwiSEVBRFxcXCIgKSB7XFxuXFx0XFx0XFx0XFx0XFx0c3RhdHVzVGV4dCA9IFxcXCJub2NvbnRlbnRcXFwiO1xcblxcblxcdFxcdFxcdFxcdC8vIGlmIG5vdCBtb2RpZmllZFxcblxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoIHN0YXR1cyA9PT0gMzA0ICkge1xcblxcdFxcdFxcdFxcdFxcdHN0YXR1c1RleHQgPSBcXFwibm90bW9kaWZpZWRcXFwiO1xcblxcblxcdFxcdFxcdFxcdC8vIElmIHdlIGhhdmUgZGF0YSwgbGV0J3MgY29udmVydCBpdFxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0c3RhdHVzVGV4dCA9IHJlc3BvbnNlLnN0YXRlO1xcblxcdFxcdFxcdFxcdFxcdHN1Y2Nlc3MgPSByZXNwb25zZS5kYXRhO1xcblxcdFxcdFxcdFxcdFxcdGVycm9yID0gcmVzcG9uc2UuZXJyb3I7XFxuXFx0XFx0XFx0XFx0XFx0aXNTdWNjZXNzID0gIWVycm9yO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdC8vIEV4dHJhY3QgZXJyb3IgZnJvbSBzdGF0dXNUZXh0IGFuZCBub3JtYWxpemUgZm9yIG5vbi1hYm9ydHNcXG5cXHRcXHRcXHRcXHRlcnJvciA9IHN0YXR1c1RleHQ7XFxuXFx0XFx0XFx0XFx0aWYgKCBzdGF0dXMgfHwgIXN0YXR1c1RleHQgKSB7XFxuXFx0XFx0XFx0XFx0XFx0c3RhdHVzVGV4dCA9IFxcXCJlcnJvclxcXCI7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBzdGF0dXMgPCAwICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHN0YXR1cyA9IDA7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gU2V0IGRhdGEgZm9yIHRoZSBmYWtlIHhociBvYmplY3RcXG5cXHRcXHRcXHRqcVhIUi5zdGF0dXMgPSBzdGF0dXM7XFxuXFx0XFx0XFx0anFYSFIuc3RhdHVzVGV4dCA9ICggbmF0aXZlU3RhdHVzVGV4dCB8fCBzdGF0dXNUZXh0ICkgKyBcXFwiXFxcIjtcXG5cXG5cXHRcXHRcXHQvLyBTdWNjZXNzL0Vycm9yXFxuXFx0XFx0XFx0aWYgKCBpc1N1Y2Nlc3MgKSB7XFxuXFx0XFx0XFx0XFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBzdWNjZXNzLCBzdGF0dXNUZXh0LCBqcVhIUiBdICk7XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRkZWZlcnJlZC5yZWplY3RXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsganFYSFIsIHN0YXR1c1RleHQsIGVycm9yIF0gKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3NcXG5cXHRcXHRcXHRqcVhIUi5zdGF0dXNDb2RlKCBzdGF0dXNDb2RlICk7XFxuXFx0XFx0XFx0c3RhdHVzQ29kZSA9IHVuZGVmaW5lZDtcXG5cXG5cXHRcXHRcXHRpZiAoIGZpcmVHbG9iYWxzICkge1xcblxcdFxcdFxcdFxcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBpc1N1Y2Nlc3MgPyBcXFwiYWpheFN1Y2Nlc3NcXFwiIDogXFxcImFqYXhFcnJvclxcXCIsXFxuXFx0XFx0XFx0XFx0XFx0WyBqcVhIUiwgcywgaXNTdWNjZXNzID8gc3VjY2VzcyA6IGVycm9yIF0gKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gQ29tcGxldGVcXG5cXHRcXHRcXHRjb21wbGV0ZURlZmVycmVkLmZpcmVXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsganFYSFIsIHN0YXR1c1RleHQgXSApO1xcblxcblxcdFxcdFxcdGlmICggZmlyZUdsb2JhbHMgKSB7XFxuXFx0XFx0XFx0XFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFxcXCJhamF4Q29tcGxldGVcXFwiLCBbIGpxWEhSLCBzIF0gKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBIYW5kbGUgdGhlIGdsb2JhbCBBSkFYIGNvdW50ZXJcXG5cXHRcXHRcXHRcXHRpZiAoICEoIC0talF1ZXJ5LmFjdGl2ZSApICkge1xcblxcdFxcdFxcdFxcdFxcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBcXFwiYWpheFN0b3BcXFwiICk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIGpxWEhSO1xcblxcdH0sXFxuXFxuXFx0Z2V0SlNPTjogZnVuY3Rpb24oIHVybCwgZGF0YSwgY2FsbGJhY2sgKSB7XFxuXFx0XFx0cmV0dXJuIGpRdWVyeS5nZXQoIHVybCwgZGF0YSwgY2FsbGJhY2ssIFxcXCJqc29uXFxcIiApO1xcblxcdH0sXFxuXFxuXFx0Z2V0U2NyaXB0OiBmdW5jdGlvbiggdXJsLCBjYWxsYmFjayApIHtcXG5cXHRcXHRyZXR1cm4galF1ZXJ5LmdldCggdXJsLCB1bmRlZmluZWQsIGNhbGxiYWNrLCBcXFwic2NyaXB0XFxcIiApO1xcblxcdH1cXG59ICk7XFxuXFxualF1ZXJ5LmVhY2goIFsgXFxcImdldFxcXCIsIFxcXCJwb3N0XFxcIiBdLCBmdW5jdGlvbiggaSwgbWV0aG9kICkge1xcblxcdGpRdWVyeVsgbWV0aG9kIF0gPSBmdW5jdGlvbiggdXJsLCBkYXRhLCBjYWxsYmFjaywgdHlwZSApIHtcXG5cXG5cXHRcXHQvLyBTaGlmdCBhcmd1bWVudHMgaWYgZGF0YSBhcmd1bWVudCB3YXMgb21pdHRlZFxcblxcdFxcdGlmICggaXNGdW5jdGlvbiggZGF0YSApICkge1xcblxcdFxcdFxcdHR5cGUgPSB0eXBlIHx8IGNhbGxiYWNrO1xcblxcdFxcdFxcdGNhbGxiYWNrID0gZGF0YTtcXG5cXHRcXHRcXHRkYXRhID0gdW5kZWZpbmVkO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBUaGUgdXJsIGNhbiBiZSBhbiBvcHRpb25zIG9iamVjdCAod2hpY2ggdGhlbiBtdXN0IGhhdmUgLnVybClcXG5cXHRcXHRyZXR1cm4galF1ZXJ5LmFqYXgoIGpRdWVyeS5leHRlbmQoIHtcXG5cXHRcXHRcXHR1cmw6IHVybCxcXG5cXHRcXHRcXHR0eXBlOiBtZXRob2QsXFxuXFx0XFx0XFx0ZGF0YVR5cGU6IHR5cGUsXFxuXFx0XFx0XFx0ZGF0YTogZGF0YSxcXG5cXHRcXHRcXHRzdWNjZXNzOiBjYWxsYmFja1xcblxcdFxcdH0sIGpRdWVyeS5pc1BsYWluT2JqZWN0KCB1cmwgKSAmJiB1cmwgKSApO1xcblxcdH07XFxufSApO1xcblxcblxcbmpRdWVyeS5fZXZhbFVybCA9IGZ1bmN0aW9uKCB1cmwgKSB7XFxuXFx0cmV0dXJuIGpRdWVyeS5hamF4KCB7XFxuXFx0XFx0dXJsOiB1cmwsXFxuXFxuXFx0XFx0Ly8gTWFrZSB0aGlzIGV4cGxpY2l0LCBzaW5jZSB1c2VyIGNhbiBvdmVycmlkZSB0aGlzIHRocm91Z2ggYWpheFNldHVwICgjMTEyNjQpXFxuXFx0XFx0dHlwZTogXFxcIkdFVFxcXCIsXFxuXFx0XFx0ZGF0YVR5cGU6IFxcXCJzY3JpcHRcXFwiLFxcblxcdFxcdGNhY2hlOiB0cnVlLFxcblxcdFxcdGFzeW5jOiBmYWxzZSxcXG5cXHRcXHRnbG9iYWw6IGZhbHNlLFxcblxcdFxcdFxcXCJ0aHJvd3NcXFwiOiB0cnVlXFxuXFx0fSApO1xcbn07XFxuXFxuXFxualF1ZXJ5LmZuLmV4dGVuZCgge1xcblxcdHdyYXBBbGw6IGZ1bmN0aW9uKCBodG1sICkge1xcblxcdFxcdHZhciB3cmFwO1xcblxcblxcdFxcdGlmICggdGhpc1sgMCBdICkge1xcblxcdFxcdFxcdGlmICggaXNGdW5jdGlvbiggaHRtbCApICkge1xcblxcdFxcdFxcdFxcdGh0bWwgPSBodG1sLmNhbGwoIHRoaXNbIDAgXSApO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBUaGUgZWxlbWVudHMgdG8gd3JhcCB0aGUgdGFyZ2V0IGFyb3VuZFxcblxcdFxcdFxcdHdyYXAgPSBqUXVlcnkoIGh0bWwsIHRoaXNbIDAgXS5vd25lckRvY3VtZW50ICkuZXEoIDAgKS5jbG9uZSggdHJ1ZSApO1xcblxcblxcdFxcdFxcdGlmICggdGhpc1sgMCBdLnBhcmVudE5vZGUgKSB7XFxuXFx0XFx0XFx0XFx0d3JhcC5pbnNlcnRCZWZvcmUoIHRoaXNbIDAgXSApO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR3cmFwLm1hcCggZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0dmFyIGVsZW0gPSB0aGlzO1xcblxcblxcdFxcdFxcdFxcdHdoaWxlICggZWxlbS5maXJzdEVsZW1lbnRDaGlsZCApIHtcXG5cXHRcXHRcXHRcXHRcXHRlbGVtID0gZWxlbS5maXJzdEVsZW1lbnRDaGlsZDtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIGVsZW07XFxuXFx0XFx0XFx0fSApLmFwcGVuZCggdGhpcyApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gdGhpcztcXG5cXHR9LFxcblxcblxcdHdyYXBJbm5lcjogZnVuY3Rpb24oIGh0bWwgKSB7XFxuXFx0XFx0aWYgKCBpc0Z1bmN0aW9uKCBodG1sICkgKSB7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XFxuXFx0XFx0XFx0XFx0alF1ZXJ5KCB0aGlzICkud3JhcElubmVyKCBodG1sLmNhbGwoIHRoaXMsIGkgKSApO1xcblxcdFxcdFxcdH0gKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0dmFyIHNlbGYgPSBqUXVlcnkoIHRoaXMgKSxcXG5cXHRcXHRcXHRcXHRjb250ZW50cyA9IHNlbGYuY29udGVudHMoKTtcXG5cXG5cXHRcXHRcXHRpZiAoIGNvbnRlbnRzLmxlbmd0aCApIHtcXG5cXHRcXHRcXHRcXHRjb250ZW50cy53cmFwQWxsKCBodG1sICk7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRzZWxmLmFwcGVuZCggaHRtbCApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9ICk7XFxuXFx0fSxcXG5cXG5cXHR3cmFwOiBmdW5jdGlvbiggaHRtbCApIHtcXG5cXHRcXHR2YXIgaHRtbElzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uKCBodG1sICk7XFxuXFxuXFx0XFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XFxuXFx0XFx0XFx0alF1ZXJ5KCB0aGlzICkud3JhcEFsbCggaHRtbElzRnVuY3Rpb24gPyBodG1sLmNhbGwoIHRoaXMsIGkgKSA6IGh0bWwgKTtcXG5cXHRcXHR9ICk7XFxuXFx0fSxcXG5cXG5cXHR1bndyYXA6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcXG5cXHRcXHR0aGlzLnBhcmVudCggc2VsZWN0b3IgKS5ub3QoIFxcXCJib2R5XFxcIiApLmVhY2goIGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdGpRdWVyeSggdGhpcyApLnJlcGxhY2VXaXRoKCB0aGlzLmNoaWxkTm9kZXMgKTtcXG5cXHRcXHR9ICk7XFxuXFx0XFx0cmV0dXJuIHRoaXM7XFxuXFx0fVxcbn0gKTtcXG5cXG5cXG5qUXVlcnkuZXhwci5wc2V1ZG9zLmhpZGRlbiA9IGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdHJldHVybiAhalF1ZXJ5LmV4cHIucHNldWRvcy52aXNpYmxlKCBlbGVtICk7XFxufTtcXG5qUXVlcnkuZXhwci5wc2V1ZG9zLnZpc2libGUgPSBmdW5jdGlvbiggZWxlbSApIHtcXG5cXHRyZXR1cm4gISEoIGVsZW0ub2Zmc2V0V2lkdGggfHwgZWxlbS5vZmZzZXRIZWlnaHQgfHwgZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCApO1xcbn07XFxuXFxuXFxuXFxuXFxualF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIgPSBmdW5jdGlvbigpIHtcXG5cXHR0cnkge1xcblxcdFxcdHJldHVybiBuZXcgd2luZG93LlhNTEh0dHBSZXF1ZXN0KCk7XFxuXFx0fSBjYXRjaCAoIGUgKSB7fVxcbn07XFxuXFxudmFyIHhoclN1Y2Nlc3NTdGF0dXMgPSB7XFxuXFxuXFx0XFx0Ly8gRmlsZSBwcm90b2NvbCBhbHdheXMgeWllbGRzIHN0YXR1cyBjb2RlIDAsIGFzc3VtZSAyMDBcXG5cXHRcXHQwOiAyMDAsXFxuXFxuXFx0XFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcXG5cXHRcXHQvLyAjMTQ1MDogc29tZXRpbWVzIElFIHJldHVybnMgMTIyMyB3aGVuIGl0IHNob3VsZCBiZSAyMDRcXG5cXHRcXHQxMjIzOiAyMDRcXG5cXHR9LFxcblxcdHhoclN1cHBvcnRlZCA9IGpRdWVyeS5hamF4U2V0dGluZ3MueGhyKCk7XFxuXFxuc3VwcG9ydC5jb3JzID0gISF4aHJTdXBwb3J0ZWQgJiYgKCBcXFwid2l0aENyZWRlbnRpYWxzXFxcIiBpbiB4aHJTdXBwb3J0ZWQgKTtcXG5zdXBwb3J0LmFqYXggPSB4aHJTdXBwb3J0ZWQgPSAhIXhoclN1cHBvcnRlZDtcXG5cXG5qUXVlcnkuYWpheFRyYW5zcG9ydCggZnVuY3Rpb24oIG9wdGlvbnMgKSB7XFxuXFx0dmFyIGNhbGxiYWNrLCBlcnJvckNhbGxiYWNrO1xcblxcblxcdC8vIENyb3NzIGRvbWFpbiBvbmx5IGFsbG93ZWQgaWYgc3VwcG9ydGVkIHRocm91Z2ggWE1MSHR0cFJlcXVlc3RcXG5cXHRpZiAoIHN1cHBvcnQuY29ycyB8fCB4aHJTdXBwb3J0ZWQgJiYgIW9wdGlvbnMuY3Jvc3NEb21haW4gKSB7XFxuXFx0XFx0cmV0dXJuIHtcXG5cXHRcXHRcXHRzZW5kOiBmdW5jdGlvbiggaGVhZGVycywgY29tcGxldGUgKSB7XFxuXFx0XFx0XFx0XFx0dmFyIGksXFxuXFx0XFx0XFx0XFx0XFx0eGhyID0gb3B0aW9ucy54aHIoKTtcXG5cXG5cXHRcXHRcXHRcXHR4aHIub3BlbihcXG5cXHRcXHRcXHRcXHRcXHRvcHRpb25zLnR5cGUsXFxuXFx0XFx0XFx0XFx0XFx0b3B0aW9ucy51cmwsXFxuXFx0XFx0XFx0XFx0XFx0b3B0aW9ucy5hc3luYyxcXG5cXHRcXHRcXHRcXHRcXHRvcHRpb25zLnVzZXJuYW1lLFxcblxcdFxcdFxcdFxcdFxcdG9wdGlvbnMucGFzc3dvcmRcXG5cXHRcXHRcXHRcXHQpO1xcblxcblxcdFxcdFxcdFxcdC8vIEFwcGx5IGN1c3RvbSBmaWVsZHMgaWYgcHJvdmlkZWRcXG5cXHRcXHRcXHRcXHRpZiAoIG9wdGlvbnMueGhyRmllbGRzICkge1xcblxcdFxcdFxcdFxcdFxcdGZvciAoIGkgaW4gb3B0aW9ucy54aHJGaWVsZHMgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0eGhyWyBpIF0gPSBvcHRpb25zLnhockZpZWxkc1sgaSBdO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gT3ZlcnJpZGUgbWltZSB0eXBlIGlmIG5lZWRlZFxcblxcdFxcdFxcdFxcdGlmICggb3B0aW9ucy5taW1lVHlwZSAmJiB4aHIub3ZlcnJpZGVNaW1lVHlwZSApIHtcXG5cXHRcXHRcXHRcXHRcXHR4aHIub3ZlcnJpZGVNaW1lVHlwZSggb3B0aW9ucy5taW1lVHlwZSApO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBYLVJlcXVlc3RlZC1XaXRoIGhlYWRlclxcblxcdFxcdFxcdFxcdC8vIEZvciBjcm9zcy1kb21haW4gcmVxdWVzdHMsIHNlZWluZyBhcyBjb25kaXRpb25zIGZvciBhIHByZWZsaWdodCBhcmVcXG5cXHRcXHRcXHRcXHQvLyBha2luIHRvIGEgamlnc2F3IHB1enpsZSwgd2Ugc2ltcGx5IG5ldmVyIHNldCBpdCB0byBiZSBzdXJlLlxcblxcdFxcdFxcdFxcdC8vIChpdCBjYW4gYWx3YXlzIGJlIHNldCBvbiBhIHBlci1yZXF1ZXN0IGJhc2lzIG9yIGV2ZW4gdXNpbmcgYWpheFNldHVwKVxcblxcdFxcdFxcdFxcdC8vIEZvciBzYW1lLWRvbWFpbiByZXF1ZXN0cywgd29uJ3QgY2hhbmdlIGhlYWRlciBpZiBhbHJlYWR5IHByb3ZpZGVkLlxcblxcdFxcdFxcdFxcdGlmICggIW9wdGlvbnMuY3Jvc3NEb21haW4gJiYgIWhlYWRlcnNbIFxcXCJYLVJlcXVlc3RlZC1XaXRoXFxcIiBdICkge1xcblxcdFxcdFxcdFxcdFxcdGhlYWRlcnNbIFxcXCJYLVJlcXVlc3RlZC1XaXRoXFxcIiBdID0gXFxcIlhNTEh0dHBSZXF1ZXN0XFxcIjtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gU2V0IGhlYWRlcnNcXG5cXHRcXHRcXHRcXHRmb3IgKCBpIGluIGhlYWRlcnMgKSB7XFxuXFx0XFx0XFx0XFx0XFx0eGhyLnNldFJlcXVlc3RIZWFkZXIoIGksIGhlYWRlcnNbIGkgXSApO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBDYWxsYmFja1xcblxcdFxcdFxcdFxcdGNhbGxiYWNrID0gZnVuY3Rpb24oIHR5cGUgKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggY2FsbGJhY2sgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Y2FsbGJhY2sgPSBlcnJvckNhbGxiYWNrID0geGhyLm9ubG9hZCA9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0eGhyLm9uZXJyb3IgPSB4aHIub25hYm9ydCA9IHhoci5vbnRpbWVvdXQgPVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggdHlwZSA9PT0gXFxcImFib3J0XFxcIiApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR4aHIuYWJvcnQoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2UgaWYgKCB0eXBlID09PSBcXFwiZXJyb3JcXFwiICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gT24gYSBtYW51YWwgbmF0aXZlIGFib3J0LCBJRTkgdGhyb3dzXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gZXJyb3JzIG9uIGFueSBwcm9wZXJ0eSBhY2Nlc3MgdGhhdCBpcyBub3QgcmVhZHlTdGF0ZVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggdHlwZW9mIHhoci5zdGF0dXMgIT09IFxcXCJudW1iZXJcXFwiICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGNvbXBsZXRlKCAwLCBcXFwiZXJyb3JcXFwiICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRjb21wbGV0ZShcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBGaWxlOiBwcm90b2NvbCBhbHdheXMgeWllbGRzIHN0YXR1cyAwOyBzZWUgIzg2MDUsICMxNDIwN1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHhoci5zdGF0dXMsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0eGhyLnN0YXR1c1RleHRcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGNvbXBsZXRlKFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHhoclN1Y2Nlc3NTdGF0dXNbIHhoci5zdGF0dXMgXSB8fCB4aHIuc3RhdHVzLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHhoci5zdGF0dXNUZXh0LFxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gSUU5IGhhcyBubyBYSFIyIGJ1dCB0aHJvd3Mgb24gYmluYXJ5ICh0cmFjLTExNDI2KVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIEZvciBYSFIyIG5vbi10ZXh0LCBsZXQgdGhlIGNhbGxlciBoYW5kbGUgaXQgKGdoLTI0OTgpXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0KCB4aHIucmVzcG9uc2VUeXBlIHx8IFxcXCJ0ZXh0XFxcIiApICE9PSBcXFwidGV4dFxcXCIgIHx8XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dHlwZW9mIHhoci5yZXNwb25zZVRleHQgIT09IFxcXCJzdHJpbmdcXFwiID9cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR7IGJpbmFyeTogeGhyLnJlc3BvbnNlIH0gOlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHsgdGV4dDogeGhyLnJlc3BvbnNlVGV4dCB9LFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9O1xcblxcdFxcdFxcdFxcdH07XFxuXFxuXFx0XFx0XFx0XFx0Ly8gTGlzdGVuIHRvIGV2ZW50c1xcblxcdFxcdFxcdFxcdHhoci5vbmxvYWQgPSBjYWxsYmFjaygpO1xcblxcdFxcdFxcdFxcdGVycm9yQ2FsbGJhY2sgPSB4aHIub25lcnJvciA9IHhoci5vbnRpbWVvdXQgPSBjYWxsYmFjayggXFxcImVycm9yXFxcIiApO1xcblxcblxcdFxcdFxcdFxcdC8vIFN1cHBvcnQ6IElFIDkgb25seVxcblxcdFxcdFxcdFxcdC8vIFVzZSBvbnJlYWR5c3RhdGVjaGFuZ2UgdG8gcmVwbGFjZSBvbmFib3J0XFxuXFx0XFx0XFx0XFx0Ly8gdG8gaGFuZGxlIHVuY2F1Z2h0IGFib3J0c1xcblxcdFxcdFxcdFxcdGlmICggeGhyLm9uYWJvcnQgIT09IHVuZGVmaW5lZCApIHtcXG5cXHRcXHRcXHRcXHRcXHR4aHIub25hYm9ydCA9IGVycm9yQ2FsbGJhY2s7XFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gQ2hlY2sgcmVhZHlTdGF0ZSBiZWZvcmUgdGltZW91dCBhcyBpdCBjaGFuZ2VzXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCB4aHIucmVhZHlTdGF0ZSA9PT0gNCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBBbGxvdyBvbmVycm9yIHRvIGJlIGNhbGxlZCBmaXJzdCxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBidXQgdGhhdCB3aWxsIG5vdCBoYW5kbGUgYSBuYXRpdmUgYWJvcnRcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBBbHNvLCBzYXZlIGVycm9yQ2FsbGJhY2sgdG8gYSB2YXJpYWJsZVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIGFzIHhoci5vbmVycm9yIGNhbm5vdCBiZSBhY2Nlc3NlZFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGNhbGxiYWNrICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGVycm9yQ2FsbGJhY2soKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fSApO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9O1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBDcmVhdGUgdGhlIGFib3J0IGNhbGxiYWNrXFxuXFx0XFx0XFx0XFx0Y2FsbGJhY2sgPSBjYWxsYmFjayggXFxcImFib3J0XFxcIiApO1xcblxcblxcdFxcdFxcdFxcdHRyeSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gRG8gc2VuZCB0aGUgcmVxdWVzdCAodGhpcyBtYXkgcmFpc2UgYW4gZXhjZXB0aW9uKVxcblxcdFxcdFxcdFxcdFxcdHhoci5zZW5kKCBvcHRpb25zLmhhc0NvbnRlbnQgJiYgb3B0aW9ucy5kYXRhIHx8IG51bGwgKTtcXG5cXHRcXHRcXHRcXHR9IGNhdGNoICggZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyAjMTQ2ODM6IE9ubHkgcmV0aHJvdyBpZiB0aGlzIGhhc24ndCBiZWVuIG5vdGlmaWVkIGFzIGFuIGVycm9yIHlldFxcblxcdFxcdFxcdFxcdFxcdGlmICggY2FsbGJhY2sgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhyb3cgZTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0YWJvcnQ6IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdGlmICggY2FsbGJhY2sgKSB7XFxuXFx0XFx0XFx0XFx0XFx0Y2FsbGJhY2soKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH07XFxuXFx0fVxcbn0gKTtcXG5cXG5cXG5cXG5cXG4vLyBQcmV2ZW50IGF1dG8tZXhlY3V0aW9uIG9mIHNjcmlwdHMgd2hlbiBubyBleHBsaWNpdCBkYXRhVHlwZSB3YXMgcHJvdmlkZWQgKFNlZSBnaC0yNDMyKVxcbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBmdW5jdGlvbiggcyApIHtcXG5cXHRpZiAoIHMuY3Jvc3NEb21haW4gKSB7XFxuXFx0XFx0cy5jb250ZW50cy5zY3JpcHQgPSBmYWxzZTtcXG5cXHR9XFxufSApO1xcblxcbi8vIEluc3RhbGwgc2NyaXB0IGRhdGFUeXBlXFxualF1ZXJ5LmFqYXhTZXR1cCgge1xcblxcdGFjY2VwdHM6IHtcXG5cXHRcXHRzY3JpcHQ6IFxcXCJ0ZXh0L2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL2phdmFzY3JpcHQsIFxcXCIgK1xcblxcdFxcdFxcdFxcXCJhcHBsaWNhdGlvbi9lY21hc2NyaXB0LCBhcHBsaWNhdGlvbi94LWVjbWFzY3JpcHRcXFwiXFxuXFx0fSxcXG5cXHRjb250ZW50czoge1xcblxcdFxcdHNjcmlwdDogL1xcXFxiKD86amF2YXxlY21hKXNjcmlwdFxcXFxiL1xcblxcdH0sXFxuXFx0Y29udmVydGVyczoge1xcblxcdFxcdFxcXCJ0ZXh0IHNjcmlwdFxcXCI6IGZ1bmN0aW9uKCB0ZXh0ICkge1xcblxcdFxcdFxcdGpRdWVyeS5nbG9iYWxFdmFsKCB0ZXh0ICk7XFxuXFx0XFx0XFx0cmV0dXJuIHRleHQ7XFxuXFx0XFx0fVxcblxcdH1cXG59ICk7XFxuXFxuLy8gSGFuZGxlIGNhY2hlJ3Mgc3BlY2lhbCBjYXNlIGFuZCBjcm9zc0RvbWFpblxcbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBcXFwic2NyaXB0XFxcIiwgZnVuY3Rpb24oIHMgKSB7XFxuXFx0aWYgKCBzLmNhY2hlID09PSB1bmRlZmluZWQgKSB7XFxuXFx0XFx0cy5jYWNoZSA9IGZhbHNlO1xcblxcdH1cXG5cXHRpZiAoIHMuY3Jvc3NEb21haW4gKSB7XFxuXFx0XFx0cy50eXBlID0gXFxcIkdFVFxcXCI7XFxuXFx0fVxcbn0gKTtcXG5cXG4vLyBCaW5kIHNjcmlwdCB0YWcgaGFjayB0cmFuc3BvcnRcXG5qUXVlcnkuYWpheFRyYW5zcG9ydCggXFxcInNjcmlwdFxcXCIsIGZ1bmN0aW9uKCBzICkge1xcblxcblxcdC8vIFRoaXMgdHJhbnNwb3J0IG9ubHkgZGVhbHMgd2l0aCBjcm9zcyBkb21haW4gcmVxdWVzdHNcXG5cXHRpZiAoIHMuY3Jvc3NEb21haW4gKSB7XFxuXFx0XFx0dmFyIHNjcmlwdCwgY2FsbGJhY2s7XFxuXFx0XFx0cmV0dXJuIHtcXG5cXHRcXHRcXHRzZW5kOiBmdW5jdGlvbiggXywgY29tcGxldGUgKSB7XFxuXFx0XFx0XFx0XFx0c2NyaXB0ID0galF1ZXJ5KCBcXFwiPHNjcmlwdD5cXFwiICkucHJvcCgge1xcblxcdFxcdFxcdFxcdFxcdGNoYXJzZXQ6IHMuc2NyaXB0Q2hhcnNldCxcXG5cXHRcXHRcXHRcXHRcXHRzcmM6IHMudXJsXFxuXFx0XFx0XFx0XFx0fSApLm9uKFxcblxcdFxcdFxcdFxcdFxcdFxcXCJsb2FkIGVycm9yXFxcIixcXG5cXHRcXHRcXHRcXHRcXHRjYWxsYmFjayA9IGZ1bmN0aW9uKCBldnQgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0c2NyaXB0LnJlbW92ZSgpO1xcblxcdFxcdFxcdFxcdFxcdFxcdGNhbGxiYWNrID0gbnVsbDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGV2dCApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRjb21wbGV0ZSggZXZ0LnR5cGUgPT09IFxcXCJlcnJvclxcXCIgPyA0MDQgOiAyMDAsIGV2dC50eXBlICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHQpO1xcblxcblxcdFxcdFxcdFxcdC8vIFVzZSBuYXRpdmUgRE9NIG1hbmlwdWxhdGlvbiB0byBhdm9pZCBvdXIgZG9tTWFuaXAgQUpBWCB0cmlja2VyeVxcblxcdFxcdFxcdFxcdGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoIHNjcmlwdFsgMCBdICk7XFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRhYm9ydDogZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCBjYWxsYmFjayApIHtcXG5cXHRcXHRcXHRcXHRcXHRjYWxsYmFjaygpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fTtcXG5cXHR9XFxufSApO1xcblxcblxcblxcblxcbnZhciBvbGRDYWxsYmFja3MgPSBbXSxcXG5cXHRyanNvbnAgPSAvKD0pXFxcXD8oPz0mfCQpfFxcXFw/XFxcXD8vO1xcblxcbi8vIERlZmF1bHQganNvbnAgc2V0dGluZ3NcXG5qUXVlcnkuYWpheFNldHVwKCB7XFxuXFx0anNvbnA6IFxcXCJjYWxsYmFja1xcXCIsXFxuXFx0anNvbnBDYWxsYmFjazogZnVuY3Rpb24oKSB7XFxuXFx0XFx0dmFyIGNhbGxiYWNrID0gb2xkQ2FsbGJhY2tzLnBvcCgpIHx8ICggalF1ZXJ5LmV4cGFuZG8gKyBcXFwiX1xcXCIgKyAoIG5vbmNlKysgKSApO1xcblxcdFxcdHRoaXNbIGNhbGxiYWNrIF0gPSB0cnVlO1xcblxcdFxcdHJldHVybiBjYWxsYmFjaztcXG5cXHR9XFxufSApO1xcblxcbi8vIERldGVjdCwgbm9ybWFsaXplIG9wdGlvbnMgYW5kIGluc3RhbGwgY2FsbGJhY2tzIGZvciBqc29ucCByZXF1ZXN0c1xcbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBcXFwianNvbiBqc29ucFxcXCIsIGZ1bmN0aW9uKCBzLCBvcmlnaW5hbFNldHRpbmdzLCBqcVhIUiApIHtcXG5cXG5cXHR2YXIgY2FsbGJhY2tOYW1lLCBvdmVyd3JpdHRlbiwgcmVzcG9uc2VDb250YWluZXIsXFxuXFx0XFx0anNvblByb3AgPSBzLmpzb25wICE9PSBmYWxzZSAmJiAoIHJqc29ucC50ZXN0KCBzLnVybCApID9cXG5cXHRcXHRcXHRcXFwidXJsXFxcIiA6XFxuXFx0XFx0XFx0dHlwZW9mIHMuZGF0YSA9PT0gXFxcInN0cmluZ1xcXCIgJiZcXG5cXHRcXHRcXHRcXHQoIHMuY29udGVudFR5cGUgfHwgXFxcIlxcXCIgKVxcblxcdFxcdFxcdFxcdFxcdC5pbmRleE9mKCBcXFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXFxcIiApID09PSAwICYmXFxuXFx0XFx0XFx0XFx0cmpzb25wLnRlc3QoIHMuZGF0YSApICYmIFxcXCJkYXRhXFxcIlxcblxcdFxcdCk7XFxuXFxuXFx0Ly8gSGFuZGxlIGlmZiB0aGUgZXhwZWN0ZWQgZGF0YSB0eXBlIGlzIFxcXCJqc29ucFxcXCIgb3Igd2UgaGF2ZSBhIHBhcmFtZXRlciB0byBzZXRcXG5cXHRpZiAoIGpzb25Qcm9wIHx8IHMuZGF0YVR5cGVzWyAwIF0gPT09IFxcXCJqc29ucFxcXCIgKSB7XFxuXFxuXFx0XFx0Ly8gR2V0IGNhbGxiYWNrIG5hbWUsIHJlbWVtYmVyaW5nIHByZWV4aXN0aW5nIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCBpdFxcblxcdFxcdGNhbGxiYWNrTmFtZSA9IHMuanNvbnBDYWxsYmFjayA9IGlzRnVuY3Rpb24oIHMuanNvbnBDYWxsYmFjayApID9cXG5cXHRcXHRcXHRzLmpzb25wQ2FsbGJhY2soKSA6XFxuXFx0XFx0XFx0cy5qc29ucENhbGxiYWNrO1xcblxcblxcdFxcdC8vIEluc2VydCBjYWxsYmFjayBpbnRvIHVybCBvciBmb3JtIGRhdGFcXG5cXHRcXHRpZiAoIGpzb25Qcm9wICkge1xcblxcdFxcdFxcdHNbIGpzb25Qcm9wIF0gPSBzWyBqc29uUHJvcCBdLnJlcGxhY2UoIHJqc29ucCwgXFxcIiQxXFxcIiArIGNhbGxiYWNrTmFtZSApO1xcblxcdFxcdH0gZWxzZSBpZiAoIHMuanNvbnAgIT09IGZhbHNlICkge1xcblxcdFxcdFxcdHMudXJsICs9ICggcnF1ZXJ5LnRlc3QoIHMudXJsICkgPyBcXFwiJlxcXCIgOiBcXFwiP1xcXCIgKSArIHMuanNvbnAgKyBcXFwiPVxcXCIgKyBjYWxsYmFja05hbWU7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIFVzZSBkYXRhIGNvbnZlcnRlciB0byByZXRyaWV2ZSBqc29uIGFmdGVyIHNjcmlwdCBleGVjdXRpb25cXG5cXHRcXHRzLmNvbnZlcnRlcnNbIFxcXCJzY3JpcHQganNvblxcXCIgXSA9IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdGlmICggIXJlc3BvbnNlQ29udGFpbmVyICkge1xcblxcdFxcdFxcdFxcdGpRdWVyeS5lcnJvciggY2FsbGJhY2tOYW1lICsgXFxcIiB3YXMgbm90IGNhbGxlZFxcXCIgKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cmV0dXJuIHJlc3BvbnNlQ29udGFpbmVyWyAwIF07XFxuXFx0XFx0fTtcXG5cXG5cXHRcXHQvLyBGb3JjZSBqc29uIGRhdGFUeXBlXFxuXFx0XFx0cy5kYXRhVHlwZXNbIDAgXSA9IFxcXCJqc29uXFxcIjtcXG5cXG5cXHRcXHQvLyBJbnN0YWxsIGNhbGxiYWNrXFxuXFx0XFx0b3ZlcndyaXR0ZW4gPSB3aW5kb3dbIGNhbGxiYWNrTmFtZSBdO1xcblxcdFxcdHdpbmRvd1sgY2FsbGJhY2tOYW1lIF0gPSBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRyZXNwb25zZUNvbnRhaW5lciA9IGFyZ3VtZW50cztcXG5cXHRcXHR9O1xcblxcblxcdFxcdC8vIENsZWFuLXVwIGZ1bmN0aW9uIChmaXJlcyBhZnRlciBjb252ZXJ0ZXJzKVxcblxcdFxcdGpxWEhSLmFsd2F5cyggZnVuY3Rpb24oKSB7XFxuXFxuXFx0XFx0XFx0Ly8gSWYgcHJldmlvdXMgdmFsdWUgZGlkbid0IGV4aXN0IC0gcmVtb3ZlIGl0XFxuXFx0XFx0XFx0aWYgKCBvdmVyd3JpdHRlbiA9PT0gdW5kZWZpbmVkICkge1xcblxcdFxcdFxcdFxcdGpRdWVyeSggd2luZG93ICkucmVtb3ZlUHJvcCggY2FsbGJhY2tOYW1lICk7XFxuXFxuXFx0XFx0XFx0Ly8gT3RoZXJ3aXNlIHJlc3RvcmUgcHJlZXhpc3RpbmcgdmFsdWVcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdHdpbmRvd1sgY2FsbGJhY2tOYW1lIF0gPSBvdmVyd3JpdHRlbjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gU2F2ZSBiYWNrIGFzIGZyZWVcXG5cXHRcXHRcXHRpZiAoIHNbIGNhbGxiYWNrTmFtZSBdICkge1xcblxcblxcdFxcdFxcdFxcdC8vIE1ha2Ugc3VyZSB0aGF0IHJlLXVzaW5nIHRoZSBvcHRpb25zIGRvZXNuJ3Qgc2NyZXcgdGhpbmdzIGFyb3VuZFxcblxcdFxcdFxcdFxcdHMuanNvbnBDYWxsYmFjayA9IG9yaWdpbmFsU2V0dGluZ3MuanNvbnBDYWxsYmFjaztcXG5cXG5cXHRcXHRcXHRcXHQvLyBTYXZlIHRoZSBjYWxsYmFjayBuYW1lIGZvciBmdXR1cmUgdXNlXFxuXFx0XFx0XFx0XFx0b2xkQ2FsbGJhY2tzLnB1c2goIGNhbGxiYWNrTmFtZSApO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBDYWxsIGlmIGl0IHdhcyBhIGZ1bmN0aW9uIGFuZCB3ZSBoYXZlIGEgcmVzcG9uc2VcXG5cXHRcXHRcXHRpZiAoIHJlc3BvbnNlQ29udGFpbmVyICYmIGlzRnVuY3Rpb24oIG92ZXJ3cml0dGVuICkgKSB7XFxuXFx0XFx0XFx0XFx0b3ZlcndyaXR0ZW4oIHJlc3BvbnNlQ29udGFpbmVyWyAwIF0gKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmVzcG9uc2VDb250YWluZXIgPSBvdmVyd3JpdHRlbiA9IHVuZGVmaW5lZDtcXG5cXHRcXHR9ICk7XFxuXFxuXFx0XFx0Ly8gRGVsZWdhdGUgdG8gc2NyaXB0XFxuXFx0XFx0cmV0dXJuIFxcXCJzY3JpcHRcXFwiO1xcblxcdH1cXG59ICk7XFxuXFxuXFxuXFxuXFxuLy8gU3VwcG9ydDogU2FmYXJpIDggb25seVxcbi8vIEluIFNhZmFyaSA4IGRvY3VtZW50cyBjcmVhdGVkIHZpYSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnRcXG4vLyBjb2xsYXBzZSBzaWJsaW5nIGZvcm1zOiB0aGUgc2Vjb25kIG9uZSBiZWNvbWVzIGEgY2hpbGQgb2YgdGhlIGZpcnN0IG9uZS5cXG4vLyBCZWNhdXNlIG9mIHRoYXQsIHRoaXMgc2VjdXJpdHkgbWVhc3VyZSBoYXMgdG8gYmUgZGlzYWJsZWQgaW4gU2FmYXJpIDguXFxuLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEzNzMzN1xcbnN1cHBvcnQuY3JlYXRlSFRNTERvY3VtZW50ID0gKCBmdW5jdGlvbigpIHtcXG5cXHR2YXIgYm9keSA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCggXFxcIlxcXCIgKS5ib2R5O1xcblxcdGJvZHkuaW5uZXJIVE1MID0gXFxcIjxmb3JtPjwvZm9ybT48Zm9ybT48L2Zvcm0+XFxcIjtcXG5cXHRyZXR1cm4gYm9keS5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMjtcXG59ICkoKTtcXG5cXG5cXG4vLyBBcmd1bWVudCBcXFwiZGF0YVxcXCIgc2hvdWxkIGJlIHN0cmluZyBvZiBodG1sXFxuLy8gY29udGV4dCAob3B0aW9uYWwpOiBJZiBzcGVjaWZpZWQsIHRoZSBmcmFnbWVudCB3aWxsIGJlIGNyZWF0ZWQgaW4gdGhpcyBjb250ZXh0LFxcbi8vIGRlZmF1bHRzIHRvIGRvY3VtZW50XFxuLy8ga2VlcFNjcmlwdHMgKG9wdGlvbmFsKTogSWYgdHJ1ZSwgd2lsbCBpbmNsdWRlIHNjcmlwdHMgcGFzc2VkIGluIHRoZSBodG1sIHN0cmluZ1xcbmpRdWVyeS5wYXJzZUhUTUwgPSBmdW5jdGlvbiggZGF0YSwgY29udGV4dCwga2VlcFNjcmlwdHMgKSB7XFxuXFx0aWYgKCB0eXBlb2YgZGF0YSAhPT0gXFxcInN0cmluZ1xcXCIgKSB7XFxuXFx0XFx0cmV0dXJuIFtdO1xcblxcdH1cXG5cXHRpZiAoIHR5cGVvZiBjb250ZXh0ID09PSBcXFwiYm9vbGVhblxcXCIgKSB7XFxuXFx0XFx0a2VlcFNjcmlwdHMgPSBjb250ZXh0O1xcblxcdFxcdGNvbnRleHQgPSBmYWxzZTtcXG5cXHR9XFxuXFxuXFx0dmFyIGJhc2UsIHBhcnNlZCwgc2NyaXB0cztcXG5cXG5cXHRpZiAoICFjb250ZXh0ICkge1xcblxcblxcdFxcdC8vIFN0b3Agc2NyaXB0cyBvciBpbmxpbmUgZXZlbnQgaGFuZGxlcnMgZnJvbSBiZWluZyBleGVjdXRlZCBpbW1lZGlhdGVseVxcblxcdFxcdC8vIGJ5IHVzaW5nIGRvY3VtZW50LmltcGxlbWVudGF0aW9uXFxuXFx0XFx0aWYgKCBzdXBwb3J0LmNyZWF0ZUhUTUxEb2N1bWVudCApIHtcXG5cXHRcXHRcXHRjb250ZXh0ID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCBcXFwiXFxcIiApO1xcblxcblxcdFxcdFxcdC8vIFNldCB0aGUgYmFzZSBocmVmIGZvciB0aGUgY3JlYXRlZCBkb2N1bWVudFxcblxcdFxcdFxcdC8vIHNvIGFueSBwYXJzZWQgZWxlbWVudHMgd2l0aCBVUkxzXFxuXFx0XFx0XFx0Ly8gYXJlIGJhc2VkIG9uIHRoZSBkb2N1bWVudCdzIFVSTCAoZ2gtMjk2NSlcXG5cXHRcXHRcXHRiYXNlID0gY29udGV4dC5jcmVhdGVFbGVtZW50KCBcXFwiYmFzZVxcXCIgKTtcXG5cXHRcXHRcXHRiYXNlLmhyZWYgPSBkb2N1bWVudC5sb2NhdGlvbi5ocmVmO1xcblxcdFxcdFxcdGNvbnRleHQuaGVhZC5hcHBlbmRDaGlsZCggYmFzZSApO1xcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0Y29udGV4dCA9IGRvY3VtZW50O1xcblxcdFxcdH1cXG5cXHR9XFxuXFxuXFx0cGFyc2VkID0gcnNpbmdsZVRhZy5leGVjKCBkYXRhICk7XFxuXFx0c2NyaXB0cyA9ICFrZWVwU2NyaXB0cyAmJiBbXTtcXG5cXG5cXHQvLyBTaW5nbGUgdGFnXFxuXFx0aWYgKCBwYXJzZWQgKSB7XFxuXFx0XFx0cmV0dXJuIFsgY29udGV4dC5jcmVhdGVFbGVtZW50KCBwYXJzZWRbIDEgXSApIF07XFxuXFx0fVxcblxcblxcdHBhcnNlZCA9IGJ1aWxkRnJhZ21lbnQoIFsgZGF0YSBdLCBjb250ZXh0LCBzY3JpcHRzICk7XFxuXFxuXFx0aWYgKCBzY3JpcHRzICYmIHNjcmlwdHMubGVuZ3RoICkge1xcblxcdFxcdGpRdWVyeSggc2NyaXB0cyApLnJlbW92ZSgpO1xcblxcdH1cXG5cXG5cXHRyZXR1cm4galF1ZXJ5Lm1lcmdlKCBbXSwgcGFyc2VkLmNoaWxkTm9kZXMgKTtcXG59O1xcblxcblxcbi8qKlxcbiAqIExvYWQgYSB1cmwgaW50byBhIHBhZ2VcXG4gKi9cXG5qUXVlcnkuZm4ubG9hZCA9IGZ1bmN0aW9uKCB1cmwsIHBhcmFtcywgY2FsbGJhY2sgKSB7XFxuXFx0dmFyIHNlbGVjdG9yLCB0eXBlLCByZXNwb25zZSxcXG5cXHRcXHRzZWxmID0gdGhpcyxcXG5cXHRcXHRvZmYgPSB1cmwuaW5kZXhPZiggXFxcIiBcXFwiICk7XFxuXFxuXFx0aWYgKCBvZmYgPiAtMSApIHtcXG5cXHRcXHRzZWxlY3RvciA9IHN0cmlwQW5kQ29sbGFwc2UoIHVybC5zbGljZSggb2ZmICkgKTtcXG5cXHRcXHR1cmwgPSB1cmwuc2xpY2UoIDAsIG9mZiApO1xcblxcdH1cXG5cXG5cXHQvLyBJZiBpdCdzIGEgZnVuY3Rpb25cXG5cXHRpZiAoIGlzRnVuY3Rpb24oIHBhcmFtcyApICkge1xcblxcblxcdFxcdC8vIFdlIGFzc3VtZSB0aGF0IGl0J3MgdGhlIGNhbGxiYWNrXFxuXFx0XFx0Y2FsbGJhY2sgPSBwYXJhbXM7XFxuXFx0XFx0cGFyYW1zID0gdW5kZWZpbmVkO1xcblxcblxcdC8vIE90aGVyd2lzZSwgYnVpbGQgYSBwYXJhbSBzdHJpbmdcXG5cXHR9IGVsc2UgaWYgKCBwYXJhbXMgJiYgdHlwZW9mIHBhcmFtcyA9PT0gXFxcIm9iamVjdFxcXCIgKSB7XFxuXFx0XFx0dHlwZSA9IFxcXCJQT1NUXFxcIjtcXG5cXHR9XFxuXFxuXFx0Ly8gSWYgd2UgaGF2ZSBlbGVtZW50cyB0byBtb2RpZnksIG1ha2UgdGhlIHJlcXVlc3RcXG5cXHRpZiAoIHNlbGYubGVuZ3RoID4gMCApIHtcXG5cXHRcXHRqUXVlcnkuYWpheCgge1xcblxcdFxcdFxcdHVybDogdXJsLFxcblxcblxcdFxcdFxcdC8vIElmIFxcXCJ0eXBlXFxcIiB2YXJpYWJsZSBpcyB1bmRlZmluZWQsIHRoZW4gXFxcIkdFVFxcXCIgbWV0aG9kIHdpbGwgYmUgdXNlZC5cXG5cXHRcXHRcXHQvLyBNYWtlIHZhbHVlIG9mIHRoaXMgZmllbGQgZXhwbGljaXQgc2luY2VcXG5cXHRcXHRcXHQvLyB1c2VyIGNhbiBvdmVycmlkZSBpdCB0aHJvdWdoIGFqYXhTZXR1cCBtZXRob2RcXG5cXHRcXHRcXHR0eXBlOiB0eXBlIHx8IFxcXCJHRVRcXFwiLFxcblxcdFxcdFxcdGRhdGFUeXBlOiBcXFwiaHRtbFxcXCIsXFxuXFx0XFx0XFx0ZGF0YTogcGFyYW1zXFxuXFx0XFx0fSApLmRvbmUoIGZ1bmN0aW9uKCByZXNwb25zZVRleHQgKSB7XFxuXFxuXFx0XFx0XFx0Ly8gU2F2ZSByZXNwb25zZSBmb3IgdXNlIGluIGNvbXBsZXRlIGNhbGxiYWNrXFxuXFx0XFx0XFx0cmVzcG9uc2UgPSBhcmd1bWVudHM7XFxuXFxuXFx0XFx0XFx0c2VsZi5odG1sKCBzZWxlY3RvciA/XFxuXFxuXFx0XFx0XFx0XFx0Ly8gSWYgYSBzZWxlY3RvciB3YXMgc3BlY2lmaWVkLCBsb2NhdGUgdGhlIHJpZ2h0IGVsZW1lbnRzIGluIGEgZHVtbXkgZGl2XFxuXFx0XFx0XFx0XFx0Ly8gRXhjbHVkZSBzY3JpcHRzIHRvIGF2b2lkIElFICdQZXJtaXNzaW9uIERlbmllZCcgZXJyb3JzXFxuXFx0XFx0XFx0XFx0alF1ZXJ5KCBcXFwiPGRpdj5cXFwiICkuYXBwZW5kKCBqUXVlcnkucGFyc2VIVE1MKCByZXNwb25zZVRleHQgKSApLmZpbmQoIHNlbGVjdG9yICkgOlxcblxcblxcdFxcdFxcdFxcdC8vIE90aGVyd2lzZSB1c2UgdGhlIGZ1bGwgcmVzdWx0XFxuXFx0XFx0XFx0XFx0cmVzcG9uc2VUZXh0ICk7XFxuXFxuXFx0XFx0Ly8gSWYgdGhlIHJlcXVlc3Qgc3VjY2VlZHMsIHRoaXMgZnVuY3Rpb24gZ2V0cyBcXFwiZGF0YVxcXCIsIFxcXCJzdGF0dXNcXFwiLCBcXFwianFYSFJcXFwiXFxuXFx0XFx0Ly8gYnV0IHRoZXkgYXJlIGlnbm9yZWQgYmVjYXVzZSByZXNwb25zZSB3YXMgc2V0IGFib3ZlLlxcblxcdFxcdC8vIElmIGl0IGZhaWxzLCB0aGlzIGZ1bmN0aW9uIGdldHMgXFxcImpxWEhSXFxcIiwgXFxcInN0YXR1c1xcXCIsIFxcXCJlcnJvclxcXCJcXG5cXHRcXHR9ICkuYWx3YXlzKCBjYWxsYmFjayAmJiBmdW5jdGlvbigganFYSFIsIHN0YXR1cyApIHtcXG5cXHRcXHRcXHRzZWxmLmVhY2goIGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdGNhbGxiYWNrLmFwcGx5KCB0aGlzLCByZXNwb25zZSB8fCBbIGpxWEhSLnJlc3BvbnNlVGV4dCwgc3RhdHVzLCBqcVhIUiBdICk7XFxuXFx0XFx0XFx0fSApO1xcblxcdFxcdH0gKTtcXG5cXHR9XFxuXFxuXFx0cmV0dXJuIHRoaXM7XFxufTtcXG5cXG5cXG5cXG5cXG4vLyBBdHRhY2ggYSBidW5jaCBvZiBmdW5jdGlvbnMgZm9yIGhhbmRsaW5nIGNvbW1vbiBBSkFYIGV2ZW50c1xcbmpRdWVyeS5lYWNoKCBbXFxuXFx0XFxcImFqYXhTdGFydFxcXCIsXFxuXFx0XFxcImFqYXhTdG9wXFxcIixcXG5cXHRcXFwiYWpheENvbXBsZXRlXFxcIixcXG5cXHRcXFwiYWpheEVycm9yXFxcIixcXG5cXHRcXFwiYWpheFN1Y2Nlc3NcXFwiLFxcblxcdFxcXCJhamF4U2VuZFxcXCJcXG5dLCBmdW5jdGlvbiggaSwgdHlwZSApIHtcXG5cXHRqUXVlcnkuZm5bIHR5cGUgXSA9IGZ1bmN0aW9uKCBmbiApIHtcXG5cXHRcXHRyZXR1cm4gdGhpcy5vbiggdHlwZSwgZm4gKTtcXG5cXHR9O1xcbn0gKTtcXG5cXG5cXG5cXG5cXG5qUXVlcnkuZXhwci5wc2V1ZG9zLmFuaW1hdGVkID0gZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBqUXVlcnkudGltZXJzLCBmdW5jdGlvbiggZm4gKSB7XFxuXFx0XFx0cmV0dXJuIGVsZW0gPT09IGZuLmVsZW07XFxuXFx0fSApLmxlbmd0aDtcXG59O1xcblxcblxcblxcblxcbmpRdWVyeS5vZmZzZXQgPSB7XFxuXFx0c2V0T2Zmc2V0OiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgaSApIHtcXG5cXHRcXHR2YXIgY3VyUG9zaXRpb24sIGN1ckxlZnQsIGN1ckNTU1RvcCwgY3VyVG9wLCBjdXJPZmZzZXQsIGN1ckNTU0xlZnQsIGNhbGN1bGF0ZVBvc2l0aW9uLFxcblxcdFxcdFxcdHBvc2l0aW9uID0galF1ZXJ5LmNzcyggZWxlbSwgXFxcInBvc2l0aW9uXFxcIiApLFxcblxcdFxcdFxcdGN1ckVsZW0gPSBqUXVlcnkoIGVsZW0gKSxcXG5cXHRcXHRcXHRwcm9wcyA9IHt9O1xcblxcblxcdFxcdC8vIFNldCBwb3NpdGlvbiBmaXJzdCwgaW4tY2FzZSB0b3AvbGVmdCBhcmUgc2V0IGV2ZW4gb24gc3RhdGljIGVsZW1cXG5cXHRcXHRpZiAoIHBvc2l0aW9uID09PSBcXFwic3RhdGljXFxcIiApIHtcXG5cXHRcXHRcXHRlbGVtLnN0eWxlLnBvc2l0aW9uID0gXFxcInJlbGF0aXZlXFxcIjtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Y3VyT2Zmc2V0ID0gY3VyRWxlbS5vZmZzZXQoKTtcXG5cXHRcXHRjdXJDU1NUb3AgPSBqUXVlcnkuY3NzKCBlbGVtLCBcXFwidG9wXFxcIiApO1xcblxcdFxcdGN1ckNTU0xlZnQgPSBqUXVlcnkuY3NzKCBlbGVtLCBcXFwibGVmdFxcXCIgKTtcXG5cXHRcXHRjYWxjdWxhdGVQb3NpdGlvbiA9ICggcG9zaXRpb24gPT09IFxcXCJhYnNvbHV0ZVxcXCIgfHwgcG9zaXRpb24gPT09IFxcXCJmaXhlZFxcXCIgKSAmJlxcblxcdFxcdFxcdCggY3VyQ1NTVG9wICsgY3VyQ1NTTGVmdCApLmluZGV4T2YoIFxcXCJhdXRvXFxcIiApID4gLTE7XFxuXFxuXFx0XFx0Ly8gTmVlZCB0byBiZSBhYmxlIHRvIGNhbGN1bGF0ZSBwb3NpdGlvbiBpZiBlaXRoZXJcXG5cXHRcXHQvLyB0b3Agb3IgbGVmdCBpcyBhdXRvIGFuZCBwb3NpdGlvbiBpcyBlaXRoZXIgYWJzb2x1dGUgb3IgZml4ZWRcXG5cXHRcXHRpZiAoIGNhbGN1bGF0ZVBvc2l0aW9uICkge1xcblxcdFxcdFxcdGN1clBvc2l0aW9uID0gY3VyRWxlbS5wb3NpdGlvbigpO1xcblxcdFxcdFxcdGN1clRvcCA9IGN1clBvc2l0aW9uLnRvcDtcXG5cXHRcXHRcXHRjdXJMZWZ0ID0gY3VyUG9zaXRpb24ubGVmdDtcXG5cXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdGN1clRvcCA9IHBhcnNlRmxvYXQoIGN1ckNTU1RvcCApIHx8IDA7XFxuXFx0XFx0XFx0Y3VyTGVmdCA9IHBhcnNlRmxvYXQoIGN1ckNTU0xlZnQgKSB8fCAwO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAoIGlzRnVuY3Rpb24oIG9wdGlvbnMgKSApIHtcXG5cXG5cXHRcXHRcXHQvLyBVc2UgalF1ZXJ5LmV4dGVuZCBoZXJlIHRvIGFsbG93IG1vZGlmaWNhdGlvbiBvZiBjb29yZGluYXRlcyBhcmd1bWVudCAoZ2gtMTg0OClcXG5cXHRcXHRcXHRvcHRpb25zID0gb3B0aW9ucy5jYWxsKCBlbGVtLCBpLCBqUXVlcnkuZXh0ZW5kKCB7fSwgY3VyT2Zmc2V0ICkgKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKCBvcHRpb25zLnRvcCAhPSBudWxsICkge1xcblxcdFxcdFxcdHByb3BzLnRvcCA9ICggb3B0aW9ucy50b3AgLSBjdXJPZmZzZXQudG9wICkgKyBjdXJUb3A7XFxuXFx0XFx0fVxcblxcdFxcdGlmICggb3B0aW9ucy5sZWZ0ICE9IG51bGwgKSB7XFxuXFx0XFx0XFx0cHJvcHMubGVmdCA9ICggb3B0aW9ucy5sZWZ0IC0gY3VyT2Zmc2V0LmxlZnQgKSArIGN1ckxlZnQ7XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICggXFxcInVzaW5nXFxcIiBpbiBvcHRpb25zICkge1xcblxcdFxcdFxcdG9wdGlvbnMudXNpbmcuY2FsbCggZWxlbSwgcHJvcHMgKTtcXG5cXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdGN1ckVsZW0uY3NzKCBwcm9wcyApO1xcblxcdFxcdH1cXG5cXHR9XFxufTtcXG5cXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XFxuXFxuXFx0Ly8gb2Zmc2V0KCkgcmVsYXRlcyBhbiBlbGVtZW50J3MgYm9yZGVyIGJveCB0byB0aGUgZG9jdW1lbnQgb3JpZ2luXFxuXFx0b2Zmc2V0OiBmdW5jdGlvbiggb3B0aW9ucyApIHtcXG5cXG5cXHRcXHQvLyBQcmVzZXJ2ZSBjaGFpbmluZyBmb3Igc2V0dGVyXFxuXFx0XFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoICkge1xcblxcdFxcdFxcdHJldHVybiBvcHRpb25zID09PSB1bmRlZmluZWQgP1xcblxcdFxcdFxcdFxcdHRoaXMgOlxcblxcdFxcdFxcdFxcdHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0alF1ZXJ5Lm9mZnNldC5zZXRPZmZzZXQoIHRoaXMsIG9wdGlvbnMsIGkgKTtcXG5cXHRcXHRcXHRcXHR9ICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdHZhciByZWN0LCB3aW4sXFxuXFx0XFx0XFx0ZWxlbSA9IHRoaXNbIDAgXTtcXG5cXG5cXHRcXHRpZiAoICFlbGVtICkge1xcblxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gUmV0dXJuIHplcm9zIGZvciBkaXNjb25uZWN0ZWQgYW5kIGhpZGRlbiAoZGlzcGxheTogbm9uZSkgZWxlbWVudHMgKGdoLTIzMTApXFxuXFx0XFx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XFxuXFx0XFx0Ly8gUnVubmluZyBnZXRCb3VuZGluZ0NsaWVudFJlY3Qgb24gYVxcblxcdFxcdC8vIGRpc2Nvbm5lY3RlZCBub2RlIGluIElFIHRocm93cyBhbiBlcnJvclxcblxcdFxcdGlmICggIWVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggKSB7XFxuXFx0XFx0XFx0cmV0dXJuIHsgdG9wOiAwLCBsZWZ0OiAwIH07XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIEdldCBkb2N1bWVudC1yZWxhdGl2ZSBwb3NpdGlvbiBieSBhZGRpbmcgdmlld3BvcnQgc2Nyb2xsIHRvIHZpZXdwb3J0LXJlbGF0aXZlIGdCQ1JcXG5cXHRcXHRyZWN0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcXG5cXHRcXHR3aW4gPSBlbGVtLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XFxuXFx0XFx0cmV0dXJuIHtcXG5cXHRcXHRcXHR0b3A6IHJlY3QudG9wICsgd2luLnBhZ2VZT2Zmc2V0LFxcblxcdFxcdFxcdGxlZnQ6IHJlY3QubGVmdCArIHdpbi5wYWdlWE9mZnNldFxcblxcdFxcdH07XFxuXFx0fSxcXG5cXG5cXHQvLyBwb3NpdGlvbigpIHJlbGF0ZXMgYW4gZWxlbWVudCdzIG1hcmdpbiBib3ggdG8gaXRzIG9mZnNldCBwYXJlbnQncyBwYWRkaW5nIGJveFxcblxcdC8vIFRoaXMgY29ycmVzcG9uZHMgdG8gdGhlIGJlaGF2aW9yIG9mIENTUyBhYnNvbHV0ZSBwb3NpdGlvbmluZ1xcblxcdHBvc2l0aW9uOiBmdW5jdGlvbigpIHtcXG5cXHRcXHRpZiAoICF0aGlzWyAwIF0gKSB7XFxuXFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdH1cXG5cXG5cXHRcXHR2YXIgb2Zmc2V0UGFyZW50LCBvZmZzZXQsIGRvYyxcXG5cXHRcXHRcXHRlbGVtID0gdGhpc1sgMCBdLFxcblxcdFxcdFxcdHBhcmVudE9mZnNldCA9IHsgdG9wOiAwLCBsZWZ0OiAwIH07XFxuXFxuXFx0XFx0Ly8gcG9zaXRpb246Zml4ZWQgZWxlbWVudHMgYXJlIG9mZnNldCBmcm9tIHRoZSB2aWV3cG9ydCwgd2hpY2ggaXRzZWxmIGFsd2F5cyBoYXMgemVybyBvZmZzZXRcXG5cXHRcXHRpZiAoIGpRdWVyeS5jc3MoIGVsZW0sIFxcXCJwb3NpdGlvblxcXCIgKSA9PT0gXFxcImZpeGVkXFxcIiApIHtcXG5cXG5cXHRcXHRcXHQvLyBBc3N1bWUgcG9zaXRpb246Zml4ZWQgaW1wbGllcyBhdmFpbGFiaWxpdHkgb2YgZ2V0Qm91bmRpbmdDbGllbnRSZWN0XFxuXFx0XFx0XFx0b2Zmc2V0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcXG5cXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdG9mZnNldCA9IHRoaXMub2Zmc2V0KCk7XFxuXFxuXFx0XFx0XFx0Ly8gQWNjb3VudCBmb3IgdGhlICpyZWFsKiBvZmZzZXQgcGFyZW50LCB3aGljaCBjYW4gYmUgdGhlIGRvY3VtZW50IG9yIGl0cyByb290IGVsZW1lbnRcXG5cXHRcXHRcXHQvLyB3aGVuIGEgc3RhdGljYWxseSBwb3NpdGlvbmVkIGVsZW1lbnQgaXMgaWRlbnRpZmllZFxcblxcdFxcdFxcdGRvYyA9IGVsZW0ub3duZXJEb2N1bWVudDtcXG5cXHRcXHRcXHRvZmZzZXRQYXJlbnQgPSBlbGVtLm9mZnNldFBhcmVudCB8fCBkb2MuZG9jdW1lbnRFbGVtZW50O1xcblxcdFxcdFxcdHdoaWxlICggb2Zmc2V0UGFyZW50ICYmXFxuXFx0XFx0XFx0XFx0KCBvZmZzZXRQYXJlbnQgPT09IGRvYy5ib2R5IHx8IG9mZnNldFBhcmVudCA9PT0gZG9jLmRvY3VtZW50RWxlbWVudCApICYmXFxuXFx0XFx0XFx0XFx0alF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcXFwicG9zaXRpb25cXFwiICkgPT09IFxcXCJzdGF0aWNcXFwiICkge1xcblxcblxcdFxcdFxcdFxcdG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudC5wYXJlbnROb2RlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoIG9mZnNldFBhcmVudCAmJiBvZmZzZXRQYXJlbnQgIT09IGVsZW0gJiYgb2Zmc2V0UGFyZW50Lm5vZGVUeXBlID09PSAxICkge1xcblxcblxcdFxcdFxcdFxcdC8vIEluY29ycG9yYXRlIGJvcmRlcnMgaW50byBpdHMgb2Zmc2V0LCBzaW5jZSB0aGV5IGFyZSBvdXRzaWRlIGl0cyBjb250ZW50IG9yaWdpblxcblxcdFxcdFxcdFxcdHBhcmVudE9mZnNldCA9IGpRdWVyeSggb2Zmc2V0UGFyZW50ICkub2Zmc2V0KCk7XFxuXFx0XFx0XFx0XFx0cGFyZW50T2Zmc2V0LnRvcCArPSBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFxcXCJib3JkZXJUb3BXaWR0aFxcXCIsIHRydWUgKTtcXG5cXHRcXHRcXHRcXHRwYXJlbnRPZmZzZXQubGVmdCArPSBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFxcXCJib3JkZXJMZWZ0V2lkdGhcXFwiLCB0cnVlICk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBTdWJ0cmFjdCBwYXJlbnQgb2Zmc2V0cyBhbmQgZWxlbWVudCBtYXJnaW5zXFxuXFx0XFx0cmV0dXJuIHtcXG5cXHRcXHRcXHR0b3A6IG9mZnNldC50b3AgLSBwYXJlbnRPZmZzZXQudG9wIC0galF1ZXJ5LmNzcyggZWxlbSwgXFxcIm1hcmdpblRvcFxcXCIsIHRydWUgKSxcXG5cXHRcXHRcXHRsZWZ0OiBvZmZzZXQubGVmdCAtIHBhcmVudE9mZnNldC5sZWZ0IC0galF1ZXJ5LmNzcyggZWxlbSwgXFxcIm1hcmdpbkxlZnRcXFwiLCB0cnVlIClcXG5cXHRcXHR9O1xcblxcdH0sXFxuXFxuXFx0Ly8gVGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gZG9jdW1lbnRFbGVtZW50IGluIHRoZSBmb2xsb3dpbmcgY2FzZXM6XFxuXFx0Ly8gMSkgRm9yIHRoZSBlbGVtZW50IGluc2lkZSB0aGUgaWZyYW1lIHdpdGhvdXQgb2Zmc2V0UGFyZW50LCB0aGlzIG1ldGhvZCB3aWxsIHJldHVyblxcblxcdC8vICAgIGRvY3VtZW50RWxlbWVudCBvZiB0aGUgcGFyZW50IHdpbmRvd1xcblxcdC8vIDIpIEZvciB0aGUgaGlkZGVuIG9yIGRldGFjaGVkIGVsZW1lbnRcXG5cXHQvLyAzKSBGb3IgYm9keSBvciBodG1sIGVsZW1lbnQsIGkuZS4gaW4gY2FzZSBvZiB0aGUgaHRtbCBub2RlIC0gaXQgd2lsbCByZXR1cm4gaXRzZWxmXFxuXFx0Ly9cXG5cXHQvLyBidXQgdGhvc2UgZXhjZXB0aW9ucyB3ZXJlIG5ldmVyIHByZXNlbnRlZCBhcyBhIHJlYWwgbGlmZSB1c2UtY2FzZXNcXG5cXHQvLyBhbmQgbWlnaHQgYmUgY29uc2lkZXJlZCBhcyBtb3JlIHByZWZlcmFibGUgcmVzdWx0cy5cXG5cXHQvL1xcblxcdC8vIFRoaXMgbG9naWMsIGhvd2V2ZXIsIGlzIG5vdCBndWFyYW50ZWVkIGFuZCBjYW4gY2hhbmdlIGF0IGFueSBwb2ludCBpbiB0aGUgZnV0dXJlXFxuXFx0b2Zmc2V0UGFyZW50OiBmdW5jdGlvbigpIHtcXG5cXHRcXHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdHZhciBvZmZzZXRQYXJlbnQgPSB0aGlzLm9mZnNldFBhcmVudDtcXG5cXG5cXHRcXHRcXHR3aGlsZSAoIG9mZnNldFBhcmVudCAmJiBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFxcXCJwb3NpdGlvblxcXCIgKSA9PT0gXFxcInN0YXRpY1xcXCIgKSB7XFxuXFx0XFx0XFx0XFx0b2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50Lm9mZnNldFBhcmVudDtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIG9mZnNldFBhcmVudCB8fCBkb2N1bWVudEVsZW1lbnQ7XFxuXFx0XFx0fSApO1xcblxcdH1cXG59ICk7XFxuXFxuLy8gQ3JlYXRlIHNjcm9sbExlZnQgYW5kIHNjcm9sbFRvcCBtZXRob2RzXFxualF1ZXJ5LmVhY2goIHsgc2Nyb2xsTGVmdDogXFxcInBhZ2VYT2Zmc2V0XFxcIiwgc2Nyb2xsVG9wOiBcXFwicGFnZVlPZmZzZXRcXFwiIH0sIGZ1bmN0aW9uKCBtZXRob2QsIHByb3AgKSB7XFxuXFx0dmFyIHRvcCA9IFxcXCJwYWdlWU9mZnNldFxcXCIgPT09IHByb3A7XFxuXFxuXFx0alF1ZXJ5LmZuWyBtZXRob2QgXSA9IGZ1bmN0aW9uKCB2YWwgKSB7XFxuXFx0XFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIG1ldGhvZCwgdmFsICkge1xcblxcblxcdFxcdFxcdC8vIENvYWxlc2NlIGRvY3VtZW50cyBhbmQgd2luZG93c1xcblxcdFxcdFxcdHZhciB3aW47XFxuXFx0XFx0XFx0aWYgKCBpc1dpbmRvdyggZWxlbSApICkge1xcblxcdFxcdFxcdFxcdHdpbiA9IGVsZW07XFxuXFx0XFx0XFx0fSBlbHNlIGlmICggZWxlbS5ub2RlVHlwZSA9PT0gOSApIHtcXG5cXHRcXHRcXHRcXHR3aW4gPSBlbGVtLmRlZmF1bHRWaWV3O1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIHZhbCA9PT0gdW5kZWZpbmVkICkge1xcblxcdFxcdFxcdFxcdHJldHVybiB3aW4gPyB3aW5bIHByb3AgXSA6IGVsZW1bIG1ldGhvZCBdO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIHdpbiApIHtcXG5cXHRcXHRcXHRcXHR3aW4uc2Nyb2xsVG8oXFxuXFx0XFx0XFx0XFx0XFx0IXRvcCA/IHZhbCA6IHdpbi5wYWdlWE9mZnNldCxcXG5cXHRcXHRcXHRcXHRcXHR0b3AgPyB2YWwgOiB3aW4ucGFnZVlPZmZzZXRcXG5cXHRcXHRcXHRcXHQpO1xcblxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0ZWxlbVsgbWV0aG9kIF0gPSB2YWw7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sIG1ldGhvZCwgdmFsLCBhcmd1bWVudHMubGVuZ3RoICk7XFxuXFx0fTtcXG59ICk7XFxuXFxuLy8gU3VwcG9ydDogU2FmYXJpIDw9NyAtIDkuMSwgQ2hyb21lIDw9MzcgLSA0OVxcbi8vIEFkZCB0aGUgdG9wL2xlZnQgY3NzSG9va3MgdXNpbmcgalF1ZXJ5LmZuLnBvc2l0aW9uXFxuLy8gV2Via2l0IGJ1ZzogaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTI5MDg0XFxuLy8gQmxpbmsgYnVnOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD01ODkzNDdcXG4vLyBnZXRDb21wdXRlZFN0eWxlIHJldHVybnMgcGVyY2VudCB3aGVuIHNwZWNpZmllZCBmb3IgdG9wL2xlZnQvYm90dG9tL3JpZ2h0O1xcbi8vIHJhdGhlciB0aGFuIG1ha2UgdGhlIGNzcyBtb2R1bGUgZGVwZW5kIG9uIHRoZSBvZmZzZXQgbW9kdWxlLCBqdXN0IGNoZWNrIGZvciBpdCBoZXJlXFxualF1ZXJ5LmVhY2goIFsgXFxcInRvcFxcXCIsIFxcXCJsZWZ0XFxcIiBdLCBmdW5jdGlvbiggaSwgcHJvcCApIHtcXG5cXHRqUXVlcnkuY3NzSG9va3NbIHByb3AgXSA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5waXhlbFBvc2l0aW9uLFxcblxcdFxcdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcXG5cXHRcXHRcXHRpZiAoIGNvbXB1dGVkICkge1xcblxcdFxcdFxcdFxcdGNvbXB1dGVkID0gY3VyQ1NTKCBlbGVtLCBwcm9wICk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gSWYgY3VyQ1NTIHJldHVybnMgcGVyY2VudGFnZSwgZmFsbGJhY2sgdG8gb2Zmc2V0XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHJudW1ub25weC50ZXN0KCBjb21wdXRlZCApID9cXG5cXHRcXHRcXHRcXHRcXHRqUXVlcnkoIGVsZW0gKS5wb3NpdGlvbigpWyBwcm9wIF0gKyBcXFwicHhcXFwiIDpcXG5cXHRcXHRcXHRcXHRcXHRjb21wdXRlZDtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdCk7XFxufSApO1xcblxcblxcbi8vIENyZWF0ZSBpbm5lckhlaWdodCwgaW5uZXJXaWR0aCwgaGVpZ2h0LCB3aWR0aCwgb3V0ZXJIZWlnaHQgYW5kIG91dGVyV2lkdGggbWV0aG9kc1xcbmpRdWVyeS5lYWNoKCB7IEhlaWdodDogXFxcImhlaWdodFxcXCIsIFdpZHRoOiBcXFwid2lkdGhcXFwiIH0sIGZ1bmN0aW9uKCBuYW1lLCB0eXBlICkge1xcblxcdGpRdWVyeS5lYWNoKCB7IHBhZGRpbmc6IFxcXCJpbm5lclxcXCIgKyBuYW1lLCBjb250ZW50OiB0eXBlLCBcXFwiXFxcIjogXFxcIm91dGVyXFxcIiArIG5hbWUgfSxcXG5cXHRcXHRmdW5jdGlvbiggZGVmYXVsdEV4dHJhLCBmdW5jTmFtZSApIHtcXG5cXG5cXHRcXHQvLyBNYXJnaW4gaXMgb25seSBmb3Igb3V0ZXJIZWlnaHQsIG91dGVyV2lkdGhcXG5cXHRcXHRqUXVlcnkuZm5bIGZ1bmNOYW1lIF0gPSBmdW5jdGlvbiggbWFyZ2luLCB2YWx1ZSApIHtcXG5cXHRcXHRcXHR2YXIgY2hhaW5hYmxlID0gYXJndW1lbnRzLmxlbmd0aCAmJiAoIGRlZmF1bHRFeHRyYSB8fCB0eXBlb2YgbWFyZ2luICE9PSBcXFwiYm9vbGVhblxcXCIgKSxcXG5cXHRcXHRcXHRcXHRleHRyYSA9IGRlZmF1bHRFeHRyYSB8fCAoIG1hcmdpbiA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gdHJ1ZSA/IFxcXCJtYXJnaW5cXFwiIDogXFxcImJvcmRlclxcXCIgKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgdHlwZSwgdmFsdWUgKSB7XFxuXFx0XFx0XFx0XFx0dmFyIGRvYztcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGlzV2luZG93KCBlbGVtICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gJCggd2luZG93ICkub3V0ZXJXaWR0aC9IZWlnaHQgcmV0dXJuIHcvaCBpbmNsdWRpbmcgc2Nyb2xsYmFycyAoZ2gtMTcyOSlcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gZnVuY05hbWUuaW5kZXhPZiggXFxcIm91dGVyXFxcIiApID09PSAwID9cXG5cXHRcXHRcXHRcXHRcXHRcXHRlbGVtWyBcXFwiaW5uZXJcXFwiICsgbmFtZSBdIDpcXG5cXHRcXHRcXHRcXHRcXHRcXHRlbGVtLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudFsgXFxcImNsaWVudFxcXCIgKyBuYW1lIF07XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIEdldCBkb2N1bWVudCB3aWR0aCBvciBoZWlnaHRcXG5cXHRcXHRcXHRcXHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZG9jID0gZWxlbS5kb2N1bWVudEVsZW1lbnQ7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gRWl0aGVyIHNjcm9sbFtXaWR0aC9IZWlnaHRdIG9yIG9mZnNldFtXaWR0aC9IZWlnaHRdIG9yIGNsaWVudFtXaWR0aC9IZWlnaHRdLFxcblxcdFxcdFxcdFxcdFxcdC8vIHdoaWNoZXZlciBpcyBncmVhdGVzdFxcblxcdFxcdFxcdFxcdFxcdHJldHVybiBNYXRoLm1heChcXG5cXHRcXHRcXHRcXHRcXHRcXHRlbGVtLmJvZHlbIFxcXCJzY3JvbGxcXFwiICsgbmFtZSBdLCBkb2NbIFxcXCJzY3JvbGxcXFwiICsgbmFtZSBdLFxcblxcdFxcdFxcdFxcdFxcdFxcdGVsZW0uYm9keVsgXFxcIm9mZnNldFxcXCIgKyBuYW1lIF0sIGRvY1sgXFxcIm9mZnNldFxcXCIgKyBuYW1lIF0sXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZG9jWyBcXFwiY2xpZW50XFxcIiArIG5hbWUgXVxcblxcdFxcdFxcdFxcdFxcdCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID9cXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBHZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50LCByZXF1ZXN0aW5nIGJ1dCBub3QgZm9yY2luZyBwYXJzZUZsb2F0XFxuXFx0XFx0XFx0XFx0XFx0alF1ZXJ5LmNzcyggZWxlbSwgdHlwZSwgZXh0cmEgKSA6XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gU2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudFxcblxcdFxcdFxcdFxcdFxcdGpRdWVyeS5zdHlsZSggZWxlbSwgdHlwZSwgdmFsdWUsIGV4dHJhICk7XFxuXFx0XFx0XFx0fSwgdHlwZSwgY2hhaW5hYmxlID8gbWFyZ2luIDogdW5kZWZpbmVkLCBjaGFpbmFibGUgKTtcXG5cXHRcXHR9O1xcblxcdH0gKTtcXG59ICk7XFxuXFxuXFxualF1ZXJ5LmVhY2goICggXFxcImJsdXIgZm9jdXMgZm9jdXNpbiBmb2N1c291dCByZXNpemUgc2Nyb2xsIGNsaWNrIGRibGNsaWNrIFxcXCIgK1xcblxcdFxcXCJtb3VzZWRvd24gbW91c2V1cCBtb3VzZW1vdmUgbW91c2VvdmVyIG1vdXNlb3V0IG1vdXNlZW50ZXIgbW91c2VsZWF2ZSBcXFwiICtcXG5cXHRcXFwiY2hhbmdlIHNlbGVjdCBzdWJtaXQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBjb250ZXh0bWVudVxcXCIgKS5zcGxpdCggXFxcIiBcXFwiICksXFxuXFx0ZnVuY3Rpb24oIGksIG5hbWUgKSB7XFxuXFxuXFx0Ly8gSGFuZGxlIGV2ZW50IGJpbmRpbmdcXG5cXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBkYXRhLCBmbiApIHtcXG5cXHRcXHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDAgP1xcblxcdFxcdFxcdHRoaXMub24oIG5hbWUsIG51bGwsIGRhdGEsIGZuICkgOlxcblxcdFxcdFxcdHRoaXMudHJpZ2dlciggbmFtZSApO1xcblxcdH07XFxufSApO1xcblxcbmpRdWVyeS5mbi5leHRlbmQoIHtcXG5cXHRob3ZlcjogZnVuY3Rpb24oIGZuT3ZlciwgZm5PdXQgKSB7XFxuXFx0XFx0cmV0dXJuIHRoaXMubW91c2VlbnRlciggZm5PdmVyICkubW91c2VsZWF2ZSggZm5PdXQgfHwgZm5PdmVyICk7XFxuXFx0fVxcbn0gKTtcXG5cXG5cXG5cXG5cXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XFxuXFxuXFx0YmluZDogZnVuY3Rpb24oIHR5cGVzLCBkYXRhLCBmbiApIHtcXG5cXHRcXHRyZXR1cm4gdGhpcy5vbiggdHlwZXMsIG51bGwsIGRhdGEsIGZuICk7XFxuXFx0fSxcXG5cXHR1bmJpbmQ6IGZ1bmN0aW9uKCB0eXBlcywgZm4gKSB7XFxuXFx0XFx0cmV0dXJuIHRoaXMub2ZmKCB0eXBlcywgbnVsbCwgZm4gKTtcXG5cXHR9LFxcblxcblxcdGRlbGVnYXRlOiBmdW5jdGlvbiggc2VsZWN0b3IsIHR5cGVzLCBkYXRhLCBmbiApIHtcXG5cXHRcXHRyZXR1cm4gdGhpcy5vbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApO1xcblxcdH0sXFxuXFx0dW5kZWxlZ2F0ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCB0eXBlcywgZm4gKSB7XFxuXFxuXFx0XFx0Ly8gKCBuYW1lc3BhY2UgKSBvciAoIHNlbGVjdG9yLCB0eXBlcyBbLCBmbl0gKVxcblxcdFxcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID9cXG5cXHRcXHRcXHR0aGlzLm9mZiggc2VsZWN0b3IsIFxcXCIqKlxcXCIgKSA6XFxuXFx0XFx0XFx0dGhpcy5vZmYoIHR5cGVzLCBzZWxlY3RvciB8fCBcXFwiKipcXFwiLCBmbiApO1xcblxcdH1cXG59ICk7XFxuXFxuLy8gQmluZCBhIGZ1bmN0aW9uIHRvIGEgY29udGV4dCwgb3B0aW9uYWxseSBwYXJ0aWFsbHkgYXBwbHlpbmcgYW55XFxuLy8gYXJndW1lbnRzLlxcbi8vIGpRdWVyeS5wcm94eSBpcyBkZXByZWNhdGVkIHRvIHByb21vdGUgc3RhbmRhcmRzIChzcGVjaWZpY2FsbHkgRnVuY3Rpb24jYmluZClcXG4vLyBIb3dldmVyLCBpdCBpcyBub3Qgc2xhdGVkIGZvciByZW1vdmFsIGFueSB0aW1lIHNvb25cXG5qUXVlcnkucHJveHkgPSBmdW5jdGlvbiggZm4sIGNvbnRleHQgKSB7XFxuXFx0dmFyIHRtcCwgYXJncywgcHJveHk7XFxuXFxuXFx0aWYgKCB0eXBlb2YgY29udGV4dCA9PT0gXFxcInN0cmluZ1xcXCIgKSB7XFxuXFx0XFx0dG1wID0gZm5bIGNvbnRleHQgXTtcXG5cXHRcXHRjb250ZXh0ID0gZm47XFxuXFx0XFx0Zm4gPSB0bXA7XFxuXFx0fVxcblxcblxcdC8vIFF1aWNrIGNoZWNrIHRvIGRldGVybWluZSBpZiB0YXJnZXQgaXMgY2FsbGFibGUsIGluIHRoZSBzcGVjXFxuXFx0Ly8gdGhpcyB0aHJvd3MgYSBUeXBlRXJyb3IsIGJ1dCB3ZSB3aWxsIGp1c3QgcmV0dXJuIHVuZGVmaW5lZC5cXG5cXHRpZiAoICFpc0Z1bmN0aW9uKCBmbiApICkge1xcblxcdFxcdHJldHVybiB1bmRlZmluZWQ7XFxuXFx0fVxcblxcblxcdC8vIFNpbXVsYXRlZCBiaW5kXFxuXFx0YXJncyA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMiApO1xcblxcdHByb3h5ID0gZnVuY3Rpb24oKSB7XFxuXFx0XFx0cmV0dXJuIGZuLmFwcGx5KCBjb250ZXh0IHx8IHRoaXMsIGFyZ3MuY29uY2F0KCBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSApICk7XFxuXFx0fTtcXG5cXG5cXHQvLyBTZXQgdGhlIGd1aWQgb2YgdW5pcXVlIGhhbmRsZXIgdG8gdGhlIHNhbWUgb2Ygb3JpZ2luYWwgaGFuZGxlciwgc28gaXQgY2FuIGJlIHJlbW92ZWRcXG5cXHRwcm94eS5ndWlkID0gZm4uZ3VpZCA9IGZuLmd1aWQgfHwgalF1ZXJ5Lmd1aWQrKztcXG5cXG5cXHRyZXR1cm4gcHJveHk7XFxufTtcXG5cXG5qUXVlcnkuaG9sZFJlYWR5ID0gZnVuY3Rpb24oIGhvbGQgKSB7XFxuXFx0aWYgKCBob2xkICkge1xcblxcdFxcdGpRdWVyeS5yZWFkeVdhaXQrKztcXG5cXHR9IGVsc2Uge1xcblxcdFxcdGpRdWVyeS5yZWFkeSggdHJ1ZSApO1xcblxcdH1cXG59O1xcbmpRdWVyeS5pc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcXG5qUXVlcnkucGFyc2VKU09OID0gSlNPTi5wYXJzZTtcXG5qUXVlcnkubm9kZU5hbWUgPSBub2RlTmFtZTtcXG5qUXVlcnkuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XFxualF1ZXJ5LmlzV2luZG93ID0gaXNXaW5kb3c7XFxualF1ZXJ5LmNhbWVsQ2FzZSA9IGNhbWVsQ2FzZTtcXG5qUXVlcnkudHlwZSA9IHRvVHlwZTtcXG5cXG5qUXVlcnkubm93ID0gRGF0ZS5ub3c7XFxuXFxualF1ZXJ5LmlzTnVtZXJpYyA9IGZ1bmN0aW9uKCBvYmogKSB7XFxuXFxuXFx0Ly8gQXMgb2YgalF1ZXJ5IDMuMCwgaXNOdW1lcmljIGlzIGxpbWl0ZWQgdG9cXG5cXHQvLyBzdHJpbmdzIGFuZCBudW1iZXJzIChwcmltaXRpdmVzIG9yIG9iamVjdHMpXFxuXFx0Ly8gdGhhdCBjYW4gYmUgY29lcmNlZCB0byBmaW5pdGUgbnVtYmVycyAoZ2gtMjY2MilcXG5cXHR2YXIgdHlwZSA9IGpRdWVyeS50eXBlKCBvYmogKTtcXG5cXHRyZXR1cm4gKCB0eXBlID09PSBcXFwibnVtYmVyXFxcIiB8fCB0eXBlID09PSBcXFwic3RyaW5nXFxcIiApICYmXFxuXFxuXFx0XFx0Ly8gcGFyc2VGbG9hdCBOYU5zIG51bWVyaWMtY2FzdCBmYWxzZSBwb3NpdGl2ZXMgKFxcXCJcXFwiKVxcblxcdFxcdC8vIC4uLmJ1dCBtaXNpbnRlcnByZXRzIGxlYWRpbmctbnVtYmVyIHN0cmluZ3MsIHBhcnRpY3VsYXJseSBoZXggbGl0ZXJhbHMgKFxcXCIweC4uLlxcXCIpXFxuXFx0XFx0Ly8gc3VidHJhY3Rpb24gZm9yY2VzIGluZmluaXRpZXMgdG8gTmFOXFxuXFx0XFx0IWlzTmFOKCBvYmogLSBwYXJzZUZsb2F0KCBvYmogKSApO1xcbn07XFxuXFxuXFxuXFxuXFxuLy8gUmVnaXN0ZXIgYXMgYSBuYW1lZCBBTUQgbW9kdWxlLCBzaW5jZSBqUXVlcnkgY2FuIGJlIGNvbmNhdGVuYXRlZCB3aXRoIG90aGVyXFxuLy8gZmlsZXMgdGhhdCBtYXkgdXNlIGRlZmluZSwgYnV0IG5vdCB2aWEgYSBwcm9wZXIgY29uY2F0ZW5hdGlvbiBzY3JpcHQgdGhhdFxcbi8vIHVuZGVyc3RhbmRzIGFub255bW91cyBBTUQgbW9kdWxlcy4gQSBuYW1lZCBBTUQgaXMgc2FmZXN0IGFuZCBtb3N0IHJvYnVzdFxcbi8vIHdheSB0byByZWdpc3Rlci4gTG93ZXJjYXNlIGpxdWVyeSBpcyB1c2VkIGJlY2F1c2UgQU1EIG1vZHVsZSBuYW1lcyBhcmVcXG4vLyBkZXJpdmVkIGZyb20gZmlsZSBuYW1lcywgYW5kIGpRdWVyeSBpcyBub3JtYWxseSBkZWxpdmVyZWQgaW4gYSBsb3dlcmNhc2VcXG4vLyBmaWxlIG5hbWUuIERvIHRoaXMgYWZ0ZXIgY3JlYXRpbmcgdGhlIGdsb2JhbCBzbyB0aGF0IGlmIGFuIEFNRCBtb2R1bGUgd2FudHNcXG4vLyB0byBjYWxsIG5vQ29uZmxpY3QgdG8gaGlkZSB0aGlzIHZlcnNpb24gb2YgalF1ZXJ5LCBpdCB3aWxsIHdvcmsuXFxuXFxuLy8gTm90ZSB0aGF0IGZvciBtYXhpbXVtIHBvcnRhYmlsaXR5LCBsaWJyYXJpZXMgdGhhdCBhcmUgbm90IGpRdWVyeSBzaG91bGRcXG4vLyBkZWNsYXJlIHRoZW1zZWx2ZXMgYXMgYW5vbnltb3VzIG1vZHVsZXMsIGFuZCBhdm9pZCBzZXR0aW5nIGEgZ2xvYmFsIGlmIGFuXFxuLy8gQU1EIGxvYWRlciBpcyBwcmVzZW50LiBqUXVlcnkgaXMgYSBzcGVjaWFsIGNhc2UuIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWVcXG4vLyBodHRwczovL2dpdGh1Yi5jb20vanJidXJrZS9yZXF1aXJlanMvd2lraS9VcGRhdGluZy1leGlzdGluZy1saWJyYXJpZXMjd2lraS1hbm9uXFxuXFxuaWYgKCB0cnVlICkge1xcblxcdCEoX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyA9IFtdLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IGZ1bmN0aW9uKCkge1xcblxcdFxcdHJldHVybiBqUXVlcnk7XFxuXFx0fS5hcHBseShleHBvcnRzLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fKSxcXG5cXHRcXHRcXHRcXHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XFxufVxcblxcblxcblxcblxcbnZhclxcblxcblxcdC8vIE1hcCBvdmVyIGpRdWVyeSBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxcblxcdF9qUXVlcnkgPSB3aW5kb3cualF1ZXJ5LFxcblxcblxcdC8vIE1hcCBvdmVyIHRoZSAkIGluIGNhc2Ugb2Ygb3ZlcndyaXRlXFxuXFx0XyQgPSB3aW5kb3cuJDtcXG5cXG5qUXVlcnkubm9Db25mbGljdCA9IGZ1bmN0aW9uKCBkZWVwICkge1xcblxcdGlmICggd2luZG93LiQgPT09IGpRdWVyeSApIHtcXG5cXHRcXHR3aW5kb3cuJCA9IF8kO1xcblxcdH1cXG5cXG5cXHRpZiAoIGRlZXAgJiYgd2luZG93LmpRdWVyeSA9PT0galF1ZXJ5ICkge1xcblxcdFxcdHdpbmRvdy5qUXVlcnkgPSBfalF1ZXJ5O1xcblxcdH1cXG5cXG5cXHRyZXR1cm4galF1ZXJ5O1xcbn07XFxuXFxuLy8gRXhwb3NlIGpRdWVyeSBhbmQgJCBpZGVudGlmaWVycywgZXZlbiBpbiBBTURcXG4vLyAoIzcxMDIjY29tbWVudDoxMCwgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9qcXVlcnkvcHVsbC81NTcpXFxuLy8gYW5kIENvbW1vbkpTIGZvciBicm93c2VyIGVtdWxhdG9ycyAoIzEzNTY2KVxcbmlmICggIW5vR2xvYmFsICkge1xcblxcdHdpbmRvdy5qUXVlcnkgPSB3aW5kb3cuJCA9IGpRdWVyeTtcXG59XFxuXFxuXFxuXFxuXFxucmV0dXJuIGpRdWVyeTtcXG59ICk7XFxuXFxuXFxuLy8vLy8vLy8vLy8vLy8vLy8vXFxuLy8gV0VCUEFDSyBGT09URVJcXG4vLyAuL34vanF1ZXJ5L2Rpc3QvanF1ZXJ5LmpzXFxuLy8gbW9kdWxlIGlkID0gMVxcbi8vIG1vZHVsZSBjaHVua3MgPSAwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vfi9qcXVlcnkvZGlzdC9qcXVlcnkuanM/XCIpO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDIgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcbmV2YWwoXCJcXG5cXG4vKipcXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cXG4gKlxcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cXG4gKlxcbiAqIFxcbiAqL1xcblxcbmZ1bmN0aW9uIG1ha2VFbXB0eUZ1bmN0aW9uKGFyZykge1xcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcXG4gICAgcmV0dXJuIGFyZztcXG4gIH07XFxufVxcblxcbi8qKlxcbiAqIFRoaXMgZnVuY3Rpb24gYWNjZXB0cyBhbmQgZGlzY2FyZHMgaW5wdXRzOyBpdCBoYXMgbm8gc2lkZSBlZmZlY3RzLiBUaGlzIGlzXFxuICogcHJpbWFyaWx5IHVzZWZ1bCBpZGlvbWF0aWNhbGx5IGZvciBvdmVycmlkYWJsZSBmdW5jdGlvbiBlbmRwb2ludHMgd2hpY2hcXG4gKiBhbHdheXMgbmVlZCB0byBiZSBjYWxsYWJsZSwgc2luY2UgSlMgbGFja3MgYSBudWxsLWNhbGwgaWRpb20gYWxhIENvY29hLlxcbiAqL1xcbnZhciBlbXB0eUZ1bmN0aW9uID0gZnVuY3Rpb24gZW1wdHlGdW5jdGlvbigpIHt9O1xcblxcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnMgPSBtYWtlRW1wdHlGdW5jdGlvbjtcXG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zRmFsc2UgPSBtYWtlRW1wdHlGdW5jdGlvbihmYWxzZSk7XFxuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWUgPSBtYWtlRW1wdHlGdW5jdGlvbih0cnVlKTtcXG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbCA9IG1ha2VFbXB0eUZ1bmN0aW9uKG51bGwpO1xcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUaGlzID0gZnVuY3Rpb24gKCkge1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zQXJndW1lbnQgPSBmdW5jdGlvbiAoYXJnKSB7XFxuICByZXR1cm4gYXJnO1xcbn07XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBlbXB0eUZ1bmN0aW9uO1xcblxcbi8vLy8vLy8vLy8vLy8vLy8vL1xcbi8vIFdFQlBBQ0sgRk9PVEVSXFxuLy8gLi9+L2ZianMvbGliL2VtcHR5RnVuY3Rpb24uanNcXG4vLyBtb2R1bGUgaWQgPSAyXFxuLy8gbW9kdWxlIGNodW5rcyA9IDBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9+L2ZianMvbGliL2VtcHR5RnVuY3Rpb24uanM/XCIpO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDMgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcbmV2YWwoXCIvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24ocHJvY2Vzcykgey8qKlxcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxcbiAqXFxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXFxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxcbiAqXFxuICovXFxuXFxuXFxuXFxuLyoqXFxuICogVXNlIGludmFyaWFudCgpIHRvIGFzc2VydCBzdGF0ZSB3aGljaCB5b3VyIHByb2dyYW0gYXNzdW1lcyB0byBiZSB0cnVlLlxcbiAqXFxuICogUHJvdmlkZSBzcHJpbnRmLXN0eWxlIGZvcm1hdCAob25seSAlcyBpcyBzdXBwb3J0ZWQpIGFuZCBhcmd1bWVudHNcXG4gKiB0byBwcm92aWRlIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgYnJva2UgYW5kIHdoYXQgeW91IHdlcmVcXG4gKiBleHBlY3RpbmcuXFxuICpcXG4gKiBUaGUgaW52YXJpYW50IG1lc3NhZ2Ugd2lsbCBiZSBzdHJpcHBlZCBpbiBwcm9kdWN0aW9uLCBidXQgdGhlIGludmFyaWFudFxcbiAqIHdpbGwgcmVtYWluIHRvIGVuc3VyZSBsb2dpYyBkb2VzIG5vdCBkaWZmZXIgaW4gcHJvZHVjdGlvbi5cXG4gKi9cXG5cXG52YXIgdmFsaWRhdGVGb3JtYXQgPSBmdW5jdGlvbiB2YWxpZGF0ZUZvcm1hdChmb3JtYXQpIHt9O1xcblxcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XFxuICB2YWxpZGF0ZUZvcm1hdCA9IGZ1bmN0aW9uIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCkge1xcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFyaWFudCByZXF1aXJlcyBhbiBlcnJvciBtZXNzYWdlIGFyZ3VtZW50Jyk7XFxuICAgIH1cXG4gIH07XFxufVxcblxcbmZ1bmN0aW9uIGludmFyaWFudChjb25kaXRpb24sIGZvcm1hdCwgYSwgYiwgYywgZCwgZSwgZikge1xcbiAgdmFsaWRhdGVGb3JtYXQoZm9ybWF0KTtcXG5cXG4gIGlmICghY29uZGl0aW9uKSB7XFxuICAgIHZhciBlcnJvcjtcXG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ01pbmlmaWVkIGV4Y2VwdGlvbiBvY2N1cnJlZDsgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50ICcgKyAnZm9yIHRoZSBmdWxsIGVycm9yIG1lc3NhZ2UgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy4nKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICB2YXIgYXJncyA9IFthLCBiLCBjLCBkLCBlLCBmXTtcXG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcXG4gICAgICB9KSk7XFxuICAgICAgZXJyb3IubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcXG4gICAgfVxcblxcbiAgICBlcnJvci5mcmFtZXNUb1BvcCA9IDE7IC8vIHdlIGRvbid0IGNhcmUgYWJvdXQgaW52YXJpYW50J3Mgb3duIGZyYW1lXFxuICAgIHRocm93IGVycm9yO1xcbiAgfVxcbn1cXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGludmFyaWFudDtcXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXygwKSkpXFxuXFxuLy8vLy8vLy8vLy8vLy8vLy8vXFxuLy8gV0VCUEFDSyBGT09URVJcXG4vLyAuL34vZmJqcy9saWIvaW52YXJpYW50LmpzXFxuLy8gbW9kdWxlIGlkID0gM1xcbi8vIG1vZHVsZSBjaHVua3MgPSAwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9pbnZhcmlhbnQuanM/XCIpO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDQgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcbmV2YWwoXCIvKipcXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cXG4gKlxcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cXG4gKi9cXG5cXG5cXG5cXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnO1xcblxcbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQcm9wVHlwZXNTZWNyZXQ7XFxuXFxuXFxuLy8vLy8vLy8vLy8vLy8vLy8vXFxuLy8gV0VCUEFDSyBGT09URVJcXG4vLyAuL34vcHJvcC10eXBlcy9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanNcXG4vLyBtb2R1bGUgaWQgPSA0XFxuLy8gbW9kdWxlIGNodW5rcyA9IDBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9+L3Byb3AtdHlwZXMvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzP1wiKTtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiA1ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcbmV2YWwoXCIvKlxcblxcdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXFxuXFx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxcbiovXFxuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHVzZVNvdXJjZU1hcCkge1xcblxcdHZhciBsaXN0ID0gW107XFxuXFxuXFx0Ly8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xcblxcdGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcXG5cXHRcXHRyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcXG5cXHRcXHRcXHR2YXIgY29udGVudCA9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKTtcXG5cXHRcXHRcXHRpZihpdGVtWzJdKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIFxcXCJAbWVkaWEgXFxcIiArIGl0ZW1bMl0gKyBcXFwie1xcXCIgKyBjb250ZW50ICsgXFxcIn1cXFwiO1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGNvbnRlbnQ7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0pLmpvaW4oXFxcIlxcXCIpO1xcblxcdH07XFxuXFxuXFx0Ly8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3RcXG5cXHRsaXN0LmkgPSBmdW5jdGlvbihtb2R1bGVzLCBtZWRpYVF1ZXJ5KSB7XFxuXFx0XFx0aWYodHlwZW9mIG1vZHVsZXMgPT09IFxcXCJzdHJpbmdcXFwiKVxcblxcdFxcdFxcdG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsIFxcXCJcXFwiXV07XFxuXFx0XFx0dmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcXG5cXHRcXHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xcblxcdFxcdFxcdHZhciBpZCA9IHRoaXNbaV1bMF07XFxuXFx0XFx0XFx0aWYodHlwZW9mIGlkID09PSBcXFwibnVtYmVyXFxcIilcXG5cXHRcXHRcXHRcXHRhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XFxuXFx0XFx0fVxcblxcdFxcdGZvcihpID0gMDsgaSA8IG1vZHVsZXMubGVuZ3RoOyBpKyspIHtcXG5cXHRcXHRcXHR2YXIgaXRlbSA9IG1vZHVsZXNbaV07XFxuXFx0XFx0XFx0Ly8gc2tpcCBhbHJlYWR5IGltcG9ydGVkIG1vZHVsZVxcblxcdFxcdFxcdC8vIHRoaXMgaW1wbGVtZW50YXRpb24gaXMgbm90IDEwMCUgcGVyZmVjdCBmb3Igd2VpcmQgbWVkaWEgcXVlcnkgY29tYmluYXRpb25zXFxuXFx0XFx0XFx0Ly8gIHdoZW4gYSBtb2R1bGUgaXMgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgbWVkaWEgcXVlcmllcy5cXG5cXHRcXHRcXHQvLyAgSSBob3BlIHRoaXMgd2lsbCBuZXZlciBvY2N1ciAoSGV5IHRoaXMgd2F5IHdlIGhhdmUgc21hbGxlciBidW5kbGVzKVxcblxcdFxcdFxcdGlmKHR5cGVvZiBpdGVtWzBdICE9PSBcXFwibnVtYmVyXFxcIiB8fCAhYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xcblxcdFxcdFxcdFxcdGlmKG1lZGlhUXVlcnkgJiYgIWl0ZW1bMl0pIHtcXG5cXHRcXHRcXHRcXHRcXHRpdGVtWzJdID0gbWVkaWFRdWVyeTtcXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYobWVkaWFRdWVyeSkge1xcblxcdFxcdFxcdFxcdFxcdGl0ZW1bMl0gPSBcXFwiKFxcXCIgKyBpdGVtWzJdICsgXFxcIikgYW5kIChcXFwiICsgbWVkaWFRdWVyeSArIFxcXCIpXFxcIjtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0bGlzdC5wdXNoKGl0ZW0pO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fTtcXG5cXHRyZXR1cm4gbGlzdDtcXG59O1xcblxcbmZ1bmN0aW9uIGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKSB7XFxuXFx0dmFyIGNvbnRlbnQgPSBpdGVtWzFdIHx8ICcnO1xcblxcdHZhciBjc3NNYXBwaW5nID0gaXRlbVszXTtcXG5cXHRpZiAoIWNzc01hcHBpbmcpIHtcXG5cXHRcXHRyZXR1cm4gY29udGVudDtcXG5cXHR9XFxuXFxuXFx0aWYgKHVzZVNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJykge1xcblxcdFxcdHZhciBzb3VyY2VNYXBwaW5nID0gdG9Db21tZW50KGNzc01hcHBpbmcpO1xcblxcdFxcdHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XFxuXFx0XFx0XFx0cmV0dXJuICcvKiMgc291cmNlVVJMPScgKyBjc3NNYXBwaW5nLnNvdXJjZVJvb3QgKyBzb3VyY2UgKyAnICovJ1xcblxcdFxcdH0pO1xcblxcblxcdFxcdHJldHVybiBbY29udGVudF0uY29uY2F0KHNvdXJjZVVSTHMpLmNvbmNhdChbc291cmNlTWFwcGluZ10pLmpvaW4oJ1xcXFxuJyk7XFxuXFx0fVxcblxcblxcdHJldHVybiBbY29udGVudF0uam9pbignXFxcXG4nKTtcXG59XFxuXFxuLy8gQWRhcHRlZCBmcm9tIGNvbnZlcnQtc291cmNlLW1hcCAoTUlUKVxcbmZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcXG5cXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcXG5cXHR2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKTtcXG5cXHR2YXIgZGF0YSA9ICdzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCwnICsgYmFzZTY0O1xcblxcblxcdHJldHVybiAnLyojICcgKyBkYXRhICsgJyAqLyc7XFxufVxcblxcblxcbi8vLy8vLy8vLy8vLy8vLy8vL1xcbi8vIFdFQlBBQ0sgRk9PVEVSXFxuLy8gLi9+L2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXFxuLy8gbW9kdWxlIGlkID0gNVxcbi8vIG1vZHVsZSBjaHVua3MgPSAwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vfi9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qcz9cIik7XHJcblxyXG4vKioqLyB9KSxcclxuLyogNiAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuZXZhbChcIi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihwcm9jZXNzKSB7LyoqXFxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXFxuICpcXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXFxuICpcXG4gKi9cXG5cXG5cXG5cXG52YXIgZW1wdHlGdW5jdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XFxuXFxuLyoqXFxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxcbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gbG9nIGlzc3VlcyBpbiBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMgaW4gY3JpdGljYWxcXG4gKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxcbiAqL1xcblxcbnZhciB3YXJuaW5nID0gZW1wdHlGdW5jdGlvbjtcXG5cXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xcbiAgdmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uIHByaW50V2FybmluZyhmb3JtYXQpIHtcXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XFxuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XFxuICAgIH1cXG5cXG4gICAgdmFyIGFyZ0luZGV4ID0gMDtcXG4gICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XFxuICAgIH0pO1xcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XFxuICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcXG4gICAgfVxcbiAgICB0cnkge1xcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cXG4gICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XFxuICAgIH0gY2F0Y2ggKHgpIHt9XFxuICB9O1xcblxcbiAgd2FybmluZyA9IGZ1bmN0aW9uIHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQpIHtcXG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdgd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncylgIHJlcXVpcmVzIGEgd2FybmluZyAnICsgJ21lc3NhZ2UgYXJndW1lbnQnKTtcXG4gICAgfVxcblxcbiAgICBpZiAoZm9ybWF0LmluZGV4T2YoJ0ZhaWxlZCBDb21wb3NpdGUgcHJvcFR5cGU6ICcpID09PSAwKSB7XFxuICAgICAgcmV0dXJuOyAvLyBJZ25vcmUgQ29tcG9zaXRlQ29tcG9uZW50IHByb3B0eXBlIGNoZWNrLlxcbiAgICB9XFxuXFxuICAgIGlmICghY29uZGl0aW9uKSB7XFxuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjIgPiAyID8gX2xlbjIgLSAyIDogMCksIF9rZXkyID0gMjsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xcbiAgICAgICAgYXJnc1tfa2V5MiAtIDJdID0gYXJndW1lbnRzW19rZXkyXTtcXG4gICAgICB9XFxuXFxuICAgICAgcHJpbnRXYXJuaW5nLmFwcGx5KHVuZGVmaW5lZCwgW2Zvcm1hdF0uY29uY2F0KGFyZ3MpKTtcXG4gICAgfVxcbiAgfTtcXG59XFxuXFxubW9kdWxlLmV4cG9ydHMgPSB3YXJuaW5nO1xcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDApKSlcXG5cXG4vLy8vLy8vLy8vLy8vLy8vLy9cXG4vLyBXRUJQQUNLIEZPT1RFUlxcbi8vIC4vfi9mYmpzL2xpYi93YXJuaW5nLmpzXFxuLy8gbW9kdWxlIGlkID0gNlxcbi8vIG1vZHVsZSBjaHVua3MgPSAwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi93YXJuaW5nLmpzP1wiKTtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiA3ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbmV2YWwoXCIvKlxcblxcdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXFxuXFx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxcbiovXFxudmFyIHN0eWxlc0luRG9tID0ge30sXFxuXFx0bWVtb2l6ZSA9IGZ1bmN0aW9uKGZuKSB7XFxuXFx0XFx0dmFyIG1lbW87XFxuXFx0XFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRpZiAodHlwZW9mIG1lbW8gPT09IFxcXCJ1bmRlZmluZWRcXFwiKSBtZW1vID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG5cXHRcXHRcXHRyZXR1cm4gbWVtbztcXG5cXHRcXHR9O1xcblxcdH0sXFxuXFx0aXNPbGRJRSA9IG1lbW9pemUoZnVuY3Rpb24oKSB7XFxuXFx0XFx0Ly8gVGVzdCBmb3IgSUUgPD0gOSBhcyBwcm9wb3NlZCBieSBCcm93c2VyaGFja3NcXG5cXHRcXHQvLyBAc2VlIGh0dHA6Ly9icm93c2VyaGFja3MuY29tLyNoYWNrLWU3MWQ4NjkyZjY1MzM0MTczZmVlNzE1YzIyMmNiODA1XFxuXFx0XFx0Ly8gVGVzdHMgZm9yIGV4aXN0ZW5jZSBvZiBzdGFuZGFyZCBnbG9iYWxzIGlzIHRvIGFsbG93IHN0eWxlLWxvYWRlciBcXG5cXHRcXHQvLyB0byBvcGVyYXRlIGNvcnJlY3RseSBpbnRvIG5vbi1zdGFuZGFyZCBlbnZpcm9ubWVudHNcXG5cXHRcXHQvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyL2lzc3Vlcy8xNzdcXG5cXHRcXHRyZXR1cm4gd2luZG93ICYmIGRvY3VtZW50ICYmIGRvY3VtZW50LmFsbCAmJiAhd2luZG93LmF0b2I7XFxuXFx0fSksXFxuXFx0Z2V0RWxlbWVudCA9IChmdW5jdGlvbihmbikge1xcblxcdFxcdHZhciBtZW1vID0ge307XFxuXFx0XFx0cmV0dXJuIGZ1bmN0aW9uKHNlbGVjdG9yKSB7XFxuXFx0XFx0XFx0aWYgKHR5cGVvZiBtZW1vW3NlbGVjdG9yXSA9PT0gXFxcInVuZGVmaW5lZFxcXCIpIHtcXG5cXHRcXHRcXHRcXHRtZW1vW3NlbGVjdG9yXSA9IGZuLmNhbGwodGhpcywgc2VsZWN0b3IpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRyZXR1cm4gbWVtb1tzZWxlY3Rvcl1cXG5cXHRcXHR9O1xcblxcdH0pKGZ1bmN0aW9uIChzdHlsZVRhcmdldCkge1xcblxcdFxcdHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHN0eWxlVGFyZ2V0KVxcblxcdH0pLFxcblxcdHNpbmdsZXRvbkVsZW1lbnQgPSBudWxsLFxcblxcdHNpbmdsZXRvbkNvdW50ZXIgPSAwLFxcblxcdHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wID0gW10sXFxuXFx0Zml4VXJscyA9IF9fd2VicGFja19yZXF1aXJlX18oMjIpO1xcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obGlzdCwgb3B0aW9ucykge1xcblxcdGlmKHR5cGVvZiBERUJVRyAhPT0gXFxcInVuZGVmaW5lZFxcXCIgJiYgREVCVUcpIHtcXG5cXHRcXHRpZih0eXBlb2YgZG9jdW1lbnQgIT09IFxcXCJvYmplY3RcXFwiKSB0aHJvdyBuZXcgRXJyb3IoXFxcIlRoZSBzdHlsZS1sb2FkZXIgY2Fubm90IGJlIHVzZWQgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudFxcXCIpO1xcblxcdH1cXG5cXG5cXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcXG5cXHRvcHRpb25zLmF0dHJzID0gdHlwZW9mIG9wdGlvbnMuYXR0cnMgPT09IFxcXCJvYmplY3RcXFwiID8gb3B0aW9ucy5hdHRycyA6IHt9O1xcblxcblxcdC8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxcblxcdC8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2VcXG5cXHRpZiAodHlwZW9mIG9wdGlvbnMuc2luZ2xldG9uID09PSBcXFwidW5kZWZpbmVkXFxcIikgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XFxuXFxuXFx0Ly8gQnkgZGVmYXVsdCwgYWRkIDxzdHlsZT4gdGFncyB0byB0aGUgPGhlYWQ+IGVsZW1lbnRcXG5cXHRpZiAodHlwZW9mIG9wdGlvbnMuaW5zZXJ0SW50byA9PT0gXFxcInVuZGVmaW5lZFxcXCIpIG9wdGlvbnMuaW5zZXJ0SW50byA9IFxcXCJoZWFkXFxcIjtcXG5cXG5cXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSBib3R0b20gb2YgdGhlIHRhcmdldFxcblxcdGlmICh0eXBlb2Ygb3B0aW9ucy5pbnNlcnRBdCA9PT0gXFxcInVuZGVmaW5lZFxcXCIpIG9wdGlvbnMuaW5zZXJ0QXQgPSBcXFwiYm90dG9tXFxcIjtcXG5cXG5cXHR2YXIgc3R5bGVzID0gbGlzdFRvU3R5bGVzKGxpc3QsIG9wdGlvbnMpO1xcblxcdGFkZFN0eWxlc1RvRG9tKHN0eWxlcywgb3B0aW9ucyk7XFxuXFxuXFx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZShuZXdMaXN0KSB7XFxuXFx0XFx0dmFyIG1heVJlbW92ZSA9IFtdO1xcblxcdFxcdGZvcih2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcXG5cXHRcXHRcXHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcXG5cXHRcXHRcXHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcXG5cXHRcXHRcXHRkb21TdHlsZS5yZWZzLS07XFxuXFx0XFx0XFx0bWF5UmVtb3ZlLnB1c2goZG9tU3R5bGUpO1xcblxcdFxcdH1cXG5cXHRcXHRpZihuZXdMaXN0KSB7XFxuXFx0XFx0XFx0dmFyIG5ld1N0eWxlcyA9IGxpc3RUb1N0eWxlcyhuZXdMaXN0LCBvcHRpb25zKTtcXG5cXHRcXHRcXHRhZGRTdHlsZXNUb0RvbShuZXdTdHlsZXMsIG9wdGlvbnMpO1xcblxcdFxcdH1cXG5cXHRcXHRmb3IodmFyIGkgPSAwOyBpIDwgbWF5UmVtb3ZlLmxlbmd0aDsgaSsrKSB7XFxuXFx0XFx0XFx0dmFyIGRvbVN0eWxlID0gbWF5UmVtb3ZlW2ldO1xcblxcdFxcdFxcdGlmKGRvbVN0eWxlLnJlZnMgPT09IDApIHtcXG5cXHRcXHRcXHRcXHRmb3IodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspXFxuXFx0XFx0XFx0XFx0XFx0ZG9tU3R5bGUucGFydHNbal0oKTtcXG5cXHRcXHRcXHRcXHRkZWxldGUgc3R5bGVzSW5Eb21bZG9tU3R5bGUuaWRdO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fTtcXG59O1xcblxcbmZ1bmN0aW9uIGFkZFN0eWxlc1RvRG9tKHN0eWxlcywgb3B0aW9ucykge1xcblxcdGZvcih2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcXG5cXHRcXHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcXG5cXHRcXHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcXG5cXHRcXHRpZihkb21TdHlsZSkge1xcblxcdFxcdFxcdGRvbVN0eWxlLnJlZnMrKztcXG5cXHRcXHRcXHRmb3IodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcXG5cXHRcXHRcXHRcXHRkb21TdHlsZS5wYXJ0c1tqXShpdGVtLnBhcnRzW2pdKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0Zm9yKDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcXG5cXHRcXHRcXHRcXHRkb21TdHlsZS5wYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHR2YXIgcGFydHMgPSBbXTtcXG5cXHRcXHRcXHRmb3IodmFyIGogPSAwOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xcblxcdFxcdFxcdFxcdHBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRzdHlsZXNJbkRvbVtpdGVtLmlkXSA9IHtpZDogaXRlbS5pZCwgcmVmczogMSwgcGFydHM6IHBhcnRzfTtcXG5cXHRcXHR9XFxuXFx0fVxcbn1cXG5cXG5mdW5jdGlvbiBsaXN0VG9TdHlsZXMobGlzdCwgb3B0aW9ucykge1xcblxcdHZhciBzdHlsZXMgPSBbXTtcXG5cXHR2YXIgbmV3U3R5bGVzID0ge307XFxuXFx0Zm9yKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcXG5cXHRcXHR2YXIgaXRlbSA9IGxpc3RbaV07XFxuXFx0XFx0dmFyIGlkID0gb3B0aW9ucy5iYXNlID8gaXRlbVswXSArIG9wdGlvbnMuYmFzZSA6IGl0ZW1bMF07XFxuXFx0XFx0dmFyIGNzcyA9IGl0ZW1bMV07XFxuXFx0XFx0dmFyIG1lZGlhID0gaXRlbVsyXTtcXG5cXHRcXHR2YXIgc291cmNlTWFwID0gaXRlbVszXTtcXG5cXHRcXHR2YXIgcGFydCA9IHtjc3M6IGNzcywgbWVkaWE6IG1lZGlhLCBzb3VyY2VNYXA6IHNvdXJjZU1hcH07XFxuXFx0XFx0aWYoIW5ld1N0eWxlc1tpZF0pXFxuXFx0XFx0XFx0c3R5bGVzLnB1c2gobmV3U3R5bGVzW2lkXSA9IHtpZDogaWQsIHBhcnRzOiBbcGFydF19KTtcXG5cXHRcXHRlbHNlXFxuXFx0XFx0XFx0bmV3U3R5bGVzW2lkXS5wYXJ0cy5wdXNoKHBhcnQpO1xcblxcdH1cXG5cXHRyZXR1cm4gc3R5bGVzO1xcbn1cXG5cXG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgc3R5bGVFbGVtZW50KSB7XFxuXFx0dmFyIHN0eWxlVGFyZ2V0ID0gZ2V0RWxlbWVudChvcHRpb25zLmluc2VydEludG8pXFxuXFx0aWYgKCFzdHlsZVRhcmdldCkge1xcblxcdFxcdHRocm93IG5ldyBFcnJvcihcXFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnRJbnRvJyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cXFwiKTtcXG5cXHR9XFxuXFx0dmFyIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wID0gc3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3Bbc3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AubGVuZ3RoIC0gMV07XFxuXFx0aWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFxcXCJ0b3BcXFwiKSB7XFxuXFx0XFx0aWYoIWxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wKSB7XFxuXFx0XFx0XFx0c3R5bGVUYXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlRWxlbWVudCwgc3R5bGVUYXJnZXQuZmlyc3RDaGlsZCk7XFxuXFx0XFx0fSBlbHNlIGlmKGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKSB7XFxuXFx0XFx0XFx0c3R5bGVUYXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlRWxlbWVudCwgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpO1xcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0c3R5bGVUYXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGVFbGVtZW50KTtcXG5cXHRcXHR9XFxuXFx0XFx0c3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AucHVzaChzdHlsZUVsZW1lbnQpO1xcblxcdH0gZWxzZSBpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXFxcImJvdHRvbVxcXCIpIHtcXG5cXHRcXHRzdHlsZVRhcmdldC5hcHBlbmRDaGlsZChzdHlsZUVsZW1lbnQpO1xcblxcdH0gZWxzZSB7XFxuXFx0XFx0dGhyb3cgbmV3IEVycm9yKFxcXCJJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgJ2luc2VydEF0Jy4gTXVzdCBiZSAndG9wJyBvciAnYm90dG9tJy5cXFwiKTtcXG5cXHR9XFxufVxcblxcbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpIHtcXG5cXHRzdHlsZUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQpO1xcblxcdHZhciBpZHggPSBzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5pbmRleE9mKHN0eWxlRWxlbWVudCk7XFxuXFx0aWYoaWR4ID49IDApIHtcXG5cXHRcXHRzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5zcGxpY2UoaWR4LCAxKTtcXG5cXHR9XFxufVxcblxcbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKSB7XFxuXFx0dmFyIHN0eWxlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXFxcInN0eWxlXFxcIik7XFxuXFx0b3B0aW9ucy5hdHRycy50eXBlID0gXFxcInRleHQvY3NzXFxcIjtcXG5cXG5cXHRhdHRhY2hUYWdBdHRycyhzdHlsZUVsZW1lbnQsIG9wdGlvbnMuYXR0cnMpO1xcblxcdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBzdHlsZUVsZW1lbnQpO1xcblxcdHJldHVybiBzdHlsZUVsZW1lbnQ7XFxufVxcblxcbmZ1bmN0aW9uIGNyZWF0ZUxpbmtFbGVtZW50KG9wdGlvbnMpIHtcXG5cXHR2YXIgbGlua0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFxcXCJsaW5rXFxcIik7XFxuXFx0b3B0aW9ucy5hdHRycy50eXBlID0gXFxcInRleHQvY3NzXFxcIjtcXG5cXHRvcHRpb25zLmF0dHJzLnJlbCA9IFxcXCJzdHlsZXNoZWV0XFxcIjtcXG5cXG5cXHRhdHRhY2hUYWdBdHRycyhsaW5rRWxlbWVudCwgb3B0aW9ucy5hdHRycyk7XFxuXFx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIGxpbmtFbGVtZW50KTtcXG5cXHRyZXR1cm4gbGlua0VsZW1lbnQ7XFxufVxcblxcbmZ1bmN0aW9uIGF0dGFjaFRhZ0F0dHJzKGVsZW1lbnQsIGF0dHJzKSB7XFxuXFx0T2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xcblxcdFxcdGVsZW1lbnQuc2V0QXR0cmlidXRlKGtleSwgYXR0cnNba2V5XSk7XFxuXFx0fSk7XFxufVxcblxcbmZ1bmN0aW9uIGFkZFN0eWxlKG9iaiwgb3B0aW9ucykge1xcblxcdHZhciBzdHlsZUVsZW1lbnQsIHVwZGF0ZSwgcmVtb3ZlLCB0cmFuc2Zvcm1SZXN1bHQ7XFxuXFxuXFx0Ly8gSWYgYSB0cmFuc2Zvcm0gZnVuY3Rpb24gd2FzIGRlZmluZWQsIHJ1biBpdCBvbiB0aGUgY3NzXFxuXFx0aWYgKG9wdGlvbnMudHJhbnNmb3JtICYmIG9iai5jc3MpIHtcXG5cXHQgICAgdHJhbnNmb3JtUmVzdWx0ID0gb3B0aW9ucy50cmFuc2Zvcm0ob2JqLmNzcyk7XFxuXFx0ICAgIFxcblxcdCAgICBpZiAodHJhbnNmb3JtUmVzdWx0KSB7XFxuXFx0ICAgIFxcdC8vIElmIHRyYW5zZm9ybSByZXR1cm5zIGEgdmFsdWUsIHVzZSB0aGF0IGluc3RlYWQgb2YgdGhlIG9yaWdpbmFsIGNzcy5cXG5cXHQgICAgXFx0Ly8gVGhpcyBhbGxvd3MgcnVubmluZyBydW50aW1lIHRyYW5zZm9ybWF0aW9ucyBvbiB0aGUgY3NzLlxcblxcdCAgICBcXHRvYmouY3NzID0gdHJhbnNmb3JtUmVzdWx0O1xcblxcdCAgICB9IGVsc2Uge1xcblxcdCAgICBcXHQvLyBJZiB0aGUgdHJhbnNmb3JtIGZ1bmN0aW9uIHJldHVybnMgYSBmYWxzeSB2YWx1ZSwgZG9uJ3QgYWRkIHRoaXMgY3NzLiBcXG5cXHQgICAgXFx0Ly8gVGhpcyBhbGxvd3MgY29uZGl0aW9uYWwgbG9hZGluZyBvZiBjc3NcXG5cXHQgICAgXFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xcblxcdCAgICBcXHRcXHQvLyBub29wXFxuXFx0ICAgIFxcdH07XFxuXFx0ICAgIH1cXG5cXHR9XFxuXFxuXFx0aWYgKG9wdGlvbnMuc2luZ2xldG9uKSB7XFxuXFx0XFx0dmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XFxuXFx0XFx0c3R5bGVFbGVtZW50ID0gc2luZ2xldG9uRWxlbWVudCB8fCAoc2luZ2xldG9uRWxlbWVudCA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKSk7XFxuXFx0XFx0dXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgZmFsc2UpO1xcblxcdFxcdHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIHRydWUpO1xcblxcdH0gZWxzZSBpZihvYmouc291cmNlTWFwICYmXFxuXFx0XFx0dHlwZW9mIFVSTCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJlxcblxcdFxcdHR5cGVvZiBVUkwuY3JlYXRlT2JqZWN0VVJMID09PSBcXFwiZnVuY3Rpb25cXFwiICYmXFxuXFx0XFx0dHlwZW9mIFVSTC5yZXZva2VPYmplY3RVUkwgPT09IFxcXCJmdW5jdGlvblxcXCIgJiZcXG5cXHRcXHR0eXBlb2YgQmxvYiA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJlxcblxcdFxcdHR5cGVvZiBidG9hID09PSBcXFwiZnVuY3Rpb25cXFwiKSB7XFxuXFx0XFx0c3R5bGVFbGVtZW50ID0gY3JlYXRlTGlua0VsZW1lbnQob3B0aW9ucyk7XFxuXFx0XFx0dXBkYXRlID0gdXBkYXRlTGluay5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgb3B0aW9ucyk7XFxuXFx0XFx0cmVtb3ZlID0gZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCk7XFxuXFx0XFx0XFx0aWYoc3R5bGVFbGVtZW50LmhyZWYpXFxuXFx0XFx0XFx0XFx0VVJMLnJldm9rZU9iamVjdFVSTChzdHlsZUVsZW1lbnQuaHJlZik7XFxuXFx0XFx0fTtcXG5cXHR9IGVsc2Uge1xcblxcdFxcdHN0eWxlRWxlbWVudCA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKTtcXG5cXHRcXHR1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50KTtcXG5cXHRcXHRyZW1vdmUgPSBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGVFbGVtZW50KTtcXG5cXHRcXHR9O1xcblxcdH1cXG5cXG5cXHR1cGRhdGUob2JqKTtcXG5cXG5cXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUobmV3T2JqKSB7XFxuXFx0XFx0aWYobmV3T2JqKSB7XFxuXFx0XFx0XFx0aWYobmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJiBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJiBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwKVxcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHR1cGRhdGUob2JqID0gbmV3T2JqKTtcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdHJlbW92ZSgpO1xcblxcdFxcdH1cXG5cXHR9O1xcbn1cXG5cXG52YXIgcmVwbGFjZVRleHQgPSAoZnVuY3Rpb24gKCkge1xcblxcdHZhciB0ZXh0U3RvcmUgPSBbXTtcXG5cXG5cXHRyZXR1cm4gZnVuY3Rpb24gKGluZGV4LCByZXBsYWNlbWVudCkge1xcblxcdFxcdHRleHRTdG9yZVtpbmRleF0gPSByZXBsYWNlbWVudDtcXG5cXHRcXHRyZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXFxcbicpO1xcblxcdH07XFxufSkoKTtcXG5cXG5mdW5jdGlvbiBhcHBseVRvU2luZ2xldG9uVGFnKHN0eWxlRWxlbWVudCwgaW5kZXgsIHJlbW92ZSwgb2JqKSB7XFxuXFx0dmFyIGNzcyA9IHJlbW92ZSA/IFxcXCJcXFwiIDogb2JqLmNzcztcXG5cXG5cXHRpZiAoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcXG5cXHRcXHRzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XFxuXFx0fSBlbHNlIHtcXG5cXHRcXHR2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcyk7XFxuXFx0XFx0dmFyIGNoaWxkTm9kZXMgPSBzdHlsZUVsZW1lbnQuY2hpbGROb2RlcztcXG5cXHRcXHRpZiAoY2hpbGROb2Rlc1tpbmRleF0pIHN0eWxlRWxlbWVudC5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2luZGV4XSk7XFxuXFx0XFx0aWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XFxuXFx0XFx0XFx0c3R5bGVFbGVtZW50Lmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoY3NzTm9kZSk7XFxuXFx0XFx0fVxcblxcdH1cXG59XFxuXFxuZnVuY3Rpb24gYXBwbHlUb1RhZyhzdHlsZUVsZW1lbnQsIG9iaikge1xcblxcdHZhciBjc3MgPSBvYmouY3NzO1xcblxcdHZhciBtZWRpYSA9IG9iai5tZWRpYTtcXG5cXG5cXHRpZihtZWRpYSkge1xcblxcdFxcdHN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoXFxcIm1lZGlhXFxcIiwgbWVkaWEpXFxuXFx0fVxcblxcblxcdGlmKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XFxuXFx0XFx0c3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcXG5cXHR9IGVsc2Uge1xcblxcdFxcdHdoaWxlKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKSB7XFxuXFx0XFx0XFx0c3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKTtcXG5cXHRcXHR9XFxuXFx0XFx0c3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xcblxcdH1cXG59XFxuXFxuZnVuY3Rpb24gdXBkYXRlTGluayhsaW5rRWxlbWVudCwgb3B0aW9ucywgb2JqKSB7XFxuXFx0dmFyIGNzcyA9IG9iai5jc3M7XFxuXFx0dmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XFxuXFxuXFx0LyogSWYgY29udmVydFRvQWJzb2x1dGVVcmxzIGlzbid0IGRlZmluZWQsIGJ1dCBzb3VyY2VtYXBzIGFyZSBlbmFibGVkXFxuXFx0YW5kIHRoZXJlIGlzIG5vIHB1YmxpY1BhdGggZGVmaW5lZCB0aGVuIGxldHMgdHVybiBjb252ZXJ0VG9BYnNvbHV0ZVVybHNcXG5cXHRvbiBieSBkZWZhdWx0LiAgT3RoZXJ3aXNlIGRlZmF1bHQgdG8gdGhlIGNvbnZlcnRUb0Fic29sdXRlVXJscyBvcHRpb25cXG5cXHRkaXJlY3RseVxcblxcdCovXFxuXFx0dmFyIGF1dG9GaXhVcmxzID0gb3B0aW9ucy5jb252ZXJ0VG9BYnNvbHV0ZVVybHMgPT09IHVuZGVmaW5lZCAmJiBzb3VyY2VNYXA7XFxuXFxuXFx0aWYgKG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzIHx8IGF1dG9GaXhVcmxzKXtcXG5cXHRcXHRjc3MgPSBmaXhVcmxzKGNzcyk7XFxuXFx0fVxcblxcblxcdGlmKHNvdXJjZU1hcCkge1xcblxcdFxcdC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI2NjAzODc1XFxuXFx0XFx0Y3NzICs9IFxcXCJcXFxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXFxcIiArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkgKyBcXFwiICovXFxcIjtcXG5cXHR9XFxuXFxuXFx0dmFyIGJsb2IgPSBuZXcgQmxvYihbY3NzXSwgeyB0eXBlOiBcXFwidGV4dC9jc3NcXFwiIH0pO1xcblxcblxcdHZhciBvbGRTcmMgPSBsaW5rRWxlbWVudC5ocmVmO1xcblxcblxcdGxpbmtFbGVtZW50LmhyZWYgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xcblxcblxcdGlmKG9sZFNyYylcXG5cXHRcXHRVUkwucmV2b2tlT2JqZWN0VVJMKG9sZFNyYyk7XFxufVxcblxcblxcbi8vLy8vLy8vLy8vLy8vLy8vL1xcbi8vIFdFQlBBQ0sgRk9PVEVSXFxuLy8gLi9+L3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcXG4vLyBtb2R1bGUgaWQgPSA3XFxuLy8gbW9kdWxlIGNodW5rcyA9IDBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9+L3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanM/XCIpO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDggKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuZXZhbChcIi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihfX3dlYnBhY2tfcHJvdmlkZWRfd2luZG93X2RvdF9qUXVlcnksIGpRdWVyeSkgey8qKlxcbiAqIE93bCBDYXJvdXNlbCB2Mi4yLjBcXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE2IERhdmlkIERldXRzY2hcXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS9Pd2xDYXJvdXNlbDIvT3dsQ2Fyb3VzZWwyL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXFxuICovXFxuLyoqXFxuICogT3dsIGNhcm91c2VsXFxuICogQHZlcnNpb24gMi4xLjZcXG4gKiBAYXV0aG9yIEJhcnRvc3ogV29qY2llY2hvd3NraVxcbiAqIEBhdXRob3IgRGF2aWQgRGV1dHNjaFxcbiAqIEBsaWNlbnNlIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxcbiAqIEB0b2RvIExhenkgTG9hZCBJY29uXFxuICogQHRvZG8gcHJldmVudCBhbmltYXRpb25lbmQgYnVibGluZ1xcbiAqIEB0b2RvIGl0ZW1zU2NhbGVVcFxcbiAqIEB0b2RvIFRlc3QgWmVwdG9cXG4gKiBAdG9kbyBzdGFnZVBhZGRpbmcgY2FsY3VsYXRlIHdyb25nIGFjdGl2ZSBjbGFzc2VzXFxuICovXFxuOyhmdW5jdGlvbigkLCB3aW5kb3csIGRvY3VtZW50LCB1bmRlZmluZWQpIHtcXG5cXG5cXHQvKipcXG5cXHQgKiBDcmVhdGVzIGEgY2Fyb3VzZWwuXFxuXFx0ICogQGNsYXNzIFRoZSBPd2wgQ2Fyb3VzZWwuXFxuXFx0ICogQHB1YmxpY1xcblxcdCAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8alF1ZXJ5fSBlbGVtZW50IC0gVGhlIGVsZW1lbnQgdG8gY3JlYXRlIHRoZSBjYXJvdXNlbCBmb3IuXFxuXFx0ICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zXFxuXFx0ICovXFxuXFx0ZnVuY3Rpb24gT3dsKGVsZW1lbnQsIG9wdGlvbnMpIHtcXG5cXG5cXHRcXHQvKipcXG5cXHRcXHQgKiBDdXJyZW50IHNldHRpbmdzIGZvciB0aGUgY2Fyb3VzZWwuXFxuXFx0XFx0ICogQHB1YmxpY1xcblxcdFxcdCAqL1xcblxcdFxcdHRoaXMuc2V0dGluZ3MgPSBudWxsO1xcblxcblxcdFxcdC8qKlxcblxcdFxcdCAqIEN1cnJlbnQgb3B0aW9ucyBzZXQgYnkgdGhlIGNhbGxlciBpbmNsdWRpbmcgZGVmYXVsdHMuXFxuXFx0XFx0ICogQHB1YmxpY1xcblxcdFxcdCAqL1xcblxcdFxcdHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBPd2wuRGVmYXVsdHMsIG9wdGlvbnMpO1xcblxcblxcdFxcdC8qKlxcblxcdFxcdCAqIFBsdWdpbiBlbGVtZW50LlxcblxcdFxcdCAqIEBwdWJsaWNcXG5cXHRcXHQgKi9cXG5cXHRcXHR0aGlzLiRlbGVtZW50ID0gJChlbGVtZW50KTtcXG5cXG5cXHRcXHQvKipcXG5cXHRcXHQgKiBQcm94aWVkIGV2ZW50IGhhbmRsZXJzLlxcblxcdFxcdCAqIEBwcm90ZWN0ZWRcXG5cXHRcXHQgKi9cXG5cXHRcXHR0aGlzLl9oYW5kbGVycyA9IHt9O1xcblxcblxcdFxcdC8qKlxcblxcdFxcdCAqIFJlZmVyZW5jZXMgdG8gdGhlIHJ1bm5pbmcgcGx1Z2lucyBvZiB0aGlzIGNhcm91c2VsLlxcblxcdFxcdCAqIEBwcm90ZWN0ZWRcXG5cXHRcXHQgKi9cXG5cXHRcXHR0aGlzLl9wbHVnaW5zID0ge307XFxuXFxuXFx0XFx0LyoqXFxuXFx0XFx0ICogQ3VycmVudGx5IHN1cHByZXNzZWQgZXZlbnRzIHRvIHByZXZlbnQgdGhlbSBmcm9tIGJlZWluZyByZXRyaWdnZXJlZC5cXG5cXHRcXHQgKiBAcHJvdGVjdGVkXFxuXFx0XFx0ICovXFxuXFx0XFx0dGhpcy5fc3VwcmVzcyA9IHt9O1xcblxcblxcdFxcdC8qKlxcblxcdFxcdCAqIEFic29sdXRlIGN1cnJlbnQgcG9zaXRpb24uXFxuXFx0XFx0ICogQHByb3RlY3RlZFxcblxcdFxcdCAqL1xcblxcdFxcdHRoaXMuX2N1cnJlbnQgPSBudWxsO1xcblxcblxcdFxcdC8qKlxcblxcdFxcdCAqIEFuaW1hdGlvbiBzcGVlZCBpbiBtaWxsaXNlY29uZHMuXFxuXFx0XFx0ICogQHByb3RlY3RlZFxcblxcdFxcdCAqL1xcblxcdFxcdHRoaXMuX3NwZWVkID0gbnVsbDtcXG5cXG5cXHRcXHQvKipcXG5cXHRcXHQgKiBDb29yZGluYXRlcyBvZiBhbGwgaXRlbXMgaW4gcGl4ZWwuXFxuXFx0XFx0ICogQHRvZG8gVGhlIG5hbWUgb2YgdGhpcyBtZW1iZXIgaXMgbWlzc2xlYWRpbmcuXFxuXFx0XFx0ICogQHByb3RlY3RlZFxcblxcdFxcdCAqL1xcblxcdFxcdHRoaXMuX2Nvb3JkaW5hdGVzID0gW107XFxuXFxuXFx0XFx0LyoqXFxuXFx0XFx0ICogQ3VycmVudCBicmVha3BvaW50LlxcblxcdFxcdCAqIEB0b2RvIFJlYWwgbWVkaWEgcXVlcmllcyB3b3VsZCBiZSBuaWNlLlxcblxcdFxcdCAqIEBwcm90ZWN0ZWRcXG5cXHRcXHQgKi9cXG5cXHRcXHR0aGlzLl9icmVha3BvaW50ID0gbnVsbDtcXG5cXG5cXHRcXHQvKipcXG5cXHRcXHQgKiBDdXJyZW50IHdpZHRoIG9mIHRoZSBwbHVnaW4gZWxlbWVudC5cXG5cXHRcXHQgKi9cXG5cXHRcXHR0aGlzLl93aWR0aCA9IG51bGw7XFxuXFxuXFx0XFx0LyoqXFxuXFx0XFx0ICogQWxsIHJlYWwgaXRlbXMuXFxuXFx0XFx0ICogQHByb3RlY3RlZFxcblxcdFxcdCAqL1xcblxcdFxcdHRoaXMuX2l0ZW1zID0gW107XFxuXFxuXFx0XFx0LyoqXFxuXFx0XFx0ICogQWxsIGNsb25lZCBpdGVtcy5cXG5cXHRcXHQgKiBAcHJvdGVjdGVkXFxuXFx0XFx0ICovXFxuXFx0XFx0dGhpcy5fY2xvbmVzID0gW107XFxuXFxuXFx0XFx0LyoqXFxuXFx0XFx0ICogTWVyZ2UgdmFsdWVzIG9mIGFsbCBpdGVtcy5cXG5cXHRcXHQgKiBAdG9kbyBNYXliZSB0aGlzIGNvdWxkIGJlIHBhcnQgb2YgYSBwbHVnaW4uXFxuXFx0XFx0ICogQHByb3RlY3RlZFxcblxcdFxcdCAqL1xcblxcdFxcdHRoaXMuX21lcmdlcnMgPSBbXTtcXG5cXG5cXHRcXHQvKipcXG5cXHRcXHQgKiBXaWR0aHMgb2YgYWxsIGl0ZW1zLlxcblxcdFxcdCAqL1xcblxcdFxcdHRoaXMuX3dpZHRocyA9IFtdO1xcblxcblxcdFxcdC8qKlxcblxcdFxcdCAqIEludmFsaWRhdGVkIHBhcnRzIHdpdGhpbiB0aGUgdXBkYXRlIHByb2Nlc3MuXFxuXFx0XFx0ICogQHByb3RlY3RlZFxcblxcdFxcdCAqL1xcblxcdFxcdHRoaXMuX2ludmFsaWRhdGVkID0ge307XFxuXFxuXFx0XFx0LyoqXFxuXFx0XFx0ICogT3JkZXJlZCBsaXN0IG9mIHdvcmtlcnMgZm9yIHRoZSB1cGRhdGUgcHJvY2Vzcy5cXG5cXHRcXHQgKiBAcHJvdGVjdGVkXFxuXFx0XFx0ICovXFxuXFx0XFx0dGhpcy5fcGlwZSA9IFtdO1xcblxcblxcdFxcdC8qKlxcblxcdFxcdCAqIEN1cnJlbnQgc3RhdGUgaW5mb3JtYXRpb24gZm9yIHRoZSBkcmFnIG9wZXJhdGlvbi5cXG5cXHRcXHQgKiBAdG9kbyAjMjYxXFxuXFx0XFx0ICogQHByb3RlY3RlZFxcblxcdFxcdCAqL1xcblxcdFxcdHRoaXMuX2RyYWcgPSB7XFxuXFx0XFx0XFx0dGltZTogbnVsbCxcXG5cXHRcXHRcXHR0YXJnZXQ6IG51bGwsXFxuXFx0XFx0XFx0cG9pbnRlcjogbnVsbCxcXG5cXHRcXHRcXHRzdGFnZToge1xcblxcdFxcdFxcdFxcdHN0YXJ0OiBudWxsLFxcblxcdFxcdFxcdFxcdGN1cnJlbnQ6IG51bGxcXG5cXHRcXHRcXHR9LFxcblxcdFxcdFxcdGRpcmVjdGlvbjogbnVsbFxcblxcdFxcdH07XFxuXFxuXFx0XFx0LyoqXFxuXFx0XFx0ICogQ3VycmVudCBzdGF0ZSBpbmZvcm1hdGlvbiBhbmQgdGhlaXIgdGFncy5cXG5cXHRcXHQgKiBAdHlwZSB7T2JqZWN0fVxcblxcdFxcdCAqIEBwcm90ZWN0ZWRcXG5cXHRcXHQgKi9cXG5cXHRcXHR0aGlzLl9zdGF0ZXMgPSB7XFxuXFx0XFx0XFx0Y3VycmVudDoge30sXFxuXFx0XFx0XFx0dGFnczoge1xcblxcdFxcdFxcdFxcdCdpbml0aWFsaXppbmcnOiBbICdidXN5JyBdLFxcblxcdFxcdFxcdFxcdCdhbmltYXRpbmcnOiBbICdidXN5JyBdLFxcblxcdFxcdFxcdFxcdCdkcmFnZ2luZyc6IFsgJ2ludGVyYWN0aW5nJyBdXFxuXFx0XFx0XFx0fVxcblxcdFxcdH07XFxuXFxuXFx0XFx0JC5lYWNoKFsgJ29uUmVzaXplJywgJ29uVGhyb3R0bGVkUmVzaXplJyBdLCAkLnByb3h5KGZ1bmN0aW9uKGksIGhhbmRsZXIpIHtcXG5cXHRcXHRcXHR0aGlzLl9oYW5kbGVyc1toYW5kbGVyXSA9ICQucHJveHkodGhpc1toYW5kbGVyXSwgdGhpcyk7XFxuXFx0XFx0fSwgdGhpcykpO1xcblxcblxcdFxcdCQuZWFjaChPd2wuUGx1Z2lucywgJC5wcm94eShmdW5jdGlvbihrZXksIHBsdWdpbikge1xcblxcdFxcdFxcdHRoaXMuX3BsdWdpbnNba2V5LmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpICsga2V5LnNsaWNlKDEpXVxcblxcdFxcdFxcdFxcdD0gbmV3IHBsdWdpbih0aGlzKTtcXG5cXHRcXHR9LCB0aGlzKSk7XFxuXFxuXFx0XFx0JC5lYWNoKE93bC5Xb3JrZXJzLCAkLnByb3h5KGZ1bmN0aW9uKHByaW9yaXR5LCB3b3JrZXIpIHtcXG5cXHRcXHRcXHR0aGlzLl9waXBlLnB1c2goe1xcblxcdFxcdFxcdFxcdCdmaWx0ZXInOiB3b3JrZXIuZmlsdGVyLFxcblxcdFxcdFxcdFxcdCdydW4nOiAkLnByb3h5KHdvcmtlci5ydW4sIHRoaXMpXFxuXFx0XFx0XFx0fSk7XFxuXFx0XFx0fSwgdGhpcykpO1xcblxcblxcdFxcdHRoaXMuc2V0dXAoKTtcXG5cXHRcXHR0aGlzLmluaXRpYWxpemUoKTtcXG5cXHR9XFxuXFxuXFx0LyoqXFxuXFx0ICogRGVmYXVsdCBvcHRpb25zIGZvciB0aGUgY2Fyb3VzZWwuXFxuXFx0ICogQHB1YmxpY1xcblxcdCAqL1xcblxcdE93bC5EZWZhdWx0cyA9IHtcXG5cXHRcXHRpdGVtczogMyxcXG5cXHRcXHRsb29wOiBmYWxzZSxcXG5cXHRcXHRjZW50ZXI6IGZhbHNlLFxcblxcdFxcdHJld2luZDogZmFsc2UsXFxuXFxuXFx0XFx0bW91c2VEcmFnOiB0cnVlLFxcblxcdFxcdHRvdWNoRHJhZzogdHJ1ZSxcXG5cXHRcXHRwdWxsRHJhZzogdHJ1ZSxcXG5cXHRcXHRmcmVlRHJhZzogZmFsc2UsXFxuXFxuXFx0XFx0bWFyZ2luOiAwLFxcblxcdFxcdHN0YWdlUGFkZGluZzogMCxcXG5cXG5cXHRcXHRtZXJnZTogZmFsc2UsXFxuXFx0XFx0bWVyZ2VGaXQ6IHRydWUsXFxuXFx0XFx0YXV0b1dpZHRoOiBmYWxzZSxcXG5cXG5cXHRcXHRzdGFydFBvc2l0aW9uOiAwLFxcblxcdFxcdHJ0bDogZmFsc2UsXFxuXFxuXFx0XFx0c21hcnRTcGVlZDogMjUwLFxcblxcdFxcdGZsdWlkU3BlZWQ6IGZhbHNlLFxcblxcdFxcdGRyYWdFbmRTcGVlZDogZmFsc2UsXFxuXFxuXFx0XFx0cmVzcG9uc2l2ZToge30sXFxuXFx0XFx0cmVzcG9uc2l2ZVJlZnJlc2hSYXRlOiAyMDAsXFxuXFx0XFx0cmVzcG9uc2l2ZUJhc2VFbGVtZW50OiB3aW5kb3csXFxuXFxuXFx0XFx0ZmFsbGJhY2tFYXNpbmc6ICdzd2luZycsXFxuXFxuXFx0XFx0aW5mbzogZmFsc2UsXFxuXFxuXFx0XFx0bmVzdGVkSXRlbVNlbGVjdG9yOiBmYWxzZSxcXG5cXHRcXHRpdGVtRWxlbWVudDogJ2RpdicsXFxuXFx0XFx0c3RhZ2VFbGVtZW50OiAnZGl2JyxcXG5cXG5cXHRcXHRyZWZyZXNoQ2xhc3M6ICdvd2wtcmVmcmVzaCcsXFxuXFx0XFx0bG9hZGVkQ2xhc3M6ICdvd2wtbG9hZGVkJyxcXG5cXHRcXHRsb2FkaW5nQ2xhc3M6ICdvd2wtbG9hZGluZycsXFxuXFx0XFx0cnRsQ2xhc3M6ICdvd2wtcnRsJyxcXG5cXHRcXHRyZXNwb25zaXZlQ2xhc3M6ICdvd2wtcmVzcG9uc2l2ZScsXFxuXFx0XFx0ZHJhZ0NsYXNzOiAnb3dsLWRyYWcnLFxcblxcdFxcdGl0ZW1DbGFzczogJ293bC1pdGVtJyxcXG5cXHRcXHRzdGFnZUNsYXNzOiAnb3dsLXN0YWdlJyxcXG5cXHRcXHRzdGFnZU91dGVyQ2xhc3M6ICdvd2wtc3RhZ2Utb3V0ZXInLFxcblxcdFxcdGdyYWJDbGFzczogJ293bC1ncmFiJ1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogRW51bWVyYXRpb24gZm9yIHdpZHRoLlxcblxcdCAqIEBwdWJsaWNcXG5cXHQgKiBAcmVhZG9ubHlcXG5cXHQgKiBAZW51bSB7U3RyaW5nfVxcblxcdCAqL1xcblxcdE93bC5XaWR0aCA9IHtcXG5cXHRcXHREZWZhdWx0OiAnZGVmYXVsdCcsXFxuXFx0XFx0SW5uZXI6ICdpbm5lcicsXFxuXFx0XFx0T3V0ZXI6ICdvdXRlcidcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEVudW1lcmF0aW9uIGZvciB0eXBlcy5cXG5cXHQgKiBAcHVibGljXFxuXFx0ICogQHJlYWRvbmx5XFxuXFx0ICogQGVudW0ge1N0cmluZ31cXG5cXHQgKi9cXG5cXHRPd2wuVHlwZSA9IHtcXG5cXHRcXHRFdmVudDogJ2V2ZW50JyxcXG5cXHRcXHRTdGF0ZTogJ3N0YXRlJ1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogQ29udGFpbnMgYWxsIHJlZ2lzdGVyZWQgcGx1Z2lucy5cXG5cXHQgKiBAcHVibGljXFxuXFx0ICovXFxuXFx0T3dsLlBsdWdpbnMgPSB7fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBMaXN0IG9mIHdvcmtlcnMgaW52b2x2ZWQgaW4gdGhlIHVwZGF0ZSBwcm9jZXNzLlxcblxcdCAqL1xcblxcdE93bC5Xb3JrZXJzID0gWyB7XFxuXFx0XFx0ZmlsdGVyOiBbICd3aWR0aCcsICdzZXR0aW5ncycgXSxcXG5cXHRcXHRydW46IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdHRoaXMuX3dpZHRoID0gdGhpcy4kZWxlbWVudC53aWR0aCgpO1xcblxcdFxcdH1cXG5cXHR9LCB7XFxuXFx0XFx0ZmlsdGVyOiBbICd3aWR0aCcsICdpdGVtcycsICdzZXR0aW5ncycgXSxcXG5cXHRcXHRydW46IGZ1bmN0aW9uKGNhY2hlKSB7XFxuXFx0XFx0XFx0Y2FjaGUuY3VycmVudCA9IHRoaXMuX2l0ZW1zICYmIHRoaXMuX2l0ZW1zW3RoaXMucmVsYXRpdmUodGhpcy5fY3VycmVudCldO1xcblxcdFxcdH1cXG5cXHR9LCB7XFxuXFx0XFx0ZmlsdGVyOiBbICdpdGVtcycsICdzZXR0aW5ncycgXSxcXG5cXHRcXHRydW46IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdHRoaXMuJHN0YWdlLmNoaWxkcmVuKCcuY2xvbmVkJykucmVtb3ZlKCk7XFxuXFx0XFx0fVxcblxcdH0sIHtcXG5cXHRcXHRmaWx0ZXI6IFsgJ3dpZHRoJywgJ2l0ZW1zJywgJ3NldHRpbmdzJyBdLFxcblxcdFxcdHJ1bjogZnVuY3Rpb24oY2FjaGUpIHtcXG5cXHRcXHRcXHR2YXIgbWFyZ2luID0gdGhpcy5zZXR0aW5ncy5tYXJnaW4gfHwgJycsXFxuXFx0XFx0XFx0XFx0Z3JpZCA9ICF0aGlzLnNldHRpbmdzLmF1dG9XaWR0aCxcXG5cXHRcXHRcXHRcXHRydGwgPSB0aGlzLnNldHRpbmdzLnJ0bCxcXG5cXHRcXHRcXHRcXHRjc3MgPSB7XFxuXFx0XFx0XFx0XFx0XFx0J3dpZHRoJzogJ2F1dG8nLFxcblxcdFxcdFxcdFxcdFxcdCdtYXJnaW4tbGVmdCc6IHJ0bCA/IG1hcmdpbiA6ICcnLFxcblxcdFxcdFxcdFxcdFxcdCdtYXJnaW4tcmlnaHQnOiBydGwgPyAnJyA6IG1hcmdpblxcblxcdFxcdFxcdFxcdH07XFxuXFxuXFx0XFx0XFx0IWdyaWQgJiYgdGhpcy4kc3RhZ2UuY2hpbGRyZW4oKS5jc3MoY3NzKTtcXG5cXG5cXHRcXHRcXHRjYWNoZS5jc3MgPSBjc3M7XFxuXFx0XFx0fVxcblxcdH0sIHtcXG5cXHRcXHRmaWx0ZXI6IFsgJ3dpZHRoJywgJ2l0ZW1zJywgJ3NldHRpbmdzJyBdLFxcblxcdFxcdHJ1bjogZnVuY3Rpb24oY2FjaGUpIHtcXG5cXHRcXHRcXHR2YXIgd2lkdGggPSAodGhpcy53aWR0aCgpIC8gdGhpcy5zZXR0aW5ncy5pdGVtcykudG9GaXhlZCgzKSAtIHRoaXMuc2V0dGluZ3MubWFyZ2luLFxcblxcdFxcdFxcdFxcdG1lcmdlID0gbnVsbCxcXG5cXHRcXHRcXHRcXHRpdGVyYXRvciA9IHRoaXMuX2l0ZW1zLmxlbmd0aCxcXG5cXHRcXHRcXHRcXHRncmlkID0gIXRoaXMuc2V0dGluZ3MuYXV0b1dpZHRoLFxcblxcdFxcdFxcdFxcdHdpZHRocyA9IFtdO1xcblxcblxcdFxcdFxcdGNhY2hlLml0ZW1zID0ge1xcblxcdFxcdFxcdFxcdG1lcmdlOiBmYWxzZSxcXG5cXHRcXHRcXHRcXHR3aWR0aDogd2lkdGhcXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdFxcdHdoaWxlIChpdGVyYXRvci0tKSB7XFxuXFx0XFx0XFx0XFx0bWVyZ2UgPSB0aGlzLl9tZXJnZXJzW2l0ZXJhdG9yXTtcXG5cXHRcXHRcXHRcXHRtZXJnZSA9IHRoaXMuc2V0dGluZ3MubWVyZ2VGaXQgJiYgTWF0aC5taW4obWVyZ2UsIHRoaXMuc2V0dGluZ3MuaXRlbXMpIHx8IG1lcmdlO1xcblxcblxcdFxcdFxcdFxcdGNhY2hlLml0ZW1zLm1lcmdlID0gbWVyZ2UgPiAxIHx8IGNhY2hlLml0ZW1zLm1lcmdlO1xcblxcblxcdFxcdFxcdFxcdHdpZHRoc1tpdGVyYXRvcl0gPSAhZ3JpZCA/IHRoaXMuX2l0ZW1zW2l0ZXJhdG9yXS53aWR0aCgpIDogd2lkdGggKiBtZXJnZTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGhpcy5fd2lkdGhzID0gd2lkdGhzO1xcblxcdFxcdH1cXG5cXHR9LCB7XFxuXFx0XFx0ZmlsdGVyOiBbICdpdGVtcycsICdzZXR0aW5ncycgXSxcXG5cXHRcXHRydW46IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdHZhciBjbG9uZXMgPSBbXSxcXG5cXHRcXHRcXHRcXHRpdGVtcyA9IHRoaXMuX2l0ZW1zLFxcblxcdFxcdFxcdFxcdHNldHRpbmdzID0gdGhpcy5zZXR0aW5ncyxcXG5cXHRcXHRcXHRcXHR2aWV3ID0gTWF0aC5tYXgoc2V0dGluZ3MuaXRlbXMgKiAyLCA0KSxcXG5cXHRcXHRcXHRcXHRzaXplID0gTWF0aC5jZWlsKGl0ZW1zLmxlbmd0aCAvIDIpICogMixcXG5cXHRcXHRcXHRcXHRyZXBlYXQgPSBzZXR0aW5ncy5sb29wICYmIGl0ZW1zLmxlbmd0aCA/IHNldHRpbmdzLnJld2luZCA/IHZpZXcgOiBNYXRoLm1heCh2aWV3LCBzaXplKSA6IDAsXFxuXFx0XFx0XFx0XFx0YXBwZW5kID0gJycsXFxuXFx0XFx0XFx0XFx0cHJlcGVuZCA9ICcnO1xcblxcblxcdFxcdFxcdHJlcGVhdCAvPSAyO1xcblxcblxcdFxcdFxcdHdoaWxlIChyZXBlYXQtLSkge1xcblxcdFxcdFxcdFxcdGNsb25lcy5wdXNoKHRoaXMubm9ybWFsaXplKGNsb25lcy5sZW5ndGggLyAyLCB0cnVlKSk7XFxuXFx0XFx0XFx0XFx0YXBwZW5kID0gYXBwZW5kICsgaXRlbXNbY2xvbmVzW2Nsb25lcy5sZW5ndGggLSAxXV1bMF0ub3V0ZXJIVE1MO1xcblxcdFxcdFxcdFxcdGNsb25lcy5wdXNoKHRoaXMubm9ybWFsaXplKGl0ZW1zLmxlbmd0aCAtIDEgLSAoY2xvbmVzLmxlbmd0aCAtIDEpIC8gMiwgdHJ1ZSkpO1xcblxcdFxcdFxcdFxcdHByZXBlbmQgPSBpdGVtc1tjbG9uZXNbY2xvbmVzLmxlbmd0aCAtIDFdXVswXS5vdXRlckhUTUwgKyBwcmVwZW5kO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGlzLl9jbG9uZXMgPSBjbG9uZXM7XFxuXFxuXFx0XFx0XFx0JChhcHBlbmQpLmFkZENsYXNzKCdjbG9uZWQnKS5hcHBlbmRUbyh0aGlzLiRzdGFnZSk7XFxuXFx0XFx0XFx0JChwcmVwZW5kKS5hZGRDbGFzcygnY2xvbmVkJykucHJlcGVuZFRvKHRoaXMuJHN0YWdlKTtcXG5cXHRcXHR9XFxuXFx0fSwge1xcblxcdFxcdGZpbHRlcjogWyAnd2lkdGgnLCAnaXRlbXMnLCAnc2V0dGluZ3MnIF0sXFxuXFx0XFx0cnVuOiBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHR2YXIgcnRsID0gdGhpcy5zZXR0aW5ncy5ydGwgPyAxIDogLTEsXFxuXFx0XFx0XFx0XFx0c2l6ZSA9IHRoaXMuX2Nsb25lcy5sZW5ndGggKyB0aGlzLl9pdGVtcy5sZW5ndGgsXFxuXFx0XFx0XFx0XFx0aXRlcmF0b3IgPSAtMSxcXG5cXHRcXHRcXHRcXHRwcmV2aW91cyA9IDAsXFxuXFx0XFx0XFx0XFx0Y3VycmVudCA9IDAsXFxuXFx0XFx0XFx0XFx0Y29vcmRpbmF0ZXMgPSBbXTtcXG5cXG5cXHRcXHRcXHR3aGlsZSAoKytpdGVyYXRvciA8IHNpemUpIHtcXG5cXHRcXHRcXHRcXHRwcmV2aW91cyA9IGNvb3JkaW5hdGVzW2l0ZXJhdG9yIC0gMV0gfHwgMDtcXG5cXHRcXHRcXHRcXHRjdXJyZW50ID0gdGhpcy5fd2lkdGhzW3RoaXMucmVsYXRpdmUoaXRlcmF0b3IpXSArIHRoaXMuc2V0dGluZ3MubWFyZ2luO1xcblxcdFxcdFxcdFxcdGNvb3JkaW5hdGVzLnB1c2gocHJldmlvdXMgKyBjdXJyZW50ICogcnRsKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGhpcy5fY29vcmRpbmF0ZXMgPSBjb29yZGluYXRlcztcXG5cXHRcXHR9XFxuXFx0fSwge1xcblxcdFxcdGZpbHRlcjogWyAnd2lkdGgnLCAnaXRlbXMnLCAnc2V0dGluZ3MnIF0sXFxuXFx0XFx0cnVuOiBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHR2YXIgcGFkZGluZyA9IHRoaXMuc2V0dGluZ3Muc3RhZ2VQYWRkaW5nLFxcblxcdFxcdFxcdFxcdGNvb3JkaW5hdGVzID0gdGhpcy5fY29vcmRpbmF0ZXMsXFxuXFx0XFx0XFx0XFx0Y3NzID0ge1xcblxcdFxcdFxcdFxcdFxcdCd3aWR0aCc6IE1hdGguY2VpbChNYXRoLmFicyhjb29yZGluYXRlc1tjb29yZGluYXRlcy5sZW5ndGggLSAxXSkpICsgcGFkZGluZyAqIDIsXFxuXFx0XFx0XFx0XFx0XFx0J3BhZGRpbmctbGVmdCc6IHBhZGRpbmcgfHwgJycsXFxuXFx0XFx0XFx0XFx0XFx0J3BhZGRpbmctcmlnaHQnOiBwYWRkaW5nIHx8ICcnXFxuXFx0XFx0XFx0XFx0fTtcXG5cXG5cXHRcXHRcXHR0aGlzLiRzdGFnZS5jc3MoY3NzKTtcXG5cXHRcXHR9XFxuXFx0fSwge1xcblxcdFxcdGZpbHRlcjogWyAnd2lkdGgnLCAnaXRlbXMnLCAnc2V0dGluZ3MnIF0sXFxuXFx0XFx0cnVuOiBmdW5jdGlvbihjYWNoZSkge1xcblxcdFxcdFxcdHZhciBpdGVyYXRvciA9IHRoaXMuX2Nvb3JkaW5hdGVzLmxlbmd0aCxcXG5cXHRcXHRcXHRcXHRncmlkID0gIXRoaXMuc2V0dGluZ3MuYXV0b1dpZHRoLFxcblxcdFxcdFxcdFxcdGl0ZW1zID0gdGhpcy4kc3RhZ2UuY2hpbGRyZW4oKTtcXG5cXG5cXHRcXHRcXHRpZiAoZ3JpZCAmJiBjYWNoZS5pdGVtcy5tZXJnZSkge1xcblxcdFxcdFxcdFxcdHdoaWxlIChpdGVyYXRvci0tKSB7XFxuXFx0XFx0XFx0XFx0XFx0Y2FjaGUuY3NzLndpZHRoID0gdGhpcy5fd2lkdGhzW3RoaXMucmVsYXRpdmUoaXRlcmF0b3IpXTtcXG5cXHRcXHRcXHRcXHRcXHRpdGVtcy5lcShpdGVyYXRvcikuY3NzKGNhY2hlLmNzcyk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0gZWxzZSBpZiAoZ3JpZCkge1xcblxcdFxcdFxcdFxcdGNhY2hlLmNzcy53aWR0aCA9IGNhY2hlLml0ZW1zLndpZHRoO1xcblxcdFxcdFxcdFxcdGl0ZW1zLmNzcyhjYWNoZS5jc3MpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fSwge1xcblxcdFxcdGZpbHRlcjogWyAnaXRlbXMnIF0sXFxuXFx0XFx0cnVuOiBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHR0aGlzLl9jb29yZGluYXRlcy5sZW5ndGggPCAxICYmIHRoaXMuJHN0YWdlLnJlbW92ZUF0dHIoJ3N0eWxlJyk7XFxuXFx0XFx0fVxcblxcdH0sIHtcXG5cXHRcXHRmaWx0ZXI6IFsgJ3dpZHRoJywgJ2l0ZW1zJywgJ3NldHRpbmdzJyBdLFxcblxcdFxcdHJ1bjogZnVuY3Rpb24oY2FjaGUpIHtcXG5cXHRcXHRcXHRjYWNoZS5jdXJyZW50ID0gY2FjaGUuY3VycmVudCA/IHRoaXMuJHN0YWdlLmNoaWxkcmVuKCkuaW5kZXgoY2FjaGUuY3VycmVudCkgOiAwO1xcblxcdFxcdFxcdGNhY2hlLmN1cnJlbnQgPSBNYXRoLm1heCh0aGlzLm1pbmltdW0oKSwgTWF0aC5taW4odGhpcy5tYXhpbXVtKCksIGNhY2hlLmN1cnJlbnQpKTtcXG5cXHRcXHRcXHR0aGlzLnJlc2V0KGNhY2hlLmN1cnJlbnQpO1xcblxcdFxcdH1cXG5cXHR9LCB7XFxuXFx0XFx0ZmlsdGVyOiBbICdwb3NpdGlvbicgXSxcXG5cXHRcXHRydW46IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdHRoaXMuYW5pbWF0ZSh0aGlzLmNvb3JkaW5hdGVzKHRoaXMuX2N1cnJlbnQpKTtcXG5cXHRcXHR9XFxuXFx0fSwge1xcblxcdFxcdGZpbHRlcjogWyAnd2lkdGgnLCAncG9zaXRpb24nLCAnaXRlbXMnLCAnc2V0dGluZ3MnIF0sXFxuXFx0XFx0cnVuOiBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHR2YXIgcnRsID0gdGhpcy5zZXR0aW5ncy5ydGwgPyAxIDogLTEsXFxuXFx0XFx0XFx0XFx0cGFkZGluZyA9IHRoaXMuc2V0dGluZ3Muc3RhZ2VQYWRkaW5nICogMixcXG5cXHRcXHRcXHRcXHRiZWdpbiA9IHRoaXMuY29vcmRpbmF0ZXModGhpcy5jdXJyZW50KCkpICsgcGFkZGluZyxcXG5cXHRcXHRcXHRcXHRlbmQgPSBiZWdpbiArIHRoaXMud2lkdGgoKSAqIHJ0bCxcXG5cXHRcXHRcXHRcXHRpbm5lciwgb3V0ZXIsIG1hdGNoZXMgPSBbXSwgaSwgbjtcXG5cXG5cXHRcXHRcXHRmb3IgKGkgPSAwLCBuID0gdGhpcy5fY29vcmRpbmF0ZXMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0aW5uZXIgPSB0aGlzLl9jb29yZGluYXRlc1tpIC0gMV0gfHwgMDtcXG5cXHRcXHRcXHRcXHRvdXRlciA9IE1hdGguYWJzKHRoaXMuX2Nvb3JkaW5hdGVzW2ldKSArIHBhZGRpbmcgKiBydGw7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCh0aGlzLm9wKGlubmVyLCAnPD0nLCBiZWdpbikgJiYgKHRoaXMub3AoaW5uZXIsICc+JywgZW5kKSkpXFxuXFx0XFx0XFx0XFx0XFx0fHwgKHRoaXMub3Aob3V0ZXIsICc8JywgYmVnaW4pICYmIHRoaXMub3Aob3V0ZXIsICc+JywgZW5kKSkpIHtcXG5cXHRcXHRcXHRcXHRcXHRtYXRjaGVzLnB1c2goaSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGlzLiRzdGFnZS5jaGlsZHJlbignLmFjdGl2ZScpLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcXG5cXHRcXHRcXHR0aGlzLiRzdGFnZS5jaGlsZHJlbignOmVxKCcgKyBtYXRjaGVzLmpvaW4oJyksIDplcSgnKSArICcpJykuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xcblxcblxcdFxcdFxcdGlmICh0aGlzLnNldHRpbmdzLmNlbnRlcikge1xcblxcdFxcdFxcdFxcdHRoaXMuJHN0YWdlLmNoaWxkcmVuKCcuY2VudGVyJykucmVtb3ZlQ2xhc3MoJ2NlbnRlcicpO1xcblxcdFxcdFxcdFxcdHRoaXMuJHN0YWdlLmNoaWxkcmVuKCkuZXEodGhpcy5jdXJyZW50KCkpLmFkZENsYXNzKCdjZW50ZXInKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdH0gXTtcXG5cXG5cXHQvKipcXG5cXHQgKiBJbml0aWFsaXplcyB0aGUgY2Fyb3VzZWwuXFxuXFx0ICogQHByb3RlY3RlZFxcblxcdCAqL1xcblxcdE93bC5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge1xcblxcdFxcdHRoaXMuZW50ZXIoJ2luaXRpYWxpemluZycpO1xcblxcdFxcdHRoaXMudHJpZ2dlcignaW5pdGlhbGl6ZScpO1xcblxcblxcdFxcdHRoaXMuJGVsZW1lbnQudG9nZ2xlQ2xhc3ModGhpcy5zZXR0aW5ncy5ydGxDbGFzcywgdGhpcy5zZXR0aW5ncy5ydGwpO1xcblxcblxcdFxcdGlmICh0aGlzLnNldHRpbmdzLmF1dG9XaWR0aCAmJiAhdGhpcy5pcygncHJlLWxvYWRpbmcnKSkge1xcblxcdFxcdFxcdHZhciBpbWdzLCBuZXN0ZWRTZWxlY3Rvciwgd2lkdGg7XFxuXFx0XFx0XFx0aW1ncyA9IHRoaXMuJGVsZW1lbnQuZmluZCgnaW1nJyk7XFxuXFx0XFx0XFx0bmVzdGVkU2VsZWN0b3IgPSB0aGlzLnNldHRpbmdzLm5lc3RlZEl0ZW1TZWxlY3RvciA/ICcuJyArIHRoaXMuc2V0dGluZ3MubmVzdGVkSXRlbVNlbGVjdG9yIDogdW5kZWZpbmVkO1xcblxcdFxcdFxcdHdpZHRoID0gdGhpcy4kZWxlbWVudC5jaGlsZHJlbihuZXN0ZWRTZWxlY3Rvcikud2lkdGgoKTtcXG5cXG5cXHRcXHRcXHRpZiAoaW1ncy5sZW5ndGggJiYgd2lkdGggPD0gMCkge1xcblxcdFxcdFxcdFxcdHRoaXMucHJlbG9hZEF1dG9XaWR0aEltYWdlcyhpbWdzKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmxvYWRpbmdDbGFzcyk7XFxuXFxuXFx0XFx0Ly8gY3JlYXRlIHN0YWdlXFxuXFx0XFx0dGhpcy4kc3RhZ2UgPSAkKCc8JyArIHRoaXMuc2V0dGluZ3Muc3RhZ2VFbGVtZW50ICsgJyBjbGFzcz1cXFwiJyArIHRoaXMuc2V0dGluZ3Muc3RhZ2VDbGFzcyArICdcXFwiLz4nKVxcblxcdFxcdFxcdC53cmFwKCc8ZGl2IGNsYXNzPVxcXCInICsgdGhpcy5zZXR0aW5ncy5zdGFnZU91dGVyQ2xhc3MgKyAnXFxcIi8+Jyk7XFxuXFxuXFx0XFx0Ly8gYXBwZW5kIHN0YWdlXFxuXFx0XFx0dGhpcy4kZWxlbWVudC5hcHBlbmQodGhpcy4kc3RhZ2UucGFyZW50KCkpO1xcblxcblxcdFxcdC8vIGFwcGVuZCBjb250ZW50XFxuXFx0XFx0dGhpcy5yZXBsYWNlKHRoaXMuJGVsZW1lbnQuY2hpbGRyZW4oKS5ub3QodGhpcy4kc3RhZ2UucGFyZW50KCkpKTtcXG5cXG5cXHRcXHQvLyBjaGVjayB2aXNpYmlsaXR5XFxuXFx0XFx0aWYgKHRoaXMuJGVsZW1lbnQuaXMoJzp2aXNpYmxlJykpIHtcXG5cXHRcXHRcXHQvLyB1cGRhdGUgdmlld1xcblxcdFxcdFxcdHRoaXMucmVmcmVzaCgpO1xcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0Ly8gaW52YWxpZGF0ZSB3aWR0aFxcblxcdFxcdFxcdHRoaXMuaW52YWxpZGF0ZSgnd2lkdGgnKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0dGhpcy4kZWxlbWVudFxcblxcdFxcdFxcdC5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMubG9hZGluZ0NsYXNzKVxcblxcdFxcdFxcdC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMubG9hZGVkQ2xhc3MpO1xcblxcblxcdFxcdC8vIHJlZ2lzdGVyIGV2ZW50IGhhbmRsZXJzXFxuXFx0XFx0dGhpcy5yZWdpc3RlckV2ZW50SGFuZGxlcnMoKTtcXG5cXG5cXHRcXHR0aGlzLmxlYXZlKCdpbml0aWFsaXppbmcnKTtcXG5cXHRcXHR0aGlzLnRyaWdnZXIoJ2luaXRpYWxpemVkJyk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBTZXR1cHMgdGhlIGN1cnJlbnQgc2V0dGluZ3MuXFxuXFx0ICogQHRvZG8gUmVtb3ZlIHJlc3BvbnNpdmUgY2xhc3Nlcy4gV2h5IHNob3VsZCBhZGFwdGl2ZSBkZXNpZ25zIGJlIGJyb3VnaHQgaW50byBJRTg/XFxuXFx0ICogQHRvZG8gU3VwcG9ydCBmb3IgbWVkaWEgcXVlcmllcyBieSB1c2luZyBgbWF0Y2hNZWRpYWAgd291bGQgYmUgbmljZS5cXG5cXHQgKiBAcHVibGljXFxuXFx0ICovXFxuXFx0T3dsLnByb3RvdHlwZS5zZXR1cCA9IGZ1bmN0aW9uKCkge1xcblxcdFxcdHZhciB2aWV3cG9ydCA9IHRoaXMudmlld3BvcnQoKSxcXG5cXHRcXHRcXHRvdmVyd3JpdGVzID0gdGhpcy5vcHRpb25zLnJlc3BvbnNpdmUsXFxuXFx0XFx0XFx0bWF0Y2ggPSAtMSxcXG5cXHRcXHRcXHRzZXR0aW5ncyA9IG51bGw7XFxuXFxuXFx0XFx0aWYgKCFvdmVyd3JpdGVzKSB7XFxuXFx0XFx0XFx0c2V0dGluZ3MgPSAkLmV4dGVuZCh7fSwgdGhpcy5vcHRpb25zKTtcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdCQuZWFjaChvdmVyd3JpdGVzLCBmdW5jdGlvbihicmVha3BvaW50KSB7XFxuXFx0XFx0XFx0XFx0aWYgKGJyZWFrcG9pbnQgPD0gdmlld3BvcnQgJiYgYnJlYWtwb2ludCA+IG1hdGNoKSB7XFxuXFx0XFx0XFx0XFx0XFx0bWF0Y2ggPSBOdW1iZXIoYnJlYWtwb2ludCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0pO1xcblxcblxcdFxcdFxcdHNldHRpbmdzID0gJC5leHRlbmQoe30sIHRoaXMub3B0aW9ucywgb3ZlcndyaXRlc1ttYXRjaF0pO1xcblxcdFxcdFxcdGlmICh0eXBlb2Ygc2V0dGluZ3Muc3RhZ2VQYWRkaW5nID09PSAnZnVuY3Rpb24nKSB7XFxuXFx0XFx0XFx0XFx0c2V0dGluZ3Muc3RhZ2VQYWRkaW5nID0gc2V0dGluZ3Muc3RhZ2VQYWRkaW5nKCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGRlbGV0ZSBzZXR0aW5ncy5yZXNwb25zaXZlO1xcblxcblxcdFxcdFxcdC8vIHJlc3BvbnNpdmUgY2xhc3NcXG5cXHRcXHRcXHRpZiAoc2V0dGluZ3MucmVzcG9uc2l2ZUNsYXNzKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy4kZWxlbWVudC5hdHRyKCdjbGFzcycsXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy4kZWxlbWVudC5hdHRyKCdjbGFzcycpLnJlcGxhY2UobmV3IFJlZ0V4cCgnKCcgKyB0aGlzLm9wdGlvbnMucmVzcG9uc2l2ZUNsYXNzICsgJy0pXFxcXFxcXFxTK1xcXFxcXFxccycsICdnJyksICckMScgKyBtYXRjaClcXG5cXHRcXHRcXHRcXHQpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0dGhpcy50cmlnZ2VyKCdjaGFuZ2UnLCB7IHByb3BlcnR5OiB7IG5hbWU6ICdzZXR0aW5ncycsIHZhbHVlOiBzZXR0aW5ncyB9IH0pO1xcblxcdFxcdHRoaXMuX2JyZWFrcG9pbnQgPSBtYXRjaDtcXG5cXHRcXHR0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XFxuXFx0XFx0dGhpcy5pbnZhbGlkYXRlKCdzZXR0aW5ncycpO1xcblxcdFxcdHRoaXMudHJpZ2dlcignY2hhbmdlZCcsIHsgcHJvcGVydHk6IHsgbmFtZTogJ3NldHRpbmdzJywgdmFsdWU6IHRoaXMuc2V0dGluZ3MgfSB9KTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIFVwZGF0ZXMgb3B0aW9uIGxvZ2ljIGlmIG5lY2Vzc2VyeS5cXG5cXHQgKiBAcHJvdGVjdGVkXFxuXFx0ICovXFxuXFx0T3dsLnByb3RvdHlwZS5vcHRpb25zTG9naWMgPSBmdW5jdGlvbigpIHtcXG5cXHRcXHRpZiAodGhpcy5zZXR0aW5ncy5hdXRvV2lkdGgpIHtcXG5cXHRcXHRcXHR0aGlzLnNldHRpbmdzLnN0YWdlUGFkZGluZyA9IGZhbHNlO1xcblxcdFxcdFxcdHRoaXMuc2V0dGluZ3MubWVyZ2UgPSBmYWxzZTtcXG5cXHRcXHR9XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBQcmVwYXJlcyBhbiBpdGVtIGJlZm9yZSBhZGQuXFxuXFx0ICogQHRvZG8gUmVuYW1lIGV2ZW50IHBhcmFtZXRlciBgY29udGVudGAgdG8gYGl0ZW1gLlxcblxcdCAqIEBwcm90ZWN0ZWRcXG5cXHQgKiBAcmV0dXJucyB7alF1ZXJ5fEhUTUxFbGVtZW50fSAtIFRoZSBpdGVtIGNvbnRhaW5lci5cXG5cXHQgKi9cXG5cXHRPd2wucHJvdG90eXBlLnByZXBhcmUgPSBmdW5jdGlvbihpdGVtKSB7XFxuXFx0XFx0dmFyIGV2ZW50ID0gdGhpcy50cmlnZ2VyKCdwcmVwYXJlJywgeyBjb250ZW50OiBpdGVtIH0pO1xcblxcblxcdFxcdGlmICghZXZlbnQuZGF0YSkge1xcblxcdFxcdFxcdGV2ZW50LmRhdGEgPSAkKCc8JyArIHRoaXMuc2V0dGluZ3MuaXRlbUVsZW1lbnQgKyAnLz4nKVxcblxcdFxcdFxcdFxcdC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuaXRlbUNsYXNzKS5hcHBlbmQoaXRlbSlcXG5cXHRcXHR9XFxuXFxuXFx0XFx0dGhpcy50cmlnZ2VyKCdwcmVwYXJlZCcsIHsgY29udGVudDogZXZlbnQuZGF0YSB9KTtcXG5cXG5cXHRcXHRyZXR1cm4gZXZlbnQuZGF0YTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIFVwZGF0ZXMgdGhlIHZpZXcuXFxuXFx0ICogQHB1YmxpY1xcblxcdCAqL1xcblxcdE93bC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKSB7XFxuXFx0XFx0dmFyIGkgPSAwLFxcblxcdFxcdFxcdG4gPSB0aGlzLl9waXBlLmxlbmd0aCxcXG5cXHRcXHRcXHRmaWx0ZXIgPSAkLnByb3h5KGZ1bmN0aW9uKHApIHsgcmV0dXJuIHRoaXNbcF0gfSwgdGhpcy5faW52YWxpZGF0ZWQpLFxcblxcdFxcdFxcdGNhY2hlID0ge307XFxuXFxuXFx0XFx0d2hpbGUgKGkgPCBuKSB7XFxuXFx0XFx0XFx0aWYgKHRoaXMuX2ludmFsaWRhdGVkLmFsbCB8fCAkLmdyZXAodGhpcy5fcGlwZVtpXS5maWx0ZXIsIGZpbHRlcikubGVuZ3RoID4gMCkge1xcblxcdFxcdFxcdFxcdHRoaXMuX3BpcGVbaV0ucnVuKGNhY2hlKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aSsrO1xcblxcdFxcdH1cXG5cXG5cXHRcXHR0aGlzLl9pbnZhbGlkYXRlZCA9IHt9O1xcblxcblxcdFxcdCF0aGlzLmlzKCd2YWxpZCcpICYmIHRoaXMuZW50ZXIoJ3ZhbGlkJyk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBHZXRzIHRoZSB3aWR0aCBvZiB0aGUgdmlldy5cXG5cXHQgKiBAcHVibGljXFxuXFx0ICogQHBhcmFtIHtPd2wuV2lkdGh9IFtkaW1lbnNpb249T3dsLldpZHRoLkRlZmF1bHRdIC0gVGhlIGRpbWVuc2lvbiB0byByZXR1cm4uXFxuXFx0ICogQHJldHVybnMge051bWJlcn0gLSBUaGUgd2lkdGggb2YgdGhlIHZpZXcgaW4gcGl4ZWwuXFxuXFx0ICovXFxuXFx0T3dsLnByb3RvdHlwZS53aWR0aCA9IGZ1bmN0aW9uKGRpbWVuc2lvbikge1xcblxcdFxcdGRpbWVuc2lvbiA9IGRpbWVuc2lvbiB8fCBPd2wuV2lkdGguRGVmYXVsdDtcXG5cXHRcXHRzd2l0Y2ggKGRpbWVuc2lvbikge1xcblxcdFxcdFxcdGNhc2UgT3dsLldpZHRoLklubmVyOlxcblxcdFxcdFxcdGNhc2UgT3dsLldpZHRoLk91dGVyOlxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLl93aWR0aDtcXG5cXHRcXHRcXHRkZWZhdWx0OlxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLl93aWR0aCAtIHRoaXMuc2V0dGluZ3Muc3RhZ2VQYWRkaW5nICogMiArIHRoaXMuc2V0dGluZ3MubWFyZ2luO1xcblxcdFxcdH1cXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIFJlZnJlc2hlcyB0aGUgY2Fyb3VzZWwgcHJpbWFyaWx5IGZvciBhZGFwdGl2ZSBwdXJwb3Nlcy5cXG5cXHQgKiBAcHVibGljXFxuXFx0ICovXFxuXFx0T3dsLnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24oKSB7XFxuXFx0XFx0dGhpcy5lbnRlcigncmVmcmVzaGluZycpO1xcblxcdFxcdHRoaXMudHJpZ2dlcigncmVmcmVzaCcpO1xcblxcblxcdFxcdHRoaXMuc2V0dXAoKTtcXG5cXG5cXHRcXHR0aGlzLm9wdGlvbnNMb2dpYygpO1xcblxcblxcdFxcdHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3ModGhpcy5vcHRpb25zLnJlZnJlc2hDbGFzcyk7XFxuXFxuXFx0XFx0dGhpcy51cGRhdGUoKTtcXG5cXG5cXHRcXHR0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5yZWZyZXNoQ2xhc3MpO1xcblxcblxcdFxcdHRoaXMubGVhdmUoJ3JlZnJlc2hpbmcnKTtcXG5cXHRcXHR0aGlzLnRyaWdnZXIoJ3JlZnJlc2hlZCcpO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogQ2hlY2tzIHdpbmRvdyBgcmVzaXplYCBldmVudC5cXG5cXHQgKiBAcHJvdGVjdGVkXFxuXFx0ICovXFxuXFx0T3dsLnByb3RvdHlwZS5vblRocm90dGxlZFJlc2l6ZSA9IGZ1bmN0aW9uKCkge1xcblxcdFxcdHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5yZXNpemVUaW1lcik7XFxuXFx0XFx0dGhpcy5yZXNpemVUaW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KHRoaXMuX2hhbmRsZXJzLm9uUmVzaXplLCB0aGlzLnNldHRpbmdzLnJlc3BvbnNpdmVSZWZyZXNoUmF0ZSk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBDaGVja3Mgd2luZG93IGByZXNpemVgIGV2ZW50LlxcblxcdCAqIEBwcm90ZWN0ZWRcXG5cXHQgKi9cXG5cXHRPd2wucHJvdG90eXBlLm9uUmVzaXplID0gZnVuY3Rpb24oKSB7XFxuXFx0XFx0aWYgKCF0aGlzLl9pdGVtcy5sZW5ndGgpIHtcXG5cXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICh0aGlzLl93aWR0aCA9PT0gdGhpcy4kZWxlbWVudC53aWR0aCgpKSB7XFxuXFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAoIXRoaXMuJGVsZW1lbnQuaXMoJzp2aXNpYmxlJykpIHtcXG5cXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0fVxcblxcblxcdFxcdHRoaXMuZW50ZXIoJ3Jlc2l6aW5nJyk7XFxuXFxuXFx0XFx0aWYgKHRoaXMudHJpZ2dlcigncmVzaXplJykuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcXG5cXHRcXHRcXHR0aGlzLmxlYXZlKCdyZXNpemluZycpO1xcblxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0dGhpcy5pbnZhbGlkYXRlKCd3aWR0aCcpO1xcblxcblxcdFxcdHRoaXMucmVmcmVzaCgpO1xcblxcblxcdFxcdHRoaXMubGVhdmUoJ3Jlc2l6aW5nJyk7XFxuXFx0XFx0dGhpcy50cmlnZ2VyKCdyZXNpemVkJyk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBSZWdpc3RlcnMgZXZlbnQgaGFuZGxlcnMuXFxuXFx0ICogQHRvZG8gQ2hlY2sgYG1zUG9pbnRlckVuYWJsZWRgXFxuXFx0ICogQHRvZG8gIzI2MVxcblxcdCAqIEBwcm90ZWN0ZWRcXG5cXHQgKi9cXG5cXHRPd2wucHJvdG90eXBlLnJlZ2lzdGVyRXZlbnRIYW5kbGVycyA9IGZ1bmN0aW9uKCkge1xcblxcdFxcdGlmICgkLnN1cHBvcnQudHJhbnNpdGlvbikge1xcblxcdFxcdFxcdHRoaXMuJHN0YWdlLm9uKCQuc3VwcG9ydC50cmFuc2l0aW9uLmVuZCArICcub3dsLmNvcmUnLCAkLnByb3h5KHRoaXMub25UcmFuc2l0aW9uRW5kLCB0aGlzKSk7XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICh0aGlzLnNldHRpbmdzLnJlc3BvbnNpdmUgIT09IGZhbHNlKSB7XFxuXFx0XFx0XFx0dGhpcy5vbih3aW5kb3csICdyZXNpemUnLCB0aGlzLl9oYW5kbGVycy5vblRocm90dGxlZFJlc2l6ZSk7XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICh0aGlzLnNldHRpbmdzLm1vdXNlRHJhZykge1xcblxcdFxcdFxcdHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmRyYWdDbGFzcyk7XFxuXFx0XFx0XFx0dGhpcy4kc3RhZ2Uub24oJ21vdXNlZG93bi5vd2wuY29yZScsICQucHJveHkodGhpcy5vbkRyYWdTdGFydCwgdGhpcykpO1xcblxcdFxcdFxcdHRoaXMuJHN0YWdlLm9uKCdkcmFnc3RhcnQub3dsLmNvcmUgc2VsZWN0c3RhcnQub3dsLmNvcmUnLCBmdW5jdGlvbigpIHsgcmV0dXJuIGZhbHNlIH0pO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAodGhpcy5zZXR0aW5ncy50b3VjaERyYWcpe1xcblxcdFxcdFxcdHRoaXMuJHN0YWdlLm9uKCd0b3VjaHN0YXJ0Lm93bC5jb3JlJywgJC5wcm94eSh0aGlzLm9uRHJhZ1N0YXJ0LCB0aGlzKSk7XFxuXFx0XFx0XFx0dGhpcy4kc3RhZ2Uub24oJ3RvdWNoY2FuY2VsLm93bC5jb3JlJywgJC5wcm94eSh0aGlzLm9uRHJhZ0VuZCwgdGhpcykpO1xcblxcdFxcdH1cXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEhhbmRsZXMgYHRvdWNoc3RhcnRgIGFuZCBgbW91c2Vkb3duYCBldmVudHMuXFxuXFx0ICogQHRvZG8gSG9yaXpvbnRhbCBzd2lwZSB0aHJlc2hvbGQgYXMgb3B0aW9uXFxuXFx0ICogQHRvZG8gIzI2MVxcblxcdCAqIEBwcm90ZWN0ZWRcXG5cXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIFRoZSBldmVudCBhcmd1bWVudHMuXFxuXFx0ICovXFxuXFx0T3dsLnByb3RvdHlwZS5vbkRyYWdTdGFydCA9IGZ1bmN0aW9uKGV2ZW50KSB7XFxuXFx0XFx0dmFyIHN0YWdlID0gbnVsbDtcXG5cXG5cXHRcXHRpZiAoZXZlbnQud2hpY2ggPT09IDMpIHtcXG5cXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICgkLnN1cHBvcnQudHJhbnNmb3JtKSB7XFxuXFx0XFx0XFx0c3RhZ2UgPSB0aGlzLiRzdGFnZS5jc3MoJ3RyYW5zZm9ybScpLnJlcGxhY2UoLy4qXFxcXCh8XFxcXCl8IC9nLCAnJykuc3BsaXQoJywnKTtcXG5cXHRcXHRcXHRzdGFnZSA9IHtcXG5cXHRcXHRcXHRcXHR4OiBzdGFnZVtzdGFnZS5sZW5ndGggPT09IDE2ID8gMTIgOiA0XSxcXG5cXHRcXHRcXHRcXHR5OiBzdGFnZVtzdGFnZS5sZW5ndGggPT09IDE2ID8gMTMgOiA1XVxcblxcdFxcdFxcdH07XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRzdGFnZSA9IHRoaXMuJHN0YWdlLnBvc2l0aW9uKCk7XFxuXFx0XFx0XFx0c3RhZ2UgPSB7XFxuXFx0XFx0XFx0XFx0eDogdGhpcy5zZXR0aW5ncy5ydGwgP1xcblxcdFxcdFxcdFxcdFxcdHN0YWdlLmxlZnQgKyB0aGlzLiRzdGFnZS53aWR0aCgpIC0gdGhpcy53aWR0aCgpICsgdGhpcy5zZXR0aW5ncy5tYXJnaW4gOlxcblxcdFxcdFxcdFxcdFxcdHN0YWdlLmxlZnQsXFxuXFx0XFx0XFx0XFx0eTogc3RhZ2UudG9wXFxuXFx0XFx0XFx0fTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKHRoaXMuaXMoJ2FuaW1hdGluZycpKSB7XFxuXFx0XFx0XFx0JC5zdXBwb3J0LnRyYW5zZm9ybSA/IHRoaXMuYW5pbWF0ZShzdGFnZS54KSA6IHRoaXMuJHN0YWdlLnN0b3AoKVxcblxcdFxcdFxcdHRoaXMuaW52YWxpZGF0ZSgncG9zaXRpb24nKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0dGhpcy4kZWxlbWVudC50b2dnbGVDbGFzcyh0aGlzLm9wdGlvbnMuZ3JhYkNsYXNzLCBldmVudC50eXBlID09PSAnbW91c2Vkb3duJyk7XFxuXFxuXFx0XFx0dGhpcy5zcGVlZCgwKTtcXG5cXG5cXHRcXHR0aGlzLl9kcmFnLnRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcXG5cXHRcXHR0aGlzLl9kcmFnLnRhcmdldCA9ICQoZXZlbnQudGFyZ2V0KTtcXG5cXHRcXHR0aGlzLl9kcmFnLnN0YWdlLnN0YXJ0ID0gc3RhZ2U7XFxuXFx0XFx0dGhpcy5fZHJhZy5zdGFnZS5jdXJyZW50ID0gc3RhZ2U7XFxuXFx0XFx0dGhpcy5fZHJhZy5wb2ludGVyID0gdGhpcy5wb2ludGVyKGV2ZW50KTtcXG5cXG5cXHRcXHQkKGRvY3VtZW50KS5vbignbW91c2V1cC5vd2wuY29yZSB0b3VjaGVuZC5vd2wuY29yZScsICQucHJveHkodGhpcy5vbkRyYWdFbmQsIHRoaXMpKTtcXG5cXG5cXHRcXHQkKGRvY3VtZW50KS5vbmUoJ21vdXNlbW92ZS5vd2wuY29yZSB0b3VjaG1vdmUub3dsLmNvcmUnLCAkLnByb3h5KGZ1bmN0aW9uKGV2ZW50KSB7XFxuXFx0XFx0XFx0dmFyIGRlbHRhID0gdGhpcy5kaWZmZXJlbmNlKHRoaXMuX2RyYWcucG9pbnRlciwgdGhpcy5wb2ludGVyKGV2ZW50KSk7XFxuXFxuXFx0XFx0XFx0JChkb2N1bWVudCkub24oJ21vdXNlbW92ZS5vd2wuY29yZSB0b3VjaG1vdmUub3dsLmNvcmUnLCAkLnByb3h5KHRoaXMub25EcmFnTW92ZSwgdGhpcykpO1xcblxcblxcdFxcdFxcdGlmIChNYXRoLmFicyhkZWx0YS54KSA8IE1hdGguYWJzKGRlbHRhLnkpICYmIHRoaXMuaXMoJ3ZhbGlkJykpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XFxuXFxuXFx0XFx0XFx0dGhpcy5lbnRlcignZHJhZ2dpbmcnKTtcXG5cXHRcXHRcXHR0aGlzLnRyaWdnZXIoJ2RyYWcnKTtcXG5cXHRcXHR9LCB0aGlzKSk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBIYW5kbGVzIHRoZSBgdG91Y2htb3ZlYCBhbmQgYG1vdXNlbW92ZWAgZXZlbnRzLlxcblxcdCAqIEB0b2RvICMyNjFcXG5cXHQgKiBAcHJvdGVjdGVkXFxuXFx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBUaGUgZXZlbnQgYXJndW1lbnRzLlxcblxcdCAqL1xcblxcdE93bC5wcm90b3R5cGUub25EcmFnTW92ZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XFxuXFx0XFx0dmFyIG1pbmltdW0gPSBudWxsLFxcblxcdFxcdFxcdG1heGltdW0gPSBudWxsLFxcblxcdFxcdFxcdHB1bGwgPSBudWxsLFxcblxcdFxcdFxcdGRlbHRhID0gdGhpcy5kaWZmZXJlbmNlKHRoaXMuX2RyYWcucG9pbnRlciwgdGhpcy5wb2ludGVyKGV2ZW50KSksXFxuXFx0XFx0XFx0c3RhZ2UgPSB0aGlzLmRpZmZlcmVuY2UodGhpcy5fZHJhZy5zdGFnZS5zdGFydCwgZGVsdGEpO1xcblxcblxcdFxcdGlmICghdGhpcy5pcygnZHJhZ2dpbmcnKSkge1xcblxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG5cXG5cXHRcXHRpZiAodGhpcy5zZXR0aW5ncy5sb29wKSB7XFxuXFx0XFx0XFx0bWluaW11bSA9IHRoaXMuY29vcmRpbmF0ZXModGhpcy5taW5pbXVtKCkpO1xcblxcdFxcdFxcdG1heGltdW0gPSB0aGlzLmNvb3JkaW5hdGVzKHRoaXMubWF4aW11bSgpICsgMSkgLSBtaW5pbXVtO1xcblxcdFxcdFxcdHN0YWdlLnggPSAoKChzdGFnZS54IC0gbWluaW11bSkgJSBtYXhpbXVtICsgbWF4aW11bSkgJSBtYXhpbXVtKSArIG1pbmltdW07XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRtaW5pbXVtID0gdGhpcy5zZXR0aW5ncy5ydGwgPyB0aGlzLmNvb3JkaW5hdGVzKHRoaXMubWF4aW11bSgpKSA6IHRoaXMuY29vcmRpbmF0ZXModGhpcy5taW5pbXVtKCkpO1xcblxcdFxcdFxcdG1heGltdW0gPSB0aGlzLnNldHRpbmdzLnJ0bCA/IHRoaXMuY29vcmRpbmF0ZXModGhpcy5taW5pbXVtKCkpIDogdGhpcy5jb29yZGluYXRlcyh0aGlzLm1heGltdW0oKSk7XFxuXFx0XFx0XFx0cHVsbCA9IHRoaXMuc2V0dGluZ3MucHVsbERyYWcgPyAtMSAqIGRlbHRhLnggLyA1IDogMDtcXG5cXHRcXHRcXHRzdGFnZS54ID0gTWF0aC5tYXgoTWF0aC5taW4oc3RhZ2UueCwgbWluaW11bSArIHB1bGwpLCBtYXhpbXVtICsgcHVsbCk7XFxuXFx0XFx0fVxcblxcblxcdFxcdHRoaXMuX2RyYWcuc3RhZ2UuY3VycmVudCA9IHN0YWdlO1xcblxcblxcdFxcdHRoaXMuYW5pbWF0ZShzdGFnZS54KTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEhhbmRsZXMgdGhlIGB0b3VjaGVuZGAgYW5kIGBtb3VzZXVwYCBldmVudHMuXFxuXFx0ICogQHRvZG8gIzI2MVxcblxcdCAqIEB0b2RvIFRocmVzaG9sZCBmb3IgY2xpY2sgZXZlbnRcXG5cXHQgKiBAcHJvdGVjdGVkXFxuXFx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBUaGUgZXZlbnQgYXJndW1lbnRzLlxcblxcdCAqL1xcblxcdE93bC5wcm90b3R5cGUub25EcmFnRW5kID0gZnVuY3Rpb24oZXZlbnQpIHtcXG5cXHRcXHR2YXIgZGVsdGEgPSB0aGlzLmRpZmZlcmVuY2UodGhpcy5fZHJhZy5wb2ludGVyLCB0aGlzLnBvaW50ZXIoZXZlbnQpKSxcXG5cXHRcXHRcXHRzdGFnZSA9IHRoaXMuX2RyYWcuc3RhZ2UuY3VycmVudCxcXG5cXHRcXHRcXHRkaXJlY3Rpb24gPSBkZWx0YS54ID4gMCBeIHRoaXMuc2V0dGluZ3MucnRsID8gJ2xlZnQnIDogJ3JpZ2h0JztcXG5cXG5cXHRcXHQkKGRvY3VtZW50KS5vZmYoJy5vd2wuY29yZScpO1xcblxcblxcdFxcdHRoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmdyYWJDbGFzcyk7XFxuXFxuXFx0XFx0aWYgKGRlbHRhLnggIT09IDAgJiYgdGhpcy5pcygnZHJhZ2dpbmcnKSB8fCAhdGhpcy5pcygndmFsaWQnKSkge1xcblxcdFxcdFxcdHRoaXMuc3BlZWQodGhpcy5zZXR0aW5ncy5kcmFnRW5kU3BlZWQgfHwgdGhpcy5zZXR0aW5ncy5zbWFydFNwZWVkKTtcXG5cXHRcXHRcXHR0aGlzLmN1cnJlbnQodGhpcy5jbG9zZXN0KHN0YWdlLngsIGRlbHRhLnggIT09IDAgPyBkaXJlY3Rpb24gOiB0aGlzLl9kcmFnLmRpcmVjdGlvbikpO1xcblxcdFxcdFxcdHRoaXMuaW52YWxpZGF0ZSgncG9zaXRpb24nKTtcXG5cXHRcXHRcXHR0aGlzLnVwZGF0ZSgpO1xcblxcblxcdFxcdFxcdHRoaXMuX2RyYWcuZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xcblxcblxcdFxcdFxcdGlmIChNYXRoLmFicyhkZWx0YS54KSA+IDMgfHwgbmV3IERhdGUoKS5nZXRUaW1lKCkgLSB0aGlzLl9kcmFnLnRpbWUgPiAzMDApIHtcXG5cXHRcXHRcXHRcXHR0aGlzLl9kcmFnLnRhcmdldC5vbmUoJ2NsaWNrLm93bC5jb3JlJywgZnVuY3Rpb24oKSB7IHJldHVybiBmYWxzZTsgfSk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAoIXRoaXMuaXMoJ2RyYWdnaW5nJykpIHtcXG5cXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0fVxcblxcblxcdFxcdHRoaXMubGVhdmUoJ2RyYWdnaW5nJyk7XFxuXFx0XFx0dGhpcy50cmlnZ2VyKCdkcmFnZ2VkJyk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBHZXRzIGFic29sdXRlIHBvc2l0aW9uIG9mIHRoZSBjbG9zZXN0IGl0ZW0gZm9yIGEgY29vcmRpbmF0ZS5cXG5cXHQgKiBAdG9kbyBTZXR0aW5nIGBmcmVlRHJhZ2AgbWFrZXMgYGNsb3Nlc3RgIG5vdCByZXVzYWJsZS4gU2VlICMxNjUuXFxuXFx0ICogQHByb3RlY3RlZFxcblxcdCAqIEBwYXJhbSB7TnVtYmVyfSBjb29yZGluYXRlIC0gVGhlIGNvb3JkaW5hdGUgaW4gcGl4ZWwuXFxuXFx0ICogQHBhcmFtIHtTdHJpbmd9IGRpcmVjdGlvbiAtIFRoZSBkaXJlY3Rpb24gdG8gY2hlY2sgZm9yIHRoZSBjbG9zZXN0IGl0ZW0uIEV0aGVyIGBsZWZ0YCBvciBgcmlnaHRgLlxcblxcdCAqIEByZXR1cm4ge051bWJlcn0gLSBUaGUgYWJzb2x1dGUgcG9zaXRpb24gb2YgdGhlIGNsb3Nlc3QgaXRlbS5cXG5cXHQgKi9cXG5cXHRPd2wucHJvdG90eXBlLmNsb3Nlc3QgPSBmdW5jdGlvbihjb29yZGluYXRlLCBkaXJlY3Rpb24pIHtcXG5cXHRcXHR2YXIgcG9zaXRpb24gPSAtMSxcXG5cXHRcXHRcXHRwdWxsID0gMzAsXFxuXFx0XFx0XFx0d2lkdGggPSB0aGlzLndpZHRoKCksXFxuXFx0XFx0XFx0Y29vcmRpbmF0ZXMgPSB0aGlzLmNvb3JkaW5hdGVzKCk7XFxuXFxuXFx0XFx0aWYgKCF0aGlzLnNldHRpbmdzLmZyZWVEcmFnKSB7XFxuXFx0XFx0XFx0Ly8gY2hlY2sgY2xvc2VzdCBpdGVtXFxuXFx0XFx0XFx0JC5lYWNoKGNvb3JkaW5hdGVzLCAkLnByb3h5KGZ1bmN0aW9uKGluZGV4LCB2YWx1ZSkge1xcblxcdFxcdFxcdFxcdC8vIG9uIGEgbGVmdCBwdWxsLCBjaGVjayBvbiBjdXJyZW50IGluZGV4XFxuXFx0XFx0XFx0XFx0aWYgKGRpcmVjdGlvbiA9PT0gJ2xlZnQnICYmIGNvb3JkaW5hdGUgPiB2YWx1ZSAtIHB1bGwgJiYgY29vcmRpbmF0ZSA8IHZhbHVlICsgcHVsbCkge1xcblxcdFxcdFxcdFxcdFxcdHBvc2l0aW9uID0gaW5kZXg7XFxuXFx0XFx0XFx0XFx0Ly8gb24gYSByaWdodCBwdWxsLCBjaGVjayBvbiBwcmV2aW91cyBpbmRleFxcblxcdFxcdFxcdFxcdC8vIHRvIGRvIHNvLCBzdWJ0cmFjdCB3aWR0aCBmcm9tIHZhbHVlIGFuZCBzZXQgcG9zaXRpb24gPSBpbmRleCArIDFcXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gJ3JpZ2h0JyAmJiBjb29yZGluYXRlID4gdmFsdWUgLSB3aWR0aCAtIHB1bGwgJiYgY29vcmRpbmF0ZSA8IHZhbHVlIC0gd2lkdGggKyBwdWxsKSB7XFxuXFx0XFx0XFx0XFx0XFx0cG9zaXRpb24gPSBpbmRleCArIDE7XFxuXFx0XFx0XFx0XFx0fSBlbHNlIGlmICh0aGlzLm9wKGNvb3JkaW5hdGUsICc8JywgdmFsdWUpXFxuXFx0XFx0XFx0XFx0XFx0JiYgdGhpcy5vcChjb29yZGluYXRlLCAnPicsIGNvb3JkaW5hdGVzW2luZGV4ICsgMV0gfHwgdmFsdWUgLSB3aWR0aCkpIHtcXG5cXHRcXHRcXHRcXHRcXHRwb3NpdGlvbiA9IGRpcmVjdGlvbiA9PT0gJ2xlZnQnID8gaW5kZXggKyAxIDogaW5kZXg7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHJldHVybiBwb3NpdGlvbiA9PT0gLTE7XFxuXFx0XFx0XFx0fSwgdGhpcykpO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAoIXRoaXMuc2V0dGluZ3MubG9vcCkge1xcblxcdFxcdFxcdC8vIG5vbiBsb29wIGJvdW5kcmllc1xcblxcdFxcdFxcdGlmICh0aGlzLm9wKGNvb3JkaW5hdGUsICc+JywgY29vcmRpbmF0ZXNbdGhpcy5taW5pbXVtKCldKSkge1xcblxcdFxcdFxcdFxcdHBvc2l0aW9uID0gY29vcmRpbmF0ZSA9IHRoaXMubWluaW11bSgpO1xcblxcdFxcdFxcdH0gZWxzZSBpZiAodGhpcy5vcChjb29yZGluYXRlLCAnPCcsIGNvb3JkaW5hdGVzW3RoaXMubWF4aW11bSgpXSkpIHtcXG5cXHRcXHRcXHRcXHRwb3NpdGlvbiA9IGNvb3JkaW5hdGUgPSB0aGlzLm1heGltdW0oKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiBwb3NpdGlvbjtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEFuaW1hdGVzIHRoZSBzdGFnZS5cXG5cXHQgKiBAdG9kbyAjMjcwXFxuXFx0ICogQHB1YmxpY1xcblxcdCAqIEBwYXJhbSB7TnVtYmVyfSBjb29yZGluYXRlIC0gVGhlIGNvb3JkaW5hdGUgaW4gcGl4ZWxzLlxcblxcdCAqL1xcblxcdE93bC5wcm90b3R5cGUuYW5pbWF0ZSA9IGZ1bmN0aW9uKGNvb3JkaW5hdGUpIHtcXG5cXHRcXHR2YXIgYW5pbWF0ZSA9IHRoaXMuc3BlZWQoKSA+IDA7XFxuXFxuXFx0XFx0dGhpcy5pcygnYW5pbWF0aW5nJykgJiYgdGhpcy5vblRyYW5zaXRpb25FbmQoKTtcXG5cXG5cXHRcXHRpZiAoYW5pbWF0ZSkge1xcblxcdFxcdFxcdHRoaXMuZW50ZXIoJ2FuaW1hdGluZycpO1xcblxcdFxcdFxcdHRoaXMudHJpZ2dlcigndHJhbnNsYXRlJyk7XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICgkLnN1cHBvcnQudHJhbnNmb3JtM2QgJiYgJC5zdXBwb3J0LnRyYW5zaXRpb24pIHtcXG5cXHRcXHRcXHR0aGlzLiRzdGFnZS5jc3Moe1xcblxcdFxcdFxcdFxcdHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKCcgKyBjb29yZGluYXRlICsgJ3B4LDBweCwwcHgpJyxcXG5cXHRcXHRcXHRcXHR0cmFuc2l0aW9uOiAodGhpcy5zcGVlZCgpIC8gMTAwMCkgKyAncydcXG5cXHRcXHRcXHR9KTtcXG5cXHRcXHR9IGVsc2UgaWYgKGFuaW1hdGUpIHtcXG5cXHRcXHRcXHR0aGlzLiRzdGFnZS5hbmltYXRlKHtcXG5cXHRcXHRcXHRcXHRsZWZ0OiBjb29yZGluYXRlICsgJ3B4J1xcblxcdFxcdFxcdH0sIHRoaXMuc3BlZWQoKSwgdGhpcy5zZXR0aW5ncy5mYWxsYmFja0Vhc2luZywgJC5wcm94eSh0aGlzLm9uVHJhbnNpdGlvbkVuZCwgdGhpcykpO1xcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0dGhpcy4kc3RhZ2UuY3NzKHtcXG5cXHRcXHRcXHRcXHRsZWZ0OiBjb29yZGluYXRlICsgJ3B4J1xcblxcdFxcdFxcdH0pO1xcblxcdFxcdH1cXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIENoZWNrcyB3aGV0aGVyIHRoZSBjYXJvdXNlbCBpcyBpbiBhIHNwZWNpZmljIHN0YXRlIG9yIG5vdC5cXG5cXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RhdGUgLSBUaGUgc3RhdGUgdG8gY2hlY2suXFxuXFx0ICogQHJldHVybnMge0Jvb2xlYW59IC0gVGhlIGZsYWcgd2hpY2ggaW5kaWNhdGVzIGlmIHRoZSBjYXJvdXNlbCBpcyBidXN5LlxcblxcdCAqL1xcblxcdE93bC5wcm90b3R5cGUuaXMgPSBmdW5jdGlvbihzdGF0ZSkge1xcblxcdFxcdHJldHVybiB0aGlzLl9zdGF0ZXMuY3VycmVudFtzdGF0ZV0gJiYgdGhpcy5fc3RhdGVzLmN1cnJlbnRbc3RhdGVdID4gMDtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIFNldHMgdGhlIGFic29sdXRlIHBvc2l0aW9uIG9mIHRoZSBjdXJyZW50IGl0ZW0uXFxuXFx0ICogQHB1YmxpY1xcblxcdCAqIEBwYXJhbSB7TnVtYmVyfSBbcG9zaXRpb25dIC0gVGhlIG5ldyBhYnNvbHV0ZSBwb3NpdGlvbiBvciBub3RoaW5nIHRvIGxlYXZlIGl0IHVuY2hhbmdlZC5cXG5cXHQgKiBAcmV0dXJucyB7TnVtYmVyfSAtIFRoZSBhYnNvbHV0ZSBwb3NpdGlvbiBvZiB0aGUgY3VycmVudCBpdGVtLlxcblxcdCAqL1xcblxcdE93bC5wcm90b3R5cGUuY3VycmVudCA9IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XFxuXFx0XFx0aWYgKHBvc2l0aW9uID09PSB1bmRlZmluZWQpIHtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5fY3VycmVudDtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKHRoaXMuX2l0ZW1zLmxlbmd0aCA9PT0gMCkge1xcblxcdFxcdFxcdHJldHVybiB1bmRlZmluZWQ7XFxuXFx0XFx0fVxcblxcblxcdFxcdHBvc2l0aW9uID0gdGhpcy5ub3JtYWxpemUocG9zaXRpb24pO1xcblxcblxcdFxcdGlmICh0aGlzLl9jdXJyZW50ICE9PSBwb3NpdGlvbikge1xcblxcdFxcdFxcdHZhciBldmVudCA9IHRoaXMudHJpZ2dlcignY2hhbmdlJywgeyBwcm9wZXJ0eTogeyBuYW1lOiAncG9zaXRpb24nLCB2YWx1ZTogcG9zaXRpb24gfSB9KTtcXG5cXG5cXHRcXHRcXHRpZiAoZXZlbnQuZGF0YSAhPT0gdW5kZWZpbmVkKSB7XFxuXFx0XFx0XFx0XFx0cG9zaXRpb24gPSB0aGlzLm5vcm1hbGl6ZShldmVudC5kYXRhKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGhpcy5fY3VycmVudCA9IHBvc2l0aW9uO1xcblxcblxcdFxcdFxcdHRoaXMuaW52YWxpZGF0ZSgncG9zaXRpb24nKTtcXG5cXG5cXHRcXHRcXHR0aGlzLnRyaWdnZXIoJ2NoYW5nZWQnLCB7IHByb3BlcnR5OiB7IG5hbWU6ICdwb3NpdGlvbicsIHZhbHVlOiB0aGlzLl9jdXJyZW50IH0gfSk7XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiB0aGlzLl9jdXJyZW50O1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogSW52YWxpZGF0ZXMgdGhlIGdpdmVuIHBhcnQgb2YgdGhlIHVwZGF0ZSByb3V0aW5lLlxcblxcdCAqIEBwYXJhbSB7U3RyaW5nfSBbcGFydF0gLSBUaGUgcGFydCB0byBpbnZhbGlkYXRlLlxcblxcdCAqIEByZXR1cm5zIHtBcnJheS48U3RyaW5nPn0gLSBUaGUgaW52YWxpZGF0ZWQgcGFydHMuXFxuXFx0ICovXFxuXFx0T3dsLnByb3RvdHlwZS5pbnZhbGlkYXRlID0gZnVuY3Rpb24ocGFydCkge1xcblxcdFxcdGlmICgkLnR5cGUocGFydCkgPT09ICdzdHJpbmcnKSB7XFxuXFx0XFx0XFx0dGhpcy5faW52YWxpZGF0ZWRbcGFydF0gPSB0cnVlO1xcblxcdFxcdFxcdHRoaXMuaXMoJ3ZhbGlkJykgJiYgdGhpcy5sZWF2ZSgndmFsaWQnKTtcXG5cXHRcXHR9XFxuXFx0XFx0cmV0dXJuICQubWFwKHRoaXMuX2ludmFsaWRhdGVkLCBmdW5jdGlvbih2LCBpKSB7IHJldHVybiBpIH0pO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogUmVzZXRzIHRoZSBhYnNvbHV0ZSBwb3NpdGlvbiBvZiB0aGUgY3VycmVudCBpdGVtLlxcblxcdCAqIEBwdWJsaWNcXG5cXHQgKiBAcGFyYW0ge051bWJlcn0gcG9zaXRpb24gLSBUaGUgYWJzb2x1dGUgcG9zaXRpb24gb2YgdGhlIG5ldyBpdGVtLlxcblxcdCAqL1xcblxcdE93bC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbihwb3NpdGlvbikge1xcblxcdFxcdHBvc2l0aW9uID0gdGhpcy5ub3JtYWxpemUocG9zaXRpb24pO1xcblxcblxcdFxcdGlmIChwb3NpdGlvbiA9PT0gdW5kZWZpbmVkKSB7XFxuXFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdH1cXG5cXG5cXHRcXHR0aGlzLl9zcGVlZCA9IDA7XFxuXFx0XFx0dGhpcy5fY3VycmVudCA9IHBvc2l0aW9uO1xcblxcblxcdFxcdHRoaXMuc3VwcHJlc3MoWyAndHJhbnNsYXRlJywgJ3RyYW5zbGF0ZWQnIF0pO1xcblxcblxcdFxcdHRoaXMuYW5pbWF0ZSh0aGlzLmNvb3JkaW5hdGVzKHBvc2l0aW9uKSk7XFxuXFxuXFx0XFx0dGhpcy5yZWxlYXNlKFsgJ3RyYW5zbGF0ZScsICd0cmFuc2xhdGVkJyBdKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIE5vcm1hbGl6ZXMgYW4gYWJzb2x1dGUgb3IgYSByZWxhdGl2ZSBwb3NpdGlvbiBvZiBhbiBpdGVtLlxcblxcdCAqIEBwdWJsaWNcXG5cXHQgKiBAcGFyYW0ge051bWJlcn0gcG9zaXRpb24gLSBUaGUgYWJzb2x1dGUgb3IgcmVsYXRpdmUgcG9zaXRpb24gdG8gbm9ybWFsaXplLlxcblxcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW3JlbGF0aXZlPWZhbHNlXSAtIFdoZXRoZXIgdGhlIGdpdmVuIHBvc2l0aW9uIGlzIHJlbGF0aXZlIG9yIG5vdC5cXG5cXHQgKiBAcmV0dXJucyB7TnVtYmVyfSAtIFRoZSBub3JtYWxpemVkIHBvc2l0aW9uLlxcblxcdCAqL1xcblxcdE93bC5wcm90b3R5cGUubm9ybWFsaXplID0gZnVuY3Rpb24ocG9zaXRpb24sIHJlbGF0aXZlKSB7XFxuXFx0XFx0dmFyIG4gPSB0aGlzLl9pdGVtcy5sZW5ndGgsXFxuXFx0XFx0XFx0bSA9IHJlbGF0aXZlID8gMCA6IHRoaXMuX2Nsb25lcy5sZW5ndGg7XFxuXFxuXFx0XFx0aWYgKCF0aGlzLmlzTnVtZXJpYyhwb3NpdGlvbikgfHwgbiA8IDEpIHtcXG5cXHRcXHRcXHRwb3NpdGlvbiA9IHVuZGVmaW5lZDtcXG5cXHRcXHR9IGVsc2UgaWYgKHBvc2l0aW9uIDwgMCB8fCBwb3NpdGlvbiA+PSBuICsgbSkge1xcblxcdFxcdFxcdHBvc2l0aW9uID0gKChwb3NpdGlvbiAtIG0gLyAyKSAlIG4gKyBuKSAlIG4gKyBtIC8gMjtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIHBvc2l0aW9uO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogQ29udmVydHMgYW4gYWJzb2x1dGUgcG9zaXRpb24gb2YgYW4gaXRlbSBpbnRvIGEgcmVsYXRpdmUgb25lLlxcblxcdCAqIEBwdWJsaWNcXG5cXHQgKiBAcGFyYW0ge051bWJlcn0gcG9zaXRpb24gLSBUaGUgYWJzb2x1dGUgcG9zaXRpb24gdG8gY29udmVydC5cXG5cXHQgKiBAcmV0dXJucyB7TnVtYmVyfSAtIFRoZSBjb252ZXJ0ZWQgcG9zaXRpb24uXFxuXFx0ICovXFxuXFx0T3dsLnByb3RvdHlwZS5yZWxhdGl2ZSA9IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XFxuXFx0XFx0cG9zaXRpb24gLT0gdGhpcy5fY2xvbmVzLmxlbmd0aCAvIDI7XFxuXFx0XFx0cmV0dXJuIHRoaXMubm9ybWFsaXplKHBvc2l0aW9uLCB0cnVlKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEdldHMgdGhlIG1heGltdW0gcG9zaXRpb24gZm9yIHRoZSBjdXJyZW50IGl0ZW0uXFxuXFx0ICogQHB1YmxpY1xcblxcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW3JlbGF0aXZlPWZhbHNlXSAtIFdoZXRoZXIgdG8gcmV0dXJuIGFuIGFic29sdXRlIHBvc2l0aW9uIG9yIGEgcmVsYXRpdmUgcG9zaXRpb24uXFxuXFx0ICogQHJldHVybnMge051bWJlcn1cXG5cXHQgKi9cXG5cXHRPd2wucHJvdG90eXBlLm1heGltdW0gPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xcblxcdFxcdHZhciBzZXR0aW5ncyA9IHRoaXMuc2V0dGluZ3MsXFxuXFx0XFx0XFx0bWF4aW11bSA9IHRoaXMuX2Nvb3JkaW5hdGVzLmxlbmd0aCxcXG5cXHRcXHRcXHRpdGVyYXRvcixcXG5cXHRcXHRcXHRyZWNpcHJvY2FsSXRlbXNXaWR0aCxcXG5cXHRcXHRcXHRlbGVtZW50V2lkdGg7XFxuXFxuXFx0XFx0aWYgKHNldHRpbmdzLmxvb3ApIHtcXG5cXHRcXHRcXHRtYXhpbXVtID0gdGhpcy5fY2xvbmVzLmxlbmd0aCAvIDIgKyB0aGlzLl9pdGVtcy5sZW5ndGggLSAxO1xcblxcdFxcdH0gZWxzZSBpZiAoc2V0dGluZ3MuYXV0b1dpZHRoIHx8IHNldHRpbmdzLm1lcmdlKSB7XFxuXFx0XFx0XFx0aXRlcmF0b3IgPSB0aGlzLl9pdGVtcy5sZW5ndGg7XFxuXFx0XFx0XFx0cmVjaXByb2NhbEl0ZW1zV2lkdGggPSB0aGlzLl9pdGVtc1stLWl0ZXJhdG9yXS53aWR0aCgpO1xcblxcdFxcdFxcdGVsZW1lbnRXaWR0aCA9IHRoaXMuJGVsZW1lbnQud2lkdGgoKTtcXG5cXHRcXHRcXHR3aGlsZSAoaXRlcmF0b3ItLSkge1xcblxcdFxcdFxcdFxcdHJlY2lwcm9jYWxJdGVtc1dpZHRoICs9IHRoaXMuX2l0ZW1zW2l0ZXJhdG9yXS53aWR0aCgpICsgdGhpcy5zZXR0aW5ncy5tYXJnaW47XFxuXFx0XFx0XFx0XFx0aWYgKHJlY2lwcm9jYWxJdGVtc1dpZHRoID4gZWxlbWVudFdpZHRoKSB7XFxuXFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRtYXhpbXVtID0gaXRlcmF0b3IgKyAxO1xcblxcdFxcdH0gZWxzZSBpZiAoc2V0dGluZ3MuY2VudGVyKSB7XFxuXFx0XFx0XFx0bWF4aW11bSA9IHRoaXMuX2l0ZW1zLmxlbmd0aCAtIDE7XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRtYXhpbXVtID0gdGhpcy5faXRlbXMubGVuZ3RoIC0gc2V0dGluZ3MuaXRlbXM7XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmIChyZWxhdGl2ZSkge1xcblxcdFxcdFxcdG1heGltdW0gLT0gdGhpcy5fY2xvbmVzLmxlbmd0aCAvIDI7XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiBNYXRoLm1heChtYXhpbXVtLCAwKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEdldHMgdGhlIG1pbmltdW0gcG9zaXRpb24gZm9yIHRoZSBjdXJyZW50IGl0ZW0uXFxuXFx0ICogQHB1YmxpY1xcblxcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW3JlbGF0aXZlPWZhbHNlXSAtIFdoZXRoZXIgdG8gcmV0dXJuIGFuIGFic29sdXRlIHBvc2l0aW9uIG9yIGEgcmVsYXRpdmUgcG9zaXRpb24uXFxuXFx0ICogQHJldHVybnMge051bWJlcn1cXG5cXHQgKi9cXG5cXHRPd2wucHJvdG90eXBlLm1pbmltdW0gPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xcblxcdFxcdHJldHVybiByZWxhdGl2ZSA/IDAgOiB0aGlzLl9jbG9uZXMubGVuZ3RoIC8gMjtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEdldHMgYW4gaXRlbSBhdCB0aGUgc3BlY2lmaWVkIHJlbGF0aXZlIHBvc2l0aW9uLlxcblxcdCAqIEBwdWJsaWNcXG5cXHQgKiBAcGFyYW0ge051bWJlcn0gW3Bvc2l0aW9uXSAtIFRoZSByZWxhdGl2ZSBwb3NpdGlvbiBvZiB0aGUgaXRlbS5cXG5cXHQgKiBAcmV0dXJuIHtqUXVlcnl8QXJyYXkuPGpRdWVyeT59IC0gVGhlIGl0ZW0gYXQgdGhlIGdpdmVuIHBvc2l0aW9uIG9yIGFsbCBpdGVtcyBpZiBubyBwb3NpdGlvbiB3YXMgZ2l2ZW4uXFxuXFx0ICovXFxuXFx0T3dsLnByb3RvdHlwZS5pdGVtcyA9IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XFxuXFx0XFx0aWYgKHBvc2l0aW9uID09PSB1bmRlZmluZWQpIHtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5faXRlbXMuc2xpY2UoKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cG9zaXRpb24gPSB0aGlzLm5vcm1hbGl6ZShwb3NpdGlvbiwgdHJ1ZSk7XFxuXFx0XFx0cmV0dXJuIHRoaXMuX2l0ZW1zW3Bvc2l0aW9uXTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEdldHMgYW4gaXRlbSBhdCB0aGUgc3BlY2lmaWVkIHJlbGF0aXZlIHBvc2l0aW9uLlxcblxcdCAqIEBwdWJsaWNcXG5cXHQgKiBAcGFyYW0ge051bWJlcn0gW3Bvc2l0aW9uXSAtIFRoZSByZWxhdGl2ZSBwb3NpdGlvbiBvZiB0aGUgaXRlbS5cXG5cXHQgKiBAcmV0dXJuIHtqUXVlcnl8QXJyYXkuPGpRdWVyeT59IC0gVGhlIGl0ZW0gYXQgdGhlIGdpdmVuIHBvc2l0aW9uIG9yIGFsbCBpdGVtcyBpZiBubyBwb3NpdGlvbiB3YXMgZ2l2ZW4uXFxuXFx0ICovXFxuXFx0T3dsLnByb3RvdHlwZS5tZXJnZXJzID0gZnVuY3Rpb24ocG9zaXRpb24pIHtcXG5cXHRcXHRpZiAocG9zaXRpb24gPT09IHVuZGVmaW5lZCkge1xcblxcdFxcdFxcdHJldHVybiB0aGlzLl9tZXJnZXJzLnNsaWNlKCk7XFxuXFx0XFx0fVxcblxcblxcdFxcdHBvc2l0aW9uID0gdGhpcy5ub3JtYWxpemUocG9zaXRpb24sIHRydWUpO1xcblxcdFxcdHJldHVybiB0aGlzLl9tZXJnZXJzW3Bvc2l0aW9uXTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEdldHMgdGhlIGFic29sdXRlIHBvc2l0aW9ucyBvZiBjbG9uZXMgZm9yIGFuIGl0ZW0uXFxuXFx0ICogQHB1YmxpY1xcblxcdCAqIEBwYXJhbSB7TnVtYmVyfSBbcG9zaXRpb25dIC0gVGhlIHJlbGF0aXZlIHBvc2l0aW9uIG9mIHRoZSBpdGVtLlxcblxcdCAqIEByZXR1cm5zIHtBcnJheS48TnVtYmVyPn0gLSBUaGUgYWJzb2x1dGUgcG9zaXRpb25zIG9mIGNsb25lcyBmb3IgdGhlIGl0ZW0gb3IgYWxsIGlmIG5vIHBvc2l0aW9uIHdhcyBnaXZlbi5cXG5cXHQgKi9cXG5cXHRPd2wucHJvdG90eXBlLmNsb25lcyA9IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XFxuXFx0XFx0dmFyIG9kZCA9IHRoaXMuX2Nsb25lcy5sZW5ndGggLyAyLFxcblxcdFxcdFxcdGV2ZW4gPSBvZGQgKyB0aGlzLl9pdGVtcy5sZW5ndGgsXFxuXFx0XFx0XFx0bWFwID0gZnVuY3Rpb24oaW5kZXgpIHsgcmV0dXJuIGluZGV4ICUgMiA9PT0gMCA/IGV2ZW4gKyBpbmRleCAvIDIgOiBvZGQgLSAoaW5kZXggKyAxKSAvIDIgfTtcXG5cXG5cXHRcXHRpZiAocG9zaXRpb24gPT09IHVuZGVmaW5lZCkge1xcblxcdFxcdFxcdHJldHVybiAkLm1hcCh0aGlzLl9jbG9uZXMsIGZ1bmN0aW9uKHYsIGkpIHsgcmV0dXJuIG1hcChpKSB9KTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuICQubWFwKHRoaXMuX2Nsb25lcywgZnVuY3Rpb24odiwgaSkgeyByZXR1cm4gdiA9PT0gcG9zaXRpb24gPyBtYXAoaSkgOiBudWxsIH0pO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogU2V0cyB0aGUgY3VycmVudCBhbmltYXRpb24gc3BlZWQuXFxuXFx0ICogQHB1YmxpY1xcblxcdCAqIEBwYXJhbSB7TnVtYmVyfSBbc3BlZWRdIC0gVGhlIGFuaW1hdGlvbiBzcGVlZCBpbiBtaWxsaXNlY29uZHMgb3Igbm90aGluZyB0byBsZWF2ZSBpdCB1bmNoYW5nZWQuXFxuXFx0ICogQHJldHVybnMge051bWJlcn0gLSBUaGUgY3VycmVudCBhbmltYXRpb24gc3BlZWQgaW4gbWlsbGlzZWNvbmRzLlxcblxcdCAqL1xcblxcdE93bC5wcm90b3R5cGUuc3BlZWQgPSBmdW5jdGlvbihzcGVlZCkge1xcblxcdFxcdGlmIChzcGVlZCAhPT0gdW5kZWZpbmVkKSB7XFxuXFx0XFx0XFx0dGhpcy5fc3BlZWQgPSBzcGVlZDtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIHRoaXMuX3NwZWVkO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogR2V0cyB0aGUgY29vcmRpbmF0ZSBvZiBhbiBpdGVtLlxcblxcdCAqIEB0b2RvIFRoZSBuYW1lIG9mIHRoaXMgbWV0aG9kIGlzIG1pc3NsZWFuZGluZy5cXG5cXHQgKiBAcHVibGljXFxuXFx0ICogQHBhcmFtIHtOdW1iZXJ9IHBvc2l0aW9uIC0gVGhlIGFic29sdXRlIHBvc2l0aW9uIG9mIHRoZSBpdGVtIHdpdGhpbiBgbWluaW11bSgpYCBhbmQgYG1heGltdW0oKWAuXFxuXFx0ICogQHJldHVybnMge051bWJlcnxBcnJheS48TnVtYmVyPn0gLSBUaGUgY29vcmRpbmF0ZSBvZiB0aGUgaXRlbSBpbiBwaXhlbCBvciBhbGwgY29vcmRpbmF0ZXMuXFxuXFx0ICovXFxuXFx0T3dsLnByb3RvdHlwZS5jb29yZGluYXRlcyA9IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XFxuXFx0XFx0dmFyIG11bHRpcGxpZXIgPSAxLFxcblxcdFxcdFxcdG5ld1Bvc2l0aW9uID0gcG9zaXRpb24gLSAxLFxcblxcdFxcdFxcdGNvb3JkaW5hdGU7XFxuXFxuXFx0XFx0aWYgKHBvc2l0aW9uID09PSB1bmRlZmluZWQpIHtcXG5cXHRcXHRcXHRyZXR1cm4gJC5tYXAodGhpcy5fY29vcmRpbmF0ZXMsICQucHJveHkoZnVuY3Rpb24oY29vcmRpbmF0ZSwgaW5kZXgpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5jb29yZGluYXRlcyhpbmRleCk7XFxuXFx0XFx0XFx0fSwgdGhpcykpO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAodGhpcy5zZXR0aW5ncy5jZW50ZXIpIHtcXG5cXHRcXHRcXHRpZiAodGhpcy5zZXR0aW5ncy5ydGwpIHtcXG5cXHRcXHRcXHRcXHRtdWx0aXBsaWVyID0gLTE7XFxuXFx0XFx0XFx0XFx0bmV3UG9zaXRpb24gPSBwb3NpdGlvbiArIDE7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGNvb3JkaW5hdGUgPSB0aGlzLl9jb29yZGluYXRlc1twb3NpdGlvbl07XFxuXFx0XFx0XFx0Y29vcmRpbmF0ZSArPSAodGhpcy53aWR0aCgpIC0gY29vcmRpbmF0ZSArICh0aGlzLl9jb29yZGluYXRlc1tuZXdQb3NpdGlvbl0gfHwgMCkpIC8gMiAqIG11bHRpcGxpZXI7XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRjb29yZGluYXRlID0gdGhpcy5fY29vcmRpbmF0ZXNbbmV3UG9zaXRpb25dIHx8IDA7XFxuXFx0XFx0fVxcblxcblxcdFxcdGNvb3JkaW5hdGUgPSBNYXRoLmNlaWwoY29vcmRpbmF0ZSk7XFxuXFxuXFx0XFx0cmV0dXJuIGNvb3JkaW5hdGU7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBDYWxjdWxhdGVzIHRoZSBzcGVlZCBmb3IgYSB0cmFuc2xhdGlvbi5cXG5cXHQgKiBAcHJvdGVjdGVkXFxuXFx0ICogQHBhcmFtIHtOdW1iZXJ9IGZyb20gLSBUaGUgYWJzb2x1dGUgcG9zaXRpb24gb2YgdGhlIHN0YXJ0IGl0ZW0uXFxuXFx0ICogQHBhcmFtIHtOdW1iZXJ9IHRvIC0gVGhlIGFic29sdXRlIHBvc2l0aW9uIG9mIHRoZSB0YXJnZXQgaXRlbS5cXG5cXHQgKiBAcGFyYW0ge051bWJlcn0gW2ZhY3Rvcj11bmRlZmluZWRdIC0gVGhlIHRpbWUgZmFjdG9yIGluIG1pbGxpc2Vjb25kcy5cXG5cXHQgKiBAcmV0dXJucyB7TnVtYmVyfSAtIFRoZSB0aW1lIGluIG1pbGxpc2Vjb25kcyBmb3IgdGhlIHRyYW5zbGF0aW9uLlxcblxcdCAqL1xcblxcdE93bC5wcm90b3R5cGUuZHVyYXRpb24gPSBmdW5jdGlvbihmcm9tLCB0bywgZmFjdG9yKSB7XFxuXFx0XFx0aWYgKGZhY3RvciA9PT0gMCkge1xcblxcdFxcdFxcdHJldHVybiAwO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgoTWF0aC5hYnModG8gLSBmcm9tKSwgMSksIDYpICogTWF0aC5hYnMoKGZhY3RvciB8fCB0aGlzLnNldHRpbmdzLnNtYXJ0U3BlZWQpKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIFNsaWRlcyB0byB0aGUgc3BlY2lmaWVkIGl0ZW0uXFxuXFx0ICogQHB1YmxpY1xcblxcdCAqIEBwYXJhbSB7TnVtYmVyfSBwb3NpdGlvbiAtIFRoZSBwb3NpdGlvbiBvZiB0aGUgaXRlbS5cXG5cXHQgKiBAcGFyYW0ge051bWJlcn0gW3NwZWVkXSAtIFRoZSB0aW1lIGluIG1pbGxpc2Vjb25kcyBmb3IgdGhlIHRyYW5zaXRpb24uXFxuXFx0ICovXFxuXFx0T3dsLnByb3RvdHlwZS50byA9IGZ1bmN0aW9uKHBvc2l0aW9uLCBzcGVlZCkge1xcblxcdFxcdHZhciBjdXJyZW50ID0gdGhpcy5jdXJyZW50KCksXFxuXFx0XFx0XFx0cmV2ZXJ0ID0gbnVsbCxcXG5cXHRcXHRcXHRkaXN0YW5jZSA9IHBvc2l0aW9uIC0gdGhpcy5yZWxhdGl2ZShjdXJyZW50KSxcXG5cXHRcXHRcXHRkaXJlY3Rpb24gPSAoZGlzdGFuY2UgPiAwKSAtIChkaXN0YW5jZSA8IDApLFxcblxcdFxcdFxcdGl0ZW1zID0gdGhpcy5faXRlbXMubGVuZ3RoLFxcblxcdFxcdFxcdG1pbmltdW0gPSB0aGlzLm1pbmltdW0oKSxcXG5cXHRcXHRcXHRtYXhpbXVtID0gdGhpcy5tYXhpbXVtKCk7XFxuXFxuXFx0XFx0aWYgKHRoaXMuc2V0dGluZ3MubG9vcCkge1xcblxcdFxcdFxcdGlmICghdGhpcy5zZXR0aW5ncy5yZXdpbmQgJiYgTWF0aC5hYnMoZGlzdGFuY2UpID4gaXRlbXMgLyAyKSB7XFxuXFx0XFx0XFx0XFx0ZGlzdGFuY2UgKz0gZGlyZWN0aW9uICogLTEgKiBpdGVtcztcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cG9zaXRpb24gPSBjdXJyZW50ICsgZGlzdGFuY2U7XFxuXFx0XFx0XFx0cmV2ZXJ0ID0gKChwb3NpdGlvbiAtIG1pbmltdW0pICUgaXRlbXMgKyBpdGVtcykgJSBpdGVtcyArIG1pbmltdW07XFxuXFxuXFx0XFx0XFx0aWYgKHJldmVydCAhPT0gcG9zaXRpb24gJiYgcmV2ZXJ0IC0gZGlzdGFuY2UgPD0gbWF4aW11bSAmJiByZXZlcnQgLSBkaXN0YW5jZSA+IDApIHtcXG5cXHRcXHRcXHRcXHRjdXJyZW50ID0gcmV2ZXJ0IC0gZGlzdGFuY2U7XFxuXFx0XFx0XFx0XFx0cG9zaXRpb24gPSByZXZlcnQ7XFxuXFx0XFx0XFx0XFx0dGhpcy5yZXNldChjdXJyZW50KTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSBlbHNlIGlmICh0aGlzLnNldHRpbmdzLnJld2luZCkge1xcblxcdFxcdFxcdG1heGltdW0gKz0gMTtcXG5cXHRcXHRcXHRwb3NpdGlvbiA9IChwb3NpdGlvbiAlIG1heGltdW0gKyBtYXhpbXVtKSAlIG1heGltdW07XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRwb3NpdGlvbiA9IE1hdGgubWF4KG1pbmltdW0sIE1hdGgubWluKG1heGltdW0sIHBvc2l0aW9uKSk7XFxuXFx0XFx0fVxcblxcblxcdFxcdHRoaXMuc3BlZWQodGhpcy5kdXJhdGlvbihjdXJyZW50LCBwb3NpdGlvbiwgc3BlZWQpKTtcXG5cXHRcXHR0aGlzLmN1cnJlbnQocG9zaXRpb24pO1xcblxcblxcdFxcdGlmICh0aGlzLiRlbGVtZW50LmlzKCc6dmlzaWJsZScpKSB7XFxuXFx0XFx0XFx0dGhpcy51cGRhdGUoKTtcXG5cXHRcXHR9XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBTbGlkZXMgdG8gdGhlIG5leHQgaXRlbS5cXG5cXHQgKiBAcHVibGljXFxuXFx0ICogQHBhcmFtIHtOdW1iZXJ9IFtzcGVlZF0gLSBUaGUgdGltZSBpbiBtaWxsaXNlY29uZHMgZm9yIHRoZSB0cmFuc2l0aW9uLlxcblxcdCAqL1xcblxcdE93bC5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKHNwZWVkKSB7XFxuXFx0XFx0c3BlZWQgPSBzcGVlZCB8fCBmYWxzZTtcXG5cXHRcXHR0aGlzLnRvKHRoaXMucmVsYXRpdmUodGhpcy5jdXJyZW50KCkpICsgMSwgc3BlZWQpO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogU2xpZGVzIHRvIHRoZSBwcmV2aW91cyBpdGVtLlxcblxcdCAqIEBwdWJsaWNcXG5cXHQgKiBAcGFyYW0ge051bWJlcn0gW3NwZWVkXSAtIFRoZSB0aW1lIGluIG1pbGxpc2Vjb25kcyBmb3IgdGhlIHRyYW5zaXRpb24uXFxuXFx0ICovXFxuXFx0T3dsLnByb3RvdHlwZS5wcmV2ID0gZnVuY3Rpb24oc3BlZWQpIHtcXG5cXHRcXHRzcGVlZCA9IHNwZWVkIHx8IGZhbHNlO1xcblxcdFxcdHRoaXMudG8odGhpcy5yZWxhdGl2ZSh0aGlzLmN1cnJlbnQoKSkgLSAxLCBzcGVlZCk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBIYW5kbGVzIHRoZSBlbmQgb2YgYW4gYW5pbWF0aW9uLlxcblxcdCAqIEBwcm90ZWN0ZWRcXG5cXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIFRoZSBldmVudCBhcmd1bWVudHMuXFxuXFx0ICovXFxuXFx0T3dsLnByb3RvdHlwZS5vblRyYW5zaXRpb25FbmQgPSBmdW5jdGlvbihldmVudCkge1xcblxcblxcdFxcdC8vIGlmIGNzczIgYW5pbWF0aW9uIHRoZW4gZXZlbnQgb2JqZWN0IGlzIHVuZGVmaW5lZFxcblxcdFxcdGlmIChldmVudCAhPT0gdW5kZWZpbmVkKSB7XFxuXFx0XFx0XFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XFxuXFxuXFx0XFx0XFx0Ly8gQ2F0Y2ggb25seSBvd2wtc3RhZ2UgdHJhbnNpdGlvbkVuZCBldmVudFxcblxcdFxcdFxcdGlmICgoZXZlbnQudGFyZ2V0IHx8IGV2ZW50LnNyY0VsZW1lbnQgfHwgZXZlbnQub3JpZ2luYWxUYXJnZXQpICE9PSB0aGlzLiRzdGFnZS5nZXQoMCkpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHR0aGlzLmxlYXZlKCdhbmltYXRpbmcnKTtcXG5cXHRcXHR0aGlzLnRyaWdnZXIoJ3RyYW5zbGF0ZWQnKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEdldHMgdmlld3BvcnQgd2lkdGguXFxuXFx0ICogQHByb3RlY3RlZFxcblxcdCAqIEByZXR1cm4ge051bWJlcn0gLSBUaGUgd2lkdGggaW4gcGl4ZWwuXFxuXFx0ICovXFxuXFx0T3dsLnByb3RvdHlwZS52aWV3cG9ydCA9IGZ1bmN0aW9uKCkge1xcblxcdFxcdHZhciB3aWR0aDtcXG5cXHRcXHRpZiAodGhpcy5vcHRpb25zLnJlc3BvbnNpdmVCYXNlRWxlbWVudCAhPT0gd2luZG93KSB7XFxuXFx0XFx0XFx0d2lkdGggPSAkKHRoaXMub3B0aW9ucy5yZXNwb25zaXZlQmFzZUVsZW1lbnQpLndpZHRoKCk7XFxuXFx0XFx0fSBlbHNlIGlmICh3aW5kb3cuaW5uZXJXaWR0aCkge1xcblxcdFxcdFxcdHdpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XFxuXFx0XFx0fSBlbHNlIGlmIChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoKSB7XFxuXFx0XFx0XFx0d2lkdGggPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg7XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHR0aHJvdyAnQ2FuIG5vdCBkZXRlY3Qgdmlld3BvcnQgd2lkdGguJztcXG5cXHRcXHR9XFxuXFx0XFx0cmV0dXJuIHdpZHRoO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogUmVwbGFjZXMgdGhlIGN1cnJlbnQgY29udGVudC5cXG5cXHQgKiBAcHVibGljXFxuXFx0ICogQHBhcmFtIHtIVE1MRWxlbWVudHxqUXVlcnl8U3RyaW5nfSBjb250ZW50IC0gVGhlIG5ldyBjb250ZW50LlxcblxcdCAqL1xcblxcdE93bC5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uKGNvbnRlbnQpIHtcXG5cXHRcXHR0aGlzLiRzdGFnZS5lbXB0eSgpO1xcblxcdFxcdHRoaXMuX2l0ZW1zID0gW107XFxuXFxuXFx0XFx0aWYgKGNvbnRlbnQpIHtcXG5cXHRcXHRcXHRjb250ZW50ID0gKGNvbnRlbnQgaW5zdGFuY2VvZiBqUXVlcnkpID8gY29udGVudCA6ICQoY29udGVudCk7XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICh0aGlzLnNldHRpbmdzLm5lc3RlZEl0ZW1TZWxlY3Rvcikge1xcblxcdFxcdFxcdGNvbnRlbnQgPSBjb250ZW50LmZpbmQoJy4nICsgdGhpcy5zZXR0aW5ncy5uZXN0ZWRJdGVtU2VsZWN0b3IpO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRjb250ZW50LmZpbHRlcihmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5ub2RlVHlwZSA9PT0gMTtcXG5cXHRcXHR9KS5lYWNoKCQucHJveHkoZnVuY3Rpb24oaW5kZXgsIGl0ZW0pIHtcXG5cXHRcXHRcXHRpdGVtID0gdGhpcy5wcmVwYXJlKGl0ZW0pO1xcblxcdFxcdFxcdHRoaXMuJHN0YWdlLmFwcGVuZChpdGVtKTtcXG5cXHRcXHRcXHR0aGlzLl9pdGVtcy5wdXNoKGl0ZW0pO1xcblxcdFxcdFxcdHRoaXMuX21lcmdlcnMucHVzaChpdGVtLmZpbmQoJ1tkYXRhLW1lcmdlXScpLmFkZEJhY2soJ1tkYXRhLW1lcmdlXScpLmF0dHIoJ2RhdGEtbWVyZ2UnKSAqIDEgfHwgMSk7XFxuXFx0XFx0fSwgdGhpcykpO1xcblxcblxcdFxcdHRoaXMucmVzZXQodGhpcy5pc051bWVyaWModGhpcy5zZXR0aW5ncy5zdGFydFBvc2l0aW9uKSA/IHRoaXMuc2V0dGluZ3Muc3RhcnRQb3NpdGlvbiA6IDApO1xcblxcblxcdFxcdHRoaXMuaW52YWxpZGF0ZSgnaXRlbXMnKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEFkZHMgYW4gaXRlbS5cXG5cXHQgKiBAdG9kbyBVc2UgYGl0ZW1gIGluc3RlYWQgb2YgYGNvbnRlbnRgIGZvciB0aGUgZXZlbnQgYXJndW1lbnRzLlxcblxcdCAqIEBwdWJsaWNcXG5cXHQgKiBAcGFyYW0ge0hUTUxFbGVtZW50fGpRdWVyeXxTdHJpbmd9IGNvbnRlbnQgLSBUaGUgaXRlbSBjb250ZW50IHRvIGFkZC5cXG5cXHQgKiBAcGFyYW0ge051bWJlcn0gW3Bvc2l0aW9uXSAtIFRoZSByZWxhdGl2ZSBwb3NpdGlvbiBhdCB3aGljaCB0byBpbnNlcnQgdGhlIGl0ZW0gb3RoZXJ3aXNlIHRoZSBpdGVtIHdpbGwgYmUgYWRkZWQgdG8gdGhlIGVuZC5cXG5cXHQgKi9cXG5cXHRPd2wucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGNvbnRlbnQsIHBvc2l0aW9uKSB7XFxuXFx0XFx0dmFyIGN1cnJlbnQgPSB0aGlzLnJlbGF0aXZlKHRoaXMuX2N1cnJlbnQpO1xcblxcblxcdFxcdHBvc2l0aW9uID0gcG9zaXRpb24gPT09IHVuZGVmaW5lZCA/IHRoaXMuX2l0ZW1zLmxlbmd0aCA6IHRoaXMubm9ybWFsaXplKHBvc2l0aW9uLCB0cnVlKTtcXG5cXHRcXHRjb250ZW50ID0gY29udGVudCBpbnN0YW5jZW9mIGpRdWVyeSA/IGNvbnRlbnQgOiAkKGNvbnRlbnQpO1xcblxcblxcdFxcdHRoaXMudHJpZ2dlcignYWRkJywgeyBjb250ZW50OiBjb250ZW50LCBwb3NpdGlvbjogcG9zaXRpb24gfSk7XFxuXFxuXFx0XFx0Y29udGVudCA9IHRoaXMucHJlcGFyZShjb250ZW50KTtcXG5cXG5cXHRcXHRpZiAodGhpcy5faXRlbXMubGVuZ3RoID09PSAwIHx8IHBvc2l0aW9uID09PSB0aGlzLl9pdGVtcy5sZW5ndGgpIHtcXG5cXHRcXHRcXHR0aGlzLl9pdGVtcy5sZW5ndGggPT09IDAgJiYgdGhpcy4kc3RhZ2UuYXBwZW5kKGNvbnRlbnQpO1xcblxcdFxcdFxcdHRoaXMuX2l0ZW1zLmxlbmd0aCAhPT0gMCAmJiB0aGlzLl9pdGVtc1twb3NpdGlvbiAtIDFdLmFmdGVyKGNvbnRlbnQpO1xcblxcdFxcdFxcdHRoaXMuX2l0ZW1zLnB1c2goY29udGVudCk7XFxuXFx0XFx0XFx0dGhpcy5fbWVyZ2Vycy5wdXNoKGNvbnRlbnQuZmluZCgnW2RhdGEtbWVyZ2VdJykuYWRkQmFjaygnW2RhdGEtbWVyZ2VdJykuYXR0cignZGF0YS1tZXJnZScpICogMSB8fCAxKTtcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdHRoaXMuX2l0ZW1zW3Bvc2l0aW9uXS5iZWZvcmUoY29udGVudCk7XFxuXFx0XFx0XFx0dGhpcy5faXRlbXMuc3BsaWNlKHBvc2l0aW9uLCAwLCBjb250ZW50KTtcXG5cXHRcXHRcXHR0aGlzLl9tZXJnZXJzLnNwbGljZShwb3NpdGlvbiwgMCwgY29udGVudC5maW5kKCdbZGF0YS1tZXJnZV0nKS5hZGRCYWNrKCdbZGF0YS1tZXJnZV0nKS5hdHRyKCdkYXRhLW1lcmdlJykgKiAxIHx8IDEpO1xcblxcdFxcdH1cXG5cXG5cXHRcXHR0aGlzLl9pdGVtc1tjdXJyZW50XSAmJiB0aGlzLnJlc2V0KHRoaXMuX2l0ZW1zW2N1cnJlbnRdLmluZGV4KCkpO1xcblxcblxcdFxcdHRoaXMuaW52YWxpZGF0ZSgnaXRlbXMnKTtcXG5cXG5cXHRcXHR0aGlzLnRyaWdnZXIoJ2FkZGVkJywgeyBjb250ZW50OiBjb250ZW50LCBwb3NpdGlvbjogcG9zaXRpb24gfSk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBSZW1vdmVzIGFuIGl0ZW0gYnkgaXRzIHBvc2l0aW9uLlxcblxcdCAqIEB0b2RvIFVzZSBgaXRlbWAgaW5zdGVhZCBvZiBgY29udGVudGAgZm9yIHRoZSBldmVudCBhcmd1bWVudHMuXFxuXFx0ICogQHB1YmxpY1xcblxcdCAqIEBwYXJhbSB7TnVtYmVyfSBwb3NpdGlvbiAtIFRoZSByZWxhdGl2ZSBwb3NpdGlvbiBvZiB0aGUgaXRlbSB0byByZW1vdmUuXFxuXFx0ICovXFxuXFx0T3dsLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihwb3NpdGlvbikge1xcblxcdFxcdHBvc2l0aW9uID0gdGhpcy5ub3JtYWxpemUocG9zaXRpb24sIHRydWUpO1xcblxcblxcdFxcdGlmIChwb3NpdGlvbiA9PT0gdW5kZWZpbmVkKSB7XFxuXFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdH1cXG5cXG5cXHRcXHR0aGlzLnRyaWdnZXIoJ3JlbW92ZScsIHsgY29udGVudDogdGhpcy5faXRlbXNbcG9zaXRpb25dLCBwb3NpdGlvbjogcG9zaXRpb24gfSk7XFxuXFxuXFx0XFx0dGhpcy5faXRlbXNbcG9zaXRpb25dLnJlbW92ZSgpO1xcblxcdFxcdHRoaXMuX2l0ZW1zLnNwbGljZShwb3NpdGlvbiwgMSk7XFxuXFx0XFx0dGhpcy5fbWVyZ2Vycy5zcGxpY2UocG9zaXRpb24sIDEpO1xcblxcblxcdFxcdHRoaXMuaW52YWxpZGF0ZSgnaXRlbXMnKTtcXG5cXG5cXHRcXHR0aGlzLnRyaWdnZXIoJ3JlbW92ZWQnLCB7IGNvbnRlbnQ6IG51bGwsIHBvc2l0aW9uOiBwb3NpdGlvbiB9KTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIFByZWxvYWRzIGltYWdlcyB3aXRoIGF1dG8gd2lkdGguXFxuXFx0ICogQHRvZG8gUmVwbGFjZSBieSBhIG1vcmUgZ2VuZXJpYyBhcHByb2FjaFxcblxcdCAqIEBwcm90ZWN0ZWRcXG5cXHQgKi9cXG5cXHRPd2wucHJvdG90eXBlLnByZWxvYWRBdXRvV2lkdGhJbWFnZXMgPSBmdW5jdGlvbihpbWFnZXMpIHtcXG5cXHRcXHRpbWFnZXMuZWFjaCgkLnByb3h5KGZ1bmN0aW9uKGksIGVsZW1lbnQpIHtcXG5cXHRcXHRcXHR0aGlzLmVudGVyKCdwcmUtbG9hZGluZycpO1xcblxcdFxcdFxcdGVsZW1lbnQgPSAkKGVsZW1lbnQpO1xcblxcdFxcdFxcdCQobmV3IEltYWdlKCkpLm9uZSgnbG9hZCcsICQucHJveHkoZnVuY3Rpb24oZSkge1xcblxcdFxcdFxcdFxcdGVsZW1lbnQuYXR0cignc3JjJywgZS50YXJnZXQuc3JjKTtcXG5cXHRcXHRcXHRcXHRlbGVtZW50LmNzcygnb3BhY2l0eScsIDEpO1xcblxcdFxcdFxcdFxcdHRoaXMubGVhdmUoJ3ByZS1sb2FkaW5nJyk7XFxuXFx0XFx0XFx0XFx0IXRoaXMuaXMoJ3ByZS1sb2FkaW5nJykgJiYgIXRoaXMuaXMoJ2luaXRpYWxpemluZycpICYmIHRoaXMucmVmcmVzaCgpO1xcblxcdFxcdFxcdH0sIHRoaXMpKS5hdHRyKCdzcmMnLCBlbGVtZW50LmF0dHIoJ3NyYycpIHx8IGVsZW1lbnQuYXR0cignZGF0YS1zcmMnKSB8fCBlbGVtZW50LmF0dHIoJ2RhdGEtc3JjLXJldGluYScpKTtcXG5cXHRcXHR9LCB0aGlzKSk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBEZXN0cm95cyB0aGUgY2Fyb3VzZWwuXFxuXFx0ICogQHB1YmxpY1xcblxcdCAqL1xcblxcdE93bC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xcblxcblxcdFxcdHRoaXMuJGVsZW1lbnQub2ZmKCcub3dsLmNvcmUnKTtcXG5cXHRcXHR0aGlzLiRzdGFnZS5vZmYoJy5vd2wuY29yZScpO1xcblxcdFxcdCQoZG9jdW1lbnQpLm9mZignLm93bC5jb3JlJyk7XFxuXFxuXFx0XFx0aWYgKHRoaXMuc2V0dGluZ3MucmVzcG9uc2l2ZSAhPT0gZmFsc2UpIHtcXG5cXHRcXHRcXHR3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMucmVzaXplVGltZXIpO1xcblxcdFxcdFxcdHRoaXMub2ZmKHdpbmRvdywgJ3Jlc2l6ZScsIHRoaXMuX2hhbmRsZXJzLm9uVGhyb3R0bGVkUmVzaXplKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9wbHVnaW5zKSB7XFxuXFx0XFx0XFx0dGhpcy5fcGx1Z2luc1tpXS5kZXN0cm95KCk7XFxuXFx0XFx0fVxcblxcblxcdFxcdHRoaXMuJHN0YWdlLmNoaWxkcmVuKCcuY2xvbmVkJykucmVtb3ZlKCk7XFxuXFxuXFx0XFx0dGhpcy4kc3RhZ2UudW53cmFwKCk7XFxuXFx0XFx0dGhpcy4kc3RhZ2UuY2hpbGRyZW4oKS5jb250ZW50cygpLnVud3JhcCgpO1xcblxcdFxcdHRoaXMuJHN0YWdlLmNoaWxkcmVuKCkudW53cmFwKCk7XFxuXFxuXFx0XFx0dGhpcy4kZWxlbWVudFxcblxcdFxcdFxcdC5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMucmVmcmVzaENsYXNzKVxcblxcdFxcdFxcdC5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMubG9hZGluZ0NsYXNzKVxcblxcdFxcdFxcdC5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMubG9hZGVkQ2xhc3MpXFxuXFx0XFx0XFx0LnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5ydGxDbGFzcylcXG5cXHRcXHRcXHQucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmRyYWdDbGFzcylcXG5cXHRcXHRcXHQucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmdyYWJDbGFzcylcXG5cXHRcXHRcXHQuYXR0cignY2xhc3MnLCB0aGlzLiRlbGVtZW50LmF0dHIoJ2NsYXNzJykucmVwbGFjZShuZXcgUmVnRXhwKHRoaXMub3B0aW9ucy5yZXNwb25zaXZlQ2xhc3MgKyAnLVxcXFxcXFxcUytcXFxcXFxcXHMnLCAnZycpLCAnJykpXFxuXFx0XFx0XFx0LnJlbW92ZURhdGEoJ293bC5jYXJvdXNlbCcpO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogT3BlcmF0b3JzIHRvIGNhbGN1bGF0ZSByaWdodC10by1sZWZ0IGFuZCBsZWZ0LXRvLXJpZ2h0LlxcblxcdCAqIEBwcm90ZWN0ZWRcXG5cXHQgKiBAcGFyYW0ge051bWJlcn0gW2FdIC0gVGhlIGxlZnQgc2lkZSBvcGVyYW5kLlxcblxcdCAqIEBwYXJhbSB7U3RyaW5nfSBbb10gLSBUaGUgb3BlcmF0b3IuXFxuXFx0ICogQHBhcmFtIHtOdW1iZXJ9IFtiXSAtIFRoZSByaWdodCBzaWRlIG9wZXJhbmQuXFxuXFx0ICovXFxuXFx0T3dsLnByb3RvdHlwZS5vcCA9IGZ1bmN0aW9uKGEsIG8sIGIpIHtcXG5cXHRcXHR2YXIgcnRsID0gdGhpcy5zZXR0aW5ncy5ydGw7XFxuXFx0XFx0c3dpdGNoIChvKSB7XFxuXFx0XFx0XFx0Y2FzZSAnPCc6XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHJ0bCA/IGEgPiBiIDogYSA8IGI7XFxuXFx0XFx0XFx0Y2FzZSAnPic6XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHJ0bCA/IGEgPCBiIDogYSA+IGI7XFxuXFx0XFx0XFx0Y2FzZSAnPj0nOlxcblxcdFxcdFxcdFxcdHJldHVybiBydGwgPyBhIDw9IGIgOiBhID49IGI7XFxuXFx0XFx0XFx0Y2FzZSAnPD0nOlxcblxcdFxcdFxcdFxcdHJldHVybiBydGwgPyBhID49IGIgOiBhIDw9IGI7XFxuXFx0XFx0XFx0ZGVmYXVsdDpcXG5cXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHR9XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBBdHRhY2hlcyB0byBhbiBpbnRlcm5hbCBldmVudC5cXG5cXHQgKiBAcHJvdGVjdGVkXFxuXFx0ICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCAtIFRoZSBldmVudCBzb3VyY2UuXFxuXFx0ICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IC0gVGhlIGV2ZW50IG5hbWUuXFxuXFx0ICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgLSBUaGUgZXZlbnQgaGFuZGxlciB0byBhdHRhY2guXFxuXFx0ICogQHBhcmFtIHtCb29sZWFufSBjYXB0dXJlIC0gV2V0aGVyIHRoZSBldmVudCBzaG91bGQgYmUgaGFuZGxlZCBhdCB0aGUgY2FwdHVyaW5nIHBoYXNlIG9yIG5vdC5cXG5cXHQgKi9cXG5cXHRPd2wucHJvdG90eXBlLm9uID0gZnVuY3Rpb24oZWxlbWVudCwgZXZlbnQsIGxpc3RlbmVyLCBjYXB0dXJlKSB7XFxuXFx0XFx0aWYgKGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcikge1xcblxcdFxcdFxcdGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIsIGNhcHR1cmUpO1xcblxcdFxcdH0gZWxzZSBpZiAoZWxlbWVudC5hdHRhY2hFdmVudCkge1xcblxcdFxcdFxcdGVsZW1lbnQuYXR0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBsaXN0ZW5lcik7XFxuXFx0XFx0fVxcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogRGV0YWNoZXMgZnJvbSBhbiBpbnRlcm5hbCBldmVudC5cXG5cXHQgKiBAcHJvdGVjdGVkXFxuXFx0ICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCAtIFRoZSBldmVudCBzb3VyY2UuXFxuXFx0ICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IC0gVGhlIGV2ZW50IG5hbWUuXFxuXFx0ICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgLSBUaGUgYXR0YWNoZWQgZXZlbnQgaGFuZGxlciB0byBkZXRhY2guXFxuXFx0ICogQHBhcmFtIHtCb29sZWFufSBjYXB0dXJlIC0gV2V0aGVyIHRoZSBhdHRhY2hlZCBldmVudCBoYW5kbGVyIHdhcyByZWdpc3RlcmVkIGFzIGEgY2FwdHVyaW5nIGxpc3RlbmVyIG9yIG5vdC5cXG5cXHQgKi9cXG5cXHRPd2wucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uKGVsZW1lbnQsIGV2ZW50LCBsaXN0ZW5lciwgY2FwdHVyZSkge1xcblxcdFxcdGlmIChlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcXG5cXHRcXHRcXHRlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyLCBjYXB0dXJlKTtcXG5cXHRcXHR9IGVsc2UgaWYgKGVsZW1lbnQuZGV0YWNoRXZlbnQpIHtcXG5cXHRcXHRcXHRlbGVtZW50LmRldGFjaEV2ZW50KCdvbicgKyBldmVudCwgbGlzdGVuZXIpO1xcblxcdFxcdH1cXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIFRyaWdnZXJzIGEgcHVibGljIGV2ZW50LlxcblxcdCAqIEB0b2RvIFJlbW92ZSBgc3RhdHVzYCwgYHJlbGF0ZWRUYXJnZXRgIHNob3VsZCBiZSB1c2VkIGluc3RlYWQuXFxuXFx0ICogQHByb3RlY3RlZFxcblxcdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gVGhlIGV2ZW50IG5hbWUuXFxuXFx0ICogQHBhcmFtIHsqfSBbZGF0YT1udWxsXSAtIFRoZSBldmVudCBkYXRhLlxcblxcdCAqIEBwYXJhbSB7U3RyaW5nfSBbbmFtZXNwYWNlPWNhcm91c2VsXSAtIFRoZSBldmVudCBuYW1lc3BhY2UuXFxuXFx0ICogQHBhcmFtIHtTdHJpbmd9IFtzdGF0ZV0gLSBUaGUgc3RhdGUgd2hpY2ggaXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBldmVudC5cXG5cXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtlbnRlcj1mYWxzZV0gLSBJbmRpY2F0ZXMgaWYgdGhlIGNhbGwgZW50ZXJzIHRoZSBzcGVjaWZpZWQgc3RhdGUgb3Igbm90LlxcblxcdCAqIEByZXR1cm5zIHtFdmVudH0gLSBUaGUgZXZlbnQgYXJndW1lbnRzLlxcblxcdCAqL1xcblxcdE93bC5wcm90b3R5cGUudHJpZ2dlciA9IGZ1bmN0aW9uKG5hbWUsIGRhdGEsIG5hbWVzcGFjZSwgc3RhdGUsIGVudGVyKSB7XFxuXFx0XFx0dmFyIHN0YXR1cyA9IHtcXG5cXHRcXHRcXHRpdGVtOiB7IGNvdW50OiB0aGlzLl9pdGVtcy5sZW5ndGgsIGluZGV4OiB0aGlzLmN1cnJlbnQoKSB9XFxuXFx0XFx0fSwgaGFuZGxlciA9ICQuY2FtZWxDYXNlKFxcblxcdFxcdFxcdCQuZ3JlcChbICdvbicsIG5hbWUsIG5hbWVzcGFjZSBdLCBmdW5jdGlvbih2KSB7IHJldHVybiB2IH0pXFxuXFx0XFx0XFx0XFx0LmpvaW4oJy0nKS50b0xvd2VyQ2FzZSgpXFxuXFx0XFx0KSwgZXZlbnQgPSAkLkV2ZW50KFxcblxcdFxcdFxcdFsgbmFtZSwgJ293bCcsIG5hbWVzcGFjZSB8fCAnY2Fyb3VzZWwnIF0uam9pbignLicpLnRvTG93ZXJDYXNlKCksXFxuXFx0XFx0XFx0JC5leHRlbmQoeyByZWxhdGVkVGFyZ2V0OiB0aGlzIH0sIHN0YXR1cywgZGF0YSlcXG5cXHRcXHQpO1xcblxcblxcdFxcdGlmICghdGhpcy5fc3VwcmVzc1tuYW1lXSkge1xcblxcdFxcdFxcdCQuZWFjaCh0aGlzLl9wbHVnaW5zLCBmdW5jdGlvbihuYW1lLCBwbHVnaW4pIHtcXG5cXHRcXHRcXHRcXHRpZiAocGx1Z2luLm9uVHJpZ2dlcikge1xcblxcdFxcdFxcdFxcdFxcdHBsdWdpbi5vblRyaWdnZXIoZXZlbnQpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9KTtcXG5cXG5cXHRcXHRcXHR0aGlzLnJlZ2lzdGVyKHsgdHlwZTogT3dsLlR5cGUuRXZlbnQsIG5hbWU6IG5hbWUgfSk7XFxuXFx0XFx0XFx0dGhpcy4kZWxlbWVudC50cmlnZ2VyKGV2ZW50KTtcXG5cXG5cXHRcXHRcXHRpZiAodGhpcy5zZXR0aW5ncyAmJiB0eXBlb2YgdGhpcy5zZXR0aW5nc1toYW5kbGVyXSA9PT0gJ2Z1bmN0aW9uJykge1xcblxcdFxcdFxcdFxcdHRoaXMuc2V0dGluZ3NbaGFuZGxlcl0uY2FsbCh0aGlzLCBldmVudCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gZXZlbnQ7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBFbnRlcnMgYSBzdGF0ZS5cXG5cXHQgKiBAcGFyYW0gbmFtZSAtIFRoZSBzdGF0ZSBuYW1lLlxcblxcdCAqL1xcblxcdE93bC5wcm90b3R5cGUuZW50ZXIgPSBmdW5jdGlvbihuYW1lKSB7XFxuXFx0XFx0JC5lYWNoKFsgbmFtZSBdLmNvbmNhdCh0aGlzLl9zdGF0ZXMudGFnc1tuYW1lXSB8fCBbXSksICQucHJveHkoZnVuY3Rpb24oaSwgbmFtZSkge1xcblxcdFxcdFxcdGlmICh0aGlzLl9zdGF0ZXMuY3VycmVudFtuYW1lXSA9PT0gdW5kZWZpbmVkKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5fc3RhdGVzLmN1cnJlbnRbbmFtZV0gPSAwO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGlzLl9zdGF0ZXMuY3VycmVudFtuYW1lXSsrO1xcblxcdFxcdH0sIHRoaXMpKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIExlYXZlcyBhIHN0YXRlLlxcblxcdCAqIEBwYXJhbSBuYW1lIC0gVGhlIHN0YXRlIG5hbWUuXFxuXFx0ICovXFxuXFx0T3dsLnByb3RvdHlwZS5sZWF2ZSA9IGZ1bmN0aW9uKG5hbWUpIHtcXG5cXHRcXHQkLmVhY2goWyBuYW1lIF0uY29uY2F0KHRoaXMuX3N0YXRlcy50YWdzW25hbWVdIHx8IFtdKSwgJC5wcm94eShmdW5jdGlvbihpLCBuYW1lKSB7XFxuXFx0XFx0XFx0dGhpcy5fc3RhdGVzLmN1cnJlbnRbbmFtZV0tLTtcXG5cXHRcXHR9LCB0aGlzKSk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBSZWdpc3RlcnMgYW4gZXZlbnQgb3Igc3RhdGUuXFxuXFx0ICogQHB1YmxpY1xcblxcdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgLSBUaGUgZXZlbnQgb3Igc3RhdGUgdG8gcmVnaXN0ZXIuXFxuXFx0ICovXFxuXFx0T3dsLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uKG9iamVjdCkge1xcblxcdFxcdGlmIChvYmplY3QudHlwZSA9PT0gT3dsLlR5cGUuRXZlbnQpIHtcXG5cXHRcXHRcXHRpZiAoISQuZXZlbnQuc3BlY2lhbFtvYmplY3QubmFtZV0pIHtcXG5cXHRcXHRcXHRcXHQkLmV2ZW50LnNwZWNpYWxbb2JqZWN0Lm5hbWVdID0ge307XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICghJC5ldmVudC5zcGVjaWFsW29iamVjdC5uYW1lXS5vd2wpIHtcXG5cXHRcXHRcXHRcXHR2YXIgX2RlZmF1bHQgPSAkLmV2ZW50LnNwZWNpYWxbb2JqZWN0Lm5hbWVdLl9kZWZhdWx0O1xcblxcdFxcdFxcdFxcdCQuZXZlbnQuc3BlY2lhbFtvYmplY3QubmFtZV0uX2RlZmF1bHQgPSBmdW5jdGlvbihlKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKF9kZWZhdWx0ICYmIF9kZWZhdWx0LmFwcGx5ICYmICghZS5uYW1lc3BhY2UgfHwgZS5uYW1lc3BhY2UuaW5kZXhPZignb3dsJykgPT09IC0xKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBfZGVmYXVsdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gZS5uYW1lc3BhY2UgJiYgZS5uYW1lc3BhY2UuaW5kZXhPZignb3dsJykgPiAtMTtcXG5cXHRcXHRcXHRcXHR9O1xcblxcdFxcdFxcdFxcdCQuZXZlbnQuc3BlY2lhbFtvYmplY3QubmFtZV0ub3dsID0gdHJ1ZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSBlbHNlIGlmIChvYmplY3QudHlwZSA9PT0gT3dsLlR5cGUuU3RhdGUpIHtcXG5cXHRcXHRcXHRpZiAoIXRoaXMuX3N0YXRlcy50YWdzW29iamVjdC5uYW1lXSkge1xcblxcdFxcdFxcdFxcdHRoaXMuX3N0YXRlcy50YWdzW29iamVjdC5uYW1lXSA9IG9iamVjdC50YWdzO1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5fc3RhdGVzLnRhZ3Nbb2JqZWN0Lm5hbWVdID0gdGhpcy5fc3RhdGVzLnRhZ3Nbb2JqZWN0Lm5hbWVdLmNvbmNhdChvYmplY3QudGFncyk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRoaXMuX3N0YXRlcy50YWdzW29iamVjdC5uYW1lXSA9ICQuZ3JlcCh0aGlzLl9zdGF0ZXMudGFnc1tvYmplY3QubmFtZV0sICQucHJveHkoZnVuY3Rpb24odGFnLCBpKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuICQuaW5BcnJheSh0YWcsIHRoaXMuX3N0YXRlcy50YWdzW29iamVjdC5uYW1lXSkgPT09IGk7XFxuXFx0XFx0XFx0fSwgdGhpcykpO1xcblxcdFxcdH1cXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIFN1cHByZXNzZXMgZXZlbnRzLlxcblxcdCAqIEBwcm90ZWN0ZWRcXG5cXHQgKiBAcGFyYW0ge0FycmF5LjxTdHJpbmc+fSBldmVudHMgLSBUaGUgZXZlbnRzIHRvIHN1cHByZXNzLlxcblxcdCAqL1xcblxcdE93bC5wcm90b3R5cGUuc3VwcHJlc3MgPSBmdW5jdGlvbihldmVudHMpIHtcXG5cXHRcXHQkLmVhY2goZXZlbnRzLCAkLnByb3h5KGZ1bmN0aW9uKGluZGV4LCBldmVudCkge1xcblxcdFxcdFxcdHRoaXMuX3N1cHJlc3NbZXZlbnRdID0gdHJ1ZTtcXG5cXHRcXHR9LCB0aGlzKSk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBSZWxlYXNlcyBzdXBwcmVzc2VkIGV2ZW50cy5cXG5cXHQgKiBAcHJvdGVjdGVkXFxuXFx0ICogQHBhcmFtIHtBcnJheS48U3RyaW5nPn0gZXZlbnRzIC0gVGhlIGV2ZW50cyB0byByZWxlYXNlLlxcblxcdCAqL1xcblxcdE93bC5wcm90b3R5cGUucmVsZWFzZSA9IGZ1bmN0aW9uKGV2ZW50cykge1xcblxcdFxcdCQuZWFjaChldmVudHMsICQucHJveHkoZnVuY3Rpb24oaW5kZXgsIGV2ZW50KSB7XFxuXFx0XFx0XFx0ZGVsZXRlIHRoaXMuX3N1cHJlc3NbZXZlbnRdO1xcblxcdFxcdH0sIHRoaXMpKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEdldHMgdW5pZmllZCBwb2ludGVyIGNvb3JkaW5hdGVzIGZyb20gZXZlbnQuXFxuXFx0ICogQHRvZG8gIzI2MVxcblxcdCAqIEBwcm90ZWN0ZWRcXG5cXHQgKiBAcGFyYW0ge0V2ZW50fSAtIFRoZSBgbW91c2Vkb3duYCBvciBgdG91Y2hzdGFydGAgZXZlbnQuXFxuXFx0ICogQHJldHVybnMge09iamVjdH0gLSBDb250YWlucyBgeGAgYW5kIGB5YCBjb29yZGluYXRlcyBvZiBjdXJyZW50IHBvaW50ZXIgcG9zaXRpb24uXFxuXFx0ICovXFxuXFx0T3dsLnByb3RvdHlwZS5wb2ludGVyID0gZnVuY3Rpb24oZXZlbnQpIHtcXG5cXHRcXHR2YXIgcmVzdWx0ID0geyB4OiBudWxsLCB5OiBudWxsIH07XFxuXFxuXFx0XFx0ZXZlbnQgPSBldmVudC5vcmlnaW5hbEV2ZW50IHx8IGV2ZW50IHx8IHdpbmRvdy5ldmVudDtcXG5cXG5cXHRcXHRldmVudCA9IGV2ZW50LnRvdWNoZXMgJiYgZXZlbnQudG91Y2hlcy5sZW5ndGggP1xcblxcdFxcdFxcdGV2ZW50LnRvdWNoZXNbMF0gOiBldmVudC5jaGFuZ2VkVG91Y2hlcyAmJiBldmVudC5jaGFuZ2VkVG91Y2hlcy5sZW5ndGggP1xcblxcdFxcdFxcdFxcdGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdIDogZXZlbnQ7XFxuXFxuXFx0XFx0aWYgKGV2ZW50LnBhZ2VYKSB7XFxuXFx0XFx0XFx0cmVzdWx0LnggPSBldmVudC5wYWdlWDtcXG5cXHRcXHRcXHRyZXN1bHQueSA9IGV2ZW50LnBhZ2VZO1xcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0cmVzdWx0LnggPSBldmVudC5jbGllbnRYO1xcblxcdFxcdFxcdHJlc3VsdC55ID0gZXZlbnQuY2xpZW50WTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIHJlc3VsdDtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIERldGVybWluZXMgaWYgdGhlIGlucHV0IGlzIGEgTnVtYmVyIG9yIHNvbWV0aGluZyB0aGF0IGNhbiBiZSBjb2VyY2VkIHRvIGEgTnVtYmVyXFxuXFx0ICogQHByb3RlY3RlZFxcblxcdCAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ3xPYmplY3R8QXJyYXl8Qm9vbGVhbnxSZWdFeHB8RnVuY3Rpb258U3ltYm9sfSAtIFRoZSBpbnB1dCB0byBiZSB0ZXN0ZWRcXG5cXHQgKiBAcmV0dXJucyB7Qm9vbGVhbn0gLSBBbiBpbmRpY2F0aW9uIGlmIHRoZSBpbnB1dCBpcyBhIE51bWJlciBvciBjYW4gYmUgY29lcmNlZCB0byBhIE51bWJlclxcblxcdCAqL1xcblxcdE93bC5wcm90b3R5cGUuaXNOdW1lcmljID0gZnVuY3Rpb24obnVtYmVyKSB7XFxuXFx0XFx0cmV0dXJuICFpc05hTihwYXJzZUZsb2F0KG51bWJlcikpO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogR2V0cyB0aGUgZGlmZmVyZW5jZSBvZiB0d28gdmVjdG9ycy5cXG5cXHQgKiBAdG9kbyAjMjYxXFxuXFx0ICogQHByb3RlY3RlZFxcblxcdCAqIEBwYXJhbSB7T2JqZWN0fSAtIFRoZSBmaXJzdCB2ZWN0b3IuXFxuXFx0ICogQHBhcmFtIHtPYmplY3R9IC0gVGhlIHNlY29uZCB2ZWN0b3IuXFxuXFx0ICogQHJldHVybnMge09iamVjdH0gLSBUaGUgZGlmZmVyZW5jZS5cXG5cXHQgKi9cXG5cXHRPd2wucHJvdG90eXBlLmRpZmZlcmVuY2UgPSBmdW5jdGlvbihmaXJzdCwgc2Vjb25kKSB7XFxuXFx0XFx0cmV0dXJuIHtcXG5cXHRcXHRcXHR4OiBmaXJzdC54IC0gc2Vjb25kLngsXFxuXFx0XFx0XFx0eTogZmlyc3QueSAtIHNlY29uZC55XFxuXFx0XFx0fTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIFRoZSBqUXVlcnkgUGx1Z2luIGZvciB0aGUgT3dsIENhcm91c2VsXFxuXFx0ICogQHRvZG8gTmF2aWdhdGlvbiBwbHVnaW4gYG5leHRgIGFuZCBgcHJldmBcXG5cXHQgKiBAcHVibGljXFxuXFx0ICovXFxuXFx0JC5mbi5vd2xDYXJvdXNlbCA9IGZ1bmN0aW9uKG9wdGlvbikge1xcblxcdFxcdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcXG5cXG5cXHRcXHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdHZhciAkdGhpcyA9ICQodGhpcyksXFxuXFx0XFx0XFx0XFx0ZGF0YSA9ICR0aGlzLmRhdGEoJ293bC5jYXJvdXNlbCcpO1xcblxcblxcdFxcdFxcdGlmICghZGF0YSkge1xcblxcdFxcdFxcdFxcdGRhdGEgPSBuZXcgT3dsKHRoaXMsIHR5cGVvZiBvcHRpb24gPT0gJ29iamVjdCcgJiYgb3B0aW9uKTtcXG5cXHRcXHRcXHRcXHQkdGhpcy5kYXRhKCdvd2wuY2Fyb3VzZWwnLCBkYXRhKTtcXG5cXG5cXHRcXHRcXHRcXHQkLmVhY2goW1xcblxcdFxcdFxcdFxcdFxcdCduZXh0JywgJ3ByZXYnLCAndG8nLCAnZGVzdHJveScsICdyZWZyZXNoJywgJ3JlcGxhY2UnLCAnYWRkJywgJ3JlbW92ZSdcXG5cXHRcXHRcXHRcXHRdLCBmdW5jdGlvbihpLCBldmVudCkge1xcblxcdFxcdFxcdFxcdFxcdGRhdGEucmVnaXN0ZXIoeyB0eXBlOiBPd2wuVHlwZS5FdmVudCwgbmFtZTogZXZlbnQgfSk7XFxuXFx0XFx0XFx0XFx0XFx0ZGF0YS4kZWxlbWVudC5vbihldmVudCArICcub3dsLmNhcm91c2VsLmNvcmUnLCAkLnByb3h5KGZ1bmN0aW9uKGUpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoZS5uYW1lc3BhY2UgJiYgZS5yZWxhdGVkVGFyZ2V0ICE9PSB0aGlzKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5zdXBwcmVzcyhbIGV2ZW50IF0pO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGRhdGFbZXZlbnRdLmFwcGx5KHRoaXMsIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5yZWxlYXNlKFsgZXZlbnQgXSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH0sIGRhdGEpKTtcXG5cXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKHR5cGVvZiBvcHRpb24gPT0gJ3N0cmluZycgJiYgb3B0aW9uLmNoYXJBdCgwKSAhPT0gJ18nKSB7XFxuXFx0XFx0XFx0XFx0ZGF0YVtvcHRpb25dLmFwcGx5KGRhdGEsIGFyZ3MpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9KTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIFRoZSBjb25zdHJ1Y3RvciBmb3IgdGhlIGpRdWVyeSBQbHVnaW5cXG5cXHQgKiBAcHVibGljXFxuXFx0ICovXFxuXFx0JC5mbi5vd2xDYXJvdXNlbC5Db25zdHJ1Y3RvciA9IE93bDtcXG5cXG59KSh3aW5kb3cuWmVwdG8gfHwgX193ZWJwYWNrX3Byb3ZpZGVkX3dpbmRvd19kb3RfalF1ZXJ5LCB3aW5kb3csIGRvY3VtZW50KTtcXG5cXG4vKipcXG4gKiBBdXRvUmVmcmVzaCBQbHVnaW5cXG4gKiBAdmVyc2lvbiAyLjEuMFxcbiAqIEBhdXRob3IgQXJ0dXMgS29sYW5vd3NraVxcbiAqIEBhdXRob3IgRGF2aWQgRGV1dHNjaFxcbiAqIEBsaWNlbnNlIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxcbiAqL1xcbjsoZnVuY3Rpb24oJCwgd2luZG93LCBkb2N1bWVudCwgdW5kZWZpbmVkKSB7XFxuXFxuXFx0LyoqXFxuXFx0ICogQ3JlYXRlcyB0aGUgYXV0byByZWZyZXNoIHBsdWdpbi5cXG5cXHQgKiBAY2xhc3MgVGhlIEF1dG8gUmVmcmVzaCBQbHVnaW5cXG5cXHQgKiBAcGFyYW0ge093bH0gY2Fyb3VzZWwgLSBUaGUgT3dsIENhcm91c2VsXFxuXFx0ICovXFxuXFx0dmFyIEF1dG9SZWZyZXNoID0gZnVuY3Rpb24oY2Fyb3VzZWwpIHtcXG5cXHRcXHQvKipcXG5cXHRcXHQgKiBSZWZlcmVuY2UgdG8gdGhlIGNvcmUuXFxuXFx0XFx0ICogQHByb3RlY3RlZFxcblxcdFxcdCAqIEB0eXBlIHtPd2x9XFxuXFx0XFx0ICovXFxuXFx0XFx0dGhpcy5fY29yZSA9IGNhcm91c2VsO1xcblxcblxcdFxcdC8qKlxcblxcdFxcdCAqIFJlZnJlc2ggaW50ZXJ2YWwuXFxuXFx0XFx0ICogQHByb3RlY3RlZFxcblxcdFxcdCAqIEB0eXBlIHtudW1iZXJ9XFxuXFx0XFx0ICovXFxuXFx0XFx0dGhpcy5faW50ZXJ2YWwgPSBudWxsO1xcblxcblxcdFxcdC8qKlxcblxcdFxcdCAqIFdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgY3VycmVudGx5IHZpc2libGUgb3Igbm90LlxcblxcdFxcdCAqIEBwcm90ZWN0ZWRcXG5cXHRcXHQgKiBAdHlwZSB7Qm9vbGVhbn1cXG5cXHRcXHQgKi9cXG5cXHRcXHR0aGlzLl92aXNpYmxlID0gbnVsbDtcXG5cXG5cXHRcXHQvKipcXG5cXHRcXHQgKiBBbGwgZXZlbnQgaGFuZGxlcnMuXFxuXFx0XFx0ICogQHByb3RlY3RlZFxcblxcdFxcdCAqIEB0eXBlIHtPYmplY3R9XFxuXFx0XFx0ICovXFxuXFx0XFx0dGhpcy5faGFuZGxlcnMgPSB7XFxuXFx0XFx0XFx0J2luaXRpYWxpemVkLm93bC5jYXJvdXNlbCc6ICQucHJveHkoZnVuY3Rpb24oZSkge1xcblxcdFxcdFxcdFxcdGlmIChlLm5hbWVzcGFjZSAmJiB0aGlzLl9jb3JlLnNldHRpbmdzLmF1dG9SZWZyZXNoKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy53YXRjaCgpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LCB0aGlzKVxcblxcdFxcdH07XFxuXFxuXFx0XFx0Ly8gc2V0IGRlZmF1bHQgb3B0aW9uc1xcblxcdFxcdHRoaXMuX2NvcmUub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBBdXRvUmVmcmVzaC5EZWZhdWx0cywgdGhpcy5fY29yZS5vcHRpb25zKTtcXG5cXG5cXHRcXHQvLyByZWdpc3RlciBldmVudCBoYW5kbGVyc1xcblxcdFxcdHRoaXMuX2NvcmUuJGVsZW1lbnQub24odGhpcy5faGFuZGxlcnMpO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogRGVmYXVsdCBvcHRpb25zLlxcblxcdCAqIEBwdWJsaWNcXG5cXHQgKi9cXG5cXHRBdXRvUmVmcmVzaC5EZWZhdWx0cyA9IHtcXG5cXHRcXHRhdXRvUmVmcmVzaDogdHJ1ZSxcXG5cXHRcXHRhdXRvUmVmcmVzaEludGVydmFsOiA1MDBcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIFdhdGNoZXMgdGhlIGVsZW1lbnQuXFxuXFx0ICovXFxuXFx0QXV0b1JlZnJlc2gucHJvdG90eXBlLndhdGNoID0gZnVuY3Rpb24oKSB7XFxuXFx0XFx0aWYgKHRoaXMuX2ludGVydmFsKSB7XFxuXFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdH1cXG5cXG5cXHRcXHR0aGlzLl92aXNpYmxlID0gdGhpcy5fY29yZS4kZWxlbWVudC5pcygnOnZpc2libGUnKTtcXG5cXHRcXHR0aGlzLl9pbnRlcnZhbCA9IHdpbmRvdy5zZXRJbnRlcnZhbCgkLnByb3h5KHRoaXMucmVmcmVzaCwgdGhpcyksIHRoaXMuX2NvcmUuc2V0dGluZ3MuYXV0b1JlZnJlc2hJbnRlcnZhbCk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBSZWZyZXNoZXMgdGhlIGVsZW1lbnQuXFxuXFx0ICovXFxuXFx0QXV0b1JlZnJlc2gucHJvdG90eXBlLnJlZnJlc2ggPSBmdW5jdGlvbigpIHtcXG5cXHRcXHRpZiAodGhpcy5fY29yZS4kZWxlbWVudC5pcygnOnZpc2libGUnKSA9PT0gdGhpcy5fdmlzaWJsZSkge1xcblxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0dGhpcy5fdmlzaWJsZSA9ICF0aGlzLl92aXNpYmxlO1xcblxcblxcdFxcdHRoaXMuX2NvcmUuJGVsZW1lbnQudG9nZ2xlQ2xhc3MoJ293bC1oaWRkZW4nLCAhdGhpcy5fdmlzaWJsZSk7XFxuXFxuXFx0XFx0dGhpcy5fdmlzaWJsZSAmJiAodGhpcy5fY29yZS5pbnZhbGlkYXRlKCd3aWR0aCcpICYmIHRoaXMuX2NvcmUucmVmcmVzaCgpKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIERlc3Ryb3lzIHRoZSBwbHVnaW4uXFxuXFx0ICovXFxuXFx0QXV0b1JlZnJlc2gucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcXG5cXHRcXHR2YXIgaGFuZGxlciwgcHJvcGVydHk7XFxuXFxuXFx0XFx0d2luZG93LmNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWwpO1xcblxcblxcdFxcdGZvciAoaGFuZGxlciBpbiB0aGlzLl9oYW5kbGVycykge1xcblxcdFxcdFxcdHRoaXMuX2NvcmUuJGVsZW1lbnQub2ZmKGhhbmRsZXIsIHRoaXMuX2hhbmRsZXJzW2hhbmRsZXJdKTtcXG5cXHRcXHR9XFxuXFx0XFx0Zm9yIChwcm9wZXJ0eSBpbiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzKSkge1xcblxcdFxcdFxcdHR5cGVvZiB0aGlzW3Byb3BlcnR5XSAhPSAnZnVuY3Rpb24nICYmICh0aGlzW3Byb3BlcnR5XSA9IG51bGwpO1xcblxcdFxcdH1cXG5cXHR9O1xcblxcblxcdCQuZm4ub3dsQ2Fyb3VzZWwuQ29uc3RydWN0b3IuUGx1Z2lucy5BdXRvUmVmcmVzaCA9IEF1dG9SZWZyZXNoO1xcblxcbn0pKHdpbmRvdy5aZXB0byB8fCBfX3dlYnBhY2tfcHJvdmlkZWRfd2luZG93X2RvdF9qUXVlcnksIHdpbmRvdywgZG9jdW1lbnQpO1xcblxcbi8qKlxcbiAqIExhenkgUGx1Z2luXFxuICogQHZlcnNpb24gMi4xLjBcXG4gKiBAYXV0aG9yIEJhcnRvc3ogV29qY2llY2hvd3NraVxcbiAqIEBhdXRob3IgRGF2aWQgRGV1dHNjaFxcbiAqIEBsaWNlbnNlIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxcbiAqL1xcbjsoZnVuY3Rpb24oJCwgd2luZG93LCBkb2N1bWVudCwgdW5kZWZpbmVkKSB7XFxuXFxuXFx0LyoqXFxuXFx0ICogQ3JlYXRlcyB0aGUgbGF6eSBwbHVnaW4uXFxuXFx0ICogQGNsYXNzIFRoZSBMYXp5IFBsdWdpblxcblxcdCAqIEBwYXJhbSB7T3dsfSBjYXJvdXNlbCAtIFRoZSBPd2wgQ2Fyb3VzZWxcXG5cXHQgKi9cXG5cXHR2YXIgTGF6eSA9IGZ1bmN0aW9uKGNhcm91c2VsKSB7XFxuXFxuXFx0XFx0LyoqXFxuXFx0XFx0ICogUmVmZXJlbmNlIHRvIHRoZSBjb3JlLlxcblxcdFxcdCAqIEBwcm90ZWN0ZWRcXG5cXHRcXHQgKiBAdHlwZSB7T3dsfVxcblxcdFxcdCAqL1xcblxcdFxcdHRoaXMuX2NvcmUgPSBjYXJvdXNlbDtcXG5cXG5cXHRcXHQvKipcXG5cXHRcXHQgKiBBbHJlYWR5IGxvYWRlZCBpdGVtcy5cXG5cXHRcXHQgKiBAcHJvdGVjdGVkXFxuXFx0XFx0ICogQHR5cGUge0FycmF5LjxqUXVlcnk+fVxcblxcdFxcdCAqL1xcblxcdFxcdHRoaXMuX2xvYWRlZCA9IFtdO1xcblxcblxcdFxcdC8qKlxcblxcdFxcdCAqIEV2ZW50IGhhbmRsZXJzLlxcblxcdFxcdCAqIEBwcm90ZWN0ZWRcXG5cXHRcXHQgKiBAdHlwZSB7T2JqZWN0fVxcblxcdFxcdCAqL1xcblxcdFxcdHRoaXMuX2hhbmRsZXJzID0ge1xcblxcdFxcdFxcdCdpbml0aWFsaXplZC5vd2wuY2Fyb3VzZWwgY2hhbmdlLm93bC5jYXJvdXNlbCByZXNpemVkLm93bC5jYXJvdXNlbCc6ICQucHJveHkoZnVuY3Rpb24oZSkge1xcblxcdFxcdFxcdFxcdGlmICghZS5uYW1lc3BhY2UpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGlmICghdGhpcy5fY29yZS5zZXR0aW5ncyB8fCAhdGhpcy5fY29yZS5zZXR0aW5ncy5sYXp5TG9hZCkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0aWYgKChlLnByb3BlcnR5ICYmIGUucHJvcGVydHkubmFtZSA9PSAncG9zaXRpb24nKSB8fCBlLnR5cGUgPT0gJ2luaXRpYWxpemVkJykge1xcblxcdFxcdFxcdFxcdFxcdHZhciBzZXR0aW5ncyA9IHRoaXMuX2NvcmUuc2V0dGluZ3MsXFxuXFx0XFx0XFx0XFx0XFx0XFx0biA9IChzZXR0aW5ncy5jZW50ZXIgJiYgTWF0aC5jZWlsKHNldHRpbmdzLml0ZW1zIC8gMikgfHwgc2V0dGluZ3MuaXRlbXMpLFxcblxcdFxcdFxcdFxcdFxcdFxcdGkgPSAoKHNldHRpbmdzLmNlbnRlciAmJiBuICogLTEpIHx8IDApLFxcblxcdFxcdFxcdFxcdFxcdFxcdHBvc2l0aW9uID0gKGUucHJvcGVydHkgJiYgZS5wcm9wZXJ0eS52YWx1ZSAhPT0gdW5kZWZpbmVkID8gZS5wcm9wZXJ0eS52YWx1ZSA6IHRoaXMuX2NvcmUuY3VycmVudCgpKSArIGksXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2xvbmVzID0gdGhpcy5fY29yZS5jbG9uZXMoKS5sZW5ndGgsXFxuXFx0XFx0XFx0XFx0XFx0XFx0bG9hZCA9ICQucHJveHkoZnVuY3Rpb24oaSwgdikgeyB0aGlzLmxvYWQodikgfSwgdGhpcyk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0d2hpbGUgKGkrKyA8IG4pIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLmxvYWQoY2xvbmVzIC8gMiArIHRoaXMuX2NvcmUucmVsYXRpdmUocG9zaXRpb24pKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRjbG9uZXMgJiYgJC5lYWNoKHRoaXMuX2NvcmUuY2xvbmVzKHRoaXMuX2NvcmUucmVsYXRpdmUocG9zaXRpb24pKSwgbG9hZCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cG9zaXRpb24rKztcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sIHRoaXMpXFxuXFx0XFx0fTtcXG5cXG5cXHRcXHQvLyBzZXQgdGhlIGRlZmF1bHQgb3B0aW9uc1xcblxcdFxcdHRoaXMuX2NvcmUub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBMYXp5LkRlZmF1bHRzLCB0aGlzLl9jb3JlLm9wdGlvbnMpO1xcblxcblxcdFxcdC8vIHJlZ2lzdGVyIGV2ZW50IGhhbmRsZXJcXG5cXHRcXHR0aGlzLl9jb3JlLiRlbGVtZW50Lm9uKHRoaXMuX2hhbmRsZXJzKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIERlZmF1bHQgb3B0aW9ucy5cXG5cXHQgKiBAcHVibGljXFxuXFx0ICovXFxuXFx0TGF6eS5EZWZhdWx0cyA9IHtcXG5cXHRcXHRsYXp5TG9hZDogZmFsc2VcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIExvYWRzIGFsbCByZXNvdXJjZXMgb2YgYW4gaXRlbSBhdCB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uLlxcblxcdCAqIEBwYXJhbSB7TnVtYmVyfSBwb3NpdGlvbiAtIFRoZSBhYnNvbHV0ZSBwb3NpdGlvbiBvZiB0aGUgaXRlbS5cXG5cXHQgKiBAcHJvdGVjdGVkXFxuXFx0ICovXFxuXFx0TGF6eS5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XFxuXFx0XFx0dmFyICRpdGVtID0gdGhpcy5fY29yZS4kc3RhZ2UuY2hpbGRyZW4oKS5lcShwb3NpdGlvbiksXFxuXFx0XFx0XFx0JGVsZW1lbnRzID0gJGl0ZW0gJiYgJGl0ZW0uZmluZCgnLm93bC1sYXp5Jyk7XFxuXFxuXFx0XFx0aWYgKCEkZWxlbWVudHMgfHwgJC5pbkFycmF5KCRpdGVtLmdldCgwKSwgdGhpcy5fbG9hZGVkKSA+IC0xKSB7XFxuXFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQkZWxlbWVudHMuZWFjaCgkLnByb3h5KGZ1bmN0aW9uKGluZGV4LCBlbGVtZW50KSB7XFxuXFx0XFx0XFx0dmFyICRlbGVtZW50ID0gJChlbGVtZW50KSwgaW1hZ2UsXFxuXFx0XFx0XFx0XFx0dXJsID0gKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvID4gMSAmJiAkZWxlbWVudC5hdHRyKCdkYXRhLXNyYy1yZXRpbmEnKSkgfHwgJGVsZW1lbnQuYXR0cignZGF0YS1zcmMnKTtcXG5cXG5cXHRcXHRcXHR0aGlzLl9jb3JlLnRyaWdnZXIoJ2xvYWQnLCB7IGVsZW1lbnQ6ICRlbGVtZW50LCB1cmw6IHVybCB9LCAnbGF6eScpO1xcblxcblxcdFxcdFxcdGlmICgkZWxlbWVudC5pcygnaW1nJykpIHtcXG5cXHRcXHRcXHRcXHQkZWxlbWVudC5vbmUoJ2xvYWQub3dsLmxhenknLCAkLnByb3h5KGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdFxcdCRlbGVtZW50LmNzcygnb3BhY2l0eScsIDEpO1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuX2NvcmUudHJpZ2dlcignbG9hZGVkJywgeyBlbGVtZW50OiAkZWxlbWVudCwgdXJsOiB1cmwgfSwgJ2xhenknKTtcXG5cXHRcXHRcXHRcXHR9LCB0aGlzKSkuYXR0cignc3JjJywgdXJsKTtcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdGltYWdlID0gbmV3IEltYWdlKCk7XFxuXFx0XFx0XFx0XFx0aW1hZ2Uub25sb2FkID0gJC5wcm94eShmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRcXHQkZWxlbWVudC5jc3Moe1xcblxcdFxcdFxcdFxcdFxcdFxcdCdiYWNrZ3JvdW5kLWltYWdlJzogJ3VybCgnICsgdXJsICsgJyknLFxcblxcdFxcdFxcdFxcdFxcdFxcdCdvcGFjaXR5JzogJzEnXFxuXFx0XFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fY29yZS50cmlnZ2VyKCdsb2FkZWQnLCB7IGVsZW1lbnQ6ICRlbGVtZW50LCB1cmw6IHVybCB9LCAnbGF6eScpO1xcblxcdFxcdFxcdFxcdH0sIHRoaXMpO1xcblxcdFxcdFxcdFxcdGltYWdlLnNyYyA9IHVybDtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSwgdGhpcykpO1xcblxcblxcdFxcdHRoaXMuX2xvYWRlZC5wdXNoKCRpdGVtLmdldCgwKSk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBEZXN0cm95cyB0aGUgcGx1Z2luLlxcblxcdCAqIEBwdWJsaWNcXG5cXHQgKi9cXG5cXHRMYXp5LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XFxuXFx0XFx0dmFyIGhhbmRsZXIsIHByb3BlcnR5O1xcblxcblxcdFxcdGZvciAoaGFuZGxlciBpbiB0aGlzLmhhbmRsZXJzKSB7XFxuXFx0XFx0XFx0dGhpcy5fY29yZS4kZWxlbWVudC5vZmYoaGFuZGxlciwgdGhpcy5oYW5kbGVyc1toYW5kbGVyXSk7XFxuXFx0XFx0fVxcblxcdFxcdGZvciAocHJvcGVydHkgaW4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcykpIHtcXG5cXHRcXHRcXHR0eXBlb2YgdGhpc1twcm9wZXJ0eV0gIT0gJ2Z1bmN0aW9uJyAmJiAodGhpc1twcm9wZXJ0eV0gPSBudWxsKTtcXG5cXHRcXHR9XFxuXFx0fTtcXG5cXG5cXHQkLmZuLm93bENhcm91c2VsLkNvbnN0cnVjdG9yLlBsdWdpbnMuTGF6eSA9IExhenk7XFxuXFxufSkod2luZG93LlplcHRvIHx8IF9fd2VicGFja19wcm92aWRlZF93aW5kb3dfZG90X2pRdWVyeSwgd2luZG93LCBkb2N1bWVudCk7XFxuXFxuLyoqXFxuICogQXV0b0hlaWdodCBQbHVnaW5cXG4gKiBAdmVyc2lvbiAyLjEuMFxcbiAqIEBhdXRob3IgQmFydG9zeiBXb2pjaWVjaG93c2tpXFxuICogQGF1dGhvciBEYXZpZCBEZXV0c2NoXFxuICogQGxpY2Vuc2UgVGhlIE1JVCBMaWNlbnNlIChNSVQpXFxuICovXFxuOyhmdW5jdGlvbigkLCB3aW5kb3csIGRvY3VtZW50LCB1bmRlZmluZWQpIHtcXG5cXG5cXHQvKipcXG5cXHQgKiBDcmVhdGVzIHRoZSBhdXRvIGhlaWdodCBwbHVnaW4uXFxuXFx0ICogQGNsYXNzIFRoZSBBdXRvIEhlaWdodCBQbHVnaW5cXG5cXHQgKiBAcGFyYW0ge093bH0gY2Fyb3VzZWwgLSBUaGUgT3dsIENhcm91c2VsXFxuXFx0ICovXFxuXFx0dmFyIEF1dG9IZWlnaHQgPSBmdW5jdGlvbihjYXJvdXNlbCkge1xcblxcdFxcdC8qKlxcblxcdFxcdCAqIFJlZmVyZW5jZSB0byB0aGUgY29yZS5cXG5cXHRcXHQgKiBAcHJvdGVjdGVkXFxuXFx0XFx0ICogQHR5cGUge093bH1cXG5cXHRcXHQgKi9cXG5cXHRcXHR0aGlzLl9jb3JlID0gY2Fyb3VzZWw7XFxuXFxuXFx0XFx0LyoqXFxuXFx0XFx0ICogQWxsIGV2ZW50IGhhbmRsZXJzLlxcblxcdFxcdCAqIEBwcm90ZWN0ZWRcXG5cXHRcXHQgKiBAdHlwZSB7T2JqZWN0fVxcblxcdFxcdCAqL1xcblxcdFxcdHRoaXMuX2hhbmRsZXJzID0ge1xcblxcdFxcdFxcdCdpbml0aWFsaXplZC5vd2wuY2Fyb3VzZWwgcmVmcmVzaGVkLm93bC5jYXJvdXNlbCc6ICQucHJveHkoZnVuY3Rpb24oZSkge1xcblxcdFxcdFxcdFxcdGlmIChlLm5hbWVzcGFjZSAmJiB0aGlzLl9jb3JlLnNldHRpbmdzLmF1dG9IZWlnaHQpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnVwZGF0ZSgpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LCB0aGlzKSxcXG5cXHRcXHRcXHQnY2hhbmdlZC5vd2wuY2Fyb3VzZWwnOiAkLnByb3h5KGZ1bmN0aW9uKGUpIHtcXG5cXHRcXHRcXHRcXHRpZiAoZS5uYW1lc3BhY2UgJiYgdGhpcy5fY29yZS5zZXR0aW5ncy5hdXRvSGVpZ2h0ICYmIGUucHJvcGVydHkubmFtZSA9PSAncG9zaXRpb24nKXtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnVwZGF0ZSgpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LCB0aGlzKSxcXG5cXHRcXHRcXHQnbG9hZGVkLm93bC5sYXp5JzogJC5wcm94eShmdW5jdGlvbihlKSB7XFxuXFx0XFx0XFx0XFx0aWYgKGUubmFtZXNwYWNlICYmIHRoaXMuX2NvcmUuc2V0dGluZ3MuYXV0b0hlaWdodFxcblxcdFxcdFxcdFxcdFxcdCYmIGUuZWxlbWVudC5jbG9zZXN0KCcuJyArIHRoaXMuX2NvcmUuc2V0dGluZ3MuaXRlbUNsYXNzKS5pbmRleCgpID09PSB0aGlzLl9jb3JlLmN1cnJlbnQoKSkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMudXBkYXRlKCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sIHRoaXMpXFxuXFx0XFx0fTtcXG5cXG5cXHRcXHQvLyBzZXQgZGVmYXVsdCBvcHRpb25zXFxuXFx0XFx0dGhpcy5fY29yZS5vcHRpb25zID0gJC5leHRlbmQoe30sIEF1dG9IZWlnaHQuRGVmYXVsdHMsIHRoaXMuX2NvcmUub3B0aW9ucyk7XFxuXFxuXFx0XFx0Ly8gcmVnaXN0ZXIgZXZlbnQgaGFuZGxlcnNcXG5cXHRcXHR0aGlzLl9jb3JlLiRlbGVtZW50Lm9uKHRoaXMuX2hhbmRsZXJzKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIERlZmF1bHQgb3B0aW9ucy5cXG5cXHQgKiBAcHVibGljXFxuXFx0ICovXFxuXFx0QXV0b0hlaWdodC5EZWZhdWx0cyA9IHtcXG5cXHRcXHRhdXRvSGVpZ2h0OiBmYWxzZSxcXG5cXHRcXHRhdXRvSGVpZ2h0Q2xhc3M6ICdvd2wtaGVpZ2h0J1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogVXBkYXRlcyB0aGUgdmlldy5cXG5cXHQgKi9cXG5cXHRBdXRvSGVpZ2h0LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbigpIHtcXG5cXHRcXHR2YXIgc3RhcnQgPSB0aGlzLl9jb3JlLl9jdXJyZW50LFxcblxcdFxcdFxcdGVuZCA9IHN0YXJ0ICsgdGhpcy5fY29yZS5zZXR0aW5ncy5pdGVtcyxcXG5cXHRcXHRcXHR2aXNpYmxlID0gdGhpcy5fY29yZS4kc3RhZ2UuY2hpbGRyZW4oKS50b0FycmF5KCkuc2xpY2Uoc3RhcnQsIGVuZCksXFxuXFx0XFx0XFx0aGVpZ2h0cyA9IFtdLFxcblxcdFxcdFxcdG1heGhlaWdodCA9IDA7XFxuXFxuXFx0XFx0JC5lYWNoKHZpc2libGUsIGZ1bmN0aW9uKGluZGV4LCBpdGVtKSB7XFxuXFx0XFx0XFx0aGVpZ2h0cy5wdXNoKCQoaXRlbSkuaGVpZ2h0KCkpO1xcblxcdFxcdH0pO1xcblxcblxcdFxcdG1heGhlaWdodCA9IE1hdGgubWF4LmFwcGx5KG51bGwsIGhlaWdodHMpO1xcblxcblxcdFxcdHRoaXMuX2NvcmUuJHN0YWdlLnBhcmVudCgpXFxuXFx0XFx0XFx0LmhlaWdodChtYXhoZWlnaHQpXFxuXFx0XFx0XFx0LmFkZENsYXNzKHRoaXMuX2NvcmUuc2V0dGluZ3MuYXV0b0hlaWdodENsYXNzKTtcXG5cXHR9O1xcblxcblxcdEF1dG9IZWlnaHQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcXG5cXHRcXHR2YXIgaGFuZGxlciwgcHJvcGVydHk7XFxuXFxuXFx0XFx0Zm9yIChoYW5kbGVyIGluIHRoaXMuX2hhbmRsZXJzKSB7XFxuXFx0XFx0XFx0dGhpcy5fY29yZS4kZWxlbWVudC5vZmYoaGFuZGxlciwgdGhpcy5faGFuZGxlcnNbaGFuZGxlcl0pO1xcblxcdFxcdH1cXG5cXHRcXHRmb3IgKHByb3BlcnR5IGluIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMpKSB7XFxuXFx0XFx0XFx0dHlwZW9mIHRoaXNbcHJvcGVydHldICE9ICdmdW5jdGlvbicgJiYgKHRoaXNbcHJvcGVydHldID0gbnVsbCk7XFxuXFx0XFx0fVxcblxcdH07XFxuXFxuXFx0JC5mbi5vd2xDYXJvdXNlbC5Db25zdHJ1Y3Rvci5QbHVnaW5zLkF1dG9IZWlnaHQgPSBBdXRvSGVpZ2h0O1xcblxcbn0pKHdpbmRvdy5aZXB0byB8fCBfX3dlYnBhY2tfcHJvdmlkZWRfd2luZG93X2RvdF9qUXVlcnksIHdpbmRvdywgZG9jdW1lbnQpO1xcblxcbi8qKlxcbiAqIFZpZGVvIFBsdWdpblxcbiAqIEB2ZXJzaW9uIDIuMS4wXFxuICogQGF1dGhvciBCYXJ0b3N6IFdvamNpZWNob3dza2lcXG4gKiBAYXV0aG9yIERhdmlkIERldXRzY2hcXG4gKiBAbGljZW5zZSBUaGUgTUlUIExpY2Vuc2UgKE1JVClcXG4gKi9cXG47KGZ1bmN0aW9uKCQsIHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCkge1xcblxcblxcdC8qKlxcblxcdCAqIENyZWF0ZXMgdGhlIHZpZGVvIHBsdWdpbi5cXG5cXHQgKiBAY2xhc3MgVGhlIFZpZGVvIFBsdWdpblxcblxcdCAqIEBwYXJhbSB7T3dsfSBjYXJvdXNlbCAtIFRoZSBPd2wgQ2Fyb3VzZWxcXG5cXHQgKi9cXG5cXHR2YXIgVmlkZW8gPSBmdW5jdGlvbihjYXJvdXNlbCkge1xcblxcdFxcdC8qKlxcblxcdFxcdCAqIFJlZmVyZW5jZSB0byB0aGUgY29yZS5cXG5cXHRcXHQgKiBAcHJvdGVjdGVkXFxuXFx0XFx0ICogQHR5cGUge093bH1cXG5cXHRcXHQgKi9cXG5cXHRcXHR0aGlzLl9jb3JlID0gY2Fyb3VzZWw7XFxuXFxuXFx0XFx0LyoqXFxuXFx0XFx0ICogQ2FjaGUgYWxsIHZpZGVvIFVSTHMuXFxuXFx0XFx0ICogQHByb3RlY3RlZFxcblxcdFxcdCAqIEB0eXBlIHtPYmplY3R9XFxuXFx0XFx0ICovXFxuXFx0XFx0dGhpcy5fdmlkZW9zID0ge307XFxuXFxuXFx0XFx0LyoqXFxuXFx0XFx0ICogQ3VycmVudCBwbGF5aW5nIGl0ZW0uXFxuXFx0XFx0ICogQHByb3RlY3RlZFxcblxcdFxcdCAqIEB0eXBlIHtqUXVlcnl9XFxuXFx0XFx0ICovXFxuXFx0XFx0dGhpcy5fcGxheWluZyA9IG51bGw7XFxuXFxuXFx0XFx0LyoqXFxuXFx0XFx0ICogQWxsIGV2ZW50IGhhbmRsZXJzLlxcblxcdFxcdCAqIEB0b2RvIFRoZSBjbG9uZWQgY29udGVudCByZW1vdmFsZSBpcyB0b28gbGF0ZVxcblxcdFxcdCAqIEBwcm90ZWN0ZWRcXG5cXHRcXHQgKiBAdHlwZSB7T2JqZWN0fVxcblxcdFxcdCAqL1xcblxcdFxcdHRoaXMuX2hhbmRsZXJzID0ge1xcblxcdFxcdFxcdCdpbml0aWFsaXplZC5vd2wuY2Fyb3VzZWwnOiAkLnByb3h5KGZ1bmN0aW9uKGUpIHtcXG5cXHRcXHRcXHRcXHRpZiAoZS5uYW1lc3BhY2UpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl9jb3JlLnJlZ2lzdGVyKHsgdHlwZTogJ3N0YXRlJywgbmFtZTogJ3BsYXlpbmcnLCB0YWdzOiBbICdpbnRlcmFjdGluZycgXSB9KTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSwgdGhpcyksXFxuXFx0XFx0XFx0J3Jlc2l6ZS5vd2wuY2Fyb3VzZWwnOiAkLnByb3h5KGZ1bmN0aW9uKGUpIHtcXG5cXHRcXHRcXHRcXHRpZiAoZS5uYW1lc3BhY2UgJiYgdGhpcy5fY29yZS5zZXR0aW5ncy52aWRlbyAmJiB0aGlzLmlzSW5GdWxsU2NyZWVuKCkpIHtcXG5cXHRcXHRcXHRcXHRcXHRlLnByZXZlbnREZWZhdWx0KCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sIHRoaXMpLFxcblxcdFxcdFxcdCdyZWZyZXNoZWQub3dsLmNhcm91c2VsJzogJC5wcm94eShmdW5jdGlvbihlKSB7XFxuXFx0XFx0XFx0XFx0aWYgKGUubmFtZXNwYWNlICYmIHRoaXMuX2NvcmUuaXMoJ3Jlc2l6aW5nJykpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl9jb3JlLiRzdGFnZS5maW5kKCcuY2xvbmVkIC5vd2wtdmlkZW8tZnJhbWUnKS5yZW1vdmUoKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSwgdGhpcyksXFxuXFx0XFx0XFx0J2NoYW5nZWQub3dsLmNhcm91c2VsJzogJC5wcm94eShmdW5jdGlvbihlKSB7XFxuXFx0XFx0XFx0XFx0aWYgKGUubmFtZXNwYWNlICYmIGUucHJvcGVydHkubmFtZSA9PT0gJ3Bvc2l0aW9uJyAmJiB0aGlzLl9wbGF5aW5nKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5zdG9wKCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sIHRoaXMpLFxcblxcdFxcdFxcdCdwcmVwYXJlZC5vd2wuY2Fyb3VzZWwnOiAkLnByb3h5KGZ1bmN0aW9uKGUpIHtcXG5cXHRcXHRcXHRcXHRpZiAoIWUubmFtZXNwYWNlKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR2YXIgJGVsZW1lbnQgPSAkKGUuY29udGVudCkuZmluZCgnLm93bC12aWRlbycpO1xcblxcblxcdFxcdFxcdFxcdGlmICgkZWxlbWVudC5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHRcXHQkZWxlbWVudC5jc3MoJ2Rpc3BsYXknLCAnbm9uZScpO1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuZmV0Y2goJGVsZW1lbnQsICQoZS5jb250ZW50KSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sIHRoaXMpXFxuXFx0XFx0fTtcXG5cXG5cXHRcXHQvLyBzZXQgZGVmYXVsdCBvcHRpb25zXFxuXFx0XFx0dGhpcy5fY29yZS5vcHRpb25zID0gJC5leHRlbmQoe30sIFZpZGVvLkRlZmF1bHRzLCB0aGlzLl9jb3JlLm9wdGlvbnMpO1xcblxcblxcdFxcdC8vIHJlZ2lzdGVyIGV2ZW50IGhhbmRsZXJzXFxuXFx0XFx0dGhpcy5fY29yZS4kZWxlbWVudC5vbih0aGlzLl9oYW5kbGVycyk7XFxuXFxuXFx0XFx0dGhpcy5fY29yZS4kZWxlbWVudC5vbignY2xpY2sub3dsLnZpZGVvJywgJy5vd2wtdmlkZW8tcGxheS1pY29uJywgJC5wcm94eShmdW5jdGlvbihlKSB7XFxuXFx0XFx0XFx0dGhpcy5wbGF5KGUpO1xcblxcdFxcdH0sIHRoaXMpKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIERlZmF1bHQgb3B0aW9ucy5cXG5cXHQgKiBAcHVibGljXFxuXFx0ICovXFxuXFx0VmlkZW8uRGVmYXVsdHMgPSB7XFxuXFx0XFx0dmlkZW86IGZhbHNlLFxcblxcdFxcdHZpZGVvSGVpZ2h0OiBmYWxzZSxcXG5cXHRcXHR2aWRlb1dpZHRoOiBmYWxzZVxcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogR2V0cyB0aGUgdmlkZW8gSUQgYW5kIHRoZSB0eXBlIChZb3VUdWJlL1ZpbWVvL3Z6YWFyIG9ubHkpLlxcblxcdCAqIEBwcm90ZWN0ZWRcXG5cXHQgKiBAcGFyYW0ge2pRdWVyeX0gdGFyZ2V0IC0gVGhlIHRhcmdldCBjb250YWluaW5nIHRoZSB2aWRlbyBkYXRhLlxcblxcdCAqIEBwYXJhbSB7alF1ZXJ5fSBpdGVtIC0gVGhlIGl0ZW0gY29udGFpbmluZyB0aGUgdmlkZW8uXFxuXFx0ICovXFxuXFx0VmlkZW8ucHJvdG90eXBlLmZldGNoID0gZnVuY3Rpb24odGFyZ2V0LCBpdGVtKSB7XFxuXFx0XFx0XFx0dmFyIHR5cGUgPSAoZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHRhcmdldC5hdHRyKCdkYXRhLXZpbWVvLWlkJykpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gJ3ZpbWVvJztcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2UgaWYgKHRhcmdldC5hdHRyKCdkYXRhLXZ6YWFyLWlkJykpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gJ3Z6YWFyJ1xcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuICd5b3V0dWJlJztcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fSkoKSxcXG5cXHRcXHRcXHRcXHRpZCA9IHRhcmdldC5hdHRyKCdkYXRhLXZpbWVvLWlkJykgfHwgdGFyZ2V0LmF0dHIoJ2RhdGEteW91dHViZS1pZCcpIHx8IHRhcmdldC5hdHRyKCdkYXRhLXZ6YWFyLWlkJyksXFxuXFx0XFx0XFx0XFx0d2lkdGggPSB0YXJnZXQuYXR0cignZGF0YS13aWR0aCcpIHx8IHRoaXMuX2NvcmUuc2V0dGluZ3MudmlkZW9XaWR0aCxcXG5cXHRcXHRcXHRcXHRoZWlnaHQgPSB0YXJnZXQuYXR0cignZGF0YS1oZWlnaHQnKSB8fCB0aGlzLl9jb3JlLnNldHRpbmdzLnZpZGVvSGVpZ2h0LFxcblxcdFxcdFxcdFxcdHVybCA9IHRhcmdldC5hdHRyKCdocmVmJyk7XFxuXFxuXFx0XFx0aWYgKHVybCkge1xcblxcblxcdFxcdFxcdC8qXFxuXFx0XFx0XFx0XFx0XFx0UGFyc2VzIHRoZSBpZCdzIG91dCBvZiB0aGUgZm9sbG93aW5nIHVybHMgKGFuZCBwcm9iYWJseSBtb3JlKTpcXG5cXHRcXHRcXHRcXHRcXHRodHRwczovL3d3dy55b3V0dWJlLmNvbS93YXRjaD92PTppZFxcblxcdFxcdFxcdFxcdFxcdGh0dHBzOi8veW91dHUuYmUvOmlkXFxuXFx0XFx0XFx0XFx0XFx0aHR0cHM6Ly92aW1lby5jb20vOmlkXFxuXFx0XFx0XFx0XFx0XFx0aHR0cHM6Ly92aW1lby5jb20vY2hhbm5lbHMvOmNoYW5uZWwvOmlkXFxuXFx0XFx0XFx0XFx0XFx0aHR0cHM6Ly92aW1lby5jb20vZ3JvdXBzLzpncm91cC92aWRlb3MvOmlkXFxuXFx0XFx0XFx0XFx0XFx0aHR0cHM6Ly9hcHAudnphYXIuY29tL3ZpZGVvcy86aWRcXG5cXG5cXHRcXHRcXHRcXHRcXHRWaXN1YWwgZXhhbXBsZTogaHR0cHM6Ly9yZWdleHBlci5jb20vIyhodHRwJTNBJTdDaHR0cHMlM0ElN0MpJTVDJTJGJTVDJTJGKHBsYXllci4lN0N3d3cuJTdDYXBwLiklM0YodmltZW8lNUMuY29tJTdDeW91dHUoYmUlNUMuY29tJTdDJTVDLmJlJTdDYmUlNUMuZ29vZ2xlYXBpcyU1Qy5jb20pJTdDdnphYXIlNUMuY29tKSU1QyUyRih2aWRlbyU1QyUyRiU3Q3ZpZGVvcyU1QyUyRiU3Q2VtYmVkJTVDJTJGJTdDY2hhbm5lbHMlNUMlMkYuJTJCJTVDJTJGJTdDZ3JvdXBzJTVDJTJGLiUyQiU1QyUyRiU3Q3dhdGNoJTVDJTNGdiUzRCU3Q3YlNUMlMkYpJTNGKCU1QkEtWmEtejAtOS5fJTI1LSU1RCopKCU1QyUyNiU1Q1MlMkIpJTNGXFxuXFx0XFx0XFx0Ki9cXG5cXG5cXHRcXHRcXHRpZCA9IHVybC5tYXRjaCgvKGh0dHA6fGh0dHBzOnwpXFxcXC9cXFxcLyhwbGF5ZXIufHd3dy58YXBwLik/KHZpbWVvXFxcXC5jb218eW91dHUoYmVcXFxcLmNvbXxcXFxcLmJlfGJlXFxcXC5nb29nbGVhcGlzXFxcXC5jb20pfHZ6YWFyXFxcXC5jb20pXFxcXC8odmlkZW9cXFxcL3x2aWRlb3NcXFxcL3xlbWJlZFxcXFwvfGNoYW5uZWxzXFxcXC8uK1xcXFwvfGdyb3Vwc1xcXFwvLitcXFxcL3x3YXRjaFxcXFw/dj18dlxcXFwvKT8oW0EtWmEtejAtOS5fJS1dKikoXFxcXCZcXFxcUyspPy8pO1xcblxcblxcdFxcdFxcdGlmIChpZFszXS5pbmRleE9mKCd5b3V0dScpID4gLTEpIHtcXG5cXHRcXHRcXHRcXHR0eXBlID0gJ3lvdXR1YmUnO1xcblxcdFxcdFxcdH0gZWxzZSBpZiAoaWRbM10uaW5kZXhPZigndmltZW8nKSA+IC0xKSB7XFxuXFx0XFx0XFx0XFx0dHlwZSA9ICd2aW1lbyc7XFxuXFx0XFx0XFx0fSBlbHNlIGlmIChpZFszXS5pbmRleE9mKCd2emFhcicpID4gLTEpIHtcXG5cXHRcXHRcXHRcXHR0eXBlID0gJ3Z6YWFyJztcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdHRocm93IG5ldyBFcnJvcignVmlkZW8gVVJMIG5vdCBzdXBwb3J0ZWQuJyk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlkID0gaWRbNl07XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHR0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgdmlkZW8gVVJMLicpO1xcblxcdFxcdH1cXG5cXG5cXHRcXHR0aGlzLl92aWRlb3NbdXJsXSA9IHtcXG5cXHRcXHRcXHR0eXBlOiB0eXBlLFxcblxcdFxcdFxcdGlkOiBpZCxcXG5cXHRcXHRcXHR3aWR0aDogd2lkdGgsXFxuXFx0XFx0XFx0aGVpZ2h0OiBoZWlnaHRcXG5cXHRcXHR9O1xcblxcblxcdFxcdGl0ZW0uYXR0cignZGF0YS12aWRlbycsIHVybCk7XFxuXFxuXFx0XFx0dGhpcy50aHVtYm5haWwodGFyZ2V0LCB0aGlzLl92aWRlb3NbdXJsXSk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBDcmVhdGVzIHZpZGVvIHRodW1ibmFpbC5cXG5cXHQgKiBAcHJvdGVjdGVkXFxuXFx0ICogQHBhcmFtIHtqUXVlcnl9IHRhcmdldCAtIFRoZSB0YXJnZXQgY29udGFpbmluZyB0aGUgdmlkZW8gZGF0YS5cXG5cXHQgKiBAcGFyYW0ge09iamVjdH0gaW5mbyAtIFRoZSB2aWRlbyBpbmZvIG9iamVjdC5cXG5cXHQgKiBAc2VlIGBmZXRjaGBcXG5cXHQgKi9cXG5cXHRWaWRlby5wcm90b3R5cGUudGh1bWJuYWlsID0gZnVuY3Rpb24odGFyZ2V0LCB2aWRlbykge1xcblxcdFxcdHZhciB0bkxpbmssXFxuXFx0XFx0XFx0aWNvbixcXG5cXHRcXHRcXHRwYXRoLFxcblxcdFxcdFxcdGRpbWVuc2lvbnMgPSB2aWRlby53aWR0aCAmJiB2aWRlby5oZWlnaHQgPyAnc3R5bGU9XFxcIndpZHRoOicgKyB2aWRlby53aWR0aCArICdweDtoZWlnaHQ6JyArIHZpZGVvLmhlaWdodCArICdweDtcXFwiJyA6ICcnLFxcblxcdFxcdFxcdGN1c3RvbVRuID0gdGFyZ2V0LmZpbmQoJ2ltZycpLFxcblxcdFxcdFxcdHNyY1R5cGUgPSAnc3JjJyxcXG5cXHRcXHRcXHRsYXp5Q2xhc3MgPSAnJyxcXG5cXHRcXHRcXHRzZXR0aW5ncyA9IHRoaXMuX2NvcmUuc2V0dGluZ3MsXFxuXFx0XFx0XFx0Y3JlYXRlID0gZnVuY3Rpb24ocGF0aCkge1xcblxcdFxcdFxcdFxcdGljb24gPSAnPGRpdiBjbGFzcz1cXFwib3dsLXZpZGVvLXBsYXktaWNvblxcXCI+PC9kaXY+JztcXG5cXG5cXHRcXHRcXHRcXHRpZiAoc2V0dGluZ3MubGF6eUxvYWQpIHtcXG5cXHRcXHRcXHRcXHRcXHR0bkxpbmsgPSAnPGRpdiBjbGFzcz1cXFwib3dsLXZpZGVvLXRuICcgKyBsYXp5Q2xhc3MgKyAnXFxcIiAnICsgc3JjVHlwZSArICc9XFxcIicgKyBwYXRoICsgJ1xcXCI+PC9kaXY+JztcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdHRuTGluayA9ICc8ZGl2IGNsYXNzPVxcXCJvd2wtdmlkZW8tdG5cXFwiIHN0eWxlPVxcXCJvcGFjaXR5OjE7YmFja2dyb3VuZC1pbWFnZTp1cmwoJyArIHBhdGggKyAnKVxcXCI+PC9kaXY+JztcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0dGFyZ2V0LmFmdGVyKHRuTGluayk7XFxuXFx0XFx0XFx0XFx0dGFyZ2V0LmFmdGVyKGljb24pO1xcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0Ly8gd3JhcCB2aWRlbyBjb250ZW50IGludG8gb3dsLXZpZGVvLXdyYXBwZXIgZGl2XFxuXFx0XFx0dGFyZ2V0LndyYXAoJzxkaXYgY2xhc3M9XFxcIm93bC12aWRlby13cmFwcGVyXFxcIicgKyBkaW1lbnNpb25zICsgJz48L2Rpdj4nKTtcXG5cXG5cXHRcXHRpZiAodGhpcy5fY29yZS5zZXR0aW5ncy5sYXp5TG9hZCkge1xcblxcdFxcdFxcdHNyY1R5cGUgPSAnZGF0YS1zcmMnO1xcblxcdFxcdFxcdGxhenlDbGFzcyA9ICdvd2wtbGF6eSc7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIGN1c3RvbSB0aHVtYm5haWxcXG5cXHRcXHRpZiAoY3VzdG9tVG4ubGVuZ3RoKSB7XFxuXFx0XFx0XFx0Y3JlYXRlKGN1c3RvbVRuLmF0dHIoc3JjVHlwZSkpO1xcblxcdFxcdFxcdGN1c3RvbVRuLnJlbW92ZSgpO1xcblxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKHZpZGVvLnR5cGUgPT09ICd5b3V0dWJlJykge1xcblxcdFxcdFxcdHBhdGggPSBcXFwiLy9pbWcueW91dHViZS5jb20vdmkvXFxcIiArIHZpZGVvLmlkICsgXFxcIi9ocWRlZmF1bHQuanBnXFxcIjtcXG5cXHRcXHRcXHRjcmVhdGUocGF0aCk7XFxuXFx0XFx0fSBlbHNlIGlmICh2aWRlby50eXBlID09PSAndmltZW8nKSB7XFxuXFx0XFx0XFx0JC5hamF4KHtcXG5cXHRcXHRcXHRcXHR0eXBlOiAnR0VUJyxcXG5cXHRcXHRcXHRcXHR1cmw6ICcvL3ZpbWVvLmNvbS9hcGkvdjIvdmlkZW8vJyArIHZpZGVvLmlkICsgJy5qc29uJyxcXG5cXHRcXHRcXHRcXHRqc29ucDogJ2NhbGxiYWNrJyxcXG5cXHRcXHRcXHRcXHRkYXRhVHlwZTogJ2pzb25wJyxcXG5cXHRcXHRcXHRcXHRzdWNjZXNzOiBmdW5jdGlvbihkYXRhKSB7XFxuXFx0XFx0XFx0XFx0XFx0cGF0aCA9IGRhdGFbMF0udGh1bWJuYWlsX2xhcmdlO1xcblxcdFxcdFxcdFxcdFxcdGNyZWF0ZShwYXRoKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSk7XFxuXFx0XFx0fSBlbHNlIGlmICh2aWRlby50eXBlID09PSAndnphYXInKSB7XFxuXFx0XFx0XFx0JC5hamF4KHtcXG5cXHRcXHRcXHRcXHR0eXBlOiAnR0VUJyxcXG5cXHRcXHRcXHRcXHR1cmw6ICcvL3Z6YWFyLmNvbS9hcGkvdmlkZW9zLycgKyB2aWRlby5pZCArICcuanNvbicsXFxuXFx0XFx0XFx0XFx0anNvbnA6ICdjYWxsYmFjaycsXFxuXFx0XFx0XFx0XFx0ZGF0YVR5cGU6ICdqc29ucCcsXFxuXFx0XFx0XFx0XFx0c3VjY2VzczogZnVuY3Rpb24oZGF0YSkge1xcblxcdFxcdFxcdFxcdFxcdHBhdGggPSBkYXRhLmZyYW1lZ3JhYl91cmw7XFxuXFx0XFx0XFx0XFx0XFx0Y3JlYXRlKHBhdGgpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9KTtcXG5cXHRcXHR9XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBTdG9wcyB0aGUgY3VycmVudCB2aWRlby5cXG5cXHQgKiBAcHVibGljXFxuXFx0ICovXFxuXFx0VmlkZW8ucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbigpIHtcXG5cXHRcXHR0aGlzLl9jb3JlLnRyaWdnZXIoJ3N0b3AnLCBudWxsLCAndmlkZW8nKTtcXG5cXHRcXHR0aGlzLl9wbGF5aW5nLmZpbmQoJy5vd2wtdmlkZW8tZnJhbWUnKS5yZW1vdmUoKTtcXG5cXHRcXHR0aGlzLl9wbGF5aW5nLnJlbW92ZUNsYXNzKCdvd2wtdmlkZW8tcGxheWluZycpO1xcblxcdFxcdHRoaXMuX3BsYXlpbmcgPSBudWxsO1xcblxcdFxcdHRoaXMuX2NvcmUubGVhdmUoJ3BsYXlpbmcnKTtcXG5cXHRcXHR0aGlzLl9jb3JlLnRyaWdnZXIoJ3N0b3BwZWQnLCBudWxsLCAndmlkZW8nKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIFN0YXJ0cyB0aGUgY3VycmVudCB2aWRlby5cXG5cXHQgKiBAcHVibGljXFxuXFx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBUaGUgZXZlbnQgYXJndW1lbnRzLlxcblxcdCAqL1xcblxcdFZpZGVvLnByb3RvdHlwZS5wbGF5ID0gZnVuY3Rpb24oZXZlbnQpIHtcXG5cXHRcXHR2YXIgdGFyZ2V0ID0gJChldmVudC50YXJnZXQpLFxcblxcdFxcdFxcdGl0ZW0gPSB0YXJnZXQuY2xvc2VzdCgnLicgKyB0aGlzLl9jb3JlLnNldHRpbmdzLml0ZW1DbGFzcyksXFxuXFx0XFx0XFx0dmlkZW8gPSB0aGlzLl92aWRlb3NbaXRlbS5hdHRyKCdkYXRhLXZpZGVvJyldLFxcblxcdFxcdFxcdHdpZHRoID0gdmlkZW8ud2lkdGggfHwgJzEwMCUnLFxcblxcdFxcdFxcdGhlaWdodCA9IHZpZGVvLmhlaWdodCB8fCB0aGlzLl9jb3JlLiRzdGFnZS5oZWlnaHQoKSxcXG5cXHRcXHRcXHRodG1sO1xcblxcblxcdFxcdGlmICh0aGlzLl9wbGF5aW5nKSB7XFxuXFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdH1cXG5cXG5cXHRcXHR0aGlzLl9jb3JlLmVudGVyKCdwbGF5aW5nJyk7XFxuXFx0XFx0dGhpcy5fY29yZS50cmlnZ2VyKCdwbGF5JywgbnVsbCwgJ3ZpZGVvJyk7XFxuXFxuXFx0XFx0aXRlbSA9IHRoaXMuX2NvcmUuaXRlbXModGhpcy5fY29yZS5yZWxhdGl2ZShpdGVtLmluZGV4KCkpKTtcXG5cXG5cXHRcXHR0aGlzLl9jb3JlLnJlc2V0KGl0ZW0uaW5kZXgoKSk7XFxuXFxuXFx0XFx0aWYgKHZpZGVvLnR5cGUgPT09ICd5b3V0dWJlJykge1xcblxcdFxcdFxcdGh0bWwgPSAnPGlmcmFtZSB3aWR0aD1cXFwiJyArIHdpZHRoICsgJ1xcXCIgaGVpZ2h0PVxcXCInICsgaGVpZ2h0ICsgJ1xcXCIgc3JjPVxcXCIvL3d3dy55b3V0dWJlLmNvbS9lbWJlZC8nICtcXG5cXHRcXHRcXHRcXHR2aWRlby5pZCArICc/YXV0b3BsYXk9MSZ2PScgKyB2aWRlby5pZCArICdcXFwiIGZyYW1lYm9yZGVyPVxcXCIwXFxcIiBhbGxvd2Z1bGxzY3JlZW4+PC9pZnJhbWU+JztcXG5cXHRcXHR9IGVsc2UgaWYgKHZpZGVvLnR5cGUgPT09ICd2aW1lbycpIHtcXG5cXHRcXHRcXHRodG1sID0gJzxpZnJhbWUgc3JjPVxcXCIvL3BsYXllci52aW1lby5jb20vdmlkZW8vJyArIHZpZGVvLmlkICtcXG5cXHRcXHRcXHRcXHQnP2F1dG9wbGF5PTFcXFwiIHdpZHRoPVxcXCInICsgd2lkdGggKyAnXFxcIiBoZWlnaHQ9XFxcIicgKyBoZWlnaHQgK1xcblxcdFxcdFxcdFxcdCdcXFwiIGZyYW1lYm9yZGVyPVxcXCIwXFxcIiB3ZWJraXRhbGxvd2Z1bGxzY3JlZW4gbW96YWxsb3dmdWxsc2NyZWVuIGFsbG93ZnVsbHNjcmVlbj48L2lmcmFtZT4nO1xcblxcdFxcdH0gZWxzZSBpZiAodmlkZW8udHlwZSA9PT0gJ3Z6YWFyJykge1xcblxcdFxcdFxcdGh0bWwgPSAnPGlmcmFtZSBmcmFtZWJvcmRlcj1cXFwiMFxcXCInICsgJ2hlaWdodD1cXFwiJyArIGhlaWdodCArICdcXFwiJyArICd3aWR0aD1cXFwiJyArIHdpZHRoICtcXG5cXHRcXHRcXHRcXHQnXFxcIiBhbGxvd2Z1bGxzY3JlZW4gbW96YWxsb3dmdWxsc2NyZWVuIHdlYmtpdEFsbG93RnVsbFNjcmVlbiAnICtcXG5cXHRcXHRcXHRcXHQnc3JjPVxcXCIvL3ZpZXcudnphYXIuY29tLycgKyB2aWRlby5pZCArICcvcGxheWVyP2F1dG9wbGF5PXRydWVcXFwiPjwvaWZyYW1lPic7XFxuXFx0XFx0fVxcblxcblxcdFxcdCQoJzxkaXYgY2xhc3M9XFxcIm93bC12aWRlby1mcmFtZVxcXCI+JyArIGh0bWwgKyAnPC9kaXY+JykuaW5zZXJ0QWZ0ZXIoaXRlbS5maW5kKCcub3dsLXZpZGVvJykpO1xcblxcblxcdFxcdHRoaXMuX3BsYXlpbmcgPSBpdGVtLmFkZENsYXNzKCdvd2wtdmlkZW8tcGxheWluZycpO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogQ2hlY2tzIHdoZXRoZXIgYW4gdmlkZW8gaXMgY3VycmVudGx5IGluIGZ1bGwgc2NyZWVuIG1vZGUgb3Igbm90LlxcblxcdCAqIEB0b2RvIEJhZCBzdHlsZSBiZWNhdXNlIGxvb2tzIGxpa2UgYSByZWFkb25seSBtZXRob2QgYnV0IGNoYW5nZXMgbWVtYmVycy5cXG5cXHQgKiBAcHJvdGVjdGVkXFxuXFx0ICogQHJldHVybnMge0Jvb2xlYW59XFxuXFx0ICovXFxuXFx0VmlkZW8ucHJvdG90eXBlLmlzSW5GdWxsU2NyZWVuID0gZnVuY3Rpb24oKSB7XFxuXFx0XFx0dmFyIGVsZW1lbnQgPSBkb2N1bWVudC5mdWxsc2NyZWVuRWxlbWVudCB8fCBkb2N1bWVudC5tb3pGdWxsU2NyZWVuRWxlbWVudCB8fFxcblxcdFxcdFxcdFxcdGRvY3VtZW50LndlYmtpdEZ1bGxzY3JlZW5FbGVtZW50O1xcblxcblxcdFxcdHJldHVybiBlbGVtZW50ICYmICQoZWxlbWVudCkucGFyZW50KCkuaGFzQ2xhc3MoJ293bC12aWRlby1mcmFtZScpO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogRGVzdHJveXMgdGhlIHBsdWdpbi5cXG5cXHQgKi9cXG5cXHRWaWRlby5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xcblxcdFxcdHZhciBoYW5kbGVyLCBwcm9wZXJ0eTtcXG5cXG5cXHRcXHR0aGlzLl9jb3JlLiRlbGVtZW50Lm9mZignY2xpY2sub3dsLnZpZGVvJyk7XFxuXFxuXFx0XFx0Zm9yIChoYW5kbGVyIGluIHRoaXMuX2hhbmRsZXJzKSB7XFxuXFx0XFx0XFx0dGhpcy5fY29yZS4kZWxlbWVudC5vZmYoaGFuZGxlciwgdGhpcy5faGFuZGxlcnNbaGFuZGxlcl0pO1xcblxcdFxcdH1cXG5cXHRcXHRmb3IgKHByb3BlcnR5IGluIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMpKSB7XFxuXFx0XFx0XFx0dHlwZW9mIHRoaXNbcHJvcGVydHldICE9ICdmdW5jdGlvbicgJiYgKHRoaXNbcHJvcGVydHldID0gbnVsbCk7XFxuXFx0XFx0fVxcblxcdH07XFxuXFxuXFx0JC5mbi5vd2xDYXJvdXNlbC5Db25zdHJ1Y3Rvci5QbHVnaW5zLlZpZGVvID0gVmlkZW87XFxuXFxufSkod2luZG93LlplcHRvIHx8IF9fd2VicGFja19wcm92aWRlZF93aW5kb3dfZG90X2pRdWVyeSwgd2luZG93LCBkb2N1bWVudCk7XFxuXFxuLyoqXFxuICogQW5pbWF0ZSBQbHVnaW5cXG4gKiBAdmVyc2lvbiAyLjEuMFxcbiAqIEBhdXRob3IgQmFydG9zeiBXb2pjaWVjaG93c2tpXFxuICogQGF1dGhvciBEYXZpZCBEZXV0c2NoXFxuICogQGxpY2Vuc2UgVGhlIE1JVCBMaWNlbnNlIChNSVQpXFxuICovXFxuOyhmdW5jdGlvbigkLCB3aW5kb3csIGRvY3VtZW50LCB1bmRlZmluZWQpIHtcXG5cXG5cXHQvKipcXG5cXHQgKiBDcmVhdGVzIHRoZSBhbmltYXRlIHBsdWdpbi5cXG5cXHQgKiBAY2xhc3MgVGhlIE5hdmlnYXRpb24gUGx1Z2luXFxuXFx0ICogQHBhcmFtIHtPd2x9IHNjb3BlIC0gVGhlIE93bCBDYXJvdXNlbFxcblxcdCAqL1xcblxcdHZhciBBbmltYXRlID0gZnVuY3Rpb24oc2NvcGUpIHtcXG5cXHRcXHR0aGlzLmNvcmUgPSBzY29wZTtcXG5cXHRcXHR0aGlzLmNvcmUub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBBbmltYXRlLkRlZmF1bHRzLCB0aGlzLmNvcmUub3B0aW9ucyk7XFxuXFx0XFx0dGhpcy5zd2FwcGluZyA9IHRydWU7XFxuXFx0XFx0dGhpcy5wcmV2aW91cyA9IHVuZGVmaW5lZDtcXG5cXHRcXHR0aGlzLm5leHQgPSB1bmRlZmluZWQ7XFxuXFxuXFx0XFx0dGhpcy5oYW5kbGVycyA9IHtcXG5cXHRcXHRcXHQnY2hhbmdlLm93bC5jYXJvdXNlbCc6ICQucHJveHkoZnVuY3Rpb24oZSkge1xcblxcdFxcdFxcdFxcdGlmIChlLm5hbWVzcGFjZSAmJiBlLnByb3BlcnR5Lm5hbWUgPT0gJ3Bvc2l0aW9uJykge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMucHJldmlvdXMgPSB0aGlzLmNvcmUuY3VycmVudCgpO1xcblxcdFxcdFxcdFxcdFxcdHRoaXMubmV4dCA9IGUucHJvcGVydHkudmFsdWU7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sIHRoaXMpLFxcblxcdFxcdFxcdCdkcmFnLm93bC5jYXJvdXNlbCBkcmFnZ2VkLm93bC5jYXJvdXNlbCB0cmFuc2xhdGVkLm93bC5jYXJvdXNlbCc6ICQucHJveHkoZnVuY3Rpb24oZSkge1xcblxcdFxcdFxcdFxcdGlmIChlLm5hbWVzcGFjZSkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuc3dhcHBpbmcgPSBlLnR5cGUgPT0gJ3RyYW5zbGF0ZWQnO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LCB0aGlzKSxcXG5cXHRcXHRcXHQndHJhbnNsYXRlLm93bC5jYXJvdXNlbCc6ICQucHJveHkoZnVuY3Rpb24oZSkge1xcblxcdFxcdFxcdFxcdGlmIChlLm5hbWVzcGFjZSAmJiB0aGlzLnN3YXBwaW5nICYmICh0aGlzLmNvcmUub3B0aW9ucy5hbmltYXRlT3V0IHx8IHRoaXMuY29yZS5vcHRpb25zLmFuaW1hdGVJbikpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnN3YXAoKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSwgdGhpcylcXG5cXHRcXHR9O1xcblxcblxcdFxcdHRoaXMuY29yZS4kZWxlbWVudC5vbih0aGlzLmhhbmRsZXJzKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIERlZmF1bHQgb3B0aW9ucy5cXG5cXHQgKiBAcHVibGljXFxuXFx0ICovXFxuXFx0QW5pbWF0ZS5EZWZhdWx0cyA9IHtcXG5cXHRcXHRhbmltYXRlT3V0OiBmYWxzZSxcXG5cXHRcXHRhbmltYXRlSW46IGZhbHNlXFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBUb2dnbGVzIHRoZSBhbmltYXRpb24gY2xhc3NlcyB3aGVuZXZlciBhbiB0cmFuc2xhdGlvbnMgc3RhcnRzLlxcblxcdCAqIEBwcm90ZWN0ZWRcXG5cXHQgKiBAcmV0dXJucyB7Qm9vbGVhbnx1bmRlZmluZWR9XFxuXFx0ICovXFxuXFx0QW5pbWF0ZS5wcm90b3R5cGUuc3dhcCA9IGZ1bmN0aW9uKCkge1xcblxcblxcdFxcdGlmICh0aGlzLmNvcmUuc2V0dGluZ3MuaXRlbXMgIT09IDEpIHtcXG5cXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICghJC5zdXBwb3J0LmFuaW1hdGlvbiB8fCAhJC5zdXBwb3J0LnRyYW5zaXRpb24pIHtcXG5cXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0fVxcblxcblxcdFxcdHRoaXMuY29yZS5zcGVlZCgwKTtcXG5cXG5cXHRcXHR2YXIgbGVmdCxcXG5cXHRcXHRcXHRjbGVhciA9ICQucHJveHkodGhpcy5jbGVhciwgdGhpcyksXFxuXFx0XFx0XFx0cHJldmlvdXMgPSB0aGlzLmNvcmUuJHN0YWdlLmNoaWxkcmVuKCkuZXEodGhpcy5wcmV2aW91cyksXFxuXFx0XFx0XFx0bmV4dCA9IHRoaXMuY29yZS4kc3RhZ2UuY2hpbGRyZW4oKS5lcSh0aGlzLm5leHQpLFxcblxcdFxcdFxcdGluY29taW5nID0gdGhpcy5jb3JlLnNldHRpbmdzLmFuaW1hdGVJbixcXG5cXHRcXHRcXHRvdXRnb2luZyA9IHRoaXMuY29yZS5zZXR0aW5ncy5hbmltYXRlT3V0O1xcblxcblxcdFxcdGlmICh0aGlzLmNvcmUuY3VycmVudCgpID09PSB0aGlzLnByZXZpb3VzKSB7XFxuXFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAob3V0Z29pbmcpIHtcXG5cXHRcXHRcXHRsZWZ0ID0gdGhpcy5jb3JlLmNvb3JkaW5hdGVzKHRoaXMucHJldmlvdXMpIC0gdGhpcy5jb3JlLmNvb3JkaW5hdGVzKHRoaXMubmV4dCk7XFxuXFx0XFx0XFx0cHJldmlvdXMub25lKCQuc3VwcG9ydC5hbmltYXRpb24uZW5kLCBjbGVhcilcXG5cXHRcXHRcXHRcXHQuY3NzKCB7ICdsZWZ0JzogbGVmdCArICdweCcgfSApXFxuXFx0XFx0XFx0XFx0LmFkZENsYXNzKCdhbmltYXRlZCBvd2wtYW5pbWF0ZWQtb3V0JylcXG5cXHRcXHRcXHRcXHQuYWRkQ2xhc3Mob3V0Z29pbmcpO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAoaW5jb21pbmcpIHtcXG5cXHRcXHRcXHRuZXh0Lm9uZSgkLnN1cHBvcnQuYW5pbWF0aW9uLmVuZCwgY2xlYXIpXFxuXFx0XFx0XFx0XFx0LmFkZENsYXNzKCdhbmltYXRlZCBvd2wtYW5pbWF0ZWQtaW4nKVxcblxcdFxcdFxcdFxcdC5hZGRDbGFzcyhpbmNvbWluZyk7XFxuXFx0XFx0fVxcblxcdH07XFxuXFxuXFx0QW5pbWF0ZS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbihlKSB7XFxuXFx0XFx0JChlLnRhcmdldCkuY3NzKCB7ICdsZWZ0JzogJycgfSApXFxuXFx0XFx0XFx0LnJlbW92ZUNsYXNzKCdhbmltYXRlZCBvd2wtYW5pbWF0ZWQtb3V0IG93bC1hbmltYXRlZC1pbicpXFxuXFx0XFx0XFx0LnJlbW92ZUNsYXNzKHRoaXMuY29yZS5zZXR0aW5ncy5hbmltYXRlSW4pXFxuXFx0XFx0XFx0LnJlbW92ZUNsYXNzKHRoaXMuY29yZS5zZXR0aW5ncy5hbmltYXRlT3V0KTtcXG5cXHRcXHR0aGlzLmNvcmUub25UcmFuc2l0aW9uRW5kKCk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBEZXN0cm95cyB0aGUgcGx1Z2luLlxcblxcdCAqIEBwdWJsaWNcXG5cXHQgKi9cXG5cXHRBbmltYXRlLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XFxuXFx0XFx0dmFyIGhhbmRsZXIsIHByb3BlcnR5O1xcblxcblxcdFxcdGZvciAoaGFuZGxlciBpbiB0aGlzLmhhbmRsZXJzKSB7XFxuXFx0XFx0XFx0dGhpcy5jb3JlLiRlbGVtZW50Lm9mZihoYW5kbGVyLCB0aGlzLmhhbmRsZXJzW2hhbmRsZXJdKTtcXG5cXHRcXHR9XFxuXFx0XFx0Zm9yIChwcm9wZXJ0eSBpbiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzKSkge1xcblxcdFxcdFxcdHR5cGVvZiB0aGlzW3Byb3BlcnR5XSAhPSAnZnVuY3Rpb24nICYmICh0aGlzW3Byb3BlcnR5XSA9IG51bGwpO1xcblxcdFxcdH1cXG5cXHR9O1xcblxcblxcdCQuZm4ub3dsQ2Fyb3VzZWwuQ29uc3RydWN0b3IuUGx1Z2lucy5BbmltYXRlID0gQW5pbWF0ZTtcXG5cXG59KSh3aW5kb3cuWmVwdG8gfHwgX193ZWJwYWNrX3Byb3ZpZGVkX3dpbmRvd19kb3RfalF1ZXJ5LCB3aW5kb3csIGRvY3VtZW50KTtcXG5cXG4vKipcXG4gKiBBdXRvcGxheSBQbHVnaW5cXG4gKiBAdmVyc2lvbiAyLjEuMFxcbiAqIEBhdXRob3IgQmFydG9zeiBXb2pjaWVjaG93c2tpXFxuICogQGF1dGhvciBBcnR1cyBLb2xhbm93c2tpXFxuICogQGF1dGhvciBEYXZpZCBEZXV0c2NoXFxuICogQGxpY2Vuc2UgVGhlIE1JVCBMaWNlbnNlIChNSVQpXFxuICovXFxuOyhmdW5jdGlvbigkLCB3aW5kb3csIGRvY3VtZW50LCB1bmRlZmluZWQpIHtcXG5cXG5cXHQvKipcXG5cXHQgKiBDcmVhdGVzIHRoZSBhdXRvcGxheSBwbHVnaW4uXFxuXFx0ICogQGNsYXNzIFRoZSBBdXRvcGxheSBQbHVnaW5cXG5cXHQgKiBAcGFyYW0ge093bH0gc2NvcGUgLSBUaGUgT3dsIENhcm91c2VsXFxuXFx0ICovXFxuXFx0dmFyIEF1dG9wbGF5ID0gZnVuY3Rpb24oY2Fyb3VzZWwpIHtcXG5cXHRcXHQvKipcXG5cXHRcXHQgKiBSZWZlcmVuY2UgdG8gdGhlIGNvcmUuXFxuXFx0XFx0ICogQHByb3RlY3RlZFxcblxcdFxcdCAqIEB0eXBlIHtPd2x9XFxuXFx0XFx0ICovXFxuXFx0XFx0dGhpcy5fY29yZSA9IGNhcm91c2VsO1xcblxcblxcdFxcdC8qKlxcblxcdFxcdCAqIFRoZSBhdXRvcGxheSB0aW1lb3V0LlxcblxcdFxcdCAqIEB0eXBlIHtUaW1lb3V0fVxcblxcdFxcdCAqL1xcblxcdFxcdHRoaXMuX3RpbWVvdXQgPSBudWxsO1xcblxcblxcdFxcdC8qKlxcblxcdFxcdCAqIEluZGljYXRlcyB3aGVuZXZlciB0aGUgYXV0b3BsYXkgaXMgcGF1c2VkLlxcblxcdFxcdCAqIEB0eXBlIHtCb29sZWFufVxcblxcdFxcdCAqL1xcblxcdFxcdHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xcblxcblxcdFxcdC8qKlxcblxcdFxcdCAqIEFsbCBldmVudCBoYW5kbGVycy5cXG5cXHRcXHQgKiBAcHJvdGVjdGVkXFxuXFx0XFx0ICogQHR5cGUge09iamVjdH1cXG5cXHRcXHQgKi9cXG5cXHRcXHR0aGlzLl9oYW5kbGVycyA9IHtcXG5cXHRcXHRcXHQnY2hhbmdlZC5vd2wuY2Fyb3VzZWwnOiAkLnByb3h5KGZ1bmN0aW9uKGUpIHtcXG5cXHRcXHRcXHRcXHRpZiAoZS5uYW1lc3BhY2UgJiYgZS5wcm9wZXJ0eS5uYW1lID09PSAnc2V0dGluZ3MnKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHRoaXMuX2NvcmUuc2V0dGluZ3MuYXV0b3BsYXkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLnBsYXkoKTtcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuc3RvcCgpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKGUubmFtZXNwYWNlICYmIGUucHJvcGVydHkubmFtZSA9PT0gJ3Bvc2l0aW9uJykge1xcblxcdFxcdFxcdFxcdFxcdC8vY29uc29sZS5sb2coJ3BsYXk/JywgZSk7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHRoaXMuX2NvcmUuc2V0dGluZ3MuYXV0b3BsYXkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLl9zZXRBdXRvUGxheUludGVydmFsKCk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LCB0aGlzKSxcXG5cXHRcXHRcXHQnaW5pdGlhbGl6ZWQub3dsLmNhcm91c2VsJzogJC5wcm94eShmdW5jdGlvbihlKSB7XFxuXFx0XFx0XFx0XFx0aWYgKGUubmFtZXNwYWNlICYmIHRoaXMuX2NvcmUuc2V0dGluZ3MuYXV0b3BsYXkpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnBsYXkoKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSwgdGhpcyksXFxuXFx0XFx0XFx0J3BsYXkub3dsLmF1dG9wbGF5JzogJC5wcm94eShmdW5jdGlvbihlLCB0LCBzKSB7XFxuXFx0XFx0XFx0XFx0aWYgKGUubmFtZXNwYWNlKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5wbGF5KHQsIHMpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LCB0aGlzKSxcXG5cXHRcXHRcXHQnc3RvcC5vd2wuYXV0b3BsYXknOiAkLnByb3h5KGZ1bmN0aW9uKGUpIHtcXG5cXHRcXHRcXHRcXHRpZiAoZS5uYW1lc3BhY2UpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnN0b3AoKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSwgdGhpcyksXFxuXFx0XFx0XFx0J21vdXNlb3Zlci5vd2wuYXV0b3BsYXknOiAkLnByb3h5KGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdGlmICh0aGlzLl9jb3JlLnNldHRpbmdzLmF1dG9wbGF5SG92ZXJQYXVzZSAmJiB0aGlzLl9jb3JlLmlzKCdyb3RhdGluZycpKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5wYXVzZSgpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LCB0aGlzKSxcXG5cXHRcXHRcXHQnbW91c2VsZWF2ZS5vd2wuYXV0b3BsYXknOiAkLnByb3h5KGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdGlmICh0aGlzLl9jb3JlLnNldHRpbmdzLmF1dG9wbGF5SG92ZXJQYXVzZSAmJiB0aGlzLl9jb3JlLmlzKCdyb3RhdGluZycpKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5wbGF5KCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sIHRoaXMpLFxcblxcdFxcdFxcdCd0b3VjaHN0YXJ0Lm93bC5jb3JlJzogJC5wcm94eShmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRpZiAodGhpcy5fY29yZS5zZXR0aW5ncy5hdXRvcGxheUhvdmVyUGF1c2UgJiYgdGhpcy5fY29yZS5pcygncm90YXRpbmcnKSkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMucGF1c2UoKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSwgdGhpcyksXFxuXFx0XFx0XFx0J3RvdWNoZW5kLm93bC5jb3JlJzogJC5wcm94eShmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRpZiAodGhpcy5fY29yZS5zZXR0aW5ncy5hdXRvcGxheUhvdmVyUGF1c2UpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnBsYXkoKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSwgdGhpcylcXG5cXHRcXHR9O1xcblxcblxcdFxcdC8vIHJlZ2lzdGVyIGV2ZW50IGhhbmRsZXJzXFxuXFx0XFx0dGhpcy5fY29yZS4kZWxlbWVudC5vbih0aGlzLl9oYW5kbGVycyk7XFxuXFxuXFx0XFx0Ly8gc2V0IGRlZmF1bHQgb3B0aW9uc1xcblxcdFxcdHRoaXMuX2NvcmUub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBBdXRvcGxheS5EZWZhdWx0cywgdGhpcy5fY29yZS5vcHRpb25zKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIERlZmF1bHQgb3B0aW9ucy5cXG5cXHQgKiBAcHVibGljXFxuXFx0ICovXFxuXFx0QXV0b3BsYXkuRGVmYXVsdHMgPSB7XFxuXFx0XFx0YXV0b3BsYXk6IGZhbHNlLFxcblxcdFxcdGF1dG9wbGF5VGltZW91dDogNTAwMCxcXG5cXHRcXHRhdXRvcGxheUhvdmVyUGF1c2U6IGZhbHNlLFxcblxcdFxcdGF1dG9wbGF5U3BlZWQ6IGZhbHNlXFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBTdGFydHMgdGhlIGF1dG9wbGF5LlxcblxcdCAqIEBwdWJsaWNcXG5cXHQgKiBAcGFyYW0ge051bWJlcn0gW3RpbWVvdXRdIC0gVGhlIGludGVydmFsIGJlZm9yZSB0aGUgbmV4dCBhbmltYXRpb24gc3RhcnRzLlxcblxcdCAqIEBwYXJhbSB7TnVtYmVyfSBbc3BlZWRdIC0gVGhlIGFuaW1hdGlvbiBzcGVlZCBmb3IgdGhlIGFuaW1hdGlvbnMuXFxuXFx0ICovXFxuXFx0QXV0b3BsYXkucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbih0aW1lb3V0LCBzcGVlZCkge1xcblxcdFxcdHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xcblxcblxcdFxcdGlmICh0aGlzLl9jb3JlLmlzKCdyb3RhdGluZycpKSB7XFxuXFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdH1cXG5cXG5cXHRcXHR0aGlzLl9jb3JlLmVudGVyKCdyb3RhdGluZycpO1xcblxcblxcdFxcdHRoaXMuX3NldEF1dG9QbGF5SW50ZXJ2YWwoKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEdldHMgYSBuZXcgdGltZW91dFxcblxcdCAqIEBwcml2YXRlXFxuXFx0ICogQHBhcmFtIHtOdW1iZXJ9IFt0aW1lb3V0XSAtIFRoZSBpbnRlcnZhbCBiZWZvcmUgdGhlIG5leHQgYW5pbWF0aW9uIHN0YXJ0cy5cXG5cXHQgKiBAcGFyYW0ge051bWJlcn0gW3NwZWVkXSAtIFRoZSBhbmltYXRpb24gc3BlZWQgZm9yIHRoZSBhbmltYXRpb25zLlxcblxcdCAqIEByZXR1cm4ge1RpbWVvdXR9XFxuXFx0ICovXFxuXFx0QXV0b3BsYXkucHJvdG90eXBlLl9nZXROZXh0VGltZW91dCA9IGZ1bmN0aW9uKHRpbWVvdXQsIHNwZWVkKSB7XFxuXFx0XFx0aWYgKCB0aGlzLl90aW1lb3V0ICkge1xcblxcdFxcdFxcdHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5fdGltZW91dCk7XFxuXFx0XFx0fVxcblxcdFxcdHJldHVybiB3aW5kb3cuc2V0VGltZW91dCgkLnByb3h5KGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdGlmICh0aGlzLl9wYXVzZWQgfHwgdGhpcy5fY29yZS5pcygnYnVzeScpIHx8IHRoaXMuX2NvcmUuaXMoJ2ludGVyYWN0aW5nJykgfHwgZG9jdW1lbnQuaGlkZGVuKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHR0aGlzLl9jb3JlLm5leHQoc3BlZWQgfHwgdGhpcy5fY29yZS5zZXR0aW5ncy5hdXRvcGxheVNwZWVkKTtcXG5cXHRcXHR9LCB0aGlzKSwgdGltZW91dCB8fCB0aGlzLl9jb3JlLnNldHRpbmdzLmF1dG9wbGF5VGltZW91dCk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBTZXRzIGF1dG9wbGF5IGluIG1vdGlvbi5cXG5cXHQgKiBAcHJpdmF0ZVxcblxcdCAqL1xcblxcdEF1dG9wbGF5LnByb3RvdHlwZS5fc2V0QXV0b1BsYXlJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xcblxcdFxcdHRoaXMuX3RpbWVvdXQgPSB0aGlzLl9nZXROZXh0VGltZW91dCgpO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogU3RvcHMgdGhlIGF1dG9wbGF5LlxcblxcdCAqIEBwdWJsaWNcXG5cXHQgKi9cXG5cXHRBdXRvcGxheS5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKCkge1xcblxcdFxcdGlmICghdGhpcy5fY29yZS5pcygncm90YXRpbmcnKSkge1xcblxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0d2luZG93LmNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0KTtcXG5cXHRcXHR0aGlzLl9jb3JlLmxlYXZlKCdyb3RhdGluZycpO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogU3RvcHMgdGhlIGF1dG9wbGF5LlxcblxcdCAqIEBwdWJsaWNcXG5cXHQgKi9cXG5cXHRBdXRvcGxheS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbigpIHtcXG5cXHRcXHRpZiAoIXRoaXMuX2NvcmUuaXMoJ3JvdGF0aW5nJykpIHtcXG5cXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0fVxcblxcblxcdFxcdHRoaXMuX3BhdXNlZCA9IHRydWU7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBEZXN0cm95cyB0aGUgcGx1Z2luLlxcblxcdCAqL1xcblxcdEF1dG9wbGF5LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XFxuXFx0XFx0dmFyIGhhbmRsZXIsIHByb3BlcnR5O1xcblxcblxcdFxcdHRoaXMuc3RvcCgpO1xcblxcblxcdFxcdGZvciAoaGFuZGxlciBpbiB0aGlzLl9oYW5kbGVycykge1xcblxcdFxcdFxcdHRoaXMuX2NvcmUuJGVsZW1lbnQub2ZmKGhhbmRsZXIsIHRoaXMuX2hhbmRsZXJzW2hhbmRsZXJdKTtcXG5cXHRcXHR9XFxuXFx0XFx0Zm9yIChwcm9wZXJ0eSBpbiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzKSkge1xcblxcdFxcdFxcdHR5cGVvZiB0aGlzW3Byb3BlcnR5XSAhPSAnZnVuY3Rpb24nICYmICh0aGlzW3Byb3BlcnR5XSA9IG51bGwpO1xcblxcdFxcdH1cXG5cXHR9O1xcblxcblxcdCQuZm4ub3dsQ2Fyb3VzZWwuQ29uc3RydWN0b3IuUGx1Z2lucy5hdXRvcGxheSA9IEF1dG9wbGF5O1xcblxcbn0pKHdpbmRvdy5aZXB0byB8fCBfX3dlYnBhY2tfcHJvdmlkZWRfd2luZG93X2RvdF9qUXVlcnksIHdpbmRvdywgZG9jdW1lbnQpO1xcblxcbi8qKlxcbiAqIE5hdmlnYXRpb24gUGx1Z2luXFxuICogQHZlcnNpb24gMi4xLjBcXG4gKiBAYXV0aG9yIEFydHVzIEtvbGFub3dza2lcXG4gKiBAYXV0aG9yIERhdmlkIERldXRzY2hcXG4gKiBAbGljZW5zZSBUaGUgTUlUIExpY2Vuc2UgKE1JVClcXG4gKi9cXG47KGZ1bmN0aW9uKCQsIHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCkge1xcblxcdCd1c2Ugc3RyaWN0JztcXG5cXG5cXHQvKipcXG5cXHQgKiBDcmVhdGVzIHRoZSBuYXZpZ2F0aW9uIHBsdWdpbi5cXG5cXHQgKiBAY2xhc3MgVGhlIE5hdmlnYXRpb24gUGx1Z2luXFxuXFx0ICogQHBhcmFtIHtPd2x9IGNhcm91c2VsIC0gVGhlIE93bCBDYXJvdXNlbC5cXG5cXHQgKi9cXG5cXHR2YXIgTmF2aWdhdGlvbiA9IGZ1bmN0aW9uKGNhcm91c2VsKSB7XFxuXFx0XFx0LyoqXFxuXFx0XFx0ICogUmVmZXJlbmNlIHRvIHRoZSBjb3JlLlxcblxcdFxcdCAqIEBwcm90ZWN0ZWRcXG5cXHRcXHQgKiBAdHlwZSB7T3dsfVxcblxcdFxcdCAqL1xcblxcdFxcdHRoaXMuX2NvcmUgPSBjYXJvdXNlbDtcXG5cXG5cXHRcXHQvKipcXG5cXHRcXHQgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgcGx1Z2luIGlzIGluaXRpYWxpemVkIG9yIG5vdC5cXG5cXHRcXHQgKiBAcHJvdGVjdGVkXFxuXFx0XFx0ICogQHR5cGUge0Jvb2xlYW59XFxuXFx0XFx0ICovXFxuXFx0XFx0dGhpcy5faW5pdGlhbGl6ZWQgPSBmYWxzZTtcXG5cXG5cXHRcXHQvKipcXG5cXHRcXHQgKiBUaGUgY3VycmVudCBwYWdpbmcgaW5kZXhlcy5cXG5cXHRcXHQgKiBAcHJvdGVjdGVkXFxuXFx0XFx0ICogQHR5cGUge0FycmF5fVxcblxcdFxcdCAqL1xcblxcdFxcdHRoaXMuX3BhZ2VzID0gW107XFxuXFxuXFx0XFx0LyoqXFxuXFx0XFx0ICogQWxsIERPTSBlbGVtZW50cyBvZiB0aGUgdXNlciBpbnRlcmZhY2UuXFxuXFx0XFx0ICogQHByb3RlY3RlZFxcblxcdFxcdCAqIEB0eXBlIHtPYmplY3R9XFxuXFx0XFx0ICovXFxuXFx0XFx0dGhpcy5fY29udHJvbHMgPSB7fTtcXG5cXG5cXHRcXHQvKipcXG5cXHRcXHQgKiBNYXJrdXAgZm9yIGFuIGluZGljYXRvci5cXG5cXHRcXHQgKiBAcHJvdGVjdGVkXFxuXFx0XFx0ICogQHR5cGUge0FycmF5LjxTdHJpbmc+fVxcblxcdFxcdCAqL1xcblxcdFxcdHRoaXMuX3RlbXBsYXRlcyA9IFtdO1xcblxcblxcdFxcdC8qKlxcblxcdFxcdCAqIFRoZSBjYXJvdXNlbCBlbGVtZW50LlxcblxcdFxcdCAqIEB0eXBlIHtqUXVlcnl9XFxuXFx0XFx0ICovXFxuXFx0XFx0dGhpcy4kZWxlbWVudCA9IHRoaXMuX2NvcmUuJGVsZW1lbnQ7XFxuXFxuXFx0XFx0LyoqXFxuXFx0XFx0ICogT3ZlcnJpZGRlbiBtZXRob2RzIG9mIHRoZSBjYXJvdXNlbC5cXG5cXHRcXHQgKiBAcHJvdGVjdGVkXFxuXFx0XFx0ICogQHR5cGUge09iamVjdH1cXG5cXHRcXHQgKi9cXG5cXHRcXHR0aGlzLl9vdmVycmlkZXMgPSB7XFxuXFx0XFx0XFx0bmV4dDogdGhpcy5fY29yZS5uZXh0LFxcblxcdFxcdFxcdHByZXY6IHRoaXMuX2NvcmUucHJldixcXG5cXHRcXHRcXHR0bzogdGhpcy5fY29yZS50b1xcblxcdFxcdH07XFxuXFxuXFx0XFx0LyoqXFxuXFx0XFx0ICogQWxsIGV2ZW50IGhhbmRsZXJzLlxcblxcdFxcdCAqIEBwcm90ZWN0ZWRcXG5cXHRcXHQgKiBAdHlwZSB7T2JqZWN0fVxcblxcdFxcdCAqL1xcblxcdFxcdHRoaXMuX2hhbmRsZXJzID0ge1xcblxcdFxcdFxcdCdwcmVwYXJlZC5vd2wuY2Fyb3VzZWwnOiAkLnByb3h5KGZ1bmN0aW9uKGUpIHtcXG5cXHRcXHRcXHRcXHRpZiAoZS5uYW1lc3BhY2UgJiYgdGhpcy5fY29yZS5zZXR0aW5ncy5kb3RzRGF0YSkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuX3RlbXBsYXRlcy5wdXNoKCc8ZGl2IGNsYXNzPVxcXCInICsgdGhpcy5fY29yZS5zZXR0aW5ncy5kb3RDbGFzcyArICdcXFwiPicgK1xcblxcdFxcdFxcdFxcdFxcdFxcdCQoZS5jb250ZW50KS5maW5kKCdbZGF0YS1kb3RdJykuYWRkQmFjaygnW2RhdGEtZG90XScpLmF0dHIoJ2RhdGEtZG90JykgKyAnPC9kaXY+Jyk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sIHRoaXMpLFxcblxcdFxcdFxcdCdhZGRlZC5vd2wuY2Fyb3VzZWwnOiAkLnByb3h5KGZ1bmN0aW9uKGUpIHtcXG5cXHRcXHRcXHRcXHRpZiAoZS5uYW1lc3BhY2UgJiYgdGhpcy5fY29yZS5zZXR0aW5ncy5kb3RzRGF0YSkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuX3RlbXBsYXRlcy5zcGxpY2UoZS5wb3NpdGlvbiwgMCwgdGhpcy5fdGVtcGxhdGVzLnBvcCgpKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSwgdGhpcyksXFxuXFx0XFx0XFx0J3JlbW92ZS5vd2wuY2Fyb3VzZWwnOiAkLnByb3h5KGZ1bmN0aW9uKGUpIHtcXG5cXHRcXHRcXHRcXHRpZiAoZS5uYW1lc3BhY2UgJiYgdGhpcy5fY29yZS5zZXR0aW5ncy5kb3RzRGF0YSkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuX3RlbXBsYXRlcy5zcGxpY2UoZS5wb3NpdGlvbiwgMSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sIHRoaXMpLFxcblxcdFxcdFxcdCdjaGFuZ2VkLm93bC5jYXJvdXNlbCc6ICQucHJveHkoZnVuY3Rpb24oZSkge1xcblxcdFxcdFxcdFxcdGlmIChlLm5hbWVzcGFjZSAmJiBlLnByb3BlcnR5Lm5hbWUgPT0gJ3Bvc2l0aW9uJykge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuZHJhdygpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LCB0aGlzKSxcXG5cXHRcXHRcXHQnaW5pdGlhbGl6ZWQub3dsLmNhcm91c2VsJzogJC5wcm94eShmdW5jdGlvbihlKSB7XFxuXFx0XFx0XFx0XFx0aWYgKGUubmFtZXNwYWNlICYmICF0aGlzLl9pbml0aWFsaXplZCkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuX2NvcmUudHJpZ2dlcignaW5pdGlhbGl6ZScsIG51bGwsICduYXZpZ2F0aW9uJyk7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5pbml0aWFsaXplKCk7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy51cGRhdGUoKTtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmRyYXcoKTtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl9pbml0aWFsaXplZCA9IHRydWU7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fY29yZS50cmlnZ2VyKCdpbml0aWFsaXplZCcsIG51bGwsICduYXZpZ2F0aW9uJyk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sIHRoaXMpLFxcblxcdFxcdFxcdCdyZWZyZXNoZWQub3dsLmNhcm91c2VsJzogJC5wcm94eShmdW5jdGlvbihlKSB7XFxuXFx0XFx0XFx0XFx0aWYgKGUubmFtZXNwYWNlICYmIHRoaXMuX2luaXRpYWxpemVkKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fY29yZS50cmlnZ2VyKCdyZWZyZXNoJywgbnVsbCwgJ25hdmlnYXRpb24nKTtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnVwZGF0ZSgpO1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuZHJhdygpO1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuX2NvcmUudHJpZ2dlcigncmVmcmVzaGVkJywgbnVsbCwgJ25hdmlnYXRpb24nKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSwgdGhpcylcXG5cXHRcXHR9O1xcblxcblxcdFxcdC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcXG5cXHRcXHR0aGlzLl9jb3JlLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgTmF2aWdhdGlvbi5EZWZhdWx0cywgdGhpcy5fY29yZS5vcHRpb25zKTtcXG5cXG5cXHRcXHQvLyByZWdpc3RlciBldmVudCBoYW5kbGVyc1xcblxcdFxcdHRoaXMuJGVsZW1lbnQub24odGhpcy5faGFuZGxlcnMpO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogRGVmYXVsdCBvcHRpb25zLlxcblxcdCAqIEBwdWJsaWNcXG5cXHQgKiBAdG9kbyBSZW5hbWUgYHNsaWRlQnlgIHRvIGBuYXZCeWBcXG5cXHQgKi9cXG5cXHROYXZpZ2F0aW9uLkRlZmF1bHRzID0ge1xcblxcdFxcdG5hdjogZmFsc2UsXFxuXFx0XFx0bmF2VGV4dDogWyAncHJldicsICduZXh0JyBdLFxcblxcdFxcdG5hdlNwZWVkOiBmYWxzZSxcXG5cXHRcXHRuYXZFbGVtZW50OiAnZGl2JyxcXG5cXHRcXHRuYXZDb250YWluZXI6IGZhbHNlLFxcblxcdFxcdG5hdkNvbnRhaW5lckNsYXNzOiAnb3dsLW5hdicsXFxuXFx0XFx0bmF2Q2xhc3M6IFsgJ293bC1wcmV2JywgJ293bC1uZXh0JyBdLFxcblxcdFxcdHNsaWRlQnk6IDEsXFxuXFx0XFx0ZG90Q2xhc3M6ICdvd2wtZG90JyxcXG5cXHRcXHRkb3RzQ2xhc3M6ICdvd2wtZG90cycsXFxuXFx0XFx0ZG90czogdHJ1ZSxcXG5cXHRcXHRkb3RzRWFjaDogZmFsc2UsXFxuXFx0XFx0ZG90c0RhdGE6IGZhbHNlLFxcblxcdFxcdGRvdHNTcGVlZDogZmFsc2UsXFxuXFx0XFx0ZG90c0NvbnRhaW5lcjogZmFsc2VcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEluaXRpYWxpemVzIHRoZSBsYXlvdXQgb2YgdGhlIHBsdWdpbiBhbmQgZXh0ZW5kcyB0aGUgY2Fyb3VzZWwuXFxuXFx0ICogQHByb3RlY3RlZFxcblxcdCAqL1xcblxcdE5hdmlnYXRpb24ucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHtcXG5cXHRcXHR2YXIgb3ZlcnJpZGUsXFxuXFx0XFx0XFx0c2V0dGluZ3MgPSB0aGlzLl9jb3JlLnNldHRpbmdzO1xcblxcblxcdFxcdC8vIGNyZWF0ZSBET00gc3RydWN0dXJlIGZvciByZWxhdGl2ZSBuYXZpZ2F0aW9uXFxuXFx0XFx0dGhpcy5fY29udHJvbHMuJHJlbGF0aXZlID0gKHNldHRpbmdzLm5hdkNvbnRhaW5lciA/ICQoc2V0dGluZ3MubmF2Q29udGFpbmVyKVxcblxcdFxcdFxcdDogJCgnPGRpdj4nKS5hZGRDbGFzcyhzZXR0aW5ncy5uYXZDb250YWluZXJDbGFzcykuYXBwZW5kVG8odGhpcy4kZWxlbWVudCkpLmFkZENsYXNzKCdkaXNhYmxlZCcpO1xcblxcblxcdFxcdHRoaXMuX2NvbnRyb2xzLiRwcmV2aW91cyA9ICQoJzwnICsgc2V0dGluZ3MubmF2RWxlbWVudCArICc+JylcXG5cXHRcXHRcXHQuYWRkQ2xhc3Moc2V0dGluZ3MubmF2Q2xhc3NbMF0pXFxuXFx0XFx0XFx0Lmh0bWwoc2V0dGluZ3MubmF2VGV4dFswXSlcXG5cXHRcXHRcXHQucHJlcGVuZFRvKHRoaXMuX2NvbnRyb2xzLiRyZWxhdGl2ZSlcXG5cXHRcXHRcXHQub24oJ2NsaWNrJywgJC5wcm94eShmdW5jdGlvbihlKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5wcmV2KHNldHRpbmdzLm5hdlNwZWVkKTtcXG5cXHRcXHRcXHR9LCB0aGlzKSk7XFxuXFx0XFx0dGhpcy5fY29udHJvbHMuJG5leHQgPSAkKCc8JyArIHNldHRpbmdzLm5hdkVsZW1lbnQgKyAnPicpXFxuXFx0XFx0XFx0LmFkZENsYXNzKHNldHRpbmdzLm5hdkNsYXNzWzFdKVxcblxcdFxcdFxcdC5odG1sKHNldHRpbmdzLm5hdlRleHRbMV0pXFxuXFx0XFx0XFx0LmFwcGVuZFRvKHRoaXMuX2NvbnRyb2xzLiRyZWxhdGl2ZSlcXG5cXHRcXHRcXHQub24oJ2NsaWNrJywgJC5wcm94eShmdW5jdGlvbihlKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5uZXh0KHNldHRpbmdzLm5hdlNwZWVkKTtcXG5cXHRcXHRcXHR9LCB0aGlzKSk7XFxuXFxuXFx0XFx0Ly8gY3JlYXRlIERPTSBzdHJ1Y3R1cmUgZm9yIGFic29sdXRlIG5hdmlnYXRpb25cXG5cXHRcXHRpZiAoIXNldHRpbmdzLmRvdHNEYXRhKSB7XFxuXFx0XFx0XFx0dGhpcy5fdGVtcGxhdGVzID0gWyAkKCc8ZGl2PicpXFxuXFx0XFx0XFx0XFx0LmFkZENsYXNzKHNldHRpbmdzLmRvdENsYXNzKVxcblxcdFxcdFxcdFxcdC5hcHBlbmQoJCgnPHNwYW4+JykpXFxuXFx0XFx0XFx0XFx0LnByb3AoJ291dGVySFRNTCcpIF07XFxuXFx0XFx0fVxcblxcblxcdFxcdHRoaXMuX2NvbnRyb2xzLiRhYnNvbHV0ZSA9IChzZXR0aW5ncy5kb3RzQ29udGFpbmVyID8gJChzZXR0aW5ncy5kb3RzQ29udGFpbmVyKVxcblxcdFxcdFxcdDogJCgnPGRpdj4nKS5hZGRDbGFzcyhzZXR0aW5ncy5kb3RzQ2xhc3MpLmFwcGVuZFRvKHRoaXMuJGVsZW1lbnQpKS5hZGRDbGFzcygnZGlzYWJsZWQnKTtcXG5cXG5cXHRcXHR0aGlzLl9jb250cm9scy4kYWJzb2x1dGUub24oJ2NsaWNrJywgJ2RpdicsICQucHJveHkoZnVuY3Rpb24oZSkge1xcblxcdFxcdFxcdHZhciBpbmRleCA9ICQoZS50YXJnZXQpLnBhcmVudCgpLmlzKHRoaXMuX2NvbnRyb2xzLiRhYnNvbHV0ZSlcXG5cXHRcXHRcXHRcXHQ/ICQoZS50YXJnZXQpLmluZGV4KCkgOiAkKGUudGFyZ2V0KS5wYXJlbnQoKS5pbmRleCgpO1xcblxcblxcdFxcdFxcdGUucHJldmVudERlZmF1bHQoKTtcXG5cXG5cXHRcXHRcXHR0aGlzLnRvKGluZGV4LCBzZXR0aW5ncy5kb3RzU3BlZWQpO1xcblxcdFxcdH0sIHRoaXMpKTtcXG5cXG5cXHRcXHQvLyBvdmVycmlkZSBwdWJsaWMgbWV0aG9kcyBvZiB0aGUgY2Fyb3VzZWxcXG5cXHRcXHRmb3IgKG92ZXJyaWRlIGluIHRoaXMuX292ZXJyaWRlcykge1xcblxcdFxcdFxcdHRoaXMuX2NvcmVbb3ZlcnJpZGVdID0gJC5wcm94eSh0aGlzW292ZXJyaWRlXSwgdGhpcyk7XFxuXFx0XFx0fVxcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogRGVzdHJveXMgdGhlIHBsdWdpbi5cXG5cXHQgKiBAcHJvdGVjdGVkXFxuXFx0ICovXFxuXFx0TmF2aWdhdGlvbi5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xcblxcdFxcdHZhciBoYW5kbGVyLCBjb250cm9sLCBwcm9wZXJ0eSwgb3ZlcnJpZGU7XFxuXFxuXFx0XFx0Zm9yIChoYW5kbGVyIGluIHRoaXMuX2hhbmRsZXJzKSB7XFxuXFx0XFx0XFx0dGhpcy4kZWxlbWVudC5vZmYoaGFuZGxlciwgdGhpcy5faGFuZGxlcnNbaGFuZGxlcl0pO1xcblxcdFxcdH1cXG5cXHRcXHRmb3IgKGNvbnRyb2wgaW4gdGhpcy5fY29udHJvbHMpIHtcXG5cXHRcXHRcXHR0aGlzLl9jb250cm9sc1tjb250cm9sXS5yZW1vdmUoKTtcXG5cXHRcXHR9XFxuXFx0XFx0Zm9yIChvdmVycmlkZSBpbiB0aGlzLm92ZXJpZGVzKSB7XFxuXFx0XFx0XFx0dGhpcy5fY29yZVtvdmVycmlkZV0gPSB0aGlzLl9vdmVycmlkZXNbb3ZlcnJpZGVdO1xcblxcdFxcdH1cXG5cXHRcXHRmb3IgKHByb3BlcnR5IGluIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMpKSB7XFxuXFx0XFx0XFx0dHlwZW9mIHRoaXNbcHJvcGVydHldICE9ICdmdW5jdGlvbicgJiYgKHRoaXNbcHJvcGVydHldID0gbnVsbCk7XFxuXFx0XFx0fVxcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogVXBkYXRlcyB0aGUgaW50ZXJuYWwgc3RhdGUuXFxuXFx0ICogQHByb3RlY3RlZFxcblxcdCAqL1xcblxcdE5hdmlnYXRpb24ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xcblxcdFxcdHZhciBpLCBqLCBrLFxcblxcdFxcdFxcdGxvd2VyID0gdGhpcy5fY29yZS5jbG9uZXMoKS5sZW5ndGggLyAyLFxcblxcdFxcdFxcdHVwcGVyID0gbG93ZXIgKyB0aGlzLl9jb3JlLml0ZW1zKCkubGVuZ3RoLFxcblxcdFxcdFxcdG1heGltdW0gPSB0aGlzLl9jb3JlLm1heGltdW0odHJ1ZSksXFxuXFx0XFx0XFx0c2V0dGluZ3MgPSB0aGlzLl9jb3JlLnNldHRpbmdzLFxcblxcdFxcdFxcdHNpemUgPSBzZXR0aW5ncy5jZW50ZXIgfHwgc2V0dGluZ3MuYXV0b1dpZHRoIHx8IHNldHRpbmdzLmRvdHNEYXRhXFxuXFx0XFx0XFx0XFx0PyAxIDogc2V0dGluZ3MuZG90c0VhY2ggfHwgc2V0dGluZ3MuaXRlbXM7XFxuXFxuXFx0XFx0aWYgKHNldHRpbmdzLnNsaWRlQnkgIT09ICdwYWdlJykge1xcblxcdFxcdFxcdHNldHRpbmdzLnNsaWRlQnkgPSBNYXRoLm1pbihzZXR0aW5ncy5zbGlkZUJ5LCBzZXR0aW5ncy5pdGVtcyk7XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmIChzZXR0aW5ncy5kb3RzIHx8IHNldHRpbmdzLnNsaWRlQnkgPT0gJ3BhZ2UnKSB7XFxuXFx0XFx0XFx0dGhpcy5fcGFnZXMgPSBbXTtcXG5cXG5cXHRcXHRcXHRmb3IgKGkgPSBsb3dlciwgaiA9IDAsIGsgPSAwOyBpIDwgdXBwZXI7IGkrKykge1xcblxcdFxcdFxcdFxcdGlmIChqID49IHNpemUgfHwgaiA9PT0gMCkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuX3BhZ2VzLnB1c2goe1xcblxcdFxcdFxcdFxcdFxcdFxcdHN0YXJ0OiBNYXRoLm1pbihtYXhpbXVtLCBpIC0gbG93ZXIpLFxcblxcdFxcdFxcdFxcdFxcdFxcdGVuZDogaSAtIGxvd2VyICsgc2l6ZSAtIDFcXG5cXHRcXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoTWF0aC5taW4obWF4aW11bSwgaSAtIGxvd2VyKSA9PT0gbWF4aW11bSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRqID0gMCwgKytrO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRqICs9IHRoaXMuX2NvcmUubWVyZ2Vycyh0aGlzLl9jb3JlLnJlbGF0aXZlKGkpKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogRHJhd3MgdGhlIHVzZXIgaW50ZXJmYWNlLlxcblxcdCAqIEB0b2RvIFRoZSBvcHRpb24gYGRvdHNEYXRhYCB3b250IHdvcmsuXFxuXFx0ICogQHByb3RlY3RlZFxcblxcdCAqL1xcblxcdE5hdmlnYXRpb24ucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbigpIHtcXG5cXHRcXHR2YXIgZGlmZmVyZW5jZSxcXG5cXHRcXHRcXHRzZXR0aW5ncyA9IHRoaXMuX2NvcmUuc2V0dGluZ3MsXFxuXFx0XFx0XFx0ZGlzYWJsZWQgPSB0aGlzLl9jb3JlLml0ZW1zKCkubGVuZ3RoIDw9IHNldHRpbmdzLml0ZW1zLFxcblxcdFxcdFxcdGluZGV4ID0gdGhpcy5fY29yZS5yZWxhdGl2ZSh0aGlzLl9jb3JlLmN1cnJlbnQoKSksXFxuXFx0XFx0XFx0bG9vcCA9IHNldHRpbmdzLmxvb3AgfHwgc2V0dGluZ3MucmV3aW5kO1xcblxcblxcdFxcdHRoaXMuX2NvbnRyb2xzLiRyZWxhdGl2ZS50b2dnbGVDbGFzcygnZGlzYWJsZWQnLCAhc2V0dGluZ3MubmF2IHx8IGRpc2FibGVkKTtcXG5cXG5cXHRcXHRpZiAoc2V0dGluZ3MubmF2KSB7XFxuXFx0XFx0XFx0dGhpcy5fY29udHJvbHMuJHByZXZpb3VzLnRvZ2dsZUNsYXNzKCdkaXNhYmxlZCcsICFsb29wICYmIGluZGV4IDw9IHRoaXMuX2NvcmUubWluaW11bSh0cnVlKSk7XFxuXFx0XFx0XFx0dGhpcy5fY29udHJvbHMuJG5leHQudG9nZ2xlQ2xhc3MoJ2Rpc2FibGVkJywgIWxvb3AgJiYgaW5kZXggPj0gdGhpcy5fY29yZS5tYXhpbXVtKHRydWUpKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0dGhpcy5fY29udHJvbHMuJGFic29sdXRlLnRvZ2dsZUNsYXNzKCdkaXNhYmxlZCcsICFzZXR0aW5ncy5kb3RzIHx8IGRpc2FibGVkKTtcXG5cXG5cXHRcXHRpZiAoc2V0dGluZ3MuZG90cykge1xcblxcdFxcdFxcdGRpZmZlcmVuY2UgPSB0aGlzLl9wYWdlcy5sZW5ndGggLSB0aGlzLl9jb250cm9scy4kYWJzb2x1dGUuY2hpbGRyZW4oKS5sZW5ndGg7XFxuXFxuXFx0XFx0XFx0aWYgKHNldHRpbmdzLmRvdHNEYXRhICYmIGRpZmZlcmVuY2UgIT09IDApIHtcXG5cXHRcXHRcXHRcXHR0aGlzLl9jb250cm9scy4kYWJzb2x1dGUuaHRtbCh0aGlzLl90ZW1wbGF0ZXMuam9pbignJykpO1xcblxcdFxcdFxcdH0gZWxzZSBpZiAoZGlmZmVyZW5jZSA+IDApIHtcXG5cXHRcXHRcXHRcXHR0aGlzLl9jb250cm9scy4kYWJzb2x1dGUuYXBwZW5kKG5ldyBBcnJheShkaWZmZXJlbmNlICsgMSkuam9pbih0aGlzLl90ZW1wbGF0ZXNbMF0pKTtcXG5cXHRcXHRcXHR9IGVsc2UgaWYgKGRpZmZlcmVuY2UgPCAwKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5fY29udHJvbHMuJGFic29sdXRlLmNoaWxkcmVuKCkuc2xpY2UoZGlmZmVyZW5jZSkucmVtb3ZlKCk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRoaXMuX2NvbnRyb2xzLiRhYnNvbHV0ZS5maW5kKCcuYWN0aXZlJykucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpO1xcblxcdFxcdFxcdHRoaXMuX2NvbnRyb2xzLiRhYnNvbHV0ZS5jaGlsZHJlbigpLmVxKCQuaW5BcnJheSh0aGlzLmN1cnJlbnQoKSwgdGhpcy5fcGFnZXMpKS5hZGRDbGFzcygnYWN0aXZlJyk7XFxuXFx0XFx0fVxcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogRXh0ZW5kcyBldmVudCBkYXRhLlxcblxcdCAqIEBwcm90ZWN0ZWRcXG5cXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIFRoZSBldmVudCBvYmplY3Qgd2hpY2ggZ2V0cyB0aHJvd24uXFxuXFx0ICovXFxuXFx0TmF2aWdhdGlvbi5wcm90b3R5cGUub25UcmlnZ2VyID0gZnVuY3Rpb24oZXZlbnQpIHtcXG5cXHRcXHR2YXIgc2V0dGluZ3MgPSB0aGlzLl9jb3JlLnNldHRpbmdzO1xcblxcblxcdFxcdGV2ZW50LnBhZ2UgPSB7XFxuXFx0XFx0XFx0aW5kZXg6ICQuaW5BcnJheSh0aGlzLmN1cnJlbnQoKSwgdGhpcy5fcGFnZXMpLFxcblxcdFxcdFxcdGNvdW50OiB0aGlzLl9wYWdlcy5sZW5ndGgsXFxuXFx0XFx0XFx0c2l6ZTogc2V0dGluZ3MgJiYgKHNldHRpbmdzLmNlbnRlciB8fCBzZXR0aW5ncy5hdXRvV2lkdGggfHwgc2V0dGluZ3MuZG90c0RhdGFcXG5cXHRcXHRcXHRcXHQ/IDEgOiBzZXR0aW5ncy5kb3RzRWFjaCB8fCBzZXR0aW5ncy5pdGVtcylcXG5cXHRcXHR9O1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogR2V0cyB0aGUgY3VycmVudCBwYWdlIHBvc2l0aW9uIG9mIHRoZSBjYXJvdXNlbC5cXG5cXHQgKiBAcHJvdGVjdGVkXFxuXFx0ICogQHJldHVybnMge051bWJlcn1cXG5cXHQgKi9cXG5cXHROYXZpZ2F0aW9uLnByb3RvdHlwZS5jdXJyZW50ID0gZnVuY3Rpb24oKSB7XFxuXFx0XFx0dmFyIGN1cnJlbnQgPSB0aGlzLl9jb3JlLnJlbGF0aXZlKHRoaXMuX2NvcmUuY3VycmVudCgpKTtcXG5cXHRcXHRyZXR1cm4gJC5ncmVwKHRoaXMuX3BhZ2VzLCAkLnByb3h5KGZ1bmN0aW9uKHBhZ2UsIGluZGV4KSB7XFxuXFx0XFx0XFx0cmV0dXJuIHBhZ2Uuc3RhcnQgPD0gY3VycmVudCAmJiBwYWdlLmVuZCA+PSBjdXJyZW50O1xcblxcdFxcdH0sIHRoaXMpKS5wb3AoKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEdldHMgdGhlIGN1cnJlbnQgc3VjY2Vzb3IvcHJlZGVjZXNzb3IgcG9zaXRpb24uXFxuXFx0ICogQHByb3RlY3RlZFxcblxcdCAqIEByZXR1cm5zIHtOdW1iZXJ9XFxuXFx0ICovXFxuXFx0TmF2aWdhdGlvbi5wcm90b3R5cGUuZ2V0UG9zaXRpb24gPSBmdW5jdGlvbihzdWNjZXNzb3IpIHtcXG5cXHRcXHR2YXIgcG9zaXRpb24sIGxlbmd0aCxcXG5cXHRcXHRcXHRzZXR0aW5ncyA9IHRoaXMuX2NvcmUuc2V0dGluZ3M7XFxuXFxuXFx0XFx0aWYgKHNldHRpbmdzLnNsaWRlQnkgPT0gJ3BhZ2UnKSB7XFxuXFx0XFx0XFx0cG9zaXRpb24gPSAkLmluQXJyYXkodGhpcy5jdXJyZW50KCksIHRoaXMuX3BhZ2VzKTtcXG5cXHRcXHRcXHRsZW5ndGggPSB0aGlzLl9wYWdlcy5sZW5ndGg7XFxuXFx0XFx0XFx0c3VjY2Vzc29yID8gKytwb3NpdGlvbiA6IC0tcG9zaXRpb247XFxuXFx0XFx0XFx0cG9zaXRpb24gPSB0aGlzLl9wYWdlc1soKHBvc2l0aW9uICUgbGVuZ3RoKSArIGxlbmd0aCkgJSBsZW5ndGhdLnN0YXJ0O1xcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0cG9zaXRpb24gPSB0aGlzLl9jb3JlLnJlbGF0aXZlKHRoaXMuX2NvcmUuY3VycmVudCgpKTtcXG5cXHRcXHRcXHRsZW5ndGggPSB0aGlzLl9jb3JlLml0ZW1zKCkubGVuZ3RoO1xcblxcdFxcdFxcdHN1Y2Nlc3NvciA/IHBvc2l0aW9uICs9IHNldHRpbmdzLnNsaWRlQnkgOiBwb3NpdGlvbiAtPSBzZXR0aW5ncy5zbGlkZUJ5O1xcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gcG9zaXRpb247XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBTbGlkZXMgdG8gdGhlIG5leHQgaXRlbSBvciBwYWdlLlxcblxcdCAqIEBwdWJsaWNcXG5cXHQgKiBAcGFyYW0ge051bWJlcn0gW3NwZWVkPWZhbHNlXSAtIFRoZSB0aW1lIGluIG1pbGxpc2Vjb25kcyBmb3IgdGhlIHRyYW5zaXRpb24uXFxuXFx0ICovXFxuXFx0TmF2aWdhdGlvbi5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKHNwZWVkKSB7XFxuXFx0XFx0JC5wcm94eSh0aGlzLl9vdmVycmlkZXMudG8sIHRoaXMuX2NvcmUpKHRoaXMuZ2V0UG9zaXRpb24odHJ1ZSksIHNwZWVkKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIFNsaWRlcyB0byB0aGUgcHJldmlvdXMgaXRlbSBvciBwYWdlLlxcblxcdCAqIEBwdWJsaWNcXG5cXHQgKiBAcGFyYW0ge051bWJlcn0gW3NwZWVkPWZhbHNlXSAtIFRoZSB0aW1lIGluIG1pbGxpc2Vjb25kcyBmb3IgdGhlIHRyYW5zaXRpb24uXFxuXFx0ICovXFxuXFx0TmF2aWdhdGlvbi5wcm90b3R5cGUucHJldiA9IGZ1bmN0aW9uKHNwZWVkKSB7XFxuXFx0XFx0JC5wcm94eSh0aGlzLl9vdmVycmlkZXMudG8sIHRoaXMuX2NvcmUpKHRoaXMuZ2V0UG9zaXRpb24oZmFsc2UpLCBzcGVlZCk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBTbGlkZXMgdG8gdGhlIHNwZWNpZmllZCBpdGVtIG9yIHBhZ2UuXFxuXFx0ICogQHB1YmxpY1xcblxcdCAqIEBwYXJhbSB7TnVtYmVyfSBwb3NpdGlvbiAtIFRoZSBwb3NpdGlvbiBvZiB0aGUgaXRlbSBvciBwYWdlLlxcblxcdCAqIEBwYXJhbSB7TnVtYmVyfSBbc3BlZWRdIC0gVGhlIHRpbWUgaW4gbWlsbGlzZWNvbmRzIGZvciB0aGUgdHJhbnNpdGlvbi5cXG5cXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtzdGFuZGFyZD1mYWxzZV0gLSBXaGV0aGVyIHRvIHVzZSB0aGUgc3RhbmRhcmQgYmVoYXZpb3VyIG9yIG5vdC5cXG5cXHQgKi9cXG5cXHROYXZpZ2F0aW9uLnByb3RvdHlwZS50byA9IGZ1bmN0aW9uKHBvc2l0aW9uLCBzcGVlZCwgc3RhbmRhcmQpIHtcXG5cXHRcXHR2YXIgbGVuZ3RoO1xcblxcblxcdFxcdGlmICghc3RhbmRhcmQgJiYgdGhpcy5fcGFnZXMubGVuZ3RoKSB7XFxuXFx0XFx0XFx0bGVuZ3RoID0gdGhpcy5fcGFnZXMubGVuZ3RoO1xcblxcdFxcdFxcdCQucHJveHkodGhpcy5fb3ZlcnJpZGVzLnRvLCB0aGlzLl9jb3JlKSh0aGlzLl9wYWdlc1soKHBvc2l0aW9uICUgbGVuZ3RoKSArIGxlbmd0aCkgJSBsZW5ndGhdLnN0YXJ0LCBzcGVlZCk7XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHQkLnByb3h5KHRoaXMuX292ZXJyaWRlcy50bywgdGhpcy5fY29yZSkocG9zaXRpb24sIHNwZWVkKTtcXG5cXHRcXHR9XFxuXFx0fTtcXG5cXG5cXHQkLmZuLm93bENhcm91c2VsLkNvbnN0cnVjdG9yLlBsdWdpbnMuTmF2aWdhdGlvbiA9IE5hdmlnYXRpb247XFxuXFxufSkod2luZG93LlplcHRvIHx8IF9fd2VicGFja19wcm92aWRlZF93aW5kb3dfZG90X2pRdWVyeSwgd2luZG93LCBkb2N1bWVudCk7XFxuXFxuLyoqXFxuICogSGFzaCBQbHVnaW5cXG4gKiBAdmVyc2lvbiAyLjEuMFxcbiAqIEBhdXRob3IgQXJ0dXMgS29sYW5vd3NraVxcbiAqIEBhdXRob3IgRGF2aWQgRGV1dHNjaFxcbiAqIEBsaWNlbnNlIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxcbiAqL1xcbjsoZnVuY3Rpb24oJCwgd2luZG93LCBkb2N1bWVudCwgdW5kZWZpbmVkKSB7XFxuXFx0J3VzZSBzdHJpY3QnO1xcblxcblxcdC8qKlxcblxcdCAqIENyZWF0ZXMgdGhlIGhhc2ggcGx1Z2luLlxcblxcdCAqIEBjbGFzcyBUaGUgSGFzaCBQbHVnaW5cXG5cXHQgKiBAcGFyYW0ge093bH0gY2Fyb3VzZWwgLSBUaGUgT3dsIENhcm91c2VsXFxuXFx0ICovXFxuXFx0dmFyIEhhc2ggPSBmdW5jdGlvbihjYXJvdXNlbCkge1xcblxcdFxcdC8qKlxcblxcdFxcdCAqIFJlZmVyZW5jZSB0byB0aGUgY29yZS5cXG5cXHRcXHQgKiBAcHJvdGVjdGVkXFxuXFx0XFx0ICogQHR5cGUge093bH1cXG5cXHRcXHQgKi9cXG5cXHRcXHR0aGlzLl9jb3JlID0gY2Fyb3VzZWw7XFxuXFxuXFx0XFx0LyoqXFxuXFx0XFx0ICogSGFzaCBpbmRleCBmb3IgdGhlIGl0ZW1zLlxcblxcdFxcdCAqIEBwcm90ZWN0ZWRcXG5cXHRcXHQgKiBAdHlwZSB7T2JqZWN0fVxcblxcdFxcdCAqL1xcblxcdFxcdHRoaXMuX2hhc2hlcyA9IHt9O1xcblxcblxcdFxcdC8qKlxcblxcdFxcdCAqIFRoZSBjYXJvdXNlbCBlbGVtZW50LlxcblxcdFxcdCAqIEB0eXBlIHtqUXVlcnl9XFxuXFx0XFx0ICovXFxuXFx0XFx0dGhpcy4kZWxlbWVudCA9IHRoaXMuX2NvcmUuJGVsZW1lbnQ7XFxuXFxuXFx0XFx0LyoqXFxuXFx0XFx0ICogQWxsIGV2ZW50IGhhbmRsZXJzLlxcblxcdFxcdCAqIEBwcm90ZWN0ZWRcXG5cXHRcXHQgKiBAdHlwZSB7T2JqZWN0fVxcblxcdFxcdCAqL1xcblxcdFxcdHRoaXMuX2hhbmRsZXJzID0ge1xcblxcdFxcdFxcdCdpbml0aWFsaXplZC5vd2wuY2Fyb3VzZWwnOiAkLnByb3h5KGZ1bmN0aW9uKGUpIHtcXG5cXHRcXHRcXHRcXHRpZiAoZS5uYW1lc3BhY2UgJiYgdGhpcy5fY29yZS5zZXR0aW5ncy5zdGFydFBvc2l0aW9uID09PSAnVVJMSGFzaCcpIHtcXG5cXHRcXHRcXHRcXHRcXHQkKHdpbmRvdykudHJpZ2dlcignaGFzaGNoYW5nZS5vd2wubmF2aWdhdGlvbicpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LCB0aGlzKSxcXG5cXHRcXHRcXHQncHJlcGFyZWQub3dsLmNhcm91c2VsJzogJC5wcm94eShmdW5jdGlvbihlKSB7XFxuXFx0XFx0XFx0XFx0aWYgKGUubmFtZXNwYWNlKSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIGhhc2ggPSAkKGUuY29udGVudCkuZmluZCgnW2RhdGEtaGFzaF0nKS5hZGRCYWNrKCdbZGF0YS1oYXNoXScpLmF0dHIoJ2RhdGEtaGFzaCcpO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICghaGFzaCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5faGFzaGVzW2hhc2hdID0gZS5jb250ZW50O1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LCB0aGlzKSxcXG5cXHRcXHRcXHQnY2hhbmdlZC5vd2wuY2Fyb3VzZWwnOiAkLnByb3h5KGZ1bmN0aW9uKGUpIHtcXG5cXHRcXHRcXHRcXHRpZiAoZS5uYW1lc3BhY2UgJiYgZS5wcm9wZXJ0eS5uYW1lID09PSAncG9zaXRpb24nKSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIGN1cnJlbnQgPSB0aGlzLl9jb3JlLml0ZW1zKHRoaXMuX2NvcmUucmVsYXRpdmUodGhpcy5fY29yZS5jdXJyZW50KCkpKSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRoYXNoID0gJC5tYXAodGhpcy5faGFzaGVzLCBmdW5jdGlvbihpdGVtLCBoYXNoKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIGl0ZW0gPT09IGN1cnJlbnQgPyBoYXNoIDogbnVsbDtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9KS5qb2luKCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCFoYXNoIHx8IHdpbmRvdy5sb2NhdGlvbi5oYXNoLnNsaWNlKDEpID09PSBoYXNoKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHR3aW5kb3cubG9jYXRpb24uaGFzaCA9IGhhc2g7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sIHRoaXMpXFxuXFx0XFx0fTtcXG5cXG5cXHRcXHQvLyBzZXQgZGVmYXVsdCBvcHRpb25zXFxuXFx0XFx0dGhpcy5fY29yZS5vcHRpb25zID0gJC5leHRlbmQoe30sIEhhc2guRGVmYXVsdHMsIHRoaXMuX2NvcmUub3B0aW9ucyk7XFxuXFxuXFx0XFx0Ly8gcmVnaXN0ZXIgdGhlIGV2ZW50IGhhbmRsZXJzXFxuXFx0XFx0dGhpcy4kZWxlbWVudC5vbih0aGlzLl9oYW5kbGVycyk7XFxuXFxuXFx0XFx0Ly8gcmVnaXN0ZXIgZXZlbnQgbGlzdGVuZXIgZm9yIGhhc2ggbmF2aWdhdGlvblxcblxcdFxcdCQod2luZG93KS5vbignaGFzaGNoYW5nZS5vd2wubmF2aWdhdGlvbicsICQucHJveHkoZnVuY3Rpb24oZSkge1xcblxcdFxcdFxcdHZhciBoYXNoID0gd2luZG93LmxvY2F0aW9uLmhhc2guc3Vic3RyaW5nKDEpLFxcblxcdFxcdFxcdFxcdGl0ZW1zID0gdGhpcy5fY29yZS4kc3RhZ2UuY2hpbGRyZW4oKSxcXG5cXHRcXHRcXHRcXHRwb3NpdGlvbiA9IHRoaXMuX2hhc2hlc1toYXNoXSAmJiBpdGVtcy5pbmRleCh0aGlzLl9oYXNoZXNbaGFzaF0pO1xcblxcblxcdFxcdFxcdGlmIChwb3NpdGlvbiA9PT0gdW5kZWZpbmVkIHx8IHBvc2l0aW9uID09PSB0aGlzLl9jb3JlLmN1cnJlbnQoKSkge1xcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGhpcy5fY29yZS50byh0aGlzLl9jb3JlLnJlbGF0aXZlKHBvc2l0aW9uKSwgZmFsc2UsIHRydWUpO1xcblxcdFxcdH0sIHRoaXMpKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIERlZmF1bHQgb3B0aW9ucy5cXG5cXHQgKiBAcHVibGljXFxuXFx0ICovXFxuXFx0SGFzaC5EZWZhdWx0cyA9IHtcXG5cXHRcXHRVUkxoYXNoTGlzdGVuZXI6IGZhbHNlXFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBEZXN0cm95cyB0aGUgcGx1Z2luLlxcblxcdCAqIEBwdWJsaWNcXG5cXHQgKi9cXG5cXHRIYXNoLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XFxuXFx0XFx0dmFyIGhhbmRsZXIsIHByb3BlcnR5O1xcblxcblxcdFxcdCQod2luZG93KS5vZmYoJ2hhc2hjaGFuZ2Uub3dsLm5hdmlnYXRpb24nKTtcXG5cXG5cXHRcXHRmb3IgKGhhbmRsZXIgaW4gdGhpcy5faGFuZGxlcnMpIHtcXG5cXHRcXHRcXHR0aGlzLl9jb3JlLiRlbGVtZW50Lm9mZihoYW5kbGVyLCB0aGlzLl9oYW5kbGVyc1toYW5kbGVyXSk7XFxuXFx0XFx0fVxcblxcdFxcdGZvciAocHJvcGVydHkgaW4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcykpIHtcXG5cXHRcXHRcXHR0eXBlb2YgdGhpc1twcm9wZXJ0eV0gIT0gJ2Z1bmN0aW9uJyAmJiAodGhpc1twcm9wZXJ0eV0gPSBudWxsKTtcXG5cXHRcXHR9XFxuXFx0fTtcXG5cXG5cXHQkLmZuLm93bENhcm91c2VsLkNvbnN0cnVjdG9yLlBsdWdpbnMuSGFzaCA9IEhhc2g7XFxuXFxufSkod2luZG93LlplcHRvIHx8IF9fd2VicGFja19wcm92aWRlZF93aW5kb3dfZG90X2pRdWVyeSwgd2luZG93LCBkb2N1bWVudCk7XFxuXFxuLyoqXFxuICogU3VwcG9ydCBQbHVnaW5cXG4gKlxcbiAqIEB2ZXJzaW9uIDIuMS4wXFxuICogQGF1dGhvciBWaXZpZCBQbGFuZXQgU29mdHdhcmUgR21iSFxcbiAqIEBhdXRob3IgQXJ0dXMgS29sYW5vd3NraVxcbiAqIEBhdXRob3IgRGF2aWQgRGV1dHNjaFxcbiAqIEBsaWNlbnNlIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxcbiAqL1xcbjsoZnVuY3Rpb24oJCwgd2luZG93LCBkb2N1bWVudCwgdW5kZWZpbmVkKSB7XFxuXFxuXFx0dmFyIHN0eWxlID0gJCgnPHN1cHBvcnQ+JykuZ2V0KDApLnN0eWxlLFxcblxcdFxcdHByZWZpeGVzID0gJ1dlYmtpdCBNb3ogTyBtcycuc3BsaXQoJyAnKSxcXG5cXHRcXHRldmVudHMgPSB7XFxuXFx0XFx0XFx0dHJhbnNpdGlvbjoge1xcblxcdFxcdFxcdFxcdGVuZDoge1xcblxcdFxcdFxcdFxcdFxcdFdlYmtpdFRyYW5zaXRpb246ICd3ZWJraXRUcmFuc2l0aW9uRW5kJyxcXG5cXHRcXHRcXHRcXHRcXHRNb3pUcmFuc2l0aW9uOiAndHJhbnNpdGlvbmVuZCcsXFxuXFx0XFx0XFx0XFx0XFx0T1RyYW5zaXRpb246ICdvVHJhbnNpdGlvbkVuZCcsXFxuXFx0XFx0XFx0XFx0XFx0dHJhbnNpdGlvbjogJ3RyYW5zaXRpb25lbmQnXFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0YW5pbWF0aW9uOiB7XFxuXFx0XFx0XFx0XFx0ZW5kOiB7XFxuXFx0XFx0XFx0XFx0XFx0V2Via2l0QW5pbWF0aW9uOiAnd2Via2l0QW5pbWF0aW9uRW5kJyxcXG5cXHRcXHRcXHRcXHRcXHRNb3pBbmltYXRpb246ICdhbmltYXRpb25lbmQnLFxcblxcdFxcdFxcdFxcdFxcdE9BbmltYXRpb246ICdvQW5pbWF0aW9uRW5kJyxcXG5cXHRcXHRcXHRcXHRcXHRhbmltYXRpb246ICdhbmltYXRpb25lbmQnXFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcdFxcdHRlc3RzID0ge1xcblxcdFxcdFxcdGNzc3RyYW5zZm9ybXM6IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdHJldHVybiAhIXRlc3QoJ3RyYW5zZm9ybScpO1xcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0Y3NzdHJhbnNmb3JtczNkOiBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gISF0ZXN0KCdwZXJzcGVjdGl2ZScpO1xcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0Y3NzdHJhbnNpdGlvbnM6IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdHJldHVybiAhIXRlc3QoJ3RyYW5zaXRpb24nKTtcXG5cXHRcXHRcXHR9LFxcblxcdFxcdFxcdGNzc2FuaW1hdGlvbnM6IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdHJldHVybiAhIXRlc3QoJ2FuaW1hdGlvbicpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9O1xcblxcblxcdGZ1bmN0aW9uIHRlc3QocHJvcGVydHksIHByZWZpeGVkKSB7XFxuXFx0XFx0dmFyIHJlc3VsdCA9IGZhbHNlLFxcblxcdFxcdFxcdHVwcGVyID0gcHJvcGVydHkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwcm9wZXJ0eS5zbGljZSgxKTtcXG5cXG5cXHRcXHQkLmVhY2goKHByb3BlcnR5ICsgJyAnICsgcHJlZml4ZXMuam9pbih1cHBlciArICcgJykgKyB1cHBlcikuc3BsaXQoJyAnKSwgZnVuY3Rpb24oaSwgcHJvcGVydHkpIHtcXG5cXHRcXHRcXHRpZiAoc3R5bGVbcHJvcGVydHldICE9PSB1bmRlZmluZWQpIHtcXG5cXHRcXHRcXHRcXHRyZXN1bHQgPSBwcmVmaXhlZCA/IHByb3BlcnR5IDogdHJ1ZTtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0pO1xcblxcblxcdFxcdHJldHVybiByZXN1bHQ7XFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIHByZWZpeGVkKHByb3BlcnR5KSB7XFxuXFx0XFx0cmV0dXJuIHRlc3QocHJvcGVydHksIHRydWUpO1xcblxcdH1cXG5cXG5cXHRpZiAodGVzdHMuY3NzdHJhbnNpdGlvbnMoKSkge1xcblxcdFxcdC8qIGpzaGludCAtVzA1MyAqL1xcblxcdFxcdCQuc3VwcG9ydC50cmFuc2l0aW9uID0gbmV3IFN0cmluZyhwcmVmaXhlZCgndHJhbnNpdGlvbicpKVxcblxcdFxcdCQuc3VwcG9ydC50cmFuc2l0aW9uLmVuZCA9IGV2ZW50cy50cmFuc2l0aW9uLmVuZFsgJC5zdXBwb3J0LnRyYW5zaXRpb24gXTtcXG5cXHR9XFxuXFxuXFx0aWYgKHRlc3RzLmNzc2FuaW1hdGlvbnMoKSkge1xcblxcdFxcdC8qIGpzaGludCAtVzA1MyAqL1xcblxcdFxcdCQuc3VwcG9ydC5hbmltYXRpb24gPSBuZXcgU3RyaW5nKHByZWZpeGVkKCdhbmltYXRpb24nKSlcXG5cXHRcXHQkLnN1cHBvcnQuYW5pbWF0aW9uLmVuZCA9IGV2ZW50cy5hbmltYXRpb24uZW5kWyAkLnN1cHBvcnQuYW5pbWF0aW9uIF07XFxuXFx0fVxcblxcblxcdGlmICh0ZXN0cy5jc3N0cmFuc2Zvcm1zKCkpIHtcXG5cXHRcXHQvKiBqc2hpbnQgLVcwNTMgKi9cXG5cXHRcXHQkLnN1cHBvcnQudHJhbnNmb3JtID0gbmV3IFN0cmluZyhwcmVmaXhlZCgndHJhbnNmb3JtJykpO1xcblxcdFxcdCQuc3VwcG9ydC50cmFuc2Zvcm0zZCA9IHRlc3RzLmNzc3RyYW5zZm9ybXMzZCgpO1xcblxcdH1cXG5cXG59KSh3aW5kb3cuWmVwdG8gfHwgX193ZWJwYWNrX3Byb3ZpZGVkX3dpbmRvd19kb3RfalF1ZXJ5LCB3aW5kb3csIGRvY3VtZW50KTtcXG5cXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXygxKSwgX193ZWJwYWNrX3JlcXVpcmVfXygxKSkpXFxuXFxuLy8vLy8vLy8vLy8vLy8vLy8vXFxuLy8gV0VCUEFDSyBGT09URVJcXG4vLyAuL34vb3dsLmNhcm91c2VsL2Rpc3Qvb3dsLmNhcm91c2VsLmpzXFxuLy8gbW9kdWxlIGlkID0gOFxcbi8vIG1vZHVsZSBjaHVua3MgPSAwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vfi9vd2wuY2Fyb3VzZWwvZGlzdC9vd2wuY2Fyb3VzZWwuanM/XCIpO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDkgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuZXZhbChcIi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihwcm9jZXNzKSB7LyoqXFxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXFxuICpcXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXFxuICovXFxuXFxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcXG4gIHZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJlxcbiAgICBTeW1ib2wuZm9yICYmXFxuICAgIFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSkgfHxcXG4gICAgMHhlYWM3O1xcblxcbiAgdmFyIGlzVmFsaWRFbGVtZW50ID0gZnVuY3Rpb24ob2JqZWN0KSB7XFxuICAgIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJlxcbiAgICAgIG9iamVjdCAhPT0gbnVsbCAmJlxcbiAgICAgIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xcbiAgfTtcXG5cXG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IGRldmVsb3BtZW50IGJlaGF2aW9yLlxcbiAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxcbiAgdmFyIHRocm93T25EaXJlY3RBY2Nlc3MgPSB0cnVlO1xcbiAgbW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxKShpc1ZhbGlkRWxlbWVudCwgdGhyb3dPbkRpcmVjdEFjY2Vzcyk7XFxufSBlbHNlIHtcXG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IHByb2R1Y3Rpb24gYmVoYXZpb3IuXFxuICAvLyBodHRwOi8vZmIubWUvcHJvcC10eXBlcy1pbi1wcm9kXFxuICBtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMjApKCk7XFxufVxcblxcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDApKSlcXG5cXG4vLy8vLy8vLy8vLy8vLy8vLy9cXG4vLyBXRUJQQUNLIEZPT1RFUlxcbi8vIC4vfi9wcm9wLXR5cGVzL2luZGV4LmpzXFxuLy8gbW9kdWxlIGlkID0gOVxcbi8vIG1vZHVsZSBjaHVua3MgPSAwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vfi9wcm9wLXR5cGVzL2luZGV4LmpzP1wiKTtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAxMCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5ldmFsKFwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcXG5cXG4vLyBsb2FkIHRoZSBzdHlsZXNcXG52YXIgY29udGVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmksIGNvbnRlbnQsICcnXV07XFxuLy8gUHJlcGFyZSBjc3NUcmFuc2Zvcm1hdGlvblxcbnZhciB0cmFuc2Zvcm07XFxuXFxudmFyIG9wdGlvbnMgPSB7fVxcbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXFxuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxcbnZhciB1cGRhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpKGNvbnRlbnQsIG9wdGlvbnMpO1xcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcXG5pZihmYWxzZSkge1xcblxcdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXFxuXFx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XFxuXFx0XFx0bW9kdWxlLmhvdC5hY2NlcHQoXFxcIiEhLi4vLi4vLi4vY3NzLWxvYWRlci9pbmRleC5qcyEuL293bC5jYXJvdXNlbC5taW4uY3NzXFxcIiwgZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFxcXCIhIS4uLy4uLy4uL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9vd2wuY2Fyb3VzZWwubWluLmNzc1xcXCIpO1xcblxcdFxcdFxcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xcblxcdFxcdFxcdHVwZGF0ZShuZXdDb250ZW50KTtcXG5cXHRcXHR9KTtcXG5cXHR9XFxuXFx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xcblxcdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xcbn1cXG5cXG4vLy8vLy8vLy8vLy8vLy8vLy9cXG4vLyBXRUJQQUNLIEZPT1RFUlxcbi8vIC4vfi9vd2wuY2Fyb3VzZWwvZGlzdC9hc3NldHMvb3dsLmNhcm91c2VsLm1pbi5jc3NcXG4vLyBtb2R1bGUgaWQgPSAxMFxcbi8vIG1vZHVsZSBjaHVua3MgPSAwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vfi9vd2wuY2Fyb3VzZWwvZGlzdC9hc3NldHMvb3dsLmNhcm91c2VsLm1pbi5jc3M/XCIpO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDExICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbmV2YWwoXCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xcblxcbi8vIGxvYWQgdGhlIHN0eWxlc1xcbnZhciBjb250ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XFxuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaSwgY29udGVudCwgJyddXTtcXG4vLyBQcmVwYXJlIGNzc1RyYW5zZm9ybWF0aW9uXFxudmFyIHRyYW5zZm9ybTtcXG5cXG52YXIgb3B0aW9ucyA9IHt9XFxub3B0aW9ucy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cXG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXFxudmFyIHVwZGF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oNykoY29udGVudCwgb3B0aW9ucyk7XFxuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XFxuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxcbmlmKGZhbHNlKSB7XFxuXFx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3NcXG5cXHRpZighY29udGVudC5sb2NhbHMpIHtcXG5cXHRcXHRtb2R1bGUuaG90LmFjY2VwdChcXFwiISEuLi8uLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzIS4vb3dsLnRoZW1lLmRlZmF1bHQubWluLmNzc1xcXCIsIGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcXFwiISEuLi8uLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzIS4vb3dsLnRoZW1lLmRlZmF1bHQubWluLmNzc1xcXCIpO1xcblxcdFxcdFxcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xcblxcdFxcdFxcdHVwZGF0ZShuZXdDb250ZW50KTtcXG5cXHRcXHR9KTtcXG5cXHR9XFxuXFx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xcblxcdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xcbn1cXG5cXG4vLy8vLy8vLy8vLy8vLy8vLy9cXG4vLyBXRUJQQUNLIEZPT1RFUlxcbi8vIC4vfi9vd2wuY2Fyb3VzZWwvZGlzdC9hc3NldHMvb3dsLnRoZW1lLmRlZmF1bHQubWluLmNzc1xcbi8vIG1vZHVsZSBpZCA9IDExXFxuLy8gbW9kdWxlIGNodW5rcyA9IDBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9+L293bC5jYXJvdXNlbC9kaXN0L2Fzc2V0cy9vd2wudGhlbWUuZGVmYXVsdC5taW4uY3NzP1wiKTtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAxMiAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5ldmFsKFwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzEyX187XFxuXFxuLy8vLy8vLy8vLy8vLy8vLy8vXFxuLy8gV0VCUEFDSyBGT09URVJcXG4vLyBleHRlcm5hbCB7XFxcInJvb3RcXFwiOlxcXCJSZWFjdFxcXCIsXFxcImNvbW1vbmpzMlxcXCI6XFxcInJlYWN0XFxcIixcXFwiY29tbW9uanNcXFwiOlxcXCJyZWFjdFxcXCIsXFxcImFtZFxcXCI6XFxcInJlYWN0XFxcIn1cXG4vLyBtb2R1bGUgaWQgPSAxMlxcbi8vIG1vZHVsZSBjaHVua3MgPSAwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vL2V4dGVybmFsXyU3QiUyMnJvb3QlMjI6JTIyUmVhY3QlMjIsJTIyY29tbW9uanMyJTIyOiUyMnJlYWN0JTIyLCUyMmNvbW1vbmpzJTIyOiUyMnJlYWN0JTIyLCUyMmFtZCUyMjolMjJyZWFjdCUyMiU3RD9cIik7XHJcblxyXG4vKioqLyB9KSxcclxuLyogMTMgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcbmV2YWwoXCJPYmplY3QuZGVmaW5lUHJvcGVydHkoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIl9fZXNNb2R1bGVcXFwiLCB7IHZhbHVlOiB0cnVlIH0pO1xcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbigkKSB7LyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9yZWFjdF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9yZWFjdF9fX2RlZmF1bHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLm4oX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX3JlYWN0X18pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0ID0gX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX18pO1xcblxcblxcbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XFxuXFxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcXFwidmFsdWVcXFwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XFxuXFxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwga2V5cykgeyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGkgaW4gb2JqKSB7IGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlOyB0YXJnZXRbaV0gPSBvYmpbaV07IH0gcmV0dXJuIHRhcmdldDsgfVxcblxcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7IH0gfVxcblxcbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcXFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXFxcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcXFwib2JqZWN0XFxcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXFxcImZ1bmN0aW9uXFxcIikgPyBjYWxsIDogc2VsZjsgfVxcblxcbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFxcXCJmdW5jdGlvblxcXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFxcXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XFxuXFxuXFxuXFxuXFxudmFyIE93bF9DYXJvdXNlbF9PcHRpb25zID0ge1xcblxcbiAgICAvLyBvcHRpb25zXFxuICAgIGl0ZW1zOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5udW1iZXIsXFxuICAgIG1hcmdpbjogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEubnVtYmVyLFxcbiAgICBsb29wOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5ib29sLFxcbiAgICBjZW50ZXI6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLmJvb2wsXFxuICAgIG1vdXNlRHJhZzogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuYm9vbCxcXG4gICAgdG91Y2hEcmFnOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5ib29sLFxcbiAgICBwdWxsRHJhZzogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuYm9vbCxcXG4gICAgZnJlZURyYWc6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLmJvb2wsXFxuICAgIHN0YWdlUGFkZGluZzogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEubnVtYmVyLFxcbiAgICBtZXJnZTogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuYm9vbCxcXG4gICAgbWVyZ2VGaXQ6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLmJvb2wsXFxuICAgIGF1dG9XaWR0aDogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuYm9vbCxcXG4gICAgc3RhcnRQb3NpdGlvbjogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEub25lT2ZUeXBlKFtfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5udW1iZXIsIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLnN0cmluZ10pLFxcbiAgICBVUkxoYXNoTGlzdGVuZXI6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLmJvb2wsXFxuICAgIG5hdjogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuYm9vbCxcXG4gICAgcmV3aW5kOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5ib29sLFxcbiAgICBuYXZUZXh0OiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5vbmVPZlR5cGUoW19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLmFycmF5T2YoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuc3RyaW5nKSwgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuYXJyYXlPZihfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5lbGVtZW50KV0pLFxcbiAgICBuYXZFbGVtZW50OiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5zdHJpbmcsXFxuICAgIHNsaWRlQnk6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLm9uZU9mVHlwZShbX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEubnVtYmVyLCBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5zdHJpbmddKSxcXG4gICAgZG90czogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuYm9vbCxcXG4gICAgZG90c0VhY2g6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLm9uZU9mVHlwZShbX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEubnVtYmVyLCBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5ib29sXSksXFxuICAgIGRvdERhdGE6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLmJvb2wsXFxuICAgIGxhenlMb2FkOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5ib29sLFxcbiAgICBsYXp5Q29udGVudDogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuYm9vbCxcXG4gICAgYXV0b3BsYXk6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLmJvb2wsXFxuICAgIGF1dG9wbGF5VGltZW91dDogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEubnVtYmVyLFxcbiAgICBhdXRvcGxheUhvdmVyUGF1c2U6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLmJvb2wsXFxuICAgIHNtYXJ0U3BlZWQ6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLm51bWJlcixcXG4gICAgZmx1aWRTcGVlZDogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuYm9vbCxcXG4gICAgYXV0b3BsYXlTcGVlZDogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEub25lT2ZUeXBlKFtfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5udW1iZXIsIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLmJvb2xdKSxcXG4gICAgbmF2U3BlZWQ6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLm9uZU9mVHlwZShbX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEubnVtYmVyLCBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5ib29sXSksXFxuICAgIGRvdHNTcGVlZDogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEub25lT2ZUeXBlKFtfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5udW1iZXIsIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLmJvb2xdKSxcXG4gICAgZHJhZ0VuZFNwZWVkOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5vbmVPZlR5cGUoW19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLm51bWJlciwgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuYm9vbF0pLFxcbiAgICBjYWxsYmFja3M6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLmJvb2wsXFxuICAgIHJlc3BvbnNpdmU6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLm9iamVjdCxcXG4gICAgcmVzcG9uc2l2ZVJlZnJlc2hSYXRlOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5udW1iZXIsXFxuICAgIHJlc3BvbnNpdmVCYXNlRWxlbWVudDogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuZWxlbWVudCxcXG4gICAgdmlkZW86IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLmJvb2wsXFxuICAgIHZpZGVvSGVpZ2h0OiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5vbmVPZlR5cGUoW19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLm51bWJlciwgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuYm9vbF0pLFxcbiAgICB2aWRlb1dpZHRoOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5vbmVPZlR5cGUoW19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLm51bWJlciwgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuYm9vbF0pLFxcbiAgICBhbmltYXRlT3V0OiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5vbmVPZlR5cGUoW19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLnN0cmluZywgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuYm9vbF0pLFxcbiAgICBhbmltYXRlSW46IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLm9uZU9mVHlwZShbX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuc3RyaW5nLCBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5ib29sXSksXFxuICAgIGZhbGxiYWNrRWFzaW5nOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5zdHJpbmcsXFxuICAgIGluZm86IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLm9uZU9mVHlwZShbX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuZnVuYywgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuYm9vbF0pLFxcbiAgICBuZXN0ZWRJdGVtU2VsZWN0b3I6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLm9uZU9mVHlwZShbX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuc3RyaW5nLCBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5ib29sXSksXFxuICAgIGl0ZW1FbGVtZW50OiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5zdHJpbmcsXFxuICAgIHN0YWdlRWxlbWVudDogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuc3RyaW5nLFxcbiAgICBuYXZDb250YWluZXI6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLm9uZU9mVHlwZShbX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuc3RyaW5nLCBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5ib29sXSksXFxuICAgIGRvdHNDb250YWluZXI6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLm9uZU9mVHlwZShbX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuc3RyaW5nLCBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5ib29sXSksXFxuXFxuICAgIC8vIGRvbSBjbGFzc1xcbiAgICByZWZyZXNoQ2xhc3M6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLnN0cmluZyxcXG4gICAgbG9hZGluZ0NsYXNzOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5zdHJpbmcsXFxuICAgIGxvYWRlZENsYXNzOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5zdHJpbmcsXFxuICAgIHJ0bENsYXNzOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5zdHJpbmcsXFxuICAgIGRyYWdDbGFzczogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuc3RyaW5nLFxcbiAgICBncmFiQ2xhc3M6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLnN0cmluZyxcXG4gICAgc3RhZ2VDbGFzczogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuc3RyaW5nLFxcbiAgICBzdGFnZU91dGVyQ2xhc3M6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLnN0cmluZyxcXG4gICAgbmF2Q29udGFpbmVyQ2xhc3M6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLnN0cmluZyxcXG4gICAgbmF2Q2xhc3M6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLmFycmF5T2YoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuc3RyaW5nKSxcXG4gICAgY29udHJvbHNDbGFzczogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuc3RyaW5nLFxcbiAgICBkb3RDbGFzczogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuc3RyaW5nLFxcbiAgICBkb3RzQ2xhc3M6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLnN0cmluZyxcXG4gICAgYXV0b0hlaWdodENsYXNzOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5zdHJpbmcsXFxuICAgIHJlc3BvbnNpdmVDbGFzczogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEub25lT2ZUeXBlKFtfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5zdHJpbmcsIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLmJvb2xdKSxcXG5cXG4gICAgLy8gZXZlbnRcXG4gICAgb25Jbml0aWFsaXplOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5mdW5jLFxcbiAgICBvbkluaXRpYWxpemVkOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5mdW5jLFxcbiAgICBvblJlc2l6ZTogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuZnVuYyxcXG4gICAgb25SZXNpemVkOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5mdW5jLFxcbiAgICBvblJlZnJlc2g6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLmZ1bmMsXFxuICAgIG9uUmVmcmVzaGVkOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5mdW5jLFxcbiAgICBvbkRyYWc6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLmZ1bmMsXFxuICAgIG9uRHJhZ2dlZDogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuZnVuYyxcXG4gICAgb25UcmFuc2xhdGU6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLmZ1bmMsXFxuICAgIG9uVHJhbnNsYXRlZDogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuZnVuYyxcXG4gICAgb25DaGFuZ2U6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLmZ1bmMsXFxuICAgIG9uQ2hhbmdlZDogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuZnVuYyxcXG4gICAgb25Mb2FkTGF6eTogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuZnVuYyxcXG4gICAgb25Mb2FkZWRMYXp5OiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfcHJvcF90eXBlc19fX2RlZmF1bHQuYS5mdW5jLFxcbiAgICBvblN0b3BWaWRlbzogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Byb3BfdHlwZXNfX19kZWZhdWx0LmEuZnVuYyxcXG4gICAgb25QbGF5VmlkZW86IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9wcm9wX3R5cGVzX19fZGVmYXVsdC5hLmZ1bmNcXG59O1xcblxcbnZhciBPd2xDYXJvdXNlbCA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XFxuICAgIF9pbmhlcml0cyhPd2xDYXJvdXNlbCwgX0NvbXBvbmVudCk7XFxuXFxuICAgIGZ1bmN0aW9uIE93bENhcm91c2VsKHByb3BzLCBjb250ZXh0KSB7XFxuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgT3dsQ2Fyb3VzZWwpO1xcblxcbiAgICAgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKE93bENhcm91c2VsLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoT3dsQ2Fyb3VzZWwpKS5jYWxsKHRoaXMsIHByb3BzLCBjb250ZXh0KSk7XFxuXFxuICAgICAgICBfdGhpcy5uZXh0ID0gX3RoaXMubmV4dC5iaW5kKF90aGlzKTtcXG4gICAgICAgIF90aGlzLnByZXYgPSBfdGhpcy5wcmV2LmJpbmQoX3RoaXMpO1xcbiAgICAgICAgX3RoaXMudG8gPSBfdGhpcy50by5iaW5kKF90aGlzKTtcXG4gICAgICAgIF90aGlzLmNyZWF0ZSA9IF90aGlzLmNyZWF0ZS5iaW5kKF90aGlzKTtcXG4gICAgICAgIF90aGlzLmRlc3RvcnkgPSBfdGhpcy5kZXN0b3J5LmJpbmQoX3RoaXMpO1xcbiAgICAgICAgX3RoaXMucGxheSA9IF90aGlzLnBsYXkuYmluZChfdGhpcyk7XFxuICAgICAgICBfdGhpcy5zdG9wID0gX3RoaXMuc3RvcC5iaW5kKF90aGlzKTtcXG4gICAgICAgIHJldHVybiBfdGhpcztcXG4gICAgfVxcblxcbiAgICBfY3JlYXRlQ2xhc3MoT3dsQ2Fyb3VzZWwsIFt7XFxuICAgICAgICBrZXk6ICdjb21wb25lbnRXaWxsTW91bnQnLFxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcXG4gICAgICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcXG4gICAgICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcXG4gICAgICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xcblxcbiAgICAgICAgICAgIHRoaXMuX2ZpbHRlclByb3BzKHRoaXMucHJvcHMpO1xcbiAgICAgICAgfVxcbiAgICB9LCB7XFxuICAgICAgICBrZXk6ICdjb21wb25lbnREaWRNb3VudCcsXFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XFxuICAgICAgICAgICAgdGhpcy5vd2xDYXJvdXNlbCA9ICQodGhpcy5pbnN0KTtcXG4gICAgICAgICAgICB0aGlzLm93bENhcm91c2VsLm93bENhcm91c2VsKHRoaXMub3B0aW9ucyk7XFxuICAgICAgICB9XFxuICAgIH0sIHtcXG4gICAgICAgIGtleTogJ2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMnLFxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XFxuICAgICAgICAgICAgdGhpcy5fZmlsdGVyUHJvcHMobmV4dFByb3BzKTtcXG4gICAgICAgICAgICB0aGlzLmRlc3RvcnkoKTtcXG4gICAgICAgIH1cXG4gICAgfSwge1xcbiAgICAgICAga2V5OiAnY29tcG9uZW50RGlkVXBkYXRlJyxcXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUoKSB7XFxuICAgICAgICAgICAgdGhpcy5vd2xDYXJvdXNlbCA9ICQodGhpcy5pbnN0KTtcXG4gICAgICAgICAgICB0aGlzLm93bENhcm91c2VsLm93bENhcm91c2VsKHRoaXMub3B0aW9ucyk7XFxuICAgICAgICB9XFxuICAgIH0sIHtcXG4gICAgICAgIGtleTogJ2NvbXBvbmVudFdpbGxVbm1vdW50JyxcXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcXG4gICAgICAgICAgICB0aGlzLmRlc3RvcnkoKTtcXG4gICAgICAgIH1cXG4gICAgfSwge1xcbiAgICAgICAga2V5OiAnbmV4dCcsXFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbmV4dChzcGVlZCkge1xcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3BlZWQgPT0gJ251bWJlcicpIHtcXG4gICAgICAgICAgICAgICAgdGhpcy5vd2xDYXJvdXNlbC50cmlnZ2VyKCduZXh0Lm93bC5jYXJvdXNlbCcsIFtzcGVlZF0pO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIHRoaXMub3dsQ2Fyb3VzZWwudHJpZ2dlcignbmV4dC5vd2wuY2Fyb3VzZWwnKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgIH0sIHtcXG4gICAgICAgIGtleTogJ3ByZXYnLFxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHByZXYoc3BlZWQpIHtcXG4gICAgICAgICAgICBpZiAodHlwZW9mIHNwZWVkID09ICdudW1iZXInKSB7XFxuICAgICAgICAgICAgICAgIHRoaXMub3dsQ2Fyb3VzZWwudHJpZ2dlcigncHJldi5vd2wuY2Fyb3VzZWwnLCBbc3BlZWRdKTtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICB0aGlzLm93bENhcm91c2VsLnRyaWdnZXIoJ3ByZXYub3dsLmNhcm91c2VsJyk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgLy8gcmVmcmVzaChldmVudCwgc3BlZWQpIHtcXG4gICAgICAgIC8vIH1cXG5cXG4gICAgfSwge1xcbiAgICAgICAga2V5OiAndG8nLFxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvKHBvc2l0aW9uLCBzcGVlZCkge1xcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcG9zaXRpb24gPT0gJ251bWJlcicgJiYgdHlwZW9mIHNwZWVkID09ICdudW1iZXInKSB7XFxuICAgICAgICAgICAgICAgIHRoaXMub3dsQ2Fyb3VzZWwudHJpZ2dlcigndG8ub3dsLmNhcm91c2VsJywgW3Bvc2l0aW9uLCBzcGVlZF0pO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIHRoaXMub3dsQ2Fyb3VzZWwudHJpZ2dlcigndG8ub3dsLmNhcm91c2VsJyk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICB9LCB7XFxuICAgICAgICBrZXk6ICdjcmVhdGUnLFxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcXG4gICAgICAgICAgICB0aGlzLm93bENhcm91c2VsLm93bENhcm91c2VsKHRoaXMub3B0aW9ucyk7XFxuICAgICAgICB9XFxuICAgIH0sIHtcXG4gICAgICAgIGtleTogJ2Rlc3RvcnknLFxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3RvcnkoKSB7XFxuICAgICAgICAgICAgdGhpcy5vd2xDYXJvdXNlbC50cmlnZ2VyKCdkZXN0cm95Lm93bC5jYXJvdXNlbCcpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgLy8gcmVwbGFjZShkYXRhKSB7XFxuXFxuICAgICAgICAvLyB9XFxuXFxuICAgICAgICAvLyBhZGQoZGF0YSwgcG9zaXRpb24pIHtcXG5cXG4gICAgICAgIC8vIH1cXG5cXG4gICAgICAgIC8vIHJlbW92ZShwb3NpdGlvbikge1xcblxcbiAgICAgICAgLy8gfVxcblxcbiAgICB9LCB7XFxuICAgICAgICBrZXk6ICdwbGF5JyxcXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBwbGF5KHRpbWVvdXQsIHNwZWVkKSB7XFxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aW1lb3V0ID09ICdudW1iZXInICYmIHR5cGVvZiBzcGVlZCA9PSAnbnVtYmVyJykge1xcbiAgICAgICAgICAgICAgICB0aGlzLm93bENhcm91c2VsLnRyaWdnZXIoJ3BsYXkub3dsLmF1dG9wbGF5JywgW3RpbWVvdXQsIHNwZWVkXSk7XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgdGhpcy5vd2xDYXJvdXNlbC50cmlnZ2VyKCdwbGF5Lm93bC5hdXRvcGxheScpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgfSwge1xcbiAgICAgICAga2V5OiAnc3RvcCcsXFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc3RvcCgpIHtcXG4gICAgICAgICAgICB0aGlzLm93bENhcm91c2VsLnRyaWdnZXIoJ3N0b3Aub3dsLmF1dG9wbGF5Jyk7XFxuICAgICAgICB9XFxuICAgIH0sIHtcXG4gICAgICAgIGtleTogJ19maWx0ZXJQcm9wcycsXFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpbHRlclByb3BzKHByb3BzKSB7XFxuICAgICAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XFxuXFxuICAgICAgICAgICAgdGhpcy5vcHRpb25zID0ge307XFxuICAgICAgICAgICAgdGhpcy5wcm9wc1dpdGhvdXRPcHRpb25zID0ge307XFxuICAgICAgICAgICAgT2JqZWN0LmtleXMocHJvcHMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xcbiAgICAgICAgICAgICAgICBpZiAoT3dsX0Nhcm91c2VsX09wdGlvbnMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMyLm9wdGlvbnNba2V5XSA9IHByb3BzW2tleV07XFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICBfdGhpczIucHJvcHNXaXRob3V0T3B0aW9uc1trZXldID0gcHJvcHNba2V5XTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcbiAgICB9LCB7XFxuICAgICAgICBrZXk6ICdyZW5kZXInLFxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcXG4gICAgICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcXG5cXG4gICAgICAgICAgICB2YXIgX3Byb3BzV2l0aG91dE9wdGlvbnMgPSB0aGlzLnByb3BzV2l0aG91dE9wdGlvbnMsXFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZSA9IF9wcm9wc1dpdGhvdXRPcHRpb25zLmNsYXNzTmFtZSxcXG4gICAgICAgICAgICAgICAgY2hpbGRyZW4gPSBfcHJvcHNXaXRob3V0T3B0aW9ucy5jaGlsZHJlbixcXG4gICAgICAgICAgICAgICAgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3Byb3BzV2l0aG91dE9wdGlvbnMsIFsnY2xhc3NOYW1lJywgJ2NoaWxkcmVuJ10pO1xcblxcbiAgICAgICAgICAgIHJldHVybiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfcmVhY3RfX19kZWZhdWx0LmEuY3JlYXRlRWxlbWVudChcXG4gICAgICAgICAgICAgICAgJ2RpdicsXFxuICAgICAgICAgICAgICAgIF9leHRlbmRzKHtcXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ293bC1jYXJvdXNlbCAnICsgY2xhc3NOYW1lLFxcbiAgICAgICAgICAgICAgICAgICAgcmVmOiBmdW5jdGlvbiByZWYoaW5zdCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczMuaW5zdCA9IGluc3Q7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH0sIHByb3BzKSxcXG4gICAgICAgICAgICAgICAgY2hpbGRyZW5cXG4gICAgICAgICAgICApO1xcbiAgICAgICAgfVxcbiAgICB9XSk7XFxuXFxuICAgIHJldHVybiBPd2xDYXJvdXNlbDtcXG59KF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9yZWFjdF9fW1xcXCJDb21wb25lbnRcXFwiXSk7XFxuXFxuT3dsQ2Fyb3VzZWwucHJvcFR5cGVzID0gT3dsX0Nhcm91c2VsX09wdGlvbnM7XFxuXFxuT3dsQ2Fyb3VzZWwuZGVmYXVsdFByb3BzID0ge1xcbiAgICBjbGFzc05hbWU6ICcnXFxufTtcXG5cXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXFxcImRlZmF1bHRcXFwiXSA9IChPd2xDYXJvdXNlbCk7XFxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18oMSkpKVxcblxcbi8vLy8vLy8vLy8vLy8vLy8vL1xcbi8vIFdFQlBBQ0sgRk9PVEVSXFxuLy8gLi9jb21wb25lbnRzL093bENhcm91c2VsLmpzeFxcbi8vIG1vZHVsZSBpZCA9IDEzXFxuLy8gbW9kdWxlIGNodW5rcyA9IDBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9jb21wb25lbnRzL093bENhcm91c2VsLmpzeD9cIik7XHJcblxyXG4vKioqLyB9KSxcclxuLyogMTQgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuZXZhbChcInZhciBlc2NhcGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpKGZhbHNlKTtcXG4vLyBpbXBvcnRzXFxuXFxuXFxuLy8gbW9kdWxlXFxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaSwgXFxcIi8qKlxcXFxuICogT3dsIENhcm91c2VsIHYyLjIuMFxcXFxuICogQ29weXJpZ2h0IDIwMTMtMjAxNiBEYXZpZCBEZXV0c2NoXFxcXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS9Pd2xDYXJvdXNlbDIvT3dsQ2Fyb3VzZWwyL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXFxcXG4gKi9cXFxcbi5vd2wtY2Fyb3VzZWwsLm93bC1jYXJvdXNlbCAub3dsLWl0ZW17LXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOnRyYW5zcGFyZW50O3Bvc2l0aW9uOnJlbGF0aXZlfS5vd2wtY2Fyb3VzZWx7ZGlzcGxheTpub25lO3dpZHRoOjEwMCU7ei1pbmRleDoxfS5vd2wtY2Fyb3VzZWwgLm93bC1zdGFnZXtwb3NpdGlvbjpyZWxhdGl2ZTstbXMtdG91Y2gtYWN0aW9uOnBhbi1ZfS5vd2wtY2Fyb3VzZWwgLm93bC1zdGFnZTphZnRlcntjb250ZW50OlxcXFxcXFwiLlxcXFxcXFwiO2Rpc3BsYXk6YmxvY2s7Y2xlYXI6Ym90aDt2aXNpYmlsaXR5OmhpZGRlbjtsaW5lLWhlaWdodDowO2hlaWdodDowfS5vd2wtY2Fyb3VzZWwgLm93bC1zdGFnZS1vdXRlcntwb3NpdGlvbjpyZWxhdGl2ZTtvdmVyZmxvdzpoaWRkZW47LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlM2QoMCwwLDApfS5vd2wtY2Fyb3VzZWwgLm93bC1pdGVte21pbi1oZWlnaHQ6MXB4O2Zsb2F0OmxlZnQ7LXdlYmtpdC1iYWNrZmFjZS12aXNpYmlsaXR5OmhpZGRlbjstd2Via2l0LXRvdWNoLWNhbGxvdXQ6bm9uZX0ub3dsLWNhcm91c2VsIC5vd2wtaXRlbSBpbWd7ZGlzcGxheTpibG9jazt3aWR0aDoxMDAlOy13ZWJraXQtdHJhbnNmb3JtLXN0eWxlOnByZXNlcnZlLTNkfS5vd2wtY2Fyb3VzZWwgLm93bC1kb3RzLmRpc2FibGVkLC5vd2wtY2Fyb3VzZWwgLm93bC1uYXYuZGlzYWJsZWR7ZGlzcGxheTpub25lfS5uby1qcyAub3dsLWNhcm91c2VsLC5vd2wtY2Fyb3VzZWwub3dsLWxvYWRlZHtkaXNwbGF5OmJsb2NrfS5vd2wtY2Fyb3VzZWwgLm93bC1kb3QsLm93bC1jYXJvdXNlbCAub3dsLW5hdiAub3dsLW5leHQsLm93bC1jYXJvdXNlbCAub3dsLW5hdiAub3dsLXByZXZ7Y3Vyc29yOnBvaW50ZXI7Y3Vyc29yOmhhbmQ7LXdlYmtpdC11c2VyLXNlbGVjdDpub25lOy1raHRtbC11c2VyLXNlbGVjdDpub25lOy1tb3otdXNlci1zZWxlY3Q6bm9uZTstbXMtdXNlci1zZWxlY3Q6bm9uZTt1c2VyLXNlbGVjdDpub25lfS5vd2wtY2Fyb3VzZWwub3dsLWxvYWRpbmd7b3BhY2l0eTowO2Rpc3BsYXk6YmxvY2t9Lm93bC1jYXJvdXNlbC5vd2wtaGlkZGVue29wYWNpdHk6MH0ub3dsLWNhcm91c2VsLm93bC1yZWZyZXNoIC5vd2wtaXRlbXt2aXNpYmlsaXR5OmhpZGRlbn0ub3dsLWNhcm91c2VsLm93bC1kcmFnIC5vd2wtaXRlbXstd2Via2l0LXVzZXItc2VsZWN0Om5vbmU7LW1vei11c2VyLXNlbGVjdDpub25lOy1tcy11c2VyLXNlbGVjdDpub25lO3VzZXItc2VsZWN0Om5vbmV9Lm93bC1jYXJvdXNlbC5vd2wtZ3JhYntjdXJzb3I6bW92ZTtjdXJzb3I6Z3JhYn0ub3dsLWNhcm91c2VsLm93bC1ydGx7ZGlyZWN0aW9uOnJ0bH0ub3dsLWNhcm91c2VsLm93bC1ydGwgLm93bC1pdGVte2Zsb2F0OnJpZ2h0fS5vd2wtY2Fyb3VzZWwgLmFuaW1hdGVkey13ZWJraXQtYW5pbWF0aW9uLWR1cmF0aW9uOjFzO2FuaW1hdGlvbi1kdXJhdGlvbjoxczstd2Via2l0LWFuaW1hdGlvbi1maWxsLW1vZGU6Ym90aDthbmltYXRpb24tZmlsbC1tb2RlOmJvdGh9Lm93bC1jYXJvdXNlbCAub3dsLWFuaW1hdGVkLWlue3otaW5kZXg6MH0ub3dsLWNhcm91c2VsIC5vd2wtYW5pbWF0ZWQtb3V0e3otaW5kZXg6MX0ub3dsLWNhcm91c2VsIC5mYWRlT3V0ey13ZWJraXQtYW5pbWF0aW9uLW5hbWU6ZmFkZU91dDthbmltYXRpb24tbmFtZTpmYWRlT3V0fUAtd2Via2l0LWtleWZyYW1lcyBmYWRlT3V0ezAle29wYWNpdHk6MX0xMDAle29wYWNpdHk6MH19QGtleWZyYW1lcyBmYWRlT3V0ezAle29wYWNpdHk6MX0xMDAle29wYWNpdHk6MH19Lm93bC1oZWlnaHR7dHJhbnNpdGlvbjpoZWlnaHQgLjVzIGVhc2UtaW4tb3V0fS5vd2wtY2Fyb3VzZWwgLm93bC1pdGVtIC5vd2wtbGF6eXtvcGFjaXR5OjA7dHJhbnNpdGlvbjpvcGFjaXR5IC40cyBlYXNlfS5vd2wtY2Fyb3VzZWwgLm93bC1pdGVtIGltZy5vd2wtbGF6eXstd2Via2l0LXRyYW5zZm9ybS1zdHlsZTpwcmVzZXJ2ZS0zZDt0cmFuc2Zvcm0tc3R5bGU6cHJlc2VydmUtM2R9Lm93bC1jYXJvdXNlbCAub3dsLXZpZGVvLXdyYXBwZXJ7cG9zaXRpb246cmVsYXRpdmU7aGVpZ2h0OjEwMCU7YmFja2dyb3VuZDojMDAwfS5vd2wtY2Fyb3VzZWwgLm93bC12aWRlby1wbGF5LWljb257cG9zaXRpb246YWJzb2x1dGU7aGVpZ2h0OjgwcHg7d2lkdGg6ODBweDtsZWZ0OjUwJTt0b3A6NTAlO21hcmdpbi1sZWZ0Oi00MHB4O21hcmdpbi10b3A6LTQwcHg7YmFja2dyb3VuZDp1cmwoXFxcIiArIGVzY2FwZShfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KSkgKyBcXFwiKSBuby1yZXBlYXQ7Y3Vyc29yOnBvaW50ZXI7ei1pbmRleDoxOy13ZWJraXQtYmFja2ZhY2UtdmlzaWJpbGl0eTpoaWRkZW47dHJhbnNpdGlvbjotd2Via2l0LXRyYW5zZm9ybSAuMXMgZWFzZTt0cmFuc2l0aW9uOnRyYW5zZm9ybSAuMXMgZWFzZX0ub3dsLWNhcm91c2VsIC5vd2wtdmlkZW8tcGxheS1pY29uOmhvdmVyey13ZWJraXQtdHJhbnNmb3JtOnNjYWxlKDEuMywxLjMpOy1tcy10cmFuc2Zvcm06c2NhbGUoMS4zLDEuMyk7dHJhbnNmb3JtOnNjYWxlKDEuMywxLjMpfS5vd2wtY2Fyb3VzZWwgLm93bC12aWRlby1wbGF5aW5nIC5vd2wtdmlkZW8tcGxheS1pY29uLC5vd2wtY2Fyb3VzZWwgLm93bC12aWRlby1wbGF5aW5nIC5vd2wtdmlkZW8tdG57ZGlzcGxheTpub25lfS5vd2wtY2Fyb3VzZWwgLm93bC12aWRlby10bntvcGFjaXR5OjA7aGVpZ2h0OjEwMCU7YmFja2dyb3VuZC1wb3NpdGlvbjpjZW50ZXIgY2VudGVyO2JhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdDtiYWNrZ3JvdW5kLXNpemU6Y29udGFpbjt0cmFuc2l0aW9uOm9wYWNpdHkgLjRzIGVhc2V9Lm93bC1jYXJvdXNlbCAub3dsLXZpZGVvLWZyYW1le3Bvc2l0aW9uOnJlbGF0aXZlO3otaW5kZXg6MTtoZWlnaHQ6MTAwJTt3aWR0aDoxMDAlfVxcXCIsIFxcXCJcXFwiXSk7XFxuXFxuLy8gZXhwb3J0c1xcblxcblxcbi8vLy8vLy8vLy8vLy8vLy8vL1xcbi8vIFdFQlBBQ0sgRk9PVEVSXFxuLy8gLi9+L2Nzcy1sb2FkZXIhLi9+L293bC5jYXJvdXNlbC9kaXN0L2Fzc2V0cy9vd2wuY2Fyb3VzZWwubWluLmNzc1xcbi8vIG1vZHVsZSBpZCA9IDE0XFxuLy8gbW9kdWxlIGNodW5rcyA9IDBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9+L293bC5jYXJvdXNlbC9kaXN0L2Fzc2V0cy9vd2wuY2Fyb3VzZWwubWluLmNzcz8uL34vY3NzLWxvYWRlclwiKTtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAxNSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5ldmFsKFwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KShmYWxzZSk7XFxuLy8gaW1wb3J0c1xcblxcblxcbi8vIG1vZHVsZVxcbmV4cG9ydHMucHVzaChbbW9kdWxlLmksIFxcXCIvKipcXFxcbiAqIE93bCBDYXJvdXNlbCB2Mi4yLjBcXFxcbiAqIENvcHlyaWdodCAyMDEzLTIwMTYgRGF2aWQgRGV1dHNjaFxcXFxuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vT3dsQ2Fyb3VzZWwyL093bENhcm91c2VsMi9ibG9iL21hc3Rlci9MSUNFTlNFKVxcXFxuICovXFxcXG4ub3dsLXRoZW1lIC5vd2wtZG90cywub3dsLXRoZW1lIC5vd2wtbmF2e3RleHQtYWxpZ246Y2VudGVyOy13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcjp0cmFuc3BhcmVudH0ub3dsLXRoZW1lIC5vd2wtbmF2e21hcmdpbi10b3A6MTBweH0ub3dsLXRoZW1lIC5vd2wtbmF2IFtjbGFzcyo9b3dsLV17Y29sb3I6I0ZGRjtmb250LXNpemU6MTRweDttYXJnaW46NXB4O3BhZGRpbmc6NHB4IDdweDtiYWNrZ3JvdW5kOiNENkQ2RDY7ZGlzcGxheTppbmxpbmUtYmxvY2s7Y3Vyc29yOnBvaW50ZXI7Ym9yZGVyLXJhZGl1czozcHh9Lm93bC10aGVtZSAub3dsLW5hdiBbY2xhc3MqPW93bC1dOmhvdmVye2JhY2tncm91bmQ6Izg2OTc5MTtjb2xvcjojRkZGO3RleHQtZGVjb3JhdGlvbjpub25lfS5vd2wtdGhlbWUgLm93bC1uYXYgLmRpc2FibGVke29wYWNpdHk6LjU7Y3Vyc29yOmRlZmF1bHR9Lm93bC10aGVtZSAub3dsLW5hdi5kaXNhYmxlZCsub3dsLWRvdHN7bWFyZ2luLXRvcDoxMHB4fS5vd2wtdGhlbWUgLm93bC1kb3RzIC5vd2wtZG90e2Rpc3BsYXk6aW5saW5lLWJsb2NrO3pvb206MX0ub3dsLXRoZW1lIC5vd2wtZG90cyAub3dsLWRvdCBzcGFue3dpZHRoOjEwcHg7aGVpZ2h0OjEwcHg7bWFyZ2luOjVweCA3cHg7YmFja2dyb3VuZDojRDZENkQ2O2Rpc3BsYXk6YmxvY2s7LXdlYmtpdC1iYWNrZmFjZS12aXNpYmlsaXR5OnZpc2libGU7dHJhbnNpdGlvbjpvcGFjaXR5IC4ycyBlYXNlO2JvcmRlci1yYWRpdXM6MzBweH0ub3dsLXRoZW1lIC5vd2wtZG90cyAub3dsLWRvdC5hY3RpdmUgc3Bhbiwub3dsLXRoZW1lIC5vd2wtZG90cyAub3dsLWRvdDpob3ZlciBzcGFue2JhY2tncm91bmQ6Izg2OTc5MX1cXFwiLCBcXFwiXFxcIl0pO1xcblxcbi8vIGV4cG9ydHNcXG5cXG5cXG4vLy8vLy8vLy8vLy8vLy8vLy9cXG4vLyBXRUJQQUNLIEZPT1RFUlxcbi8vIC4vfi9jc3MtbG9hZGVyIS4vfi9vd2wuY2Fyb3VzZWwvZGlzdC9hc3NldHMvb3dsLnRoZW1lLmRlZmF1bHQubWluLmNzc1xcbi8vIG1vZHVsZSBpZCA9IDE1XFxuLy8gbW9kdWxlIGNodW5rcyA9IDBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9+L293bC5jYXJvdXNlbC9kaXN0L2Fzc2V0cy9vd2wudGhlbWUuZGVmYXVsdC5taW4uY3NzPy4vfi9jc3MtbG9hZGVyXCIpO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDE2ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcbmV2YWwoXCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVzY2FwZSh1cmwpIHtcXG4gICAgaWYgKHR5cGVvZiB1cmwgIT09ICdzdHJpbmcnKSB7XFxuICAgICAgICByZXR1cm4gdXJsXFxuICAgIH1cXG4gICAgLy8gSWYgdXJsIGlzIGFscmVhZHkgd3JhcHBlZCBpbiBxdW90ZXMsIHJlbW92ZSB0aGVtXFxuICAgIGlmICgvXlsnXFxcIl0uKlsnXFxcIl0kLy50ZXN0KHVybCkpIHtcXG4gICAgICAgIHVybCA9IHVybC5zbGljZSgxLCAtMSk7XFxuICAgIH1cXG4gICAgLy8gU2hvdWxkIHVybCBiZSB3cmFwcGVkP1xcbiAgICAvLyBTZWUgaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzcy12YWx1ZXMtMy8jdXJsc1xcbiAgICBpZiAoL1tcXFwiJygpIFxcXFx0XFxcXG5dLy50ZXN0KHVybCkpIHtcXG4gICAgICAgIHJldHVybiAnXFxcIicgKyB1cmwucmVwbGFjZSgvXFxcIi9nLCAnXFxcXFxcXFxcXFwiJykucmVwbGFjZSgvXFxcXG4vZywgJ1xcXFxcXFxcbicpICsgJ1xcXCInXFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIHVybFxcbn1cXG5cXG5cXG4vLy8vLy8vLy8vLy8vLy8vLy9cXG4vLyBXRUJQQUNLIEZPT1RFUlxcbi8vIC4vfi9jc3MtbG9hZGVyL2xpYi91cmwvZXNjYXBlLmpzXFxuLy8gbW9kdWxlIGlkID0gMTZcXG4vLyBtb2R1bGUgY2h1bmtzID0gMFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL34vY3NzLWxvYWRlci9saWIvdXJsL2VzY2FwZS5qcz9cIik7XHJcblxyXG4vKioqLyB9KSxcclxuLyogMTcgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuZXZhbChcIm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXy5wICsgXFxcIjRhMzdmODAwODk1OWM3NWY2MTliZjBhM2E0ZTJkN2EyLnBuZ1xcXCI7XFxuXFxuLy8vLy8vLy8vLy8vLy8vLy8vXFxuLy8gV0VCUEFDSyBGT09URVJcXG4vLyAuL34vb3dsLmNhcm91c2VsL2Rpc3QvYXNzZXRzL293bC52aWRlby5wbGF5LnBuZ1xcbi8vIG1vZHVsZSBpZCA9IDE3XFxuLy8gbW9kdWxlIGNodW5rcyA9IDBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9+L293bC5jYXJvdXNlbC9kaXN0L2Fzc2V0cy9vd2wudmlkZW8ucGxheS5wbmc/XCIpO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDE4ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5ldmFsKFwiLypcXG5vYmplY3QtYXNzaWduXFxuKGMpIFNpbmRyZSBTb3JodXNcXG5AbGljZW5zZSBNSVRcXG4qL1xcblxcblxcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXFxudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XFxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcXG52YXIgcHJvcElzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XFxuXFxuZnVuY3Rpb24gdG9PYmplY3QodmFsKSB7XFxuXFx0aWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkge1xcblxcdFxcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5hc3NpZ24gY2Fubm90IGJlIGNhbGxlZCB3aXRoIG51bGwgb3IgdW5kZWZpbmVkJyk7XFxuXFx0fVxcblxcblxcdHJldHVybiBPYmplY3QodmFsKTtcXG59XFxuXFxuZnVuY3Rpb24gc2hvdWxkVXNlTmF0aXZlKCkge1xcblxcdHRyeSB7XFxuXFx0XFx0aWYgKCFPYmplY3QuYXNzaWduKSB7XFxuXFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBEZXRlY3QgYnVnZ3kgcHJvcGVydHkgZW51bWVyYXRpb24gb3JkZXIgaW4gb2xkZXIgVjggdmVyc2lvbnMuXFxuXFxuXFx0XFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9NDExOFxcblxcdFxcdHZhciB0ZXN0MSA9IG5ldyBTdHJpbmcoJ2FiYycpOyAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXctd3JhcHBlcnNcXG5cXHRcXHR0ZXN0MVs1XSA9ICdkZSc7XFxuXFx0XFx0aWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QxKVswXSA9PT0gJzUnKSB7XFxuXFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XFxuXFx0XFx0dmFyIHRlc3QyID0ge307XFxuXFx0XFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XFxuXFx0XFx0XFx0dGVzdDJbJ18nICsgU3RyaW5nLmZyb21DaGFyQ29kZShpKV0gPSBpO1xcblxcdFxcdH1cXG5cXHRcXHR2YXIgb3JkZXIyID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDIpLm1hcChmdW5jdGlvbiAobikge1xcblxcdFxcdFxcdHJldHVybiB0ZXN0MltuXTtcXG5cXHRcXHR9KTtcXG5cXHRcXHRpZiAob3JkZXIyLmpvaW4oJycpICE9PSAnMDEyMzQ1Njc4OScpIHtcXG5cXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcXG5cXHRcXHR2YXIgdGVzdDMgPSB7fTtcXG5cXHRcXHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChsZXR0ZXIpIHtcXG5cXHRcXHRcXHR0ZXN0M1tsZXR0ZXJdID0gbGV0dGVyO1xcblxcdFxcdH0pO1xcblxcdFxcdGlmIChPYmplY3Qua2V5cyhPYmplY3QuYXNzaWduKHt9LCB0ZXN0MykpLmpvaW4oJycpICE9PVxcblxcdFxcdFxcdFxcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcpIHtcXG5cXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiB0cnVlO1xcblxcdH0gY2F0Y2ggKGVycikge1xcblxcdFxcdC8vIFdlIGRvbid0IGV4cGVjdCBhbnkgb2YgdGhlIGFib3ZlIHRvIHRocm93LCBidXQgYmV0dGVyIHRvIGJlIHNhZmUuXFxuXFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdH1cXG59XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBzaG91bGRVc2VOYXRpdmUoKSA/IE9iamVjdC5hc3NpZ24gOiBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcXG5cXHR2YXIgZnJvbTtcXG5cXHR2YXIgdG8gPSB0b09iamVjdCh0YXJnZXQpO1xcblxcdHZhciBzeW1ib2xzO1xcblxcblxcdGZvciAodmFyIHMgPSAxOyBzIDwgYXJndW1lbnRzLmxlbmd0aDsgcysrKSB7XFxuXFx0XFx0ZnJvbSA9IE9iamVjdChhcmd1bWVudHNbc10pO1xcblxcblxcdFxcdGZvciAodmFyIGtleSBpbiBmcm9tKSB7XFxuXFx0XFx0XFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xcblxcdFxcdFxcdFxcdHRvW2tleV0gPSBmcm9tW2tleV07XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAoZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XFxuXFx0XFx0XFx0c3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9scyhmcm9tKTtcXG5cXHRcXHRcXHRmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRpZiAocHJvcElzRW51bWVyYWJsZS5jYWxsKGZyb20sIHN5bWJvbHNbaV0pKSB7XFxuXFx0XFx0XFx0XFx0XFx0dG9bc3ltYm9sc1tpXV0gPSBmcm9tW3N5bWJvbHNbaV1dO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdH1cXG5cXG5cXHRyZXR1cm4gdG87XFxufTtcXG5cXG5cXG4vLy8vLy8vLy8vLy8vLy8vLy9cXG4vLyBXRUJQQUNLIEZPT1RFUlxcbi8vIC4vfi9vYmplY3QtYXNzaWduL2luZGV4LmpzXFxuLy8gbW9kdWxlIGlkID0gMThcXG4vLyBtb2R1bGUgY2h1bmtzID0gMFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL34vb2JqZWN0LWFzc2lnbi9pbmRleC5qcz9cIik7XHJcblxyXG4vKioqLyB9KSxcclxuLyogMTkgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcbmV2YWwoXCIvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24ocHJvY2Vzcykgey8qKlxcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxcbiAqXFxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXFxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxcbiAqL1xcblxcblxcblxcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XFxuICB2YXIgaW52YXJpYW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcXG4gIHZhciB3YXJuaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcXG4gIHZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XFxuICB2YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XFxufVxcblxcbi8qKlxcbiAqIEFzc2VydCB0aGF0IHRoZSB2YWx1ZXMgbWF0Y2ggd2l0aCB0aGUgdHlwZSBzcGVjcy5cXG4gKiBFcnJvciBtZXNzYWdlcyBhcmUgbWVtb3JpemVkIGFuZCB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cXG4gKlxcbiAqIEBwYXJhbSB7b2JqZWN0fSB0eXBlU3BlY3MgTWFwIG9mIG5hbWUgdG8gYSBSZWFjdFByb3BUeXBlXFxuICogQHBhcmFtIHtvYmplY3R9IHZhbHVlcyBSdW50aW1lIHZhbHVlcyB0aGF0IG5lZWQgdG8gYmUgdHlwZS1jaGVja2VkXFxuICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uIGUuZy4gXFxcInByb3BcXFwiLCBcXFwiY29udGV4dFxcXCIsIFxcXCJjaGlsZCBjb250ZXh0XFxcIlxcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wb25lbnROYW1lIE5hbWUgb2YgdGhlIGNvbXBvbmVudCBmb3IgZXJyb3IgbWVzc2FnZXMuXFxuICogQHBhcmFtIHs/RnVuY3Rpb259IGdldFN0YWNrIFJldHVybnMgdGhlIGNvbXBvbmVudCBzdGFjay5cXG4gKiBAcHJpdmF0ZVxcbiAqL1xcbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZ2V0U3RhY2spIHtcXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XFxuICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcXG4gICAgICBpZiAodHlwZVNwZWNzLmhhc093blByb3BlcnR5KHR5cGVTcGVjTmFtZSkpIHtcXG4gICAgICAgIHZhciBlcnJvcjtcXG4gICAgICAgIC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXFxuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXFxuICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXFxuICAgICAgICB0cnkge1xcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxcbiAgICAgICAgICBpbnZhcmlhbnQodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdID09PSAnZnVuY3Rpb24nLCAnJXM6ICVzIHR5cGUgYCVzYCBpcyBpbnZhbGlkOyBpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSAnICsgJ3RoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAlc2AuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBsb2NhdGlvbiwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0pO1xcbiAgICAgICAgICBlcnJvciA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcXG4gICAgICAgICAgZXJyb3IgPSBleDtcXG4gICAgICAgIH1cXG4gICAgICAgIHdhcm5pbmcoIWVycm9yIHx8IGVycm9yIGluc3RhbmNlb2YgRXJyb3IsICclczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvcik7XFxuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcXG4gICAgICAgICAgLy8gc2FtZSBlcnJvci5cXG4gICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yLm1lc3NhZ2VdID0gdHJ1ZTtcXG5cXG4gICAgICAgICAgdmFyIHN0YWNrID0gZ2V0U3RhY2sgPyBnZXRTdGFjaygpIDogJyc7XFxuXFxuICAgICAgICAgIHdhcm5pbmcoZmFsc2UsICdGYWlsZWQgJXMgdHlwZTogJXMlcycsIGxvY2F0aW9uLCBlcnJvci5tZXNzYWdlLCBzdGFjayAhPSBudWxsID8gc3RhY2sgOiAnJyk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxufVxcblxcbm1vZHVsZS5leHBvcnRzID0gY2hlY2tQcm9wVHlwZXM7XFxuXFxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18oMCkpKVxcblxcbi8vLy8vLy8vLy8vLy8vLy8vL1xcbi8vIFdFQlBBQ0sgRk9PVEVSXFxuLy8gLi9+L3Byb3AtdHlwZXMvY2hlY2tQcm9wVHlwZXMuanNcXG4vLyBtb2R1bGUgaWQgPSAxOVxcbi8vIG1vZHVsZSBjaHVua3MgPSAwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vfi9wcm9wLXR5cGVzL2NoZWNrUHJvcFR5cGVzLmpzP1wiKTtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAyMCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuZXZhbChcIi8qKlxcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxcbiAqXFxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXFxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxcbiAqL1xcblxcblxcblxcbnZhciBlbXB0eUZ1bmN0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcXG52YXIgaW52YXJpYW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XFxuICBmdW5jdGlvbiBzaGltKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XFxuICAgIGlmIChzZWNyZXQgPT09IFJlYWN0UHJvcFR5cGVzU2VjcmV0KSB7XFxuICAgICAgLy8gSXQgaXMgc3RpbGwgc2FmZSB3aGVuIGNhbGxlZCBmcm9tIFJlYWN0LlxcbiAgICAgIHJldHVybjtcXG4gICAgfVxcbiAgICBpbnZhcmlhbnQoXFxuICAgICAgZmFsc2UsXFxuICAgICAgJ0NhbGxpbmcgUHJvcFR5cGVzIHZhbGlkYXRvcnMgZGlyZWN0bHkgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xcbiAgICAgICdVc2UgUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKCkgdG8gY2FsbCB0aGVtLiAnICtcXG4gICAgICAnUmVhZCBtb3JlIGF0IGh0dHA6Ly9mYi5tZS91c2UtY2hlY2stcHJvcC10eXBlcydcXG4gICAgKTtcXG4gIH07XFxuICBzaGltLmlzUmVxdWlyZWQgPSBzaGltO1xcbiAgZnVuY3Rpb24gZ2V0U2hpbSgpIHtcXG4gICAgcmV0dXJuIHNoaW07XFxuICB9O1xcbiAgLy8gSW1wb3J0YW50IVxcbiAgLy8gS2VlcCB0aGlzIGxpc3QgaW4gc3luYyB3aXRoIHByb2R1Y3Rpb24gdmVyc2lvbiBpbiBgLi9mYWN0b3J5V2l0aFR5cGVDaGVja2Vycy5qc2AuXFxuICB2YXIgUmVhY3RQcm9wVHlwZXMgPSB7XFxuICAgIGFycmF5OiBzaGltLFxcbiAgICBib29sOiBzaGltLFxcbiAgICBmdW5jOiBzaGltLFxcbiAgICBudW1iZXI6IHNoaW0sXFxuICAgIG9iamVjdDogc2hpbSxcXG4gICAgc3RyaW5nOiBzaGltLFxcbiAgICBzeW1ib2w6IHNoaW0sXFxuXFxuICAgIGFueTogc2hpbSxcXG4gICAgYXJyYXlPZjogZ2V0U2hpbSxcXG4gICAgZWxlbWVudDogc2hpbSxcXG4gICAgaW5zdGFuY2VPZjogZ2V0U2hpbSxcXG4gICAgbm9kZTogc2hpbSxcXG4gICAgb2JqZWN0T2Y6IGdldFNoaW0sXFxuICAgIG9uZU9mOiBnZXRTaGltLFxcbiAgICBvbmVPZlR5cGU6IGdldFNoaW0sXFxuICAgIHNoYXBlOiBnZXRTaGltLFxcbiAgICBleGFjdDogZ2V0U2hpbVxcbiAgfTtcXG5cXG4gIFJlYWN0UHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzID0gZW1wdHlGdW5jdGlvbjtcXG4gIFJlYWN0UHJvcFR5cGVzLlByb3BUeXBlcyA9IFJlYWN0UHJvcFR5cGVzO1xcblxcbiAgcmV0dXJuIFJlYWN0UHJvcFR5cGVzO1xcbn07XFxuXFxuXFxuLy8vLy8vLy8vLy8vLy8vLy8vXFxuLy8gV0VCUEFDSyBGT09URVJcXG4vLyAuL34vcHJvcC10eXBlcy9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMuanNcXG4vLyBtb2R1bGUgaWQgPSAyMFxcbi8vIG1vZHVsZSBjaHVua3MgPSAwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vfi9wcm9wLXR5cGVzL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcy5qcz9cIik7XHJcblxyXG4vKioqLyB9KSxcclxuLyogMjEgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcbmV2YWwoXCIvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24ocHJvY2Vzcykgey8qKlxcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxcbiAqXFxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXFxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxcbiAqL1xcblxcblxcblxcbnZhciBlbXB0eUZ1bmN0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcXG52YXIgaW52YXJpYW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcXG52YXIgd2FybmluZyA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XFxudmFyIGFzc2lnbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTgpO1xcblxcbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XFxudmFyIGNoZWNrUHJvcFR5cGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOSk7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpc1ZhbGlkRWxlbWVudCwgdGhyb3dPbkRpcmVjdEFjY2Vzcykge1xcbiAgLyogZ2xvYmFsIFN5bWJvbCAqL1xcbiAgdmFyIElURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xcbiAgdmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InOyAvLyBCZWZvcmUgU3ltYm9sIHNwZWMuXFxuXFxuICAvKipcXG4gICAqIFJldHVybnMgdGhlIGl0ZXJhdG9yIG1ldGhvZCBmdW5jdGlvbiBjb250YWluZWQgb24gdGhlIGl0ZXJhYmxlIG9iamVjdC5cXG4gICAqXFxuICAgKiBCZSBzdXJlIHRvIGludm9rZSB0aGUgZnVuY3Rpb24gd2l0aCB0aGUgaXRlcmFibGUgYXMgY29udGV4dDpcXG4gICAqXFxuICAgKiAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG15SXRlcmFibGUpO1xcbiAgICogICAgIGlmIChpdGVyYXRvckZuKSB7XFxuICAgKiAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobXlJdGVyYWJsZSk7XFxuICAgKiAgICAgICAuLi5cXG4gICAqICAgICB9XFxuICAgKlxcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBtYXliZUl0ZXJhYmxlXFxuICAgKiBAcmV0dXJuIHs/ZnVuY3Rpb259XFxuICAgKi9cXG4gIGZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xcbiAgICB2YXIgaXRlcmF0b3JGbiA9IG1heWJlSXRlcmFibGUgJiYgKElURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF0pO1xcbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcXG4gICAgICByZXR1cm4gaXRlcmF0b3JGbjtcXG4gICAgfVxcbiAgfVxcblxcbiAgLyoqXFxuICAgKiBDb2xsZWN0aW9uIG9mIG1ldGhvZHMgdGhhdCBhbGxvdyBkZWNsYXJhdGlvbiBhbmQgdmFsaWRhdGlvbiBvZiBwcm9wcyB0aGF0IGFyZVxcbiAgICogc3VwcGxpZWQgdG8gUmVhY3QgY29tcG9uZW50cy4gRXhhbXBsZSB1c2FnZTpcXG4gICAqXFxuICAgKiAgIHZhciBQcm9wcyA9IHJlcXVpcmUoJ1JlYWN0UHJvcFR5cGVzJyk7XFxuICAgKiAgIHZhciBNeUFydGljbGUgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XFxuICAgKiAgICAgcHJvcFR5cGVzOiB7XFxuICAgKiAgICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgcHJvcCBuYW1lZCBcXFwiZGVzY3JpcHRpb25cXFwiLlxcbiAgICogICAgICAgZGVzY3JpcHRpb246IFByb3BzLnN0cmluZyxcXG4gICAqXFxuICAgKiAgICAgICAvLyBBIHJlcXVpcmVkIGVudW0gcHJvcCBuYW1lZCBcXFwiY2F0ZWdvcnlcXFwiLlxcbiAgICogICAgICAgY2F0ZWdvcnk6IFByb3BzLm9uZU9mKFsnTmV3cycsJ1Bob3RvcyddKS5pc1JlcXVpcmVkLFxcbiAgICpcXG4gICAqICAgICAgIC8vIEEgcHJvcCBuYW1lZCBcXFwiZGlhbG9nXFxcIiB0aGF0IHJlcXVpcmVzIGFuIGluc3RhbmNlIG9mIERpYWxvZy5cXG4gICAqICAgICAgIGRpYWxvZzogUHJvcHMuaW5zdGFuY2VPZihEaWFsb2cpLmlzUmVxdWlyZWRcXG4gICAqICAgICB9LFxcbiAgICogICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7IC4uLiB9XFxuICAgKiAgIH0pO1xcbiAgICpcXG4gICAqIEEgbW9yZSBmb3JtYWwgc3BlY2lmaWNhdGlvbiBvZiBob3cgdGhlc2UgbWV0aG9kcyBhcmUgdXNlZDpcXG4gICAqXFxuICAgKiAgIHR5cGUgOj0gYXJyYXl8Ym9vbHxmdW5jfG9iamVjdHxudW1iZXJ8c3RyaW5nfG9uZU9mKFsuLi5dKXxpbnN0YW5jZU9mKC4uLilcXG4gICAqICAgZGVjbCA6PSBSZWFjdFByb3BUeXBlcy57dHlwZX0oLmlzUmVxdWlyZWQpP1xcbiAgICpcXG4gICAqIEVhY2ggYW5kIGV2ZXJ5IGRlY2xhcmF0aW9uIHByb2R1Y2VzIGEgZnVuY3Rpb24gd2l0aCB0aGUgc2FtZSBzaWduYXR1cmUuIFRoaXNcXG4gICAqIGFsbG93cyB0aGUgY3JlYXRpb24gb2YgY3VzdG9tIHZhbGlkYXRpb24gZnVuY3Rpb25zLiBGb3IgZXhhbXBsZTpcXG4gICAqXFxuICAgKiAgdmFyIE15TGluayA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcXG4gICAqICAgIHByb3BUeXBlczoge1xcbiAgICogICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgb3IgVVJJIHByb3AgbmFtZWQgXFxcImhyZWZcXFwiLlxcbiAgICogICAgICBocmVmOiBmdW5jdGlvbihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcXG4gICAqICAgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xcbiAgICogICAgICAgIGlmIChwcm9wVmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgcHJvcFZhbHVlICE9PSAnc3RyaW5nJyAmJlxcbiAgICogICAgICAgICAgICAhKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFVSSSkpIHtcXG4gICAqICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoXFxuICAgKiAgICAgICAgICAgICdFeHBlY3RlZCBhIHN0cmluZyBvciBhbiBVUkkgZm9yICcgKyBwcm9wTmFtZSArICcgaW4gJyArXFxuICAgKiAgICAgICAgICAgIGNvbXBvbmVudE5hbWVcXG4gICAqICAgICAgICAgICk7XFxuICAgKiAgICAgICAgfVxcbiAgICogICAgICB9XFxuICAgKiAgICB9LFxcbiAgICogICAgcmVuZGVyOiBmdW5jdGlvbigpIHsuLi59XFxuICAgKiAgfSk7XFxuICAgKlxcbiAgICogQGludGVybmFsXFxuICAgKi9cXG5cXG4gIHZhciBBTk9OWU1PVVMgPSAnPDxhbm9ueW1vdXM+Pic7XFxuXFxuICAvLyBJbXBvcnRhbnQhXFxuICAvLyBLZWVwIHRoaXMgbGlzdCBpbiBzeW5jIHdpdGggcHJvZHVjdGlvbiB2ZXJzaW9uIGluIGAuL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcy5qc2AuXFxuICB2YXIgUmVhY3RQcm9wVHlwZXMgPSB7XFxuICAgIGFycmF5OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYXJyYXknKSxcXG4gICAgYm9vbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Jvb2xlYW4nKSxcXG4gICAgZnVuYzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Z1bmN0aW9uJyksXFxuICAgIG51bWJlcjogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ251bWJlcicpLFxcbiAgICBvYmplY3Q6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdvYmplY3QnKSxcXG4gICAgc3RyaW5nOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3RyaW5nJyksXFxuICAgIHN5bWJvbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ3N5bWJvbCcpLFxcblxcbiAgICBhbnk6IGNyZWF0ZUFueVR5cGVDaGVja2VyKCksXFxuICAgIGFycmF5T2Y6IGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcixcXG4gICAgZWxlbWVudDogY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCksXFxuICAgIGluc3RhbmNlT2Y6IGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIsXFxuICAgIG5vZGU6IGNyZWF0ZU5vZGVDaGVja2VyKCksXFxuICAgIG9iamVjdE9mOiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyLFxcbiAgICBvbmVPZjogY3JlYXRlRW51bVR5cGVDaGVja2VyLFxcbiAgICBvbmVPZlR5cGU6IGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIsXFxuICAgIHNoYXBlOiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyLFxcbiAgICBleGFjdDogY3JlYXRlU3RyaWN0U2hhcGVUeXBlQ2hlY2tlcixcXG4gIH07XFxuXFxuICAvKipcXG4gICAqIGlubGluZWQgT2JqZWN0LmlzIHBvbHlmaWxsIHRvIGF2b2lkIHJlcXVpcmluZyBjb25zdW1lcnMgc2hpcCB0aGVpciBvd25cXG4gICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1xcbiAgICovXFxuICAvKmVzbGludC1kaXNhYmxlIG5vLXNlbGYtY29tcGFyZSovXFxuICBmdW5jdGlvbiBpcyh4LCB5KSB7XFxuICAgIC8vIFNhbWVWYWx1ZSBhbGdvcml0aG1cXG4gICAgaWYgKHggPT09IHkpIHtcXG4gICAgICAvLyBTdGVwcyAxLTUsIDctMTBcXG4gICAgICAvLyBTdGVwcyA2LmItNi5lOiArMCAhPSAtMFxcbiAgICAgIHJldHVybiB4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAvLyBTdGVwIDYuYTogTmFOID09IE5hTlxcbiAgICAgIHJldHVybiB4ICE9PSB4ICYmIHkgIT09IHk7XFxuICAgIH1cXG4gIH1cXG4gIC8qZXNsaW50LWVuYWJsZSBuby1zZWxmLWNvbXBhcmUqL1xcblxcbiAgLyoqXFxuICAgKiBXZSB1c2UgYW4gRXJyb3ItbGlrZSBvYmplY3QgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgYXMgcGVvcGxlIG1heSBjYWxsXFxuICAgKiBQcm9wVHlwZXMgZGlyZWN0bHkgYW5kIGluc3BlY3QgdGhlaXIgb3V0cHV0LiBIb3dldmVyLCB3ZSBkb24ndCB1c2UgcmVhbFxcbiAgICogRXJyb3JzIGFueW1vcmUuIFdlIGRvbid0IGluc3BlY3QgdGhlaXIgc3RhY2sgYW55d2F5LCBhbmQgY3JlYXRpbmcgdGhlbVxcbiAgICogaXMgcHJvaGliaXRpdmVseSBleHBlbnNpdmUgaWYgdGhleSBhcmUgY3JlYXRlZCB0b28gb2Z0ZW4sIHN1Y2ggYXMgd2hhdFxcbiAgICogaGFwcGVucyBpbiBvbmVPZlR5cGUoKSBmb3IgYW55IHR5cGUgYmVmb3JlIHRoZSBvbmUgdGhhdCBtYXRjaGVkLlxcbiAgICovXFxuICBmdW5jdGlvbiBQcm9wVHlwZUVycm9yKG1lc3NhZ2UpIHtcXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcXG4gICAgdGhpcy5zdGFjayA9ICcnO1xcbiAgfVxcbiAgLy8gTWFrZSBgaW5zdGFuY2VvZiBFcnJvcmAgc3RpbGwgd29yayBmb3IgcmV0dXJuZWQgZXJyb3JzLlxcbiAgUHJvcFR5cGVFcnJvci5wcm90b3R5cGUgPSBFcnJvci5wcm90b3R5cGU7XFxuXFxuICBmdW5jdGlvbiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSkge1xcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xcbiAgICAgIHZhciBtYW51YWxQcm9wVHlwZUNhbGxDYWNoZSA9IHt9O1xcbiAgICAgIHZhciBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCA9IDA7XFxuICAgIH1cXG4gICAgZnVuY3Rpb24gY2hlY2tUeXBlKGlzUmVxdWlyZWQsIHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XFxuICAgICAgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudE5hbWUgfHwgQU5PTllNT1VTO1xcbiAgICAgIHByb3BGdWxsTmFtZSA9IHByb3BGdWxsTmFtZSB8fCBwcm9wTmFtZTtcXG5cXG4gICAgICBpZiAoc2VjcmV0ICE9PSBSZWFjdFByb3BUeXBlc1NlY3JldCkge1xcbiAgICAgICAgaWYgKHRocm93T25EaXJlY3RBY2Nlc3MpIHtcXG4gICAgICAgICAgLy8gTmV3IGJlaGF2aW9yIG9ubHkgZm9yIHVzZXJzIG9mIGBwcm9wLXR5cGVzYCBwYWNrYWdlXFxuICAgICAgICAgIGludmFyaWFudChcXG4gICAgICAgICAgICBmYWxzZSxcXG4gICAgICAgICAgICAnQ2FsbGluZyBQcm9wVHlwZXMgdmFsaWRhdG9ycyBkaXJlY3RseSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXFxuICAgICAgICAgICAgJ1VzZSBgUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKClgIHRvIGNhbGwgdGhlbS4gJyArXFxuICAgICAgICAgICAgJ1JlYWQgbW9yZSBhdCBodHRwOi8vZmIubWUvdXNlLWNoZWNrLXByb3AtdHlwZXMnXFxuICAgICAgICAgICk7XFxuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XFxuICAgICAgICAgIC8vIE9sZCBiZWhhdmlvciBmb3IgcGVvcGxlIHVzaW5nIFJlYWN0LlByb3BUeXBlc1xcbiAgICAgICAgICB2YXIgY2FjaGVLZXkgPSBjb21wb25lbnROYW1lICsgJzonICsgcHJvcE5hbWU7XFxuICAgICAgICAgIGlmIChcXG4gICAgICAgICAgICAhbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGVbY2FjaGVLZXldICYmXFxuICAgICAgICAgICAgLy8gQXZvaWQgc3BhbW1pbmcgdGhlIGNvbnNvbGUgYmVjYXVzZSB0aGV5IGFyZSBvZnRlbiBub3QgYWN0aW9uYWJsZSBleGNlcHQgZm9yIGxpYiBhdXRob3JzXFxuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQgPCAzXFxuICAgICAgICAgICkge1xcbiAgICAgICAgICAgIHdhcm5pbmcoXFxuICAgICAgICAgICAgICBmYWxzZSxcXG4gICAgICAgICAgICAgICdZb3UgYXJlIG1hbnVhbGx5IGNhbGxpbmcgYSBSZWFjdC5Qcm9wVHlwZXMgdmFsaWRhdGlvbiAnICtcXG4gICAgICAgICAgICAgICdmdW5jdGlvbiBmb3IgdGhlIGAlc2AgcHJvcCBvbiBgJXNgLiBUaGlzIGlzIGRlcHJlY2F0ZWQgJyArXFxuICAgICAgICAgICAgICAnYW5kIHdpbGwgdGhyb3cgaW4gdGhlIHN0YW5kYWxvbmUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xcbiAgICAgICAgICAgICAgJ1lvdSBtYXkgYmUgc2VlaW5nIHRoaXMgd2FybmluZyBkdWUgdG8gYSB0aGlyZC1wYXJ0eSBQcm9wVHlwZXMgJyArXFxuICAgICAgICAgICAgICAnbGlicmFyeS4gU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1kb250LWNhbGwtcHJvcHR5cGVzICcgKyAnZm9yIGRldGFpbHMuJyxcXG4gICAgICAgICAgICAgIHByb3BGdWxsTmFtZSxcXG4gICAgICAgICAgICAgIGNvbXBvbmVudE5hbWVcXG4gICAgICAgICAgICApO1xcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSA9IHRydWU7XFxuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQrKztcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09IG51bGwpIHtcXG4gICAgICAgIGlmIChpc1JlcXVpcmVkKSB7XFxuICAgICAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IG51bGwpIHtcXG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1RoZSAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgaXMgbWFya2VkIGFzIHJlcXVpcmVkICcgKyAoJ2luIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBidXQgaXRzIHZhbHVlIGlzIGBudWxsYC4nKSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdUaGUgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCBpbiAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgYnV0IGl0cyB2YWx1ZSBpcyBgdW5kZWZpbmVkYC4nKSk7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gbnVsbDtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSk7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIHZhciBjaGFpbmVkQ2hlY2tUeXBlID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgZmFsc2UpO1xcbiAgICBjaGFpbmVkQ2hlY2tUeXBlLmlzUmVxdWlyZWQgPSBjaGVja1R5cGUuYmluZChudWxsLCB0cnVlKTtcXG5cXG4gICAgcmV0dXJuIGNoYWluZWRDaGVja1R5cGU7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcihleHBlY3RlZFR5cGUpIHtcXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcXG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XFxuICAgICAgaWYgKHByb3BUeXBlICE9PSBleHBlY3RlZFR5cGUpIHtcXG4gICAgICAgIC8vIGBwcm9wVmFsdWVgIGJlaW5nIGluc3RhbmNlIG9mLCBzYXksIGRhdGUvcmVnZXhwLCBwYXNzIHRoZSAnb2JqZWN0J1xcbiAgICAgICAgLy8gY2hlY2ssIGJ1dCB3ZSBjYW4gb2ZmZXIgYSBtb3JlIHByZWNpc2UgZXJyb3IgbWVzc2FnZSBoZXJlIHJhdGhlciB0aGFuXFxuICAgICAgICAvLyAnb2YgdHlwZSBgb2JqZWN0YCcuXFxuICAgICAgICB2YXIgcHJlY2lzZVR5cGUgPSBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpO1xcblxcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJlY2lzZVR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2AnICsgZXhwZWN0ZWRUeXBlICsgJ2AuJykpO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gbnVsbDtcXG4gICAgfVxcbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gY3JlYXRlQW55VHlwZUNoZWNrZXIoKSB7XFxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcihlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbCk7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XFxuICAgICAgaWYgKHR5cGVvZiB0eXBlQ2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgYXJyYXlPZi4nKTtcXG4gICAgICB9XFxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcXG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xcbiAgICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcXG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIGFycmF5LicpKTtcXG4gICAgICB9XFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wVmFsdWUubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwgaSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICdbJyArIGkgKyAnXScsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcXG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XFxuICAgICAgICAgIHJldHVybiBlcnJvcjtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgcmV0dXJuIG51bGw7XFxuICAgIH1cXG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlcigpIHtcXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XFxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcXG4gICAgICBpZiAoIWlzVmFsaWRFbGVtZW50KHByb3BWYWx1ZSkpIHtcXG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XFxuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIHNpbmdsZSBSZWFjdEVsZW1lbnQuJykpO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gbnVsbDtcXG4gICAgfVxcbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcihleHBlY3RlZENsYXNzKSB7XFxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xcbiAgICAgIGlmICghKHByb3BzW3Byb3BOYW1lXSBpbnN0YW5jZW9mIGV4cGVjdGVkQ2xhc3MpKSB7XFxuICAgICAgICB2YXIgZXhwZWN0ZWRDbGFzc05hbWUgPSBleHBlY3RlZENsYXNzLm5hbWUgfHwgQU5PTllNT1VTO1xcbiAgICAgICAgdmFyIGFjdHVhbENsYXNzTmFtZSA9IGdldENsYXNzTmFtZShwcm9wc1twcm9wTmFtZV0pO1xcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgYWN0dWFsQ2xhc3NOYW1lICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkICcpICsgKCdpbnN0YW5jZSBvZiBgJyArIGV4cGVjdGVkQ2xhc3NOYW1lICsgJ2AuJykpO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gbnVsbDtcXG4gICAgfVxcbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gY3JlYXRlRW51bVR5cGVDaGVja2VyKGV4cGVjdGVkVmFsdWVzKSB7XFxuICAgIGlmICghQXJyYXkuaXNBcnJheShleHBlY3RlZFZhbHVlcykpIHtcXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2YsIGV4cGVjdGVkIGFuIGluc3RhbmNlIG9mIGFycmF5LicpIDogdm9pZCAwO1xcbiAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbDtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcXG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwZWN0ZWRWYWx1ZXMubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgIGlmIChpcyhwcm9wVmFsdWUsIGV4cGVjdGVkVmFsdWVzW2ldKSkge1xcbiAgICAgICAgICByZXR1cm4gbnVsbDtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgdmFyIHZhbHVlc1N0cmluZyA9IEpTT04uc3RyaW5naWZ5KGV4cGVjdGVkVmFsdWVzKTtcXG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHZhbHVlIGAnICsgcHJvcFZhbHVlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIG9uZSBvZiAnICsgdmFsdWVzU3RyaW5nICsgJy4nKSk7XFxuICAgIH1cXG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XFxuICAgICAgaWYgKHR5cGVvZiB0eXBlQ2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgb2JqZWN0T2YuJyk7XFxuICAgICAgfVxcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XFxuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcXG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XFxuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhbiBvYmplY3QuJykpO1xcbiAgICAgIH1cXG4gICAgICBmb3IgKHZhciBrZXkgaW4gcHJvcFZhbHVlKSB7XFxuICAgICAgICBpZiAocHJvcFZhbHVlLmhhc093blByb3BlcnR5KGtleSkpIHtcXG4gICAgICAgICAgdmFyIGVycm9yID0gdHlwZUNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcXG4gICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcXG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgcmV0dXJuIG51bGw7XFxuICAgIH1cXG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIoYXJyYXlPZlR5cGVDaGVja2Vycykge1xcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXlPZlR5cGVDaGVja2VycykpIHtcXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2ZUeXBlLCBleHBlY3RlZCBhbiBpbnN0YW5jZSBvZiBhcnJheS4nKSA6IHZvaWQgMDtcXG4gICAgICByZXR1cm4gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGw7XFxuICAgIH1cXG5cXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgdmFyIGNoZWNrZXIgPSBhcnJheU9mVHlwZUNoZWNrZXJzW2ldO1xcbiAgICAgIGlmICh0eXBlb2YgY2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgICAgd2FybmluZyhcXG4gICAgICAgICAgZmFsc2UsXFxuICAgICAgICAgICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZS4gRXhwZWN0ZWQgYW4gYXJyYXkgb2YgY2hlY2sgZnVuY3Rpb25zLCBidXQgJyArXFxuICAgICAgICAgICdyZWNlaXZlZCAlcyBhdCBpbmRleCAlcy4nLFxcbiAgICAgICAgICBnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmcoY2hlY2tlciksXFxuICAgICAgICAgIGlcXG4gICAgICAgICk7XFxuICAgICAgICByZXR1cm4gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGw7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlPZlR5cGVDaGVja2Vycy5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBhcnJheU9mVHlwZUNoZWNrZXJzW2ldO1xcbiAgICAgICAgaWYgKGNoZWNrZXIocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBSZWFjdFByb3BUeXBlc1NlY3JldCkgPT0gbnVsbCkge1xcbiAgICAgICAgICByZXR1cm4gbnVsbDtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nKSk7XFxuICAgIH1cXG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGNyZWF0ZU5vZGVDaGVja2VyKCkge1xcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcXG4gICAgICBpZiAoIWlzTm9kZShwcm9wc1twcm9wTmFtZV0pKSB7XFxuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHN1cHBsaWVkIHRvICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIFJlYWN0Tm9kZS4nKSk7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBudWxsO1xcbiAgICB9XFxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyKHNoYXBlVHlwZXMpIHtcXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XFxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcXG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcXG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSBgJyArIHByb3BUeXBlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGBvYmplY3RgLicpKTtcXG4gICAgICB9XFxuICAgICAgZm9yICh2YXIga2V5IGluIHNoYXBlVHlwZXMpIHtcXG4gICAgICAgIHZhciBjaGVja2VyID0gc2hhcGVUeXBlc1trZXldO1xcbiAgICAgICAgaWYgKCFjaGVja2VyKSB7XFxuICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgfVxcbiAgICAgICAgdmFyIGVycm9yID0gY2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xcbiAgICAgICAgaWYgKGVycm9yKSB7XFxuICAgICAgICAgIHJldHVybiBlcnJvcjtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgcmV0dXJuIG51bGw7XFxuICAgIH1cXG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGNyZWF0ZVN0cmljdFNoYXBlVHlwZUNoZWNrZXIoc2hhcGVUeXBlcykge1xcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcXG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XFxuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlIGAnICsgcHJvcFR5cGUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYG9iamVjdGAuJykpO1xcbiAgICAgIH1cXG4gICAgICAvLyBXZSBuZWVkIHRvIGNoZWNrIGFsbCBrZXlzIGluIGNhc2Ugc29tZSBhcmUgcmVxdWlyZWQgYnV0IG1pc3NpbmcgZnJvbVxcbiAgICAgIC8vIHByb3BzLlxcbiAgICAgIHZhciBhbGxLZXlzID0gYXNzaWduKHt9LCBwcm9wc1twcm9wTmFtZV0sIHNoYXBlVHlwZXMpO1xcbiAgICAgIGZvciAodmFyIGtleSBpbiBhbGxLZXlzKSB7XFxuICAgICAgICB2YXIgY2hlY2tlciA9IHNoYXBlVHlwZXNba2V5XTtcXG4gICAgICAgIGlmICghY2hlY2tlcikge1xcbiAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoXFxuICAgICAgICAgICAgJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGtleSBgJyArIGtleSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLicgK1xcbiAgICAgICAgICAgICdcXFxcbkJhZCBvYmplY3Q6ICcgKyBKU09OLnN0cmluZ2lmeShwcm9wc1twcm9wTmFtZV0sIG51bGwsICcgICcpICtcXG4gICAgICAgICAgICAnXFxcXG5WYWxpZCBrZXlzOiAnICsgIEpTT04uc3RyaW5naWZ5KE9iamVjdC5rZXlzKHNoYXBlVHlwZXMpLCBudWxsLCAnICAnKVxcbiAgICAgICAgICApO1xcbiAgICAgICAgfVxcbiAgICAgICAgdmFyIGVycm9yID0gY2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xcbiAgICAgICAgaWYgKGVycm9yKSB7XFxuICAgICAgICAgIHJldHVybiBlcnJvcjtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgcmV0dXJuIG51bGw7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGlzTm9kZShwcm9wVmFsdWUpIHtcXG4gICAgc3dpdGNoICh0eXBlb2YgcHJvcFZhbHVlKSB7XFxuICAgICAgY2FzZSAnbnVtYmVyJzpcXG4gICAgICBjYXNlICdzdHJpbmcnOlxcbiAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XFxuICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICBjYXNlICdib29sZWFuJzpcXG4gICAgICAgIHJldHVybiAhcHJvcFZhbHVlO1xcbiAgICAgIGNhc2UgJ29iamVjdCc6XFxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XFxuICAgICAgICAgIHJldHVybiBwcm9wVmFsdWUuZXZlcnkoaXNOb2RlKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChwcm9wVmFsdWUgPT09IG51bGwgfHwgaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihwcm9wVmFsdWUpO1xcbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcXG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKHByb3BWYWx1ZSk7XFxuICAgICAgICAgIHZhciBzdGVwO1xcbiAgICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gcHJvcFZhbHVlLmVudHJpZXMpIHtcXG4gICAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XFxuICAgICAgICAgICAgICBpZiAoIWlzTm9kZShzdGVwLnZhbHVlKSkge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIC8vIEl0ZXJhdG9yIHdpbGwgcHJvdmlkZSBlbnRyeSBbayx2XSB0dXBsZXMgcmF0aGVyIHRoYW4gdmFsdWVzLlxcbiAgICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcXG4gICAgICAgICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XFxuICAgICAgICAgICAgICBpZiAoZW50cnkpIHtcXG4gICAgICAgICAgICAgICAgaWYgKCFpc05vZGUoZW50cnlbMV0pKSB7XFxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICBkZWZhdWx0OlxcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICB9XFxuICB9XFxuXFxuICBmdW5jdGlvbiBpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSB7XFxuICAgIC8vIE5hdGl2ZSBTeW1ib2wuXFxuICAgIGlmIChwcm9wVHlwZSA9PT0gJ3N5bWJvbCcpIHtcXG4gICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgfVxcblxcbiAgICAvLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddID09PSAnU3ltYm9sJ1xcbiAgICBpZiAocHJvcFZhbHVlWydAQHRvU3RyaW5nVGFnJ10gPT09ICdTeW1ib2wnKSB7XFxuICAgICAgcmV0dXJuIHRydWU7XFxuICAgIH1cXG5cXG4gICAgLy8gRmFsbGJhY2sgZm9yIG5vbi1zcGVjIGNvbXBsaWFudCBTeW1ib2xzIHdoaWNoIGFyZSBwb2x5ZmlsbGVkLlxcbiAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBwcm9wVmFsdWUgaW5zdGFuY2VvZiBTeW1ib2wpIHtcXG4gICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgfVxcblxcbiAgICByZXR1cm4gZmFsc2U7XFxuICB9XFxuXFxuICAvLyBFcXVpdmFsZW50IG9mIGB0eXBlb2ZgIGJ1dCB3aXRoIHNwZWNpYWwgaGFuZGxpbmcgZm9yIGFycmF5IGFuZCByZWdleHAuXFxuICBmdW5jdGlvbiBnZXRQcm9wVHlwZShwcm9wVmFsdWUpIHtcXG4gICAgdmFyIHByb3BUeXBlID0gdHlwZW9mIHByb3BWYWx1ZTtcXG4gICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xcbiAgICAgIHJldHVybiAnYXJyYXknO1xcbiAgICB9XFxuICAgIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcXG4gICAgICAvLyBPbGQgd2Via2l0cyAoYXQgbGVhc3QgdW50aWwgQW5kcm9pZCA0LjApIHJldHVybiAnZnVuY3Rpb24nIHJhdGhlciB0aGFuXFxuICAgICAgLy8gJ29iamVjdCcgZm9yIHR5cGVvZiBhIFJlZ0V4cC4gV2UnbGwgbm9ybWFsaXplIHRoaXMgaGVyZSBzbyB0aGF0IC9ibGEvXFxuICAgICAgLy8gcGFzc2VzIFByb3BUeXBlcy5vYmplY3QuXFxuICAgICAgcmV0dXJuICdvYmplY3QnO1xcbiAgICB9XFxuICAgIGlmIChpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSkge1xcbiAgICAgIHJldHVybiAnc3ltYm9sJztcXG4gICAgfVxcbiAgICByZXR1cm4gcHJvcFR5cGU7XFxuICB9XFxuXFxuICAvLyBUaGlzIGhhbmRsZXMgbW9yZSB0eXBlcyB0aGFuIGBnZXRQcm9wVHlwZWAuIE9ubHkgdXNlZCBmb3IgZXJyb3IgbWVzc2FnZXMuXFxuICAvLyBTZWUgYGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyYC5cXG4gIGZ1bmN0aW9uIGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSkge1xcbiAgICBpZiAodHlwZW9mIHByb3BWYWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgcHJvcFZhbHVlID09PSBudWxsKSB7XFxuICAgICAgcmV0dXJuICcnICsgcHJvcFZhbHVlO1xcbiAgICB9XFxuICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XFxuICAgIGlmIChwcm9wVHlwZSA9PT0gJ29iamVjdCcpIHtcXG4gICAgICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xcbiAgICAgICAgcmV0dXJuICdkYXRlJztcXG4gICAgICB9IGVsc2UgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xcbiAgICAgICAgcmV0dXJuICdyZWdleHAnO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICByZXR1cm4gcHJvcFR5cGU7XFxuICB9XFxuXFxuICAvLyBSZXR1cm5zIGEgc3RyaW5nIHRoYXQgaXMgcG9zdGZpeGVkIHRvIGEgd2FybmluZyBhYm91dCBhbiBpbnZhbGlkIHR5cGUuXFxuICAvLyBGb3IgZXhhbXBsZSwgXFxcInVuZGVmaW5lZFxcXCIgb3IgXFxcIm9mIHR5cGUgYXJyYXlcXFwiXFxuICBmdW5jdGlvbiBnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmcodmFsdWUpIHtcXG4gICAgdmFyIHR5cGUgPSBnZXRQcmVjaXNlVHlwZSh2YWx1ZSk7XFxuICAgIHN3aXRjaCAodHlwZSkge1xcbiAgICAgIGNhc2UgJ2FycmF5JzpcXG4gICAgICBjYXNlICdvYmplY3QnOlxcbiAgICAgICAgcmV0dXJuICdhbiAnICsgdHlwZTtcXG4gICAgICBjYXNlICdib29sZWFuJzpcXG4gICAgICBjYXNlICdkYXRlJzpcXG4gICAgICBjYXNlICdyZWdleHAnOlxcbiAgICAgICAgcmV0dXJuICdhICcgKyB0eXBlO1xcbiAgICAgIGRlZmF1bHQ6XFxuICAgICAgICByZXR1cm4gdHlwZTtcXG4gICAgfVxcbiAgfVxcblxcbiAgLy8gUmV0dXJucyBjbGFzcyBuYW1lIG9mIHRoZSBvYmplY3QsIGlmIGFueS5cXG4gIGZ1bmN0aW9uIGdldENsYXNzTmFtZShwcm9wVmFsdWUpIHtcXG4gICAgaWYgKCFwcm9wVmFsdWUuY29uc3RydWN0b3IgfHwgIXByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lKSB7XFxuICAgICAgcmV0dXJuIEFOT05ZTU9VUztcXG4gICAgfVxcbiAgICByZXR1cm4gcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWU7XFxuICB9XFxuXFxuICBSZWFjdFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcyA9IGNoZWNrUHJvcFR5cGVzO1xcbiAgUmVhY3RQcm9wVHlwZXMuUHJvcFR5cGVzID0gUmVhY3RQcm9wVHlwZXM7XFxuXFxuICByZXR1cm4gUmVhY3RQcm9wVHlwZXM7XFxufTtcXG5cXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXygwKSkpXFxuXFxuLy8vLy8vLy8vLy8vLy8vLy8vXFxuLy8gV0VCUEFDSyBGT09URVJcXG4vLyAuL34vcHJvcC10eXBlcy9mYWN0b3J5V2l0aFR5cGVDaGVja2Vycy5qc1xcbi8vIG1vZHVsZSBpZCA9IDIxXFxuLy8gbW9kdWxlIGNodW5rcyA9IDBcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9+L3Byb3AtdHlwZXMvZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMuanM/XCIpO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDIyICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcbmV2YWwoXCJcXG4vKipcXG4gKiBXaGVuIHNvdXJjZSBtYXBzIGFyZSBlbmFibGVkLCBgc3R5bGUtbG9hZGVyYCB1c2VzIGEgbGluayBlbGVtZW50IHdpdGggYSBkYXRhLXVyaSB0b1xcbiAqIGVtYmVkIHRoZSBjc3Mgb24gdGhlIHBhZ2UuIFRoaXMgYnJlYWtzIGFsbCByZWxhdGl2ZSB1cmxzIGJlY2F1c2Ugbm93IHRoZXkgYXJlIHJlbGF0aXZlIHRvIGFcXG4gKiBidW5kbGUgaW5zdGVhZCBvZiB0aGUgY3VycmVudCBwYWdlLlxcbiAqXFxuICogT25lIHNvbHV0aW9uIGlzIHRvIG9ubHkgdXNlIGZ1bGwgdXJscywgYnV0IHRoYXQgbWF5IGJlIGltcG9zc2libGUuXFxuICpcXG4gKiBJbnN0ZWFkLCB0aGlzIGZ1bmN0aW9uIFxcXCJmaXhlc1xcXCIgdGhlIHJlbGF0aXZlIHVybHMgdG8gYmUgYWJzb2x1dGUgYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IHBhZ2UgbG9jYXRpb24uXFxuICpcXG4gKiBBIHJ1ZGltZW50YXJ5IHRlc3Qgc3VpdGUgaXMgbG9jYXRlZCBhdCBgdGVzdC9maXhVcmxzLmpzYCBhbmQgY2FuIGJlIHJ1biB2aWEgdGhlIGBucG0gdGVzdGAgY29tbWFuZC5cXG4gKlxcbiAqL1xcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNzcykge1xcbiAgLy8gZ2V0IGN1cnJlbnQgbG9jYXRpb25cXG4gIHZhciBsb2NhdGlvbiA9IHR5cGVvZiB3aW5kb3cgIT09IFxcXCJ1bmRlZmluZWRcXFwiICYmIHdpbmRvdy5sb2NhdGlvbjtcXG5cXG4gIGlmICghbG9jYXRpb24pIHtcXG4gICAgdGhyb3cgbmV3IEVycm9yKFxcXCJmaXhVcmxzIHJlcXVpcmVzIHdpbmRvdy5sb2NhdGlvblxcXCIpO1xcbiAgfVxcblxcblxcdC8vIGJsYW5rIG9yIG51bGw/XFxuXFx0aWYgKCFjc3MgfHwgdHlwZW9mIGNzcyAhPT0gXFxcInN0cmluZ1xcXCIpIHtcXG5cXHQgIHJldHVybiBjc3M7XFxuICB9XFxuXFxuICB2YXIgYmFzZVVybCA9IGxvY2F0aW9uLnByb3RvY29sICsgXFxcIi8vXFxcIiArIGxvY2F0aW9uLmhvc3Q7XFxuICB2YXIgY3VycmVudERpciA9IGJhc2VVcmwgKyBsb2NhdGlvbi5wYXRobmFtZS5yZXBsYWNlKC9cXFxcL1teXFxcXC9dKiQvLCBcXFwiL1xcXCIpO1xcblxcblxcdC8vIGNvbnZlcnQgZWFjaCB1cmwoLi4uKVxcblxcdC8qXFxuXFx0VGhpcyByZWd1bGFyIGV4cHJlc3Npb24gaXMganVzdCBhIHdheSB0byByZWN1cnNpdmVseSBtYXRjaCBicmFja2V0cyB3aXRoaW5cXG5cXHRhIHN0cmluZy5cXG5cXG5cXHQgL3VybFxcXFxzKlxcXFwoICA9IE1hdGNoIG9uIHRoZSB3b3JkIFxcXCJ1cmxcXFwiIHdpdGggYW55IHdoaXRlc3BhY2UgYWZ0ZXIgaXQgYW5kIHRoZW4gYSBwYXJlbnNcXG5cXHQgICAoICA9IFN0YXJ0IGEgY2FwdHVyaW5nIGdyb3VwXFxuXFx0ICAgICAoPzogID0gU3RhcnQgYSBub24tY2FwdHVyaW5nIGdyb3VwXFxuXFx0ICAgICAgICAgW14pKF0gID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXFxuXFx0ICAgICAgICAgfCAgPSBPUlxcblxcdCAgICAgICAgIFxcXFwoICA9IE1hdGNoIGEgc3RhcnQgcGFyZW50aGVzZXNcXG5cXHQgICAgICAgICAgICAgKD86ICA9IFN0YXJ0IGFub3RoZXIgbm9uLWNhcHR1cmluZyBncm91cHNcXG5cXHQgICAgICAgICAgICAgICAgIFteKShdKyAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcXG5cXHQgICAgICAgICAgICAgICAgIHwgID0gT1JcXG5cXHQgICAgICAgICAgICAgICAgIFxcXFwoICA9IE1hdGNoIGEgc3RhcnQgcGFyZW50aGVzZXNcXG5cXHQgICAgICAgICAgICAgICAgICAgICBbXikoXSogID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXFxuXFx0ICAgICAgICAgICAgICAgICBcXFxcKSAgPSBNYXRjaCBhIGVuZCBwYXJlbnRoZXNlc1xcblxcdCAgICAgICAgICAgICApICA9IEVuZCBHcm91cFxcbiAgICAgICAgICAgICAgKlxcXFwpID0gTWF0Y2ggYW55dGhpbmcgYW5kIHRoZW4gYSBjbG9zZSBwYXJlbnNcXG4gICAgICAgICAgKSAgPSBDbG9zZSBub24tY2FwdHVyaW5nIGdyb3VwXFxuICAgICAgICAgICogID0gTWF0Y2ggYW55dGhpbmdcXG4gICAgICAgKSAgPSBDbG9zZSBjYXB0dXJpbmcgZ3JvdXBcXG5cXHQgXFxcXCkgID0gTWF0Y2ggYSBjbG9zZSBwYXJlbnNcXG5cXG5cXHQgL2dpICA9IEdldCBhbGwgbWF0Y2hlcywgbm90IHRoZSBmaXJzdC4gIEJlIGNhc2UgaW5zZW5zaXRpdmUuXFxuXFx0ICovXFxuXFx0dmFyIGZpeGVkQ3NzID0gY3NzLnJlcGxhY2UoL3VybFxcXFxzKlxcXFwoKCg/OlteKShdfFxcXFwoKD86W14pKF0rfFxcXFwoW14pKF0qXFxcXCkpKlxcXFwpKSopXFxcXCkvZ2ksIGZ1bmN0aW9uKGZ1bGxNYXRjaCwgb3JpZ1VybCkge1xcblxcdFxcdC8vIHN0cmlwIHF1b3RlcyAoaWYgdGhleSBleGlzdClcXG5cXHRcXHR2YXIgdW5xdW90ZWRPcmlnVXJsID0gb3JpZ1VybFxcblxcdFxcdFxcdC50cmltKClcXG5cXHRcXHRcXHQucmVwbGFjZSgvXlxcXCIoLiopXFxcIiQvLCBmdW5jdGlvbihvLCAkMSl7IHJldHVybiAkMTsgfSlcXG5cXHRcXHRcXHQucmVwbGFjZSgvXicoLiopJyQvLCBmdW5jdGlvbihvLCAkMSl7IHJldHVybiAkMTsgfSk7XFxuXFxuXFx0XFx0Ly8gYWxyZWFkeSBhIGZ1bGwgdXJsPyBubyBjaGFuZ2VcXG5cXHRcXHRpZiAoL14oI3xkYXRhOnxodHRwOlxcXFwvXFxcXC98aHR0cHM6XFxcXC9cXFxcL3xmaWxlOlxcXFwvXFxcXC9cXFxcLykvaS50ZXN0KHVucXVvdGVkT3JpZ1VybCkpIHtcXG5cXHRcXHQgIHJldHVybiBmdWxsTWF0Y2g7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIGNvbnZlcnQgdGhlIHVybCB0byBhIGZ1bGwgdXJsXFxuXFx0XFx0dmFyIG5ld1VybDtcXG5cXG5cXHRcXHRpZiAodW5xdW90ZWRPcmlnVXJsLmluZGV4T2YoXFxcIi8vXFxcIikgPT09IDApIHtcXG5cXHRcXHQgIFxcdC8vVE9ETzogc2hvdWxkIHdlIGFkZCBwcm90b2NvbD9cXG5cXHRcXHRcXHRuZXdVcmwgPSB1bnF1b3RlZE9yaWdVcmw7XFxuXFx0XFx0fSBlbHNlIGlmICh1bnF1b3RlZE9yaWdVcmwuaW5kZXhPZihcXFwiL1xcXCIpID09PSAwKSB7XFxuXFx0XFx0XFx0Ly8gcGF0aCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gdGhlIGJhc2UgdXJsXFxuXFx0XFx0XFx0bmV3VXJsID0gYmFzZVVybCArIHVucXVvdGVkT3JpZ1VybDsgLy8gYWxyZWFkeSBzdGFydHMgd2l0aCAnLydcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdC8vIHBhdGggc2hvdWxkIGJlIHJlbGF0aXZlIHRvIGN1cnJlbnQgZGlyZWN0b3J5XFxuXFx0XFx0XFx0bmV3VXJsID0gY3VycmVudERpciArIHVucXVvdGVkT3JpZ1VybC5yZXBsYWNlKC9eXFxcXC5cXFxcLy8sIFxcXCJcXFwiKTsgLy8gU3RyaXAgbGVhZGluZyAnLi8nXFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIHNlbmQgYmFjayB0aGUgZml4ZWQgdXJsKC4uLilcXG5cXHRcXHRyZXR1cm4gXFxcInVybChcXFwiICsgSlNPTi5zdHJpbmdpZnkobmV3VXJsKSArIFxcXCIpXFxcIjtcXG5cXHR9KTtcXG5cXG5cXHQvLyBzZW5kIGJhY2sgdGhlIGZpeGVkIGNzc1xcblxcdHJldHVybiBmaXhlZENzcztcXG59O1xcblxcblxcbi8vLy8vLy8vLy8vLy8vLy8vL1xcbi8vIFdFQlBBQ0sgRk9PVEVSXFxuLy8gLi9+L3N0eWxlLWxvYWRlci9maXhVcmxzLmpzXFxuLy8gbW9kdWxlIGlkID0gMjJcXG4vLyBtb2R1bGUgY2h1bmtzID0gMFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL34vc3R5bGUtbG9hZGVyL2ZpeFVybHMuanM/XCIpO1xyXG5cclxuLyoqKi8gfSlcclxuLyoqKioqKi8gXSk7XHJcbn0pOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==